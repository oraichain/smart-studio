{"crate_graph":{"crates":[[0,{"root_file_id":0,"edition":"2018","display_name":null,"version":null,"cfg_options":{"options":[["target_pointer_width",["64"]],["target_arch",["x86_64"]],["unix",[]]]},"potential_cfg_options":{"options":[]},"env":{"env":[]},"proc_macro":[]}],[1,{"root_file_id":1,"edition":"2018","display_name":null,"version":null,"cfg_options":{"options":[["target_pointer_width",["64"]],["target_arch",["x86_64"]],["unix",[]]]},"potential_cfg_options":{"options":[]},"env":{"env":[]},"proc_macro":[]}],[2,{"root_file_id":2,"edition":"2018","display_name":null,"version":null,"cfg_options":{"options":[["target_pointer_width",["64"]],["target_arch",["x86_64"]],["unix",[]]]},"potential_cfg_options":{"options":[]},"env":{"env":[]},"proc_macro":[]}],[3,{"root_file_id":3,"edition":"2018","display_name":null,"version":null,"cfg_options":{"options":[["target_pointer_width",["64"]],["target_arch",["x86_64"]],["unix",[]]]},"potential_cfg_options":{"options":[]},"env":{"env":[]},"proc_macro":[]}],[4,{"root_file_id":4,"edition":"2018","display_name":null,"version":null,"cfg_options":{"options":[["target_pointer_width",["64"]],["target_arch",["x86_64"]],["unix",[]]]},"potential_cfg_options":{"options":[]},"env":{"env":[]},"proc_macro":[]}],[5,{"root_file_id":5,"edition":"2018","display_name":null,"version":null,"cfg_options":{"options":[["target_pointer_width",["64"]],["target_arch",["x86_64"]],["unix",[]]]},"potential_cfg_options":{"options":[]},"env":{"env":[]},"proc_macro":[]}],[6,{"root_file_id":6,"edition":"2018","display_name":null,"version":null,"cfg_options":{"options":[["target_pointer_width",["64"]],["target_arch",["x86_64"]],["unix",[]]]},"potential_cfg_options":{"options":[]},"env":{"env":[]},"proc_macro":[]}],[7,{"root_file_id":7,"edition":"2018","display_name":null,"version":null,"cfg_options":{"options":[["target_pointer_width",["64"]],["target_arch",["x86_64"]],["unix",[]]]},"potential_cfg_options":{"options":[]},"env":{"env":[]},"proc_macro":[]}],[8,{"root_file_id":8,"edition":"2018","display_name":null,"version":null,"cfg_options":{"options":[["target_pointer_width",["64"]],["target_arch",["x86_64"]],["unix",[]]]},"potential_cfg_options":{"options":[]},"env":{"env":[]},"proc_macro":[]}],[9,{"root_file_id":9,"edition":"2018","display_name":null,"version":null,"cfg_options":{"options":[["target_pointer_width",["64"]],["target_arch",["x86_64"]],["unix",[]]]},"potential_cfg_options":{"options":[]},"env":{"env":[]},"proc_macro":[]}]],"deps":[{"from":0,"name":"core","to":2},{"from":0,"name":"alloc","to":3},{"from":0,"name":"std","to":1},{"from":0,"name":"cosmwasm_derive","to":4},{"from":0,"name":"cosmwasm_schema_derive","to":5},{"from":0,"name":"cosmwasm_schema","to":6},{"from":0,"name":"cosmwasm_std","to":7},{"from":0,"name":"cosmwasm_crypto","to":8},{"from":0,"name":"cosmwasm_storage","to":9},{"from":7,"name":"core","to":2},{"from":7,"name":"cosmwasm_derive","to":4},{"from":1,"name":"core","to":2},{"from":1,"name":"alloc","to":3},{"from":9,"name":"cosmwasm_std","to":7},{"from":6,"name":"cosmwasm_schema_derive","to":5},{"from":3,"name":"core","to":2}]},"local_roots":{"roots":[[[0,"/contract_crate/main.rs"]]]},"library_roots":{"roots":[[[1,"/std/src/lib.rs"]],[[2,"/core/src/lib.rs"]],[[3,"/alloc/src/lib.rs"]],[[4,"/cosmwasm_derive/src/lib.rs"]],[[5,"/cosmwasm_schema_derive/src/lib.rs"]],[[6,"/cosmwasm_schema/src/lib.rs"]],[[7,"/cosmwasm_std/src/lib.rs"]],[[8,"/cosmwasm_crypto/src/lib.rs"]],[[9,"/cosmwasm_storage/src/lib.rs"]]]},"files_changed":{"files":[[1,"//! # The Rust Standard Library\n//!\n//! The Rust Standard Library is the foundation of portable Rust software, a\n//! set of minimal and battle-tested shared abstractions for the [broader Rust\n//! ecosystem][crates.io]. It offers core types, like [`Vec<T>`] and\n//! [`Option<T>`], library-defined [operations on language\n//! primitives](#primitives), [standard macros](#macros), [I/O] and\n//! [multithreading], among [many other things][other].\n//!\n//! `std` is available to all Rust crates by default. Therefore, the\n//! standard library can be accessed in [`use`] statements through the path\n//! `std`, as in [`use std::env`].\n//!\n//! # How to read this documentation\n//!\n//! If you already know the name of what you are looking for, the fastest way to\n//! find it is to use the <a href=\"#\" onclick=\"focusSearchBar();\">search\n//! bar</a> at the top of the page.\n//!\n//! Otherwise, you may want to jump to one of these useful sections:\n//!\n//! * [`std::*` modules](#modules)\n//! * [Primitive types](#primitives)\n//! * [Standard macros](#macros)\n//! * [The Rust Prelude](prelude/index.html)\n//!\n//! If this is your first time, the documentation for the standard library is\n//! written to be casually perused. Clicking on interesting things should\n//! generally lead you to interesting places. Still, there are important bits\n//! you don't want to miss, so read on for a tour of the standard library and\n//! its documentation!\n//!\n//! Once you are familiar with the contents of the standard library you may\n//! begin to find the verbosity of the prose distracting. At this stage in your\n//! development you may want to press the `[-]` button near the top of the\n//! page to collapse it into a more skimmable view.\n//!\n//! While you are looking at that `[-]` button also notice the `[src]`\n//! button. Rust's API documentation comes with the source code and you are\n//! encouraged to read it. The standard library source is generally high\n//! quality and a peek behind the curtains is often enlightening.\n//!\n//! # What is in the standard library documentation?\n//!\n//! First of all, The Rust Standard Library is divided into a number of focused\n//! modules, [all listed further down this page](#modules). These modules are\n//! the bedrock upon which all of Rust is forged, and they have mighty names\n//! like [`std::slice`] and [`std::cmp`]. Modules' documentation typically\n//! includes an overview of the module along with examples, and are a smart\n//! place to start familiarizing yourself with the library.\n//!\n//! Second, implicit methods on [primitive types] are documented here. This can\n//! be a source of confusion for two reasons:\n//!\n//! 1. While primitives are implemented by the compiler, the standard library\n//!    implements methods directly on the primitive types (and it is the only\n//!    library that does so), which are [documented in the section on\n//!    primitives](#primitives).\n//! 2. The standard library exports many modules *with the same name as\n//!    primitive types*. These define additional items related to the primitive\n//!    type, but not the all-important methods.\n//!\n//! So for example there is a [page for the primitive type\n//! `i32`](primitive.i32.html) that lists all the methods that can be called on\n//! 32-bit integers (very useful), and there is a [page for the module\n//! `std::i32`](i32/index.html) that documents the constant values [`MIN`] and\n//! [`MAX`](i32/constant.MAX.html) (rarely useful).\n//!\n//! Note the documentation for the primitives [`str`] and [`[T]`][slice] (also\n//! called 'slice'). Many method calls on [`String`] and [`Vec<T>`] are actually\n//! calls to methods on [`str`] and [`[T]`][slice] respectively, via [deref\n//! coercions][deref-coercions].\n//!\n//! Third, the standard library defines [The Rust Prelude], a small collection\n//! of items - mostly traits - that are imported into every module of every\n//! crate. The traits in the prelude are pervasive, making the prelude\n//! documentation a good entry point to learning about the library.\n//!\n//! And finally, the standard library exports a number of standard macros, and\n//! [lists them on this page](#macros) (technically, not all of the standard\n//! macros are defined by the standard library - some are defined by the\n//! compiler - but they are documented here the same). Like the prelude, the\n//! standard macros are imported by default into all crates.\n//!\n//! # Contributing changes to the documentation\n//!\n//! Check out the rust contribution guidelines [here](\n//! https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md).\n//! The source for this documentation can be found on [Github](https://github.com/rust-lang).\n//! To contribute changes, make sure you read the guidelines first, then submit\n//! pull-requests for your suggested changes.\n//!\n//! Contributions are appreciated! If you see a part of the docs that can be\n//! improved, submit a PR, or chat with us first on irc.mozilla.org #rust-docs.\n//!\n//! # A Tour of The Rust Standard Library\n//!\n//! The rest of this crate documentation is dedicated to pointing out notable\n//! features of The Rust Standard Library.\n//!\n//! ## Containers and collections\n//!\n//! The [`option`] and [`result`] modules define optional and error-handling\n//! types, [`Option<T>`] and [`Result<T, E>`]. The [`iter`] module defines\n//! Rust's iterator trait, [`Iterator`], which works with the [`for`] loop to\n//! access collections.\n//!\n//! The standard library exposes three common ways to deal with contiguous\n//! regions of memory:\n//!\n//! * [`Vec<T>`] - A heap-allocated *vector* that is resizable at runtime.\n//! * [`[T; n]`][array] - An inline *array* with a fixed size at compile time.\n//! * [`[T]`][slice] - A dynamically sized *slice* into any other kind of contiguous\n//!   storage, whether heap-allocated or not.\n//!\n//! Slices can only be handled through some kind of *pointer*, and as such come\n//! in many flavors such as:\n//!\n//! * `&[T]` - *shared slice*\n//! * `&mut [T]` - *mutable slice*\n//! * [`Box<[T]>`][owned slice] - *owned slice*\n//!\n//! [`str`], a UTF-8 string slice, is a primitive type, and the standard library\n//! defines many methods for it. Rust [`str`]s are typically accessed as\n//! immutable references: `&str`. Use the owned [`String`] for building and\n//! mutating strings.\n//!\n//! For converting to strings use the [`format!`] macro, and for converting from\n//! strings use the [`FromStr`] trait.\n//!\n//! Data may be shared by placing it in a reference-counted box or the [`Rc`]\n//! type, and if further contained in a [`Cell`] or [`RefCell`], may be mutated\n//! as well as shared. Likewise, in a concurrent setting it is common to pair an\n//! atomically-reference-counted box, [`Arc`], with a [`Mutex`] to get the same\n//! effect.\n//!\n//! The [`collections`] module defines maps, sets, linked lists and other\n//! typical collection types, including the common [`HashMap<K, V>`].\n//!\n//! ## Platform abstractions and I/O\n//!\n//! Besides basic data types, the standard library is largely concerned with\n//! abstracting over differences in common platforms, most notably Windows and\n//! Unix derivatives.\n//!\n//! Common types of I/O, including [files], [TCP], [UDP], are defined in the\n//! [`io`], [`fs`], and [`net`] modules.\n//!\n//! The [`thread`] module contains Rust's threading abstractions. [`sync`]\n//! contains further primitive shared memory types, including [`atomic`] and\n//! [`mpsc`], which contains the channel types for message passing.\n//!\n//! [I/O]: io/index.html\n//! [`MIN`]: i32/constant.MIN.html\n//! [TCP]: net/struct.TcpStream.html\n//! [The Rust Prelude]: prelude/index.html\n//! [UDP]: net/struct.UdpSocket.html\n//! [`Arc`]: sync/struct.Arc.html\n//! [owned slice]: boxed/index.html\n//! [`Cell`]: cell/struct.Cell.html\n//! [`FromStr`]: str/trait.FromStr.html\n//! [`HashMap<K, V>`]: collections/struct.HashMap.html\n//! [`Iterator`]: iter/trait.Iterator.html\n//! [`Mutex`]: sync/struct.Mutex.html\n//! [`Option<T>`]: option/enum.Option.html\n//! [`Rc`]: rc/index.html\n//! [`RefCell`]: cell/struct.RefCell.html\n//! [`Result<T, E>`]: result/enum.Result.html\n//! [`String`]: string/struct.String.html\n//! [`Vec<T>`]: vec/index.html\n//! [array]: primitive.array.html\n//! [slice]: primitive.slice.html\n//! [`atomic`]: sync/atomic/index.html\n//! [`collections`]: collections/index.html\n//! [`for`]: ../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n//! [`format!`]: macro.format.html\n//! [`fs`]: fs/index.html\n//! [`io`]: io/index.html\n//! [`iter`]: iter/index.html\n//! [`mpsc`]: sync/mpsc/index.html\n//! [`net`]: net/index.html\n//! [`option`]: option/index.html\n//! [`result`]: result/index.html\n//! [`std::cmp`]: cmp/index.html\n//! [`std::slice`]: slice/index.html\n//! [`str`]: primitive.str.html\n//! [`sync`]: sync/index.html\n//! [`thread`]: thread/index.html\n//! [`use std::env`]: env/index.html\n//! [`use`]: ../book/ch07-02-defining-modules-to-control-scope-and-privacy.html\n//! [crates.io]: https://crates.io\n//! [deref-coercions]: ../book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods\n//! [files]: fs/struct.File.html\n//! [multithreading]: thread/index.html\n//! [other]: #what-is-in-the-standard-library-documentation\n//! [primitive types]: ../book/ch03-02-data-types.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![doc(\n    html_root_url = \"https://doc.rust-lang.org/nightly/\",\n    html_playground_url = \"https://play.rust-lang.org/\",\n    issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n    test(no_crate_inject, attr(deny(warnings))),\n    test(attr(allow(dead_code, deprecated, unused_variables, unused_mut)))\n)]\n// Don't link to std. We are std.\n#![no_std]\n#![warn(deprecated_in_future)]\n#![warn(missing_docs)]\n#![warn(missing_debug_implementations)]\n#![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n#![allow(explicit_outlives_requirements)]\n#![allow(unused_lifetimes)]\n// Tell the compiler to link to either panic_abort or panic_unwind\n#![needs_panic_runtime]\n// std may use features in a platform-specific way\n#![allow(unused_features)]\n#![cfg_attr(test, feature(print_internals, set_stdio, update_panic_count))]\n#![cfg_attr(\n    all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n    feature(slice_index_methods, coerce_unsized, sgx_platform, ptr_wrapping_offset_from)\n)]\n#![cfg_attr(\n    all(test, target_vendor = \"fortanix\", target_env = \"sgx\"),\n    feature(fixed_size_array, maybe_uninit_extra)\n)]\n// std is implemented with unstable features, many of which are internal\n// compiler details that will never be stable\n// NB: the following list is sorted to minimize merge conflicts.\n#![feature(alloc_error_handler)]\n#![feature(alloc_layout_extra)]\n#![feature(allocator_api)]\n#![feature(allocator_internals)]\n#![feature(allow_internal_unsafe)]\n#![feature(allow_internal_unstable)]\n#![feature(atomic_mut_ptr)]\n#![feature(arbitrary_self_types)]\n#![feature(array_error_internals)]\n#![feature(asm)]\n#![feature(associated_type_bounds)]\n#![feature(box_syntax)]\n#![feature(c_variadic)]\n#![feature(cfg_target_has_atomic)]\n#![feature(cfg_target_thread_local)]\n#![feature(char_error_internals)]\n#![feature(clamp)]\n#![feature(concat_idents)]\n#![feature(const_cstr_unchecked)]\n#![feature(const_raw_ptr_deref)]\n#![feature(container_error_extra)]\n#![feature(core_intrinsics)]\n#![feature(custom_test_frameworks)]\n#![feature(decl_macro)]\n#![feature(doc_alias)]\n#![feature(doc_cfg)]\n#![feature(doc_keyword)]\n#![feature(doc_masked)]\n#![feature(doc_spotlight)]\n#![feature(dropck_eyepatch)]\n#![feature(duration_constants)]\n#![feature(exact_size_is_empty)]\n#![feature(exhaustive_patterns)]\n#![feature(external_doc)]\n#![feature(fn_traits)]\n#![feature(format_args_nl)]\n#![feature(generator_trait)]\n#![feature(global_asm)]\n#![feature(hash_raw_entry)]\n#![feature(hashmap_internals)]\n#![feature(int_error_internals)]\n#![feature(int_error_matching)]\n#![feature(integer_atomics)]\n#![feature(lang_items)]\n#![feature(libc)]\n#![feature(link_args)]\n#![feature(linkage)]\n#![feature(log_syntax)]\n#![feature(maybe_uninit_ref)]\n#![feature(maybe_uninit_slice)]\n#![feature(needs_panic_runtime)]\n#![feature(never_type)]\n#![feature(nll)]\n#![feature(optin_builtin_traits)]\n#![feature(panic_info_message)]\n#![feature(panic_internals)]\n#![feature(panic_unwind)]\n#![feature(prelude_import)]\n#![feature(ptr_internals)]\n#![feature(raw)]\n#![feature(renamed_spin_loop)]\n#![feature(rustc_attrs)]\n#![feature(rustc_private)]\n#![feature(shrink_to)]\n#![feature(slice_concat_ext)]\n#![feature(slice_internals)]\n#![cfg_attr(bootstrap, feature(slice_patterns))]\n#![feature(specialization)]\n#![feature(staged_api)]\n#![feature(std_internals)]\n#![feature(stdsimd)]\n#![feature(stmt_expr_attributes)]\n#![feature(str_internals)]\n#![feature(test)]\n#![feature(thread_local)]\n#![feature(toowned_clone_into)]\n#![feature(trace_macros)]\n#![feature(track_caller)]\n#![feature(try_reserve)]\n#![feature(unboxed_closures)]\n#![feature(untagged_unions)]\n#![feature(unwind_attributes)]\n// NB: the above list is sorted to minimize merge conflicts.\n#![default_lib_allocator]\n\n// Explicitly import the prelude. The compiler uses this same unstable attribute\n// to import the prelude implicitly when building crates that depend on std.\n#[prelude_import]\n#[allow(unused)]\nuse prelude::v1::*;\n\n// Access to Bencher, etc.\n#[cfg(test)]\nextern crate test;\n\n#[allow(unused_imports)] // macros from `alloc` are not used on all platforms\n#[macro_use]\nextern crate alloc as alloc_crate;\n#[doc(masked)]\n#[allow(unused_extern_crates)]\nextern crate libc;\n\n// We always need an unwinder currently for backtraces\n#[doc(masked)]\n#[allow(unused_extern_crates)]\nextern crate unwind;\n\n// Only needed for now for the `std_detect` module until that crate changes to\n// use `cfg_if::cfg_if!`\n#[macro_use]\n#[cfg(not(test))]\nextern crate cfg_if;\n\n// During testing, this crate is not actually the \"real\" std library, but rather\n// it links to the real std library, which was compiled from this same source\n// code. So any lang items std defines are conditionally excluded (or else they\n// would generate duplicate lang item errors), and any globals it defines are\n// _not_ the globals used by \"real\" std. So this import, defined only during\n// testing gives test-std access to real-std lang items and globals. See #2912\n#[cfg(test)]\nextern crate std as realstd;\n\n// The standard macros that are not built-in to the compiler.\n#[macro_use]\nmod macros {\n//! Standard library macros\n//!\n//! This modules contains a set of macros which are exported from the standard\n//! library. Each macro is available for use when linking against the standard\n//! library.\n\n#[cfg(bootstrap)]\n#[doc(include = \"../libcore/macros/panic.md\")]\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(libstd_sys_internals)]\nmacro_rules! panic {\n    () => ({\n        $crate::panic!(\"explicit panic\")\n    });\n    ($msg:expr) => ({\n        $crate::rt::begin_panic($msg, &($crate::file!(), $crate::line!(), $crate::column!()))\n    });\n    ($msg:expr,) => ({\n        $crate::panic!($msg)\n    });\n    ($fmt:expr, $($arg:tt)+) => ({\n        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+))\n    });\n}\n\n#[cfg(not(bootstrap))]\n#[doc(include = \"../libcore/macros/panic.md\")]\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(libstd_sys_internals)]\nmacro_rules! panic {\n    () => ({ $crate::panic!(\"explicit panic\") });\n    ($msg:expr) => ({ $crate::rt::begin_panic($msg) });\n    ($msg:expr,) => ({ $crate::panic!($msg) });\n    ($fmt:expr, $($arg:tt)+) => ({\n        $crate::rt::begin_panic_fmt(&$crate::format_args!($fmt, $($arg)+))\n    });\n}\n\n/// Prints to the standard output.\n///\n/// Equivalent to the [`println!`] macro except that a newline is not printed at\n/// the end of the message.\n///\n/// Note that stdout is frequently line-buffered by default so it may be\n/// necessary to use [`io::stdout().flush()`][flush] to ensure the output is emitted\n/// immediately.\n///\n/// Use `print!` only for the primary output of your program. Use\n/// [`eprint!`] instead to print error and progress messages.\n///\n/// [`println!`]: ../std/macro.println.html\n/// [flush]: ../std/io/trait.Write.html#tymethod.flush\n/// [`eprint!`]: ../std/macro.eprint.html\n///\n/// # Panics\n///\n/// Panics if writing to `io::stdout()` fails.\n///\n/// # Examples\n///\n/// ```\n/// use std::io::{self, Write};\n///\n/// print!(\"this \");\n/// print!(\"will \");\n/// print!(\"be \");\n/// print!(\"on \");\n/// print!(\"the \");\n/// print!(\"same \");\n/// print!(\"line \");\n///\n/// io::stdout().flush().unwrap();\n///\n/// print!(\"this string has a newline, why not choose println! instead?\\n\");\n///\n/// io::stdout().flush().unwrap();\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(print_internals)]\nmacro_rules! print {\n    ($($arg:tt)*) => ($crate::io::_print($crate::format_args!($($arg)*)));\n}\n\n/// Prints to the standard output, with a newline.\n///\n/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`)).\n///\n/// Use the [`format!`] syntax to write data to the standard output.\n/// See [`std::fmt`] for more information.\n///\n/// Use `println!` only for the primary output of your program. Use\n/// [`eprintln!`] instead to print error and progress messages.\n///\n/// [`format!`]: ../std/macro.format.html\n/// [`std::fmt`]: ../std/fmt/index.html\n/// [`eprintln!`]: ../std/macro.eprintln.html\n/// # Panics\n///\n/// Panics if writing to `io::stdout` fails.\n///\n/// # Examples\n///\n/// ```\n/// println!(); // prints just a newline\n/// println!(\"hello there!\");\n/// println!(\"format {} arguments\", \"some\");\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(print_internals, format_args_nl)]\nmacro_rules! println {\n    () => ($crate::print!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_print($crate::format_args_nl!($($arg)*));\n    })\n}\n\n/// Prints to the standard error.\n///\n/// Equivalent to the [`print!`] macro, except that output goes to\n/// [`io::stderr`] instead of `io::stdout`. See [`print!`] for\n/// example usage.\n///\n/// Use `eprint!` only for error and progress messages. Use `print!`\n/// instead for the primary output of your program.\n///\n/// [`io::stderr`]: ../std/io/struct.Stderr.html\n/// [`print!`]: ../std/macro.print.html\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Examples\n///\n/// ```\n/// eprint!(\"Error: Could not complete task\");\n/// ```\n#[macro_export]\n#[stable(feature = \"eprint\", since = \"1.19.0\")]\n#[allow_internal_unstable(print_internals)]\nmacro_rules! eprint {\n    ($($arg:tt)*) => ($crate::io::_eprint($crate::format_args!($($arg)*)));\n}\n\n/// Prints to the standard error, with a newline.\n///\n/// Equivalent to the [`println!`] macro, except that output goes to\n/// [`io::stderr`] instead of `io::stdout`. See [`println!`] for\n/// example usage.\n///\n/// Use `eprintln!` only for error and progress messages. Use `println!`\n/// instead for the primary output of your program.\n///\n/// [`io::stderr`]: ../std/io/struct.Stderr.html\n/// [`println!`]: ../std/macro.println.html\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Examples\n///\n/// ```\n/// eprintln!(\"Error: Could not complete task\");\n/// ```\n#[macro_export]\n#[stable(feature = \"eprint\", since = \"1.19.0\")]\n#[allow_internal_unstable(print_internals, format_args_nl)]\nmacro_rules! eprintln {\n    () => ($crate::eprint!(\"\\n\"));\n    ($($arg:tt)*) => ({\n        $crate::io::_eprint($crate::format_args_nl!($($arg)*));\n    })\n}\n\n/// Prints and returns the value of a given expression for quick and dirty\n/// debugging.\n///\n/// An example:\n///\n/// ```rust\n/// let a = 2;\n/// let b = dbg!(a * 2) + 1;\n/// //      ^-- prints: [src/main.rs:2] a * 2 = 4\n/// assert_eq!(b, 5);\n/// ```\n///\n/// The macro works by using the `Debug` implementation of the type of\n/// the given expression to print the value to [stderr] along with the\n/// source location of the macro invocation as well as the source code\n/// of the expression.\n///\n/// Invoking the macro on an expression moves and takes ownership of it\n/// before returning the evaluated expression unchanged. If the type\n/// of the expression does not implement `Copy` and you don't want\n/// to give up ownership, you can instead borrow with `dbg!(&expr)`\n/// for some expression `expr`.\n///\n/// The `dbg!` macro works exactly the same in release builds.\n/// This is useful when debugging issues that only occur in release\n/// builds or when debugging in release mode is significantly faster.\n///\n/// Note that the macro is intended as a debugging tool and therefore you\n/// should avoid having uses of it in version control for longer periods.\n/// Use cases involving debug output that should be added to version control\n/// are better served by macros such as [`debug!`] from the [`log`] crate.\n///\n/// # Stability\n///\n/// The exact output printed by this macro should not be relied upon\n/// and is subject to future changes.\n///\n/// # Panics\n///\n/// Panics if writing to `io::stderr` fails.\n///\n/// # Further examples\n///\n/// With a method call:\n///\n/// ```rust\n/// fn foo(n: usize) {\n///     if let Some(_) = dbg!(n.checked_sub(4)) {\n///         // ...\n///     }\n/// }\n///\n/// foo(3)\n/// ```\n///\n/// This prints to [stderr]:\n///\n/// ```text,ignore\n/// [src/main.rs:4] n.checked_sub(4) = None\n/// ```\n///\n/// Naive factorial implementation:\n///\n/// ```rust\n/// fn factorial(n: u32) -> u32 {\n///     if dbg!(n <= 1) {\n///         dbg!(1)\n///     } else {\n///         dbg!(n * factorial(n - 1))\n///     }\n/// }\n///\n/// dbg!(factorial(4));\n/// ```\n///\n/// This prints to [stderr]:\n///\n/// ```text,ignore\n/// [src/main.rs:3] n <= 1 = false\n/// [src/main.rs:3] n <= 1 = false\n/// [src/main.rs:3] n <= 1 = false\n/// [src/main.rs:3] n <= 1 = true\n/// [src/main.rs:4] 1 = 1\n/// [src/main.rs:5] n * factorial(n - 1) = 2\n/// [src/main.rs:5] n * factorial(n - 1) = 6\n/// [src/main.rs:5] n * factorial(n - 1) = 24\n/// [src/main.rs:11] factorial(4) = 24\n/// ```\n///\n/// The `dbg!(..)` macro moves the input:\n///\n/// ```compile_fail\n/// /// A wrapper around `usize` which importantly is not Copyable.\n/// #[derive(Debug)]\n/// struct NoCopy(usize);\n///\n/// let a = NoCopy(42);\n/// let _ = dbg!(a); // <-- `a` is moved here.\n/// let _ = dbg!(a); // <-- `a` is moved again; error!\n/// ```\n///\n/// You can also use `dbg!()` without a value to just print the\n/// file and line whenever it's reached.\n///\n/// Finally, if you want to `dbg!(..)` multiple values, it will treat them as\n/// a tuple (and return it, too):\n///\n/// ```\n/// assert_eq!(dbg!(1usize, 2u32), (1, 2));\n/// ```\n///\n/// However, a single argument with a trailing comma will still not be treated\n/// as a tuple, following the convention of ignoring trailing commas in macro\n/// invocations. You can use a 1-tuple directly if you need one:\n///\n/// ```\n/// assert_eq!(1, dbg!(1u32,)); // trailing comma ignored\n/// assert_eq!((1,), dbg!((1u32,))); // 1-tuple\n/// ```\n///\n/// [stderr]: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)\n/// [`debug!`]: https://docs.rs/log/*/log/macro.debug.html\n/// [`log`]: https://crates.io/crates/log\n#[macro_export]\n#[stable(feature = \"dbg_macro\", since = \"1.32.0\")]\nmacro_rules! dbg {\n    () => {\n        $crate::eprintln!(\"[{}:{}]\", $crate::file!(), $crate::line!());\n    };\n    ($val:expr) => {\n        // Use of `match` here is intentional because it affects the lifetimes\n        // of temporaries - https://stackoverflow.com/a/48732525/1063961\n        match $val {\n            tmp => {\n                $crate::eprintln!(\"[{}:{}] {} = {:#?}\",\n                    $crate::file!(), $crate::line!(), $crate::stringify!($val), &tmp);\n                tmp\n            }\n        }\n    };\n    // Trailing comma with single argument is ignored\n    ($val:expr,) => { $crate::dbg!($val) };\n    ($($val:expr),+ $(,)?) => {\n        ($($crate::dbg!($val)),+,)\n    };\n}\n\n#[cfg(test)]\nmacro_rules! assert_approx_eq {\n}\n}\n\n// The Rust prelude\npub mod prelude {\n//! The Rust Prelude.\n//!\n//! Rust comes with a variety of things in its standard library. However, if\n//! you had to manually import every single thing that you used, it would be\n//! very verbose. But importing a lot of things that a program never uses isn't\n//! good either. A balance needs to be struck.\n//!\n//! The *prelude* is the list of things that Rust automatically imports into\n//! every Rust program. It's kept as small as possible, and is focused on\n//! things, particularly traits, which are used in almost every single Rust\n//! program.\n//!\n//! On a technical level, Rust inserts\n//!\n//! ```\n//! # #[allow(unused_extern_crates)]\n//! extern crate std;\n//! ```\n//!\n//! into the crate root of every crate, and\n//!\n//! ```\n//! # #[allow(unused_imports)]\n//! use std::prelude::v1::*;\n//! ```\n//!\n//! into every module.\n//!\n//! # Other preludes\n//!\n//! Preludes can be seen as a pattern to make using multiple types more\n//! convenient. As such, you'll find other preludes in the standard library,\n//! such as [`std::io::prelude`]. Various libraries in the Rust ecosystem may\n//! also define their own preludes.\n//!\n//! [`std::io::prelude`]: ../io/prelude/index.html\n//!\n//! The difference between 'the prelude' and these other preludes is that they\n//! are not automatically `use`'d, and must be imported manually. This is still\n//! easier than importing all of their constituent components.\n//!\n//! # Prelude contents\n//!\n//! The current version of the prelude (version 1) lives in\n//! [`std::prelude::v1`], and re-exports the following.\n//!\n//! * [`std::marker`]::{[`Copy`], [`Send`], [`Sized`], [`Sync`], [`Unpin`]}. The\n//!   marker traits indicate fundamental properties of types.\n//! * [`std::ops`]::{[`Drop`], [`Fn`], [`FnMut`], [`FnOnce`]}. Various\n//!   operations for both destructors and overloading `()`.\n//! * [`std::mem`]::[`drop`][`mem::drop`], a convenience function for explicitly\n//!   dropping a value.\n//! * [`std::boxed`]::[`Box`], a way to allocate values on the heap.\n//! * [`std::borrow`]::[`ToOwned`], The conversion trait that defines\n//!   [`to_owned`], the generic method for creating an owned type from a\n//!   borrowed type.\n//! * [`std::clone`]::[`Clone`], the ubiquitous trait that defines\n//!   [`clone`][`Clone::clone`], the method for producing a copy of a value.\n//! * [`std::cmp`]::{[`PartialEq`], [`PartialOrd`], [`Eq`], [`Ord`] }. The\n//!   comparison traits, which implement the comparison operators and are often\n//!   seen in trait bounds.\n//! * [`std::convert`]::{[`AsRef`], [`AsMut`], [`Into`], [`From`]}. Generic\n//!   conversions, used by savvy API authors to create overloaded methods.\n//! * [`std::default`]::[`Default`], types that have default values.\n//! * [`std::iter`]::{[`Iterator`], [`Extend`], [`IntoIterator`],\n//!   [`DoubleEndedIterator`], [`ExactSizeIterator`]}. Iterators of various\n//!   kinds.\n//! * [`std::option`]::[`Option`]::{`self`, `Some`, `None`}. A type which\n//!   expresses the presence or absence of a value. This type is so commonly\n//!   used, its variants are also exported.\n//! * [`std::result`]::[`Result`]::{`self`, `Ok`, `Err`}. A type for functions\n//!   that may succeed or fail. Like [`Option`], its variants are exported as\n//!   well.\n//! * [`std::string`]::{[`String`], [`ToString`]}, heap allocated strings.\n//! * [`std::vec`]::[`Vec`](../vec/struct.Vec.html), a growable, heap-allocated\n//!   vector.\n//!\n//! [`AsMut`]: ../convert/trait.AsMut.html\n//! [`AsRef`]: ../convert/trait.AsRef.html\n//! [`Box`]: ../boxed/struct.Box.html\n//! [`Clone`]: ../clone/trait.Clone.html\n//! [`Copy`]: ../marker/trait.Copy.html\n//! [`Default`]: ../default/trait.Default.html\n//! [`DoubleEndedIterator`]: ../iter/trait.DoubleEndedIterator.html\n//! [`Drop`]: ../ops/trait.Drop.html\n//! [`Eq`]: ../cmp/trait.Eq.html\n//! [`ExactSizeIterator`]: ../iter/trait.ExactSizeIterator.html\n//! [`Extend`]: ../iter/trait.Extend.html\n//! [`FnMut`]: ../ops/trait.FnMut.html\n//! [`FnOnce`]: ../ops/trait.FnOnce.html\n//! [`Fn`]: ../ops/trait.Fn.html\n//! [`From`]: ../convert/trait.From.html\n//! [`IntoIterator`]: ../iter/trait.IntoIterator.html\n//! [`Into`]: ../convert/trait.Into.html\n//! [`Iterator`]: ../iter/trait.Iterator.html\n//! [`Option`]: ../option/enum.Option.html\n//! [`Ord`]: ../cmp/trait.Ord.html\n//! [`PartialEq`]: ../cmp/trait.PartialEq.html\n//! [`PartialOrd`]: ../cmp/trait.PartialOrd.html\n//! [`Result`]: ../result/enum.Result.html\n//! [`Send`]: ../marker/trait.Send.html\n//! [`Sized`]: ../marker/trait.Sized.html\n//! [`SliceConcatExt`]: ../slice/trait.SliceConcatExt.html\n//! [`String`]: ../string/struct.String.html\n//! [`Sync`]: ../marker/trait.Sync.html\n//! [`ToOwned`]: ../borrow/trait.ToOwned.html\n//! [`ToString`]: ../string/trait.ToString.html\n//! [`Unpin`]: ../marker/trait.Unpin.html\n//! [`Vec`]: ../vec/struct.Vec.html\n//! [`Clone::clone`]: ../clone/trait.Clone.html#tymethod.clone\n//! [`mem::drop`]: ../mem/fn.drop.html\n//! [`std::borrow`]: ../borrow/index.html\n//! [`std::boxed`]: ../boxed/index.html\n//! [`std::clone`]: ../clone/index.html\n//! [`std::cmp`]: ../cmp/index.html\n//! [`std::convert`]: ../convert/index.html\n//! [`std::default`]: ../default/index.html\n//! [`std::iter`]: ../iter/index.html\n//! [`std::marker`]: ../marker/index.html\n//! [`std::mem`]: ../mem/index.html\n//! [`std::ops`]: ../ops/index.html\n//! [`std::option`]: ../option/index.html\n//! [`std::prelude::v1`]: v1/index.html\n//! [`std::result`]: ../result/index.html\n//! [`std::slice`]: ../slice/index.html\n//! [`std::string`]: ../string/index.html\n//! [`std::vec`]: ../vec/index.html\n//! [`to_owned`]: ../borrow/trait.ToOwned.html#tymethod.to_owned\n//! [book-closures]: ../../book/ch13-01-closures.html\n//! [book-dtor]: ../../book/ch15-03-drop.html\n//! [book-enums]: ../../book/ch06-01-defining-an-enum.html\n//! [book-iter]: ../../book/ch13-02-iterators.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\npub mod v1 {\n//! The first version of the prelude of The Rust Standard Library.\n//!\n//! See the [module-level documentation](../index.html) for more.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n// Re-exported core operators\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::marker::{Send, Sized, Sync, Unpin};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::ops::{Drop, Fn, FnMut, FnOnce};\n\n// Re-exported functions\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::mem::drop;\n\n// Re-exported types and traits\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::convert::{AsMut, AsRef, From, Into};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::iter::{Extend, IntoIterator, Iterator};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::option::Option::{self, None, Some};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::result::Result::{self, Err, Ok};\n\n// Re-exported built-in macros\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[doc(no_inline)]\npub use core::prelude::v1::{\n    asm, assert, cfg, column, compile_error, concat, concat_idents, env, file, format_args,\n    format_args_nl, global_asm, include, include_bytes, include_str, line, log_syntax, module_path,\n    option_env, stringify, trace_macros,\n};\n\n// FIXME: Attribute and derive macros are not documented because for them rustdoc generates\n// dead links which fail link checker testing.\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow(deprecated)]\n#[doc(hidden)]\npub use core::prelude::v1::{\n    bench, global_allocator, test, test_case, Clone, Copy, Debug, Default, Eq, Hash, Ord,\n    PartialEq, PartialOrd, RustcDecodable, RustcEncodable,\n};\n\n// The file so far is equivalent to src/libcore/prelude/v1.rs,\n// and below to src/liballoc/prelude.rs.\n// Those files are duplicated rather than using glob imports\n// because we want docs to show these re-exports as pointing to within `std`.\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::borrow::ToOwned;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::boxed::Box;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::string::{String, ToString};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use crate::vec::Vec;\n}\n}\n\n// Public module declarations and re-exports\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::borrow;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::boxed;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::fmt;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::format;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::rc;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::slice;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::str;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::string;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::vec;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::any;\n#[stable(feature = \"simd_arch\", since = \"1.27.0\")]\n#[doc(no_inline)]\npub use core::arch;\n#[stable(feature = \"core_array\", since = \"1.36.0\")]\npub use core::array;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::cell;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::char;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::clone;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::cmp;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::convert;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::default;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::hash;\n#[stable(feature = \"core_hint\", since = \"1.27.0\")]\npub use core::hint;\n#[stable(feature = \"i128\", since = \"1.26.0\")]\npub use core::i128;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::i16;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::i32;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::i64;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::i8;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::intrinsics;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::isize;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::iter;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::marker;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::mem;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::ops;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::option;\n#[stable(feature = \"pin\", since = \"1.33.0\")]\npub use core::pin;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::ptr;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::raw;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::result;\n#[stable(feature = \"i128\", since = \"1.26.0\")]\npub use core::u128;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::u16;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::u32;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::u64;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::u8;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::usize;\n\npub mod f32 {\n//! This module provides constants which are specific to the implementation\n//! of the `f32` floating point data type.\n//!\n//! *[See also the `f32` primitive type](../../std/primitive.f32.html).*\n//!\n//! Mathematically significant numbers are provided in the `consts` sub-module.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![allow(missing_docs)]\n\n#[cfg(not(test))]\nuse crate::intrinsics;\n#[cfg(not(test))]\nuse crate::sys::cmath;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::f32::consts;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::f32::{DIGITS, EPSILON, MANTISSA_DIGITS, RADIX};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::f32::{INFINITY, MAX_10_EXP, NAN, NEG_INFINITY};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::f32::{MAX, MIN, MIN_POSITIVE};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::f32::{MAX_EXP, MIN_10_EXP, MIN_EXP};\n\n#[cfg(not(test))]\n#[lang = \"f32_runtime\"]\nimpl f32 {\n    /// Returns the largest integer less than or equal to a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.7_f32;\n    /// let g = 3.0_f32;\n    /// let h = -3.7_f32;\n    ///\n    /// assert_eq!(f.floor(), 3.0);\n    /// assert_eq!(g.floor(), 3.0);\n    /// assert_eq!(h.floor(), -4.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn floor(self) -> f32 {\n}\n\n    /// Returns the smallest integer greater than or equal to a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.01_f32;\n    /// let g = 4.0_f32;\n    ///\n    /// assert_eq!(f.ceil(), 4.0);\n    /// assert_eq!(g.ceil(), 4.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn ceil(self) -> f32 {\n}\n\n    /// Returns the nearest integer to a number. Round half-way cases away from\n    /// `0.0`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.3_f32;\n    /// let g = -3.3_f32;\n    ///\n    /// assert_eq!(f.round(), 3.0);\n    /// assert_eq!(g.round(), -3.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn round(self) -> f32 {\n}\n\n    /// Returns the integer part of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.7_f32;\n    /// let g = 3.0_f32;\n    /// let h = -3.7_f32;\n    ///\n    /// assert_eq!(f.trunc(), 3.0);\n    /// assert_eq!(g.trunc(), 3.0);\n    /// assert_eq!(h.trunc(), -3.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn trunc(self) -> f32 {\n}\n\n    /// Returns the fractional part of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = 3.6_f32;\n    /// let y = -3.6_f32;\n    /// let abs_difference_x = (x.fract() - 0.6).abs();\n    /// let abs_difference_y = (y.fract() - (-0.6)).abs();\n    ///\n    /// assert!(abs_difference_x <= f32::EPSILON);\n    /// assert!(abs_difference_y <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn fract(self) -> f32 {\n}\n\n    /// Computes the absolute value of `self`. Returns `NAN` if the\n    /// number is `NAN`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = 3.5_f32;\n    /// let y = -3.5_f32;\n    ///\n    /// let abs_difference_x = (x.abs() - x).abs();\n    /// let abs_difference_y = (y.abs() - (-y)).abs();\n    ///\n    /// assert!(abs_difference_x <= f32::EPSILON);\n    /// assert!(abs_difference_y <= f32::EPSILON);\n    ///\n    /// assert!(f32::NAN.abs().is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn abs(self) -> f32 {\n}\n\n    /// Returns a number that represents the sign of `self`.\n    ///\n    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n    /// - `NAN` if the number is `NAN`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let f = 3.5_f32;\n    ///\n    /// assert_eq!(f.signum(), 1.0);\n    /// assert_eq!(f32::NEG_INFINITY.signum(), -1.0);\n    ///\n    /// assert!(f32::NAN.signum().is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn signum(self) -> f32 {\n}\n\n    /// Returns a number composed of the magnitude of `self` and the sign of\n    /// `sign`.\n    ///\n    /// Equal to `self` if the sign of `self` and `sign` are the same, otherwise\n    /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of\n    /// `sign` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let f = 3.5_f32;\n    ///\n    /// assert_eq!(f.copysign(0.42), 3.5_f32);\n    /// assert_eq!(f.copysign(-0.42), -3.5_f32);\n    /// assert_eq!((-f).copysign(0.42), 3.5_f32);\n    /// assert_eq!((-f).copysign(-0.42), -3.5_f32);\n    ///\n    /// assert!(f32::NAN.copysign(1.0).is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[inline]\n    #[stable(feature = \"copysign\", since = \"1.35.0\")]\n    pub fn copysign(self, sign: f32) -> f32 {\n}\n\n    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n    /// error, yielding a more accurate result than an unfused multiply-add.\n    ///\n    /// Using `mul_add` can be more performant than an unfused multiply-add if\n    /// the target architecture has a dedicated `fma` CPU instruction.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let m = 10.0_f32;\n    /// let x = 4.0_f32;\n    /// let b = 60.0_f32;\n    ///\n    /// // 100.0\n    /// let abs_difference = (m.mul_add(x, b) - ((m * x) + b)).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn mul_add(self, a: f32, b: f32) -> f32 {\n}\n\n    /// Calculates Euclidean division, the matching method for `rem_euclid`.\n    ///\n    /// This computes the integer `n` such that\n    /// `self = n * rhs + self.rem_euclid(rhs)`.\n    /// In other words, the result is `self / rhs` rounded to the integer `n`\n    /// such that `self >= n * rhs`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a: f32 = 7.0;\n    /// let b = 4.0;\n    /// assert_eq!(a.div_euclid(b), 1.0); // 7.0 > 4.0 * 1.0\n    /// assert_eq!((-a).div_euclid(b), -2.0); // -7.0 >= 4.0 * -2.0\n    /// assert_eq!(a.div_euclid(-b), -1.0); // 7.0 >= -4.0 * -1.0\n    /// assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[inline]\n    #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n    pub fn div_euclid(self, rhs: f32) -> f32 {\n}\n\n    /// Calculates the least nonnegative remainder of `self (mod rhs)`.\n    ///\n    /// In particular, the return value `r` satisfies `0.0 <= r < rhs.abs()` in\n    /// most cases. However, due to a floating point round-off error it can\n    /// result in `r == rhs.abs()`, violating the mathematical definition, if\n    /// `self` is much smaller than `rhs.abs()` in magnitude and `self < 0.0`.\n    /// This result is not an element of the function's codomain, but it is the\n    /// closest floating point number in the real numbers and thus fulfills the\n    /// property `self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)`\n    /// approximatively.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a: f32 = 7.0;\n    /// let b = 4.0;\n    /// assert_eq!(a.rem_euclid(b), 3.0);\n    /// assert_eq!((-a).rem_euclid(b), 1.0);\n    /// assert_eq!(a.rem_euclid(-b), 3.0);\n    /// assert_eq!((-a).rem_euclid(-b), 1.0);\n    /// // limitation due to round-off error\n    /// assert!((-std::f32::EPSILON).rem_euclid(3.0) != 0.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[inline]\n    #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n    pub fn rem_euclid(self, rhs: f32) -> f32 {\n}\n\n    /// Raises a number to an integer power.\n    ///\n    /// Using this function is generally faster than using `powf`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = 2.0_f32;\n    /// let abs_difference = (x.powi(2) - (x * x)).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn powi(self, n: i32) -> f32 {\n}\n\n    /// Raises a number to a floating point power.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = 2.0_f32;\n    /// let abs_difference = (x.powf(2.0) - (x * x)).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn powf(self, n: f32) -> f32 {\n}\n\n    /// Returns the square root of a number.\n    ///\n    /// Returns NaN if `self` is a negative number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let positive = 4.0_f32;\n    /// let negative = -4.0_f32;\n    ///\n    /// let abs_difference = (positive.sqrt() - 2.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// assert!(negative.sqrt().is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sqrt(self) -> f32 {\n}\n\n    /// Returns `e^(self)`, (the exponential function).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let one = 1.0f32;\n    /// // e^1\n    /// let e = one.exp();\n    ///\n    /// // ln(e) - 1 == 0\n    /// let abs_difference = (e.ln() - 1.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn exp(self) -> f32 {\n}\n\n    /// Returns `2^(self)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let f = 2.0f32;\n    ///\n    /// // 2^2 - 4 == 0\n    /// let abs_difference = (f.exp2() - 4.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn exp2(self) -> f32 {\n}\n\n    /// Returns the natural logarithm of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let one = 1.0f32;\n    /// // e^1\n    /// let e = one.exp();\n    ///\n    /// // ln(e) - 1 == 0\n    /// let abs_difference = (e.ln() - 1.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn ln(self) -> f32 {\n}\n\n    /// Returns the logarithm of the number with respect to an arbitrary base.\n    ///\n    /// The result may not be correctly rounded owing to implementation details;\n    /// `self.log2()` can produce more accurate results for base 2, and\n    /// `self.log10()` can produce more accurate results for base 10.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let five = 5.0f32;\n    ///\n    /// // log5(5) - 1 == 0\n    /// let abs_difference = (five.log(5.0) - 1.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn log(self, base: f32) -> f32 {\n}\n\n    /// Returns the base 2 logarithm of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let two = 2.0f32;\n    ///\n    /// // log2(2) - 1 == 0\n    /// let abs_difference = (two.log2() - 1.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn log2(self) -> f32 {\n}\n\n    /// Returns the base 10 logarithm of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let ten = 10.0f32;\n    ///\n    /// // log10(10) - 1 == 0\n    /// let abs_difference = (ten.log10() - 1.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn log10(self) -> f32 {\n}\n\n    /// The positive difference of two numbers.\n    ///\n    /// * If `self <= other`: `0:0`\n    /// * Else: `self - other`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = 3.0f32;\n    /// let y = -3.0f32;\n    ///\n    /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n    /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n    ///\n    /// assert!(abs_difference_x <= f32::EPSILON);\n    /// assert!(abs_difference_y <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    #[rustc_deprecated(\n        since = \"1.10.0\",\n        reason = \"you probably meant `(self - other).abs()`: \\\n                  this operation is `(self - other).max(0.0)` \\\n                  except that `abs_sub` also propagates NaNs (also \\\n                  known as `fdimf` in C). If you truly need the positive \\\n                  difference, consider using that expression or the C function \\\n                  `fdimf`, depending on how you wish to handle NaN (please consider \\\n                  filing an issue describing your use-case too).\"\n    )]\n    pub fn abs_sub(self, other: f32) -> f32 {\n}\n\n    /// Returns the cubic root of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = 8.0f32;\n    ///\n    /// // x^(1/3) - 2 == 0\n    /// let abs_difference = (x.cbrt() - 2.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn cbrt(self) -> f32 {\n}\n\n    /// Calculates the length of the hypotenuse of a right-angle triangle given\n    /// legs of length `x` and `y`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = 2.0f32;\n    /// let y = 3.0f32;\n    ///\n    /// // sqrt(x^2 + y^2)\n    /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn hypot(self, other: f32) -> f32 {\n}\n\n    /// Computes the sine of a number (in radians).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = f32::consts::FRAC_PI_2;\n    ///\n    /// let abs_difference = (x.sin() - 1.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sin(self) -> f32 {\n}\n\n    /// Computes the cosine of a number (in radians).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = 2.0 * f32::consts::PI;\n    ///\n    /// let abs_difference = (x.cos() - 1.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn cos(self) -> f32 {\n}\n\n    /// Computes the tangent of a number (in radians).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = f32::consts::FRAC_PI_4;\n    /// let abs_difference = (x.tan() - 1.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn tan(self) -> f32 {\n}\n\n    /// Computes the arcsine of a number. Return value is in radians in\n    /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n    /// [-1, 1].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let f = f32::consts::FRAC_PI_2;\n    ///\n    /// // asin(sin(pi/2))\n    /// let abs_difference = (f.sin().asin() - f32::consts::FRAC_PI_2).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn asin(self) -> f32 {\n}\n\n    /// Computes the arccosine of a number. Return value is in radians in\n    /// the range [0, pi] or NaN if the number is outside the range\n    /// [-1, 1].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let f = f32::consts::FRAC_PI_4;\n    ///\n    /// // acos(cos(pi/4))\n    /// let abs_difference = (f.cos().acos() - f32::consts::FRAC_PI_4).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn acos(self) -> f32 {\n}\n\n    /// Computes the arctangent of a number. Return value is in radians in the\n    /// range [-pi/2, pi/2];\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let f = 1.0f32;\n    ///\n    /// // atan(tan(1))\n    /// let abs_difference = (f.tan().atan() - 1.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn atan(self) -> f32 {\n}\n\n    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`) in radians.\n    ///\n    /// * `x = 0`, `y = 0`: `0`\n    /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n    /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`\n    /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// // Positive angles measured counter-clockwise\n    /// // from positive x axis\n    /// // -pi/4 radians (45 deg clockwise)\n    /// let x1 = 3.0f32;\n    /// let y1 = -3.0f32;\n    ///\n    /// // 3pi/4 radians (135 deg counter-clockwise)\n    /// let x2 = -3.0f32;\n    /// let y2 = 3.0f32;\n    ///\n    /// let abs_difference_1 = (y1.atan2(x1) - (-f32::consts::FRAC_PI_4)).abs();\n    /// let abs_difference_2 = (y2.atan2(x2) - (3.0 * f32::consts::FRAC_PI_4)).abs();\n    ///\n    /// assert!(abs_difference_1 <= f32::EPSILON);\n    /// assert!(abs_difference_2 <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn atan2(self, other: f32) -> f32 {\n}\n\n    /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n    /// `(sin(x), cos(x))`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = f32::consts::FRAC_PI_4;\n    /// let f = x.sin_cos();\n    ///\n    /// let abs_difference_0 = (f.0 - x.sin()).abs();\n    /// let abs_difference_1 = (f.1 - x.cos()).abs();\n    ///\n    /// assert!(abs_difference_0 <= f32::EPSILON);\n    /// assert!(abs_difference_1 <= f32::EPSILON);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sin_cos(self) -> (f32, f32) {\n}\n\n    /// Returns `e^(self) - 1` in a way that is accurate even if the\n    /// number is close to zero.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = 6.0f32;\n    ///\n    /// // e^(ln(6)) - 1\n    /// let abs_difference = (x.ln().exp_m1() - 5.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn exp_m1(self) -> f32 {\n}\n\n    /// Returns `ln(1+n)` (natural logarithm) more accurately than if\n    /// the operations were performed separately.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = f32::consts::E - 1.0;\n    ///\n    /// // ln(1 + (e - 1)) == ln(e) == 1\n    /// let abs_difference = (x.ln_1p() - 1.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn ln_1p(self) -> f32 {\n}\n\n    /// Hyperbolic sine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let e = f32::consts::E;\n    /// let x = 1.0f32;\n    ///\n    /// let f = x.sinh();\n    /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n    /// let g = ((e * e) - 1.0) / (2.0 * e);\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sinh(self) -> f32 {\n}\n\n    /// Hyperbolic cosine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let e = f32::consts::E;\n    /// let x = 1.0f32;\n    /// let f = x.cosh();\n    /// // Solving cosh() at 1 gives this result\n    /// let g = ((e * e) + 1.0) / (2.0 * e);\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// // Same result\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn cosh(self) -> f32 {\n}\n\n    /// Hyperbolic tangent function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let e = f32::consts::E;\n    /// let x = 1.0f32;\n    ///\n    /// let f = x.tanh();\n    /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n    /// let g = (1.0 - e.powi(-2)) / (1.0 + e.powi(-2));\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn tanh(self) -> f32 {\n}\n\n    /// Inverse hyperbolic sine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = 1.0f32;\n    /// let f = x.sinh().asinh();\n    ///\n    /// let abs_difference = (f - x).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn asinh(self) -> f32 {\n}\n\n    /// Inverse hyperbolic cosine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = 1.0f32;\n    /// let f = x.cosh().acosh();\n    ///\n    /// let abs_difference = (f - x).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn acosh(self) -> f32 {\n}\n\n    /// Inverse hyperbolic tangent function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let e = f32::consts::E;\n    /// let f = e.tanh().atanh();\n    ///\n    /// let abs_difference = (f - e).abs();\n    ///\n    /// assert!(abs_difference <= 1e-5);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn atanh(self) -> f32 {\n}\n\n    /// Restrict a value to a certain interval unless it is NaN.\n    ///\n    /// Returns `max` if `self` is greater than `max`, and `min` if `self` is\n    /// less than `min`. Otherwise this returns `self`.\n    ///\n    /// Not that this function returns NaN if the initial value was NaN as\n    /// well.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `min > max`, `min` is NaN, or `max` is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(clamp)]\n    /// assert!((-3.0f32).clamp(-2.0, 1.0) == -2.0);\n    /// assert!((0.0f32).clamp(-2.0, 1.0) == 0.0);\n    /// assert!((2.0f32).clamp(-2.0, 1.0) == 1.0);\n    /// assert!((std::f32::NAN).clamp(-2.0, 1.0).is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[unstable(feature = \"clamp\", issue = \"44095\")]\n    #[inline]\n    pub fn clamp(self, min: f32, max: f32) -> f32 {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\npub mod f64 {\n//! This module provides constants which are specific to the implementation\n//! of the `f64` floating point data type.\n//!\n//! *[See also the `f64` primitive type](../../std/primitive.f64.html).*\n//!\n//! Mathematically significant numbers are provided in the `consts` sub-module.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![allow(missing_docs)]\n\n#[cfg(not(test))]\nuse crate::intrinsics;\n#[cfg(not(test))]\nuse crate::sys::cmath;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::f64::consts;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::f64::{DIGITS, EPSILON, MANTISSA_DIGITS, RADIX};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::f64::{INFINITY, MAX_10_EXP, NAN, NEG_INFINITY};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::f64::{MAX, MIN, MIN_POSITIVE};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::f64::{MAX_EXP, MIN_10_EXP, MIN_EXP};\n\n#[cfg(not(test))]\n#[lang = \"f64_runtime\"]\nimpl f64 {\n    /// Returns the largest integer less than or equal to a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.7_f64;\n    /// let g = 3.0_f64;\n    /// let h = -3.7_f64;\n    ///\n    /// assert_eq!(f.floor(), 3.0);\n    /// assert_eq!(g.floor(), 3.0);\n    /// assert_eq!(h.floor(), -4.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn floor(self) -> f64 {\n}\n\n    /// Returns the smallest integer greater than or equal to a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.01_f64;\n    /// let g = 4.0_f64;\n    ///\n    /// assert_eq!(f.ceil(), 4.0);\n    /// assert_eq!(g.ceil(), 4.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn ceil(self) -> f64 {\n}\n\n    /// Returns the nearest integer to a number. Round half-way cases away from\n    /// `0.0`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.3_f64;\n    /// let g = -3.3_f64;\n    ///\n    /// assert_eq!(f.round(), 3.0);\n    /// assert_eq!(g.round(), -3.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn round(self) -> f64 {\n}\n\n    /// Returns the integer part of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 3.7_f64;\n    /// let g = 3.0_f64;\n    /// let h = -3.7_f64;\n    ///\n    /// assert_eq!(f.trunc(), 3.0);\n    /// assert_eq!(g.trunc(), 3.0);\n    /// assert_eq!(h.trunc(), -3.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn trunc(self) -> f64 {\n}\n\n    /// Returns the fractional part of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 3.6_f64;\n    /// let y = -3.6_f64;\n    /// let abs_difference_x = (x.fract() - 0.6).abs();\n    /// let abs_difference_y = (y.fract() - (-0.6)).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn fract(self) -> f64 {\n}\n\n    /// Computes the absolute value of `self`. Returns `NAN` if the\n    /// number is `NAN`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let x = 3.5_f64;\n    /// let y = -3.5_f64;\n    ///\n    /// let abs_difference_x = (x.abs() - x).abs();\n    /// let abs_difference_y = (y.abs() - (-y)).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    ///\n    /// assert!(f64::NAN.abs().is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn abs(self) -> f64 {\n}\n\n    /// Returns a number that represents the sign of `self`.\n    ///\n    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n    /// - `NAN` if the number is `NAN`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let f = 3.5_f64;\n    ///\n    /// assert_eq!(f.signum(), 1.0);\n    /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);\n    ///\n    /// assert!(f64::NAN.signum().is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn signum(self) -> f64 {\n}\n\n    /// Returns a number composed of the magnitude of `self` and the sign of\n    /// `sign`.\n    ///\n    /// Equal to `self` if the sign of `self` and `sign` are the same, otherwise\n    /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of\n    /// `sign` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let f = 3.5_f64;\n    ///\n    /// assert_eq!(f.copysign(0.42), 3.5_f64);\n    /// assert_eq!(f.copysign(-0.42), -3.5_f64);\n    /// assert_eq!((-f).copysign(0.42), 3.5_f64);\n    /// assert_eq!((-f).copysign(-0.42), -3.5_f64);\n    ///\n    /// assert!(f64::NAN.copysign(1.0).is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"copysign\", since = \"1.35.0\")]\n    #[inline]\n    pub fn copysign(self, sign: f64) -> f64 {\n}\n\n    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n    /// error, yielding a more accurate result than an unfused multiply-add.\n    ///\n    /// Using `mul_add` can be more performant than an unfused multiply-add if\n    /// the target architecture has a dedicated `fma` CPU instruction.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let m = 10.0_f64;\n    /// let x = 4.0_f64;\n    /// let b = 60.0_f64;\n    ///\n    /// // 100.0\n    /// let abs_difference = (m.mul_add(x, b) - ((m * x) + b)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn mul_add(self, a: f64, b: f64) -> f64 {\n}\n\n    /// Calculates Euclidean division, the matching method for `rem_euclid`.\n    ///\n    /// This computes the integer `n` such that\n    /// `self = n * rhs + self.rem_euclid(rhs)`.\n    /// In other words, the result is `self / rhs` rounded to the integer `n`\n    /// such that `self >= n * rhs`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a: f64 = 7.0;\n    /// let b = 4.0;\n    /// assert_eq!(a.div_euclid(b), 1.0); // 7.0 > 4.0 * 1.0\n    /// assert_eq!((-a).div_euclid(b), -2.0); // -7.0 >= 4.0 * -2.0\n    /// assert_eq!(a.div_euclid(-b), -1.0); // 7.0 >= -4.0 * -1.0\n    /// assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[inline]\n    #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n    pub fn div_euclid(self, rhs: f64) -> f64 {\n}\n\n    /// Calculates the least nonnegative remainder of `self (mod rhs)`.\n    ///\n    /// In particular, the return value `r` satisfies `0.0 <= r < rhs.abs()` in\n    /// most cases. However, due to a floating point round-off error it can\n    /// result in `r == rhs.abs()`, violating the mathematical definition, if\n    /// `self` is much smaller than `rhs.abs()` in magnitude and `self < 0.0`.\n    /// This result is not an element of the function's codomain, but it is the\n    /// closest floating point number in the real numbers and thus fulfills the\n    /// property `self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)`\n    /// approximatively.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a: f64 = 7.0;\n    /// let b = 4.0;\n    /// assert_eq!(a.rem_euclid(b), 3.0);\n    /// assert_eq!((-a).rem_euclid(b), 1.0);\n    /// assert_eq!(a.rem_euclid(-b), 3.0);\n    /// assert_eq!((-a).rem_euclid(-b), 1.0);\n    /// // limitation due to round-off error\n    /// assert!((-std::f64::EPSILON).rem_euclid(3.0) != 0.0);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[inline]\n    #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n    pub fn rem_euclid(self, rhs: f64) -> f64 {\n}\n\n    /// Raises a number to an integer power.\n    ///\n    /// Using this function is generally faster than using `powf`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 2.0_f64;\n    /// let abs_difference = (x.powi(2) - (x * x)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn powi(self, n: i32) -> f64 {\n}\n\n    /// Raises a number to a floating point power.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 2.0_f64;\n    /// let abs_difference = (x.powf(2.0) - (x * x)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn powf(self, n: f64) -> f64 {\n}\n\n    /// Returns the square root of a number.\n    ///\n    /// Returns NaN if `self` is a negative number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let positive = 4.0_f64;\n    /// let negative = -4.0_f64;\n    ///\n    /// let abs_difference = (positive.sqrt() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// assert!(negative.sqrt().is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sqrt(self) -> f64 {\n}\n\n    /// Returns `e^(self)`, (the exponential function).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let one = 1.0_f64;\n    /// // e^1\n    /// let e = one.exp();\n    ///\n    /// // ln(e) - 1 == 0\n    /// let abs_difference = (e.ln() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn exp(self) -> f64 {\n}\n\n    /// Returns `2^(self)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 2.0_f64;\n    ///\n    /// // 2^2 - 4 == 0\n    /// let abs_difference = (f.exp2() - 4.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn exp2(self) -> f64 {\n}\n\n    /// Returns the natural logarithm of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let one = 1.0_f64;\n    /// // e^1\n    /// let e = one.exp();\n    ///\n    /// // ln(e) - 1 == 0\n    /// let abs_difference = (e.ln() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn ln(self) -> f64 {\n}\n\n    /// Returns the logarithm of the number with respect to an arbitrary base.\n    ///\n    /// The result may not be correctly rounded owing to implementation details;\n    /// `self.log2()` can produce more accurate results for base 2, and\n    /// `self.log10()` can produce more accurate results for base 10.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let twenty_five = 25.0_f64;\n    ///\n    /// // log5(25) - 2 == 0\n    /// let abs_difference = (twenty_five.log(5.0) - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn log(self, base: f64) -> f64 {\n}\n\n    /// Returns the base 2 logarithm of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let four = 4.0_f64;\n    ///\n    /// // log2(4) - 2 == 0\n    /// let abs_difference = (four.log2() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn log2(self) -> f64 {\n}\n\n    /// Returns the base 10 logarithm of the number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let hundred = 100.0_f64;\n    ///\n    /// // log10(100) - 2 == 0\n    /// let abs_difference = (hundred.log10() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn log10(self) -> f64 {\n}\n\n    /// The positive difference of two numbers.\n    ///\n    /// * If `self <= other`: `0:0`\n    /// * Else: `self - other`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 3.0_f64;\n    /// let y = -3.0_f64;\n    ///\n    /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n    /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n    ///\n    /// assert!(abs_difference_x < 1e-10);\n    /// assert!(abs_difference_y < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    #[rustc_deprecated(\n        since = \"1.10.0\",\n        reason = \"you probably meant `(self - other).abs()`: \\\n                  this operation is `(self - other).max(0.0)` \\\n                  except that `abs_sub` also propagates NaNs (also \\\n                  known as `fdim` in C). If you truly need the positive \\\n                  difference, consider using that expression or the C function \\\n                  `fdim`, depending on how you wish to handle NaN (please consider \\\n                  filing an issue describing your use-case too).\"\n    )]\n    pub fn abs_sub(self, other: f64) -> f64 {\n}\n\n    /// Returns the cubic root of a number.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 8.0_f64;\n    ///\n    /// // x^(1/3) - 2 == 0\n    /// let abs_difference = (x.cbrt() - 2.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn cbrt(self) -> f64 {\n}\n\n    /// Calculates the length of the hypotenuse of a right-angle triangle given\n    /// legs of length `x` and `y`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 2.0_f64;\n    /// let y = 3.0_f64;\n    ///\n    /// // sqrt(x^2 + y^2)\n    /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn hypot(self, other: f64) -> f64 {\n}\n\n    /// Computes the sine of a number (in radians).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let x = f64::consts::FRAC_PI_2;\n    ///\n    /// let abs_difference = (x.sin() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sin(self) -> f64 {\n}\n\n    /// Computes the cosine of a number (in radians).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let x = 2.0 * f64::consts::PI;\n    ///\n    /// let abs_difference = (x.cos() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn cos(self) -> f64 {\n}\n\n    /// Computes the tangent of a number (in radians).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let x = f64::consts::FRAC_PI_4;\n    /// let abs_difference = (x.tan() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-14);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn tan(self) -> f64 {\n}\n\n    /// Computes the arcsine of a number. Return value is in radians in\n    /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n    /// [-1, 1].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let f = f64::consts::FRAC_PI_2;\n    ///\n    /// // asin(sin(pi/2))\n    /// let abs_difference = (f.sin().asin() - f64::consts::FRAC_PI_2).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn asin(self) -> f64 {\n}\n\n    /// Computes the arccosine of a number. Return value is in radians in\n    /// the range [0, pi] or NaN if the number is outside the range\n    /// [-1, 1].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let f = f64::consts::FRAC_PI_4;\n    ///\n    /// // acos(cos(pi/4))\n    /// let abs_difference = (f.cos().acos() - f64::consts::FRAC_PI_4).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn acos(self) -> f64 {\n}\n\n    /// Computes the arctangent of a number. Return value is in radians in the\n    /// range [-pi/2, pi/2];\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let f = 1.0_f64;\n    ///\n    /// // atan(tan(1))\n    /// let abs_difference = (f.tan().atan() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn atan(self) -> f64 {\n}\n\n    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`) in radians.\n    ///\n    /// * `x = 0`, `y = 0`: `0`\n    /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n    /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`\n    /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// // Positive angles measured counter-clockwise\n    /// // from positive x axis\n    /// // -pi/4 radians (45 deg clockwise)\n    /// let x1 = 3.0_f64;\n    /// let y1 = -3.0_f64;\n    ///\n    /// // 3pi/4 radians (135 deg counter-clockwise)\n    /// let x2 = -3.0_f64;\n    /// let y2 = 3.0_f64;\n    ///\n    /// let abs_difference_1 = (y1.atan2(x1) - (-f64::consts::FRAC_PI_4)).abs();\n    /// let abs_difference_2 = (y2.atan2(x2) - (3.0 * f64::consts::FRAC_PI_4)).abs();\n    ///\n    /// assert!(abs_difference_1 < 1e-10);\n    /// assert!(abs_difference_2 < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn atan2(self, other: f64) -> f64 {\n}\n\n    /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n    /// `(sin(x), cos(x))`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let x = f64::consts::FRAC_PI_4;\n    /// let f = x.sin_cos();\n    ///\n    /// let abs_difference_0 = (f.0 - x.sin()).abs();\n    /// let abs_difference_1 = (f.1 - x.cos()).abs();\n    ///\n    /// assert!(abs_difference_0 < 1e-10);\n    /// assert!(abs_difference_1 < 1e-10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sin_cos(self) -> (f64, f64) {\n}\n\n    /// Returns `e^(self) - 1` in a way that is accurate even if the\n    /// number is close to zero.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 7.0_f64;\n    ///\n    /// // e^(ln(7)) - 1\n    /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn exp_m1(self) -> f64 {\n}\n\n    /// Returns `ln(1+n)` (natural logarithm) more accurately than if\n    /// the operations were performed separately.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let x = f64::consts::E - 1.0;\n    ///\n    /// // ln(1 + (e - 1)) == ln(e) == 1\n    /// let abs_difference = (x.ln_1p() - 1.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn ln_1p(self) -> f64 {\n}\n\n    /// Hyperbolic sine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let e = f64::consts::E;\n    /// let x = 1.0_f64;\n    ///\n    /// let f = x.sinh();\n    /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n    /// let g = ((e * e) - 1.0) / (2.0 * e);\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sinh(self) -> f64 {\n}\n\n    /// Hyperbolic cosine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let e = f64::consts::E;\n    /// let x = 1.0_f64;\n    /// let f = x.cosh();\n    /// // Solving cosh() at 1 gives this result\n    /// let g = ((e * e) + 1.0) / (2.0 * e);\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// // Same result\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn cosh(self) -> f64 {\n}\n\n    /// Hyperbolic tangent function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let e = f64::consts::E;\n    /// let x = 1.0_f64;\n    ///\n    /// let f = x.tanh();\n    /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n    /// let g = (1.0 - e.powi(-2)) / (1.0 + e.powi(-2));\n    /// let abs_difference = (f - g).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn tanh(self) -> f64 {\n}\n\n    /// Inverse hyperbolic sine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 1.0_f64;\n    /// let f = x.sinh().asinh();\n    ///\n    /// let abs_difference = (f - x).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn asinh(self) -> f64 {\n}\n\n    /// Inverse hyperbolic cosine function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 1.0_f64;\n    /// let f = x.cosh().acosh();\n    ///\n    /// let abs_difference = (f - x).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn acosh(self) -> f64 {\n}\n\n    /// Inverse hyperbolic tangent function.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let e = f64::consts::E;\n    /// let f = e.tanh().atanh();\n    ///\n    /// let abs_difference = (f - e).abs();\n    ///\n    /// assert!(abs_difference < 1.0e-10);\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn atanh(self) -> f64 {\n}\n\n    /// Restrict a value to a certain interval unless it is NaN.\n    ///\n    /// Returns `max` if `self` is greater than `max`, and `min` if `self` is\n    /// less than `min`. Otherwise this returns `self`.\n    ///\n    /// Not that this function returns NaN if the initial value was NaN as\n    /// well.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `min > max`, `min` is NaN, or `max` is NaN.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(clamp)]\n    /// assert!((-3.0f64).clamp(-2.0, 1.0) == -2.0);\n    /// assert!((0.0f64).clamp(-2.0, 1.0) == 0.0);\n    /// assert!((2.0f64).clamp(-2.0, 1.0) == 1.0);\n    /// assert!((std::f64::NAN).clamp(-2.0, 1.0).is_nan());\n    /// ```\n    #[must_use = \"method returns a new number and does not mutate the original value\"]\n    #[unstable(feature = \"clamp\", issue = \"44095\")]\n    #[inline]\n    pub fn clamp(self, min: f64, max: f64) -> f64 {\n}\n\n    // Solaris/Illumos requires a wrapper around log, log2, and log10 functions\n    // because of their non-standard behavior (e.g., log(-n) returns -Inf instead\n    // of expected NaN).\n    fn log_wrapper<F: Fn(f64) -> f64>(self, log_fn: F) -> f64 {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\n\n#[macro_use]\npub mod thread {\n//! Native threads.\n//!\n//! ## The threading model\n//!\n//! An executing Rust program consists of a collection of native OS threads,\n//! each with their own stack and local state. Threads can be named, and\n//! provide some built-in support for low-level synchronization.\n//!\n//! Communication between threads can be done through\n//! [channels], Rust's message-passing types, along with [other forms of thread\n//! synchronization](../../std/sync/index.html) and shared-memory data\n//! structures. In particular, types that are guaranteed to be\n//! threadsafe are easily shared between threads using the\n//! atomically-reference-counted container, [`Arc`].\n//!\n//! Fatal logic errors in Rust cause *thread panic*, during which\n//! a thread will unwind the stack, running destructors and freeing\n//! owned resources. While not meant as a 'try/catch' mechanism, panics\n//! in Rust can nonetheless be caught (unless compiling with `panic=abort`) with\n//! [`catch_unwind`](../../std/panic/fn.catch_unwind.html) and recovered\n//! from, or alternatively be resumed with\n//! [`resume_unwind`](../../std/panic/fn.resume_unwind.html). If the panic\n//! is not caught the thread will exit, but the panic may optionally be\n//! detected from a different thread with [`join`]. If the main thread panics\n//! without the panic being caught, the application will exit with a\n//! non-zero exit code.\n//!\n//! When the main thread of a Rust program terminates, the entire program shuts\n//! down, even if other threads are still running. However, this module provides\n//! convenient facilities for automatically waiting for the termination of a\n//! child thread (i.e., join).\n//!\n//! ## Spawning a thread\n//!\n//! A new thread can be spawned using the [`thread::spawn`][`spawn`] function:\n//!\n//! ```rust\n//! use std::thread;\n//!\n//! thread::spawn(move || {\n//!     // some work here\n//! });\n//! ```\n//!\n//! In this example, the spawned thread is \"detached\" from the current\n//! thread. This means that it can outlive its parent (the thread that spawned\n//! it), unless this parent is the main thread.\n//!\n//! The parent thread can also wait on the completion of the child\n//! thread; a call to [`spawn`] produces a [`JoinHandle`], which provides\n//! a `join` method for waiting:\n//!\n//! ```rust\n//! use std::thread;\n//!\n//! let child = thread::spawn(move || {\n//!     // some work here\n//! });\n//! // some work here\n//! let res = child.join();\n//! ```\n//!\n//! The [`join`] method returns a [`thread::Result`] containing [`Ok`] of the final\n//! value produced by the child thread, or [`Err`] of the value given to\n//! a call to [`panic!`] if the child panicked.\n//!\n//! ## Configuring threads\n//!\n//! A new thread can be configured before it is spawned via the [`Builder`] type,\n//! which currently allows you to set the name and stack size for the child thread:\n//!\n//! ```rust\n//! # #![allow(unused_must_use)]\n//! use std::thread;\n//!\n//! thread::Builder::new().name(\"child1\".to_string()).spawn(move || {\n//!     println!(\"Hello, world!\");\n//! });\n//! ```\n//!\n//! ## The `Thread` type\n//!\n//! Threads are represented via the [`Thread`] type, which you can get in one of\n//! two ways:\n//!\n//! * By spawning a new thread, e.g., using the [`thread::spawn`][`spawn`]\n//!   function, and calling [`thread`][`JoinHandle::thread`] on the [`JoinHandle`].\n//! * By requesting the current thread, using the [`thread::current`] function.\n//!\n//! The [`thread::current`] function is available even for threads not spawned\n//! by the APIs of this module.\n//!\n//! ## Thread-local storage\n//!\n//! This module also provides an implementation of thread-local storage for Rust\n//! programs. Thread-local storage is a method of storing data into a global\n//! variable that each thread in the program will have its own copy of.\n//! Threads do not share this data, so accesses do not need to be synchronized.\n//!\n//! A thread-local key owns the value it contains and will destroy the value when the\n//! thread exits. It is created with the [`thread_local!`] macro and can contain any\n//! value that is `'static` (no borrowed pointers). It provides an accessor function,\n//! [`with`], that yields a shared reference to the value to the specified\n//! closure. Thread-local keys allow only shared access to values, as there would be no\n//! way to guarantee uniqueness if mutable borrows were allowed. Most values\n//! will want to make use of some form of **interior mutability** through the\n//! [`Cell`] or [`RefCell`] types.\n//!\n//! ## Naming threads\n//!\n//! Threads are able to have associated names for identification purposes. By default, spawned\n//! threads are unnamed. To specify a name for a thread, build the thread with [`Builder`] and pass\n//! the desired thread name to [`Builder::name`]. To retrieve the thread name from within the\n//! thread, use [`Thread::name`]. A couple examples of where the name of a thread gets used:\n//!\n//! * If a panic occurs in a named thread, the thread name will be printed in the panic message.\n//! * The thread name is provided to the OS where applicable (e.g., `pthread_setname_np` in\n//!   unix-like platforms).\n//!\n//! ## Stack size\n//!\n//! The default stack size for spawned threads is 2 MiB, though this particular stack size is\n//! subject to change in the future. There are two ways to manually specify the stack size for\n//! spawned threads:\n//!\n//! * Build the thread with [`Builder`] and pass the desired stack size to [`Builder::stack_size`].\n//! * Set the `RUST_MIN_STACK` environment variable to an integer representing the desired stack\n//!   size (in bytes). Note that setting [`Builder::stack_size`] will override this.\n//!\n//! Note that the stack size of the main thread is *not* determined by Rust.\n//!\n//! [channels]: ../../std/sync/mpsc/index.html\n//! [`Arc`]: ../../std/sync/struct.Arc.html\n//! [`spawn`]: ../../std/thread/fn.spawn.html\n//! [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n//! [`JoinHandle::thread`]: ../../std/thread/struct.JoinHandle.html#method.thread\n//! [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n//! [`Result`]: ../../std/result/enum.Result.html\n//! [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n//! [`Err`]: ../../std/result/enum.Result.html#variant.Err\n//! [`panic!`]: ../../std/macro.panic.html\n//! [`Builder`]: ../../std/thread/struct.Builder.html\n//! [`Builder::stack_size`]: ../../std/thread/struct.Builder.html#method.stack_size\n//! [`Builder::name`]: ../../std/thread/struct.Builder.html#method.name\n//! [`thread::current`]: ../../std/thread/fn.current.html\n//! [`thread::Result`]: ../../std/thread/type.Result.html\n//! [`Thread`]: ../../std/thread/struct.Thread.html\n//! [`park`]: ../../std/thread/fn.park.html\n//! [`unpark`]: ../../std/thread/struct.Thread.html#method.unpark\n//! [`Thread::name`]: ../../std/thread/struct.Thread.html#method.name\n//! [`thread::park_timeout`]: ../../std/thread/fn.park_timeout.html\n//! [`Cell`]: ../cell/struct.Cell.html\n//! [`RefCell`]: ../cell/struct.RefCell.html\n//! [`thread_local!`]: ../macro.thread_local.html\n//! [`with`]: struct.LocalKey.html#method.with\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::any::Any;\nuse crate::cell::UnsafeCell;\nuse crate::ffi::{CStr, CString};\nuse crate::fmt;\nuse crate::io;\nuse crate::mem;\nuse crate::num::NonZeroU64;\nuse crate::panic;\nuse crate::panicking;\nuse crate::str;\nuse crate::sync::atomic::AtomicUsize;\nuse crate::sync::atomic::Ordering::SeqCst;\nuse crate::sync::{Arc, Condvar, Mutex};\nuse crate::sys::thread as imp;\nuse crate::sys_common::mutex;\nuse crate::sys_common::thread;\nuse crate::sys_common::thread_info;\nuse crate::sys_common::{AsInner, IntoInner};\nuse crate::time::Duration;\n\n////////////////////////////////////////////////////////////////////////////////\n// Thread-local storage\n////////////////////////////////////////////////////////////////////////////////\n\n#[macro_use]\nmod local {\n//! Thread local storage\n\n#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n\nuse crate::error::Error;\nuse crate::fmt;\n\n/// A thread local storage key which owns its contents.\n///\n/// This key uses the fastest possible implementation available to it for the\n/// target platform. It is instantiated with the [`thread_local!`] macro and the\n/// primary method is the [`with`] method.\n///\n/// The [`with`] method yields a reference to the contained value which cannot be\n/// sent across threads or escape the given closure.\n///\n/// # Initialization and Destruction\n///\n/// Initialization is dynamically performed on the first call to [`with`]\n/// within a thread, and values that implement [`Drop`] get destructed when a\n/// thread exits. Some caveats apply, which are explained below.\n///\n/// A `LocalKey`'s initializer cannot recursively depend on itself, and using\n/// a `LocalKey` in this way will cause the initializer to infinitely recurse\n/// on the first call to `with`.\n///\n/// # Examples\n///\n/// ```\n/// use std::cell::RefCell;\n/// use std::thread;\n///\n/// thread_local!(static FOO: RefCell<u32> = RefCell::new(1));\n///\n/// FOO.with(|f| {\n///     assert_eq!(*f.borrow(), 1);\n///     *f.borrow_mut() = 2;\n/// });\n///\n/// // each thread starts out with the initial value of 1\n/// let t = thread::spawn(move|| {\n///     FOO.with(|f| {\n///         assert_eq!(*f.borrow(), 1);\n///         *f.borrow_mut() = 3;\n///     });\n/// });\n///\n/// // wait for the thread to complete and bail out on panic\n/// t.join().unwrap();\n///\n/// // we retain our original value of 2 despite the child thread\n/// FOO.with(|f| {\n///     assert_eq!(*f.borrow(), 2);\n/// });\n/// ```\n///\n/// # Platform-specific behavior\n///\n/// Note that a \"best effort\" is made to ensure that destructors for types\n/// stored in thread local storage are run, but not all platforms can guarantee\n/// that destructors will be run for all types in thread local storage. For\n/// example, there are a number of known caveats where destructors are not run:\n///\n/// 1. On Unix systems when pthread-based TLS is being used, destructors will\n///    not be run for TLS values on the main thread when it exits. Note that the\n///    application will exit immediately after the main thread exits as well.\n/// 2. On all platforms it's possible for TLS to re-initialize other TLS slots\n///    during destruction. Some platforms ensure that this cannot happen\n///    infinitely by preventing re-initialization of any slot that has been\n///    destroyed, but not all platforms have this guard. Those platforms that do\n///    not guard typically have a synthetic limit after which point no more\n///    destructors are run.\n///\n/// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n/// [`thread_local!`]: ../../std/macro.thread_local.html\n/// [`Drop`]: ../../std/ops/trait.Drop.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct LocalKey<T: 'static> {\n    // This outer `LocalKey<T>` type is what's going to be stored in statics,\n    // but actual data inside will sometimes be tagged with #[thread_local].\n    // It's not valid for a true static to reference a #[thread_local] static,\n    // so we get around that by exposing an accessor through a layer of function\n    // indirection (this thunk).\n    //\n    // Note that the thunk is itself unsafe because the returned lifetime of the\n    // slot where data lives, `'static`, is not actually valid. The lifetime\n    // here is actually slightly shorter than the currently running thread!\n    //\n    // Although this is an extra layer of indirection, it should in theory be\n    // trivially devirtualizable by LLVM because the value of `inner` never\n    // changes and the constant should be readonly within a crate. This mainly\n    // only runs into problems when TLS statics are exported across crates.\n    inner: unsafe fn() -> Option<&'static T>,\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T: 'static> fmt::Debug for LocalKey<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// Declare a new thread local storage key of type [`std::thread::LocalKey`].\n///\n/// # Syntax\n///\n/// The macro wraps any number of static declarations and makes them thread local.\n/// Publicity and attributes for each static are allowed. Example:\n///\n/// ```\n/// use std::cell::RefCell;\n/// thread_local! {\n///     pub static FOO: RefCell<u32> = RefCell::new(1);\n///\n///     #[allow(unused)]\n///     static BAR: RefCell<f32> = RefCell::new(1.0);\n/// }\n/// # fn main() {}\n/// ```\n///\n/// See [LocalKey documentation][`std::thread::LocalKey`] for more\n/// information.\n///\n/// [`std::thread::LocalKey`]: ../std/thread/struct.LocalKey.html\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(thread_local_internals)]\nmacro_rules! thread_local {\n    // empty (base case for the recursion)\n    () => {};\n\n    // process multiple declarations\n    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; $($rest:tt)*) => (\n        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n        $crate::thread_local!($($rest)*);\n    );\n\n    // handle a single declaration\n    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr) => (\n        $crate::__thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n    );\n}\n\n#[doc(hidden)]\n#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n#[macro_export]\n#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n#[allow_internal_unsafe]\nmacro_rules! __thread_local_inner {\n}\n\n/// An error returned by [`LocalKey::try_with`](struct.LocalKey.html#method.try_with).\n#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n#[derive(Clone, Copy, Eq, PartialEq)]\npub struct AccessError {\n    _private: (),\n}\n\n#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\nimpl fmt::Debug for AccessError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\nimpl fmt::Display for AccessError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\nimpl Error for AccessError {}\n\nimpl<T: 'static> LocalKey<T> {\n    #[doc(hidden)]\n    #[unstable(\n        feature = \"thread_local_internals\",\n        reason = \"recently added to create a key\",\n        issue = \"none\"\n    )]\n    pub const unsafe fn new(inner: unsafe fn() -> Option<&'static T>) -> LocalKey<T> {\n}\n\n    /// Acquires a reference to the value in this TLS key.\n    ///\n    /// This will lazily initialize the value if this thread has not referenced\n    /// this key yet.\n    ///\n    /// # Panics\n    ///\n    /// This function will `panic!()` if the key currently has its\n    /// destructor running, and it **may** panic if the destructor has\n    /// previously been run for this thread.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with<F, R>(&'static self, f: F) -> R\n    where\n        F: FnOnce(&T) -> R,\n    {\n}\n\n    /// Acquires a reference to the value in this TLS key.\n    ///\n    /// This will lazily initialize the value if this thread has not referenced\n    /// this key yet. If the key has been destroyed (which may happen if this is called\n    /// in a destructor), this function will return an [`AccessError`](struct.AccessError.html).\n    ///\n    /// # Panics\n    ///\n    /// This function will still `panic!()` if the key is uninitialized and the\n    /// key's initializer panics.\n    #[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n    pub fn try_with<F, R>(&'static self, f: F) -> Result<R, AccessError>\n    where\n        F: FnOnce(&T) -> R,\n    {\n}\n}\n\nmod lazy {\n    use crate::cell::UnsafeCell;\n    use crate::hint;\n    use crate::mem;\n\n    pub struct LazyKeyInner<T> {\n        inner: UnsafeCell<Option<T>>,\n    }\n\n    impl<T> LazyKeyInner<T> {\n        pub const fn new() -> LazyKeyInner<T> {\n}\n\n        pub unsafe fn get(&self) -> Option<&'static T> {\n}\n\n        pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n}\n\n        #[allow(unused)]\n        pub unsafe fn take(&mut self) -> Option<T> {\n}\n    }\n}\n\n/// On some platforms like wasm32 there's no threads, so no need to generate\n/// thread locals and we can instead just use plain statics!\n#[doc(hidden)]\n#[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\npub mod statik {\n    use super::lazy::LazyKeyInner;\n    use crate::fmt;\n\n    pub struct Key<T> {\n        inner: LazyKeyInner<T>,\n    }\n\n    unsafe impl<T> Sync for Key<T> {}\n\n    impl<T> fmt::Debug for Key<T> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n    }\n\n    impl<T> Key<T> {\n        pub const fn new() -> Key<T> {\n}\n\n        pub unsafe fn get(&self, init: fn() -> T) -> Option<&'static T> {\n}\n    }\n}\n\n#[doc(hidden)]\n#[cfg(target_thread_local)]\npub mod fast {\n    use super::lazy::LazyKeyInner;\n    use crate::cell::Cell;\n    use crate::fmt;\n    use crate::mem;\n    use crate::sys::fast_thread_local::register_dtor;\n\n    #[derive(Copy, Clone)]\n    enum DtorState {\n        Unregistered,\n        Registered,\n        RunningOrHasRun,\n    }\n\n    // This data structure has been carefully constructed so that the fast path\n    // only contains one branch on x86. That optimization is necessary to avoid\n    // duplicated tls lookups on OSX.\n    //\n    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n    pub struct Key<T> {\n        // If `LazyKeyInner::get` returns `None`, that indicates either:\n        //   * The value has never been initialized\n        //   * The value is being recursively initialized\n        //   * The value has already been destroyed or is being destroyed\n        // To determine which kind of `None`, check `dtor_state`.\n        //\n        // This is very optimizer friendly for the fast path - initialized but\n        // not yet dropped.\n        inner: LazyKeyInner<T>,\n\n        // Metadata to keep track of the state of the destructor. Remember that\n        // this variable is thread-local, not global.\n        dtor_state: Cell<DtorState>,\n    }\n\n    impl<T> fmt::Debug for Key<T> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n    }\n\n    impl<T> Key<T> {\n        pub const fn new() -> Key<T> {\n}\n\n        pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n}\n\n        // `try_initialize` is only called once per fast thread local variable,\n        // except in corner cases where thread_local dtors reference other\n        // thread_local's, or it is being recursively initialized.\n        //\n        // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n        // be performed for every call to `Key::get`. The #[cold] hint makes\n        // that less likely.\n        // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n        #[cold]\n        unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n}\n\n        // `try_register_dtor` is only called once per fast thread local\n        // variable, except in corner cases where thread_local dtors reference\n        // other thread_local's, or it is being recursively initialized.\n        unsafe fn try_register_dtor(&self) -> bool {\n}\n    }\n\n    unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n}\n}\n\n#[doc(hidden)]\npub mod os {\n    use super::lazy::LazyKeyInner;\n    use crate::cell::Cell;\n    use crate::fmt;\n    use crate::marker;\n    use crate::ptr;\n    use crate::sys_common::thread_local::StaticKey as OsStaticKey;\n\n    pub struct Key<T> {\n        // OS-TLS key that we'll use to key off.\n        os: OsStaticKey,\n        marker: marker::PhantomData<Cell<T>>,\n    }\n\n    impl<T> fmt::Debug for Key<T> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n    }\n\n    unsafe impl<T> Sync for Key<T> {}\n\n    struct Value<T: 'static> {\n        inner: LazyKeyInner<T>,\n        key: &'static Key<T>,\n    }\n\n    impl<T: 'static> Key<T> {\n        pub const fn new() -> Key<T> {\n}\n\n        pub unsafe fn get(&'static self, init: fn() -> T) -> Option<&'static T> {\n}\n\n        // `try_initialize` is only called once per os thread local variable,\n        // except in corner cases where thread_local dtors reference other\n        // thread_local's, or it is being recursively initialized.\n        unsafe fn try_initialize(&'static self, init: fn() -> T) -> Option<&'static T> {\n}\n    }\n\n    unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n}\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use crate::cell::{Cell, UnsafeCell};\n    use crate::sync::mpsc::{channel, Sender};\n    use crate::thread;\n\n    struct Foo(Sender<()>);\n\n    impl Drop for Foo {\n        fn drop(&mut self) {\n}\n    }\n\n    #[test]\n    fn smoke_no_dtor() {\n}\n\n    #[test]\n    fn states() {\n}\n\n    #[test]\n    fn smoke_dtor() {\n}\n\n    #[test]\n    fn circular() {\n}\n\n    #[test]\n    fn self_referential() {\n}\n\n    // Note that this test will deadlock if TLS destructors aren't run (this\n    // requires the destructor to be run to pass the test).\n    #[test]\n    fn dtors_in_dtors_in_dtors() {\n}\n}\n\n#[cfg(test)]\nmod dynamic_tests {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::local::{AccessError, LocalKey};\n\n// The types used by the thread_local! macro to access TLS keys. Note that there\n// are two types, the \"OS\" type and the \"fast\" type. The OS thread local key\n// type is accessed via platform-specific API calls and is slow, while the fast\n// key type is accessed via code generated via LLVM, where TLS keys are set up\n// by the elf linker. Note that the OS TLS type is always available: on macOS\n// the standard library is compiled with support for older platform versions\n// where fast TLS was not available; end-user code is compiled with fast TLS\n// where available, but both are needed.\n\n#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n#[cfg(target_thread_local)]\n#[doc(hidden)]\npub use self::local::fast::Key as __FastLocalKeyInner;\n#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n#[doc(hidden)]\npub use self::local::os::Key as __OsLocalKeyInner;\n#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n#[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n#[doc(hidden)]\npub use self::local::statik::Key as __StaticLocalKeyInner;\n\n////////////////////////////////////////////////////////////////////////////////\n// Builder\n////////////////////////////////////////////////////////////////////////////////\n\n/// Thread factory, which can be used in order to configure the properties of\n/// a new thread.\n///\n/// Methods can be chained on it in order to configure it.\n///\n/// The two configurations available are:\n///\n/// - [`name`]: specifies an [associated name for the thread][naming-threads]\n/// - [`stack_size`]: specifies the [desired stack size for the thread][stack-size]\n///\n/// The [`spawn`] method will take ownership of the builder and create an\n/// [`io::Result`] to the thread handle with the given configuration.\n///\n/// The [`thread::spawn`] free function uses a `Builder` with default\n/// configuration and [`unwrap`]s its return value.\n///\n/// You may want to use [`spawn`] instead of [`thread::spawn`], when you want\n/// to recover from a failure to launch a thread, indeed the free function will\n/// panic where the `Builder` method will return a [`io::Result`].\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n///\n/// let builder = thread::Builder::new();\n///\n/// let handler = builder.spawn(|| {\n///     // thread code\n/// }).unwrap();\n///\n/// handler.join().unwrap();\n/// ```\n///\n/// [`thread::spawn`]: ../../std/thread/fn.spawn.html\n/// [`stack_size`]: ../../std/thread/struct.Builder.html#method.stack_size\n/// [`name`]: ../../std/thread/struct.Builder.html#method.name\n/// [`spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n/// [`io::Result`]: ../../std/io/type.Result.html\n/// [`unwrap`]: ../../std/result/enum.Result.html#method.unwrap\n/// [naming-threads]: ./index.html#naming-threads\n/// [stack-size]: ./index.html#stack-size\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Builder {\n    // A name for the thread-to-be, for identification in panic messages\n    name: Option<String>,\n    // The size of the stack for the spawned thread in bytes\n    stack_size: Option<usize>,\n}\n\nimpl Builder {\n    /// Generates the base configuration for spawning a thread, from which\n    /// configuration methods can be chained.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new()\n    ///                               .name(\"foo\".into())\n    ///                               .stack_size(32 * 1024);\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     // thread code\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> Builder {\n}\n\n    /// Names the thread-to-be. Currently the name is used for identification\n    /// only in panic messages.\n    ///\n    /// The name must not contain null bytes (`\\0`).\n    ///\n    /// For more information about named threads, see\n    /// [this module-level documentation][naming-threads].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new()\n    ///     .name(\"foo\".into());\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     assert_eq!(thread::current().name(), Some(\"foo\"))\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// [naming-threads]: ./index.html#naming-threads\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn name(mut self, name: String) -> Builder {\n}\n\n    /// Sets the size of the stack (in bytes) for the new thread.\n    ///\n    /// The actual stack size may be greater than this value if\n    /// the platform specifies a minimal stack size.\n    ///\n    /// For more information about the stack size for threads, see\n    /// [this module-level documentation][stack-size].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new().stack_size(32 * 1024);\n    /// ```\n    ///\n    /// [stack-size]: ./index.html#stack-size\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn stack_size(mut self, size: usize) -> Builder {\n}\n\n    /// Spawns a new thread by taking ownership of the `Builder`, and returns an\n    /// [`io::Result`] to its [`JoinHandle`].\n    ///\n    /// The spawned thread may outlive the caller (unless the caller thread\n    /// is the main thread; the whole process is terminated when the main\n    /// thread finishes). The join handle can be used to block on\n    /// termination of the child thread, including recovering its panics.\n    ///\n    /// For a more complete documentation see [`thread::spawn`][`spawn`].\n    ///\n    /// # Errors\n    ///\n    /// Unlike the [`spawn`] free function, this method yields an\n    /// [`io::Result`] to capture any failure to create the thread at\n    /// the OS level.\n    ///\n    /// [`spawn`]: ../../std/thread/fn.spawn.html\n    /// [`io::Result`]: ../../std/io/type.Result.html\n    /// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n    ///\n    /// # Panics\n    ///\n    /// Panics if a thread name was set and it contained null bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     // thread code\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>>\n    where\n        F: FnOnce() -> T,\n        F: Send + 'static,\n        T: Send + 'static,\n    {\n}\n\n    /// Spawns a new thread without any lifetime restrictions by taking ownership\n    /// of the `Builder`, and returns an [`io::Result`] to its [`JoinHandle`].\n    ///\n    /// The spawned thread may outlive the caller (unless the caller thread\n    /// is the main thread; the whole process is terminated when the main\n    /// thread finishes). The join handle can be used to block on\n    /// termination of the child thread, including recovering its panics.\n    ///\n    /// This method is identical to [`thread::Builder::spawn`][`Builder::spawn`],\n    /// except for the relaxed lifetime bounds, which render it unsafe.\n    /// For a more complete documentation see [`thread::spawn`][`spawn`].\n    ///\n    /// # Errors\n    ///\n    /// Unlike the [`spawn`] free function, this method yields an\n    /// [`io::Result`] to capture any failure to create the thread at\n    /// the OS level.\n    ///\n    /// # Panics\n    ///\n    /// Panics if a thread name was set and it contained null bytes.\n    ///\n    /// # Safety\n    ///\n    /// The caller has to ensure that no references in the supplied thread closure\n    /// or its return type can outlive the spawned thread's lifetime. This can be\n    /// guaranteed in two ways:\n    ///\n    /// - ensure that [`join`][`JoinHandle::join`] is called before any referenced\n    /// data is dropped\n    /// - use only types with `'static` lifetime bounds, i.e., those with no or only\n    /// `'static` references (both [`thread::Builder::spawn`][`Builder::spawn`]\n    /// and [`thread::spawn`][`spawn`] enforce this property statically)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(thread_spawn_unchecked)]\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let x = 1;\n    /// let thread_x = &x;\n    ///\n    /// let handler = unsafe {\n    ///     builder.spawn_unchecked(move || {\n    ///         println!(\"x = {}\", *thread_x);\n    ///     }).unwrap()\n    /// };\n    ///\n    /// // caller has to ensure `join()` is called, otherwise\n    /// // it is possible to access freed memory if `x` gets\n    /// // dropped before the thread closure is executed!\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// [`spawn`]: ../../std/thread/fn.spawn.html\n    /// [`Builder::spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n    /// [`io::Result`]: ../../std/io/type.Result.html\n    /// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n    /// [`JoinHandle::join`]: ../../std/thread/struct.JoinHandle.html#method.join\n    #[unstable(feature = \"thread_spawn_unchecked\", issue = \"55132\")]\n    pub unsafe fn spawn_unchecked<'a, F, T>(self, f: F) -> io::Result<JoinHandle<T>>\n    where\n        F: FnOnce() -> T,\n        F: Send + 'a,\n        T: Send + 'a,\n    {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Free functions\n////////////////////////////////////////////////////////////////////////////////\n\n/// Spawns a new thread, returning a [`JoinHandle`] for it.\n///\n/// The join handle will implicitly *detach* the child thread upon being\n/// dropped. In this case, the child thread may outlive the parent (unless\n/// the parent thread is the main thread; the whole process is terminated when\n/// the main thread finishes). Additionally, the join handle provides a [`join`]\n/// method that can be used to join the child thread. If the child thread\n/// panics, [`join`] will return an [`Err`] containing the argument given to\n/// [`panic`].\n///\n/// This will create a thread using default parameters of [`Builder`], if you\n/// want to specify the stack size or the name of the thread, use this API\n/// instead.\n///\n/// As you can see in the signature of `spawn` there are two constraints on\n/// both the closure given to `spawn` and its return value, let's explain them:\n///\n/// - The `'static` constraint means that the closure and its return value\n///   must have a lifetime of the whole program execution. The reason for this\n///   is that threads can `detach` and outlive the lifetime they have been\n///   created in.\n///   Indeed if the thread, and by extension its return value, can outlive their\n///   caller, we need to make sure that they will be valid afterwards, and since\n///   we *can't* know when it will return we need to have them valid as long as\n///   possible, that is until the end of the program, hence the `'static`\n///   lifetime.\n/// - The [`Send`] constraint is because the closure will need to be passed\n///   *by value* from the thread where it is spawned to the new thread. Its\n///   return value will need to be passed from the new thread to the thread\n///   where it is `join`ed.\n///   As a reminder, the [`Send`] marker trait expresses that it is safe to be\n///   passed from thread to thread. [`Sync`] expresses that it is safe to have a\n///   reference be passed from thread to thread.\n///\n/// # Panics\n///\n/// Panics if the OS fails to create a thread; use [`Builder::spawn`]\n/// to recover from such errors.\n///\n/// # Examples\n///\n/// Creating a thread.\n///\n/// ```\n/// use std::thread;\n///\n/// let handler = thread::spawn(|| {\n///     // thread code\n/// });\n///\n/// handler.join().unwrap();\n/// ```\n///\n/// As mentioned in the module documentation, threads are usually made to\n/// communicate using [`channels`], here is how it usually looks.\n///\n/// This example also shows how to use `move`, in order to give ownership\n/// of values to a thread.\n///\n/// ```\n/// use std::thread;\n/// use std::sync::mpsc::channel;\n///\n/// let (tx, rx) = channel();\n///\n/// let sender = thread::spawn(move || {\n///     tx.send(\"Hello, thread\".to_owned())\n///         .expect(\"Unable to send on channel\");\n/// });\n///\n/// let receiver = thread::spawn(move || {\n///     let value = rx.recv().expect(\"Unable to receive from channel\");\n///     println!(\"{}\", value);\n/// });\n///\n/// sender.join().expect(\"The sender thread has panicked\");\n/// receiver.join().expect(\"The receiver thread has panicked\");\n/// ```\n///\n/// A thread can also return a value through its [`JoinHandle`], you can use\n/// this to make asynchronous computations (futures might be more appropriate\n/// though).\n///\n/// ```\n/// use std::thread;\n///\n/// let computation = thread::spawn(|| {\n///     // Some expensive computation.\n///     42\n/// });\n///\n/// let result = computation.join().unwrap();\n/// println!(\"{}\", result);\n/// ```\n///\n/// [`channels`]: ../../std/sync/mpsc/index.html\n/// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n/// [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n/// [`panic`]: ../../std/macro.panic.html\n/// [`Builder::spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n/// [`Builder`]: ../../std/thread/struct.Builder.html\n/// [`Send`]: ../../std/marker/trait.Send.html\n/// [`Sync`]: ../../std/marker/trait.Sync.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn spawn<F, T>(f: F) -> JoinHandle<T>\nwhere\n    F: FnOnce() -> T,\n    F: Send + 'static,\n    T: Send + 'static,\n{\n}\n\n/// Gets a handle to the thread that invokes it.\n///\n/// # Examples\n///\n/// Getting a handle to the current thread with `thread::current()`:\n///\n/// ```\n/// use std::thread;\n///\n/// let handler = thread::Builder::new()\n///     .name(\"named thread\".into())\n///     .spawn(|| {\n///         let handle = thread::current();\n///         assert_eq!(handle.name(), Some(\"named thread\"));\n///     })\n///     .unwrap();\n///\n/// handler.join().unwrap();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn current() -> Thread {\n}\n\n/// Cooperatively gives up a timeslice to the OS scheduler.\n///\n/// This is used when the programmer knows that the thread will have nothing\n/// to do for some time, and thus avoid wasting computing time.\n///\n/// For example when polling on a resource, it is common to check that it is\n/// available, and if not to yield in order to avoid busy waiting.\n///\n/// Thus the pattern of `yield`ing after a failed poll is rather common when\n/// implementing low-level shared resources or synchronization primitives.\n///\n/// However programmers will usually prefer to use [`channel`]s, [`Condvar`]s,\n/// [`Mutex`]es or [`join`] for their synchronization routines, as they avoid\n/// thinking about thread scheduling.\n///\n/// Note that [`channel`]s for example are implemented using this primitive.\n/// Indeed when you call `send` or `recv`, which are blocking, they will yield\n/// if the channel is not available.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n///\n/// thread::yield_now();\n/// ```\n///\n/// [`channel`]: ../../std/sync/mpsc/index.html\n/// [`spawn`]: ../../std/thread/fn.spawn.html\n/// [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n/// [`Mutex`]: ../../std/sync/struct.Mutex.html\n/// [`Condvar`]: ../../std/sync/struct.Condvar.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn yield_now() {\n}\n\n/// Determines whether the current thread is unwinding because of panic.\n///\n/// A common use of this feature is to poison shared resources when writing\n/// unsafe code, by checking `panicking` when the `drop` is called.\n///\n/// This is usually not needed when writing safe code, as [`Mutex`es][Mutex]\n/// already poison themselves when a thread panics while holding the lock.\n///\n/// This can also be used in multithreaded applications, in order to send a\n/// message to other threads warning that a thread has panicked (e.g., for\n/// monitoring purposes).\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::thread;\n///\n/// struct SomeStruct;\n///\n/// impl Drop for SomeStruct {\n///     fn drop(&mut self) {\n///         if thread::panicking() {\n///             println!(\"dropped while unwinding\");\n///         } else {\n///             println!(\"dropped while not unwinding\");\n///         }\n///     }\n/// }\n///\n/// {\n///     print!(\"a: \");\n///     let a = SomeStruct;\n/// }\n///\n/// {\n///     print!(\"b: \");\n///     let b = SomeStruct;\n///     panic!()\n/// }\n/// ```\n///\n/// [Mutex]: ../../std/sync/struct.Mutex.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn panicking() -> bool {\n}\n\n/// Puts the current thread to sleep for at least the specified amount of time.\n///\n/// The thread may sleep longer than the duration specified due to scheduling\n/// specifics or platform-dependent functionality. It will never sleep less.\n///\n/// # Platform-specific behavior\n///\n/// On Unix platforms, the underlying syscall may be interrupted by a\n/// spurious wakeup or signal handler. To ensure the sleep occurs for at least\n/// the specified duration, this function may invoke that system call multiple\n/// times.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::thread;\n///\n/// // Let's sleep for 2 seconds:\n/// thread::sleep_ms(2000);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::sleep`\")]\npub fn sleep_ms(ms: u32) {\n}\n\n/// Puts the current thread to sleep for at least the specified amount of time.\n///\n/// The thread may sleep longer than the duration specified due to scheduling\n/// specifics or platform-dependent functionality. It will never sleep less.\n///\n/// # Platform-specific behavior\n///\n/// On Unix platforms, the underlying syscall may be interrupted by a\n/// spurious wakeup or signal handler. To ensure the sleep occurs for at least\n/// the specified duration, this function may invoke that system call multiple\n/// times.\n/// Platforms which do not support nanosecond precision for sleeping will\n/// have `dur` rounded up to the nearest granularity of time they can sleep for.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::{thread, time};\n///\n/// let ten_millis = time::Duration::from_millis(10);\n/// let now = time::Instant::now();\n///\n/// thread::sleep(ten_millis);\n///\n/// assert!(now.elapsed() >= ten_millis);\n/// ```\n#[stable(feature = \"thread_sleep\", since = \"1.4.0\")]\npub fn sleep(dur: Duration) {\n}\n\n// constants for park/unpark\nconst EMPTY: usize = 0;\nconst PARKED: usize = 1;\nconst NOTIFIED: usize = 2;\n\n/// Blocks unless or until the current thread's token is made available.\n///\n/// A call to `park` does not guarantee that the thread will remain parked\n/// forever, and callers should be prepared for this possibility.\n///\n/// # park and unpark\n///\n/// Every thread is equipped with some basic low-level blocking support, via the\n/// [`thread::park`][`park`] function and [`thread::Thread::unpark`][`unpark`]\n/// method. [`park`] blocks the current thread, which can then be resumed from\n/// another thread by calling the [`unpark`] method on the blocked thread's\n/// handle.\n///\n/// Conceptually, each [`Thread`] handle has an associated token, which is\n/// initially not present:\n///\n/// * The [`thread::park`][`park`] function blocks the current thread unless or\n///   until the token is available for its thread handle, at which point it\n///   atomically consumes the token. It may also return *spuriously*, without\n///   consuming the token. [`thread::park_timeout`] does the same, but allows\n///   specifying a maximum time to block the thread for.\n///\n/// * The [`unpark`] method on a [`Thread`] atomically makes the token available\n///   if it wasn't already. Because the token is initially absent, [`unpark`]\n///   followed by [`park`] will result in the second call returning immediately.\n///\n/// In other words, each [`Thread`] acts a bit like a spinlock that can be\n/// locked and unlocked using `park` and `unpark`.\n///\n/// Notice that being unblocked does not imply any synchronization with someone\n/// that unparked this thread, it could also be spurious.\n/// For example, it would be a valid, but inefficient, implementation to make both [`park`] and\n/// [`unpark`] return immediately without doing anything.\n///\n/// The API is typically used by acquiring a handle to the current thread,\n/// placing that handle in a shared data structure so that other threads can\n/// find it, and then `park`ing in a loop. When some desired condition is met, another\n/// thread calls [`unpark`] on the handle.\n///\n/// The motivation for this design is twofold:\n///\n/// * It avoids the need to allocate mutexes and condvars when building new\n///   synchronization primitives; the threads already provide basic\n///   blocking/signaling.\n///\n/// * It can be implemented very efficiently on many platforms.\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n/// use std::sync::{Arc, atomic::{Ordering, AtomicBool}};\n/// use std::time::Duration;\n///\n/// let flag = Arc::new(AtomicBool::new(false));\n/// let flag2 = Arc::clone(&flag);\n///\n/// let parked_thread = thread::spawn(move || {\n///     // We want to wait until the flag is set. We *could* just spin, but using\n///     // park/unpark is more efficient.\n///     while !flag2.load(Ordering::Acquire) {\n///         println!(\"Parking thread\");\n///         thread::park();\n///         // We *could* get here spuriously, i.e., way before the 10ms below are over!\n///         // But that is no problem, we are in a loop until the flag is set anyway.\n///         println!(\"Thread unparked\");\n///     }\n///     println!(\"Flag received\");\n/// });\n///\n/// // Let some time pass for the thread to be spawned.\n/// thread::sleep(Duration::from_millis(10));\n///\n/// // Set the flag, and let the thread wake up.\n/// // There is no race condition here, if `unpark`\n/// // happens first, `park` will return immediately.\n/// // Hence there is no risk of a deadlock.\n/// flag.store(true, Ordering::Release);\n/// println!(\"Unpark the thread\");\n/// parked_thread.thread().unpark();\n///\n/// parked_thread.join().unwrap();\n/// ```\n///\n/// [`Thread`]: ../../std/thread/struct.Thread.html\n/// [`park`]: ../../std/thread/fn.park.html\n/// [`unpark`]: ../../std/thread/struct.Thread.html#method.unpark\n/// [`thread::park_timeout`]: ../../std/thread/fn.park_timeout.html\n//\n// The implementation currently uses the trivial strategy of a Mutex+Condvar\n// with wakeup flag, which does not actually allow spurious wakeups. In the\n// future, this will be implemented in a more efficient way, perhaps along the lines of\n//   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n// or futuxes, and in either case may allow spurious wakeups.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn park() {\n}\n\n/// Use [`park_timeout`].\n///\n/// Blocks unless or until the current thread's token is made available or\n/// the specified duration has been reached (may wake spuriously).\n///\n/// The semantics of this function are equivalent to [`park`] except\n/// that the thread will be blocked for roughly no longer than `dur`. This\n/// method should not be used for precise timing due to anomalies such as\n/// preemption or platform differences that may not cause the maximum\n/// amount of time waited to be precisely `ms` long.\n///\n/// See the [park documentation][`park`] for more detail.\n///\n/// [`park_timeout`]: fn.park_timeout.html\n/// [`park`]: ../../std/thread/fn.park.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::park_timeout`\")]\npub fn park_timeout_ms(ms: u32) {\n}\n\n/// Blocks unless or until the current thread's token is made available or\n/// the specified duration has been reached (may wake spuriously).\n///\n/// The semantics of this function are equivalent to [`park`][park] except\n/// that the thread will be blocked for roughly no longer than `dur`. This\n/// method should not be used for precise timing due to anomalies such as\n/// preemption or platform differences that may not cause the maximum\n/// amount of time waited to be precisely `dur` long.\n///\n/// See the [park documentation][park] for more details.\n///\n/// # Platform-specific behavior\n///\n/// Platforms which do not support nanosecond precision for sleeping will have\n/// `dur` rounded up to the nearest granularity of time they can sleep for.\n///\n/// # Examples\n///\n/// Waiting for the complete expiration of the timeout:\n///\n/// ```rust,no_run\n/// use std::thread::park_timeout;\n/// use std::time::{Instant, Duration};\n///\n/// let timeout = Duration::from_secs(2);\n/// let beginning_park = Instant::now();\n///\n/// let mut timeout_remaining = timeout;\n/// loop {\n///     park_timeout(timeout_remaining);\n///     let elapsed = beginning_park.elapsed();\n///     if elapsed >= timeout {\n///         break;\n///     }\n///     println!(\"restarting park_timeout after {:?}\", elapsed);\n///     timeout_remaining = timeout - elapsed;\n/// }\n/// ```\n///\n/// [park]: fn.park.html\n#[stable(feature = \"park_timeout\", since = \"1.4.0\")]\npub fn park_timeout(dur: Duration) {\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ThreadId\n////////////////////////////////////////////////////////////////////////////////\n\n/// A unique identifier for a running thread.\n///\n/// A `ThreadId` is an opaque object that has a unique value for each thread\n/// that creates one. `ThreadId`s are not guaranteed to correspond to a thread's\n/// system-designated identifier. A `ThreadId` can be retrieved from the [`id`]\n/// method on a [`Thread`].\n///\n/// # Examples\n///\n/// ```\n/// use std::thread;\n///\n/// let other_thread = thread::spawn(|| {\n///     thread::current().id()\n/// });\n///\n/// let other_thread_id = other_thread.join().unwrap();\n/// assert!(thread::current().id() != other_thread_id);\n/// ```\n///\n/// [`id`]: ../../std/thread/struct.Thread.html#method.id\n/// [`Thread`]: ../../std/thread/struct.Thread.html\n#[stable(feature = \"thread_id\", since = \"1.19.0\")]\n#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\npub struct ThreadId(NonZeroU64);\n\nimpl ThreadId {\n    // Generate a new unique thread ID.\n    fn new() -> ThreadId {\n}\n\n    /// This returns a numeric identifier for the thread identified by this\n    /// `ThreadId`.\n    ///\n    /// As noted in the documentation for the type itself, it is essentially an\n    /// opaque ID, but is guaranteed to be unique for each thread. The returned\n    /// value is entirely opaque -- only equality testing is stable. Note that\n    /// it is not guaranteed which values new threads will return, and this may\n    /// change across Rust versions.\n    #[unstable(feature = \"thread_id_value\", issue = \"67939\")]\n    pub fn as_u64(&self) -> u64 {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Thread\n////////////////////////////////////////////////////////////////////////////////\n\n/// The internal representation of a `Thread` handle\nstruct Inner {\n    name: Option<CString>, // Guaranteed to be UTF-8\n    id: ThreadId,\n\n    // state for thread park/unpark\n    state: AtomicUsize,\n    lock: Mutex<()>,\n    cvar: Condvar,\n}\n\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n/// A handle to a thread.\n///\n/// Threads are represented via the `Thread` type, which you can get in one of\n/// two ways:\n///\n/// * By spawning a new thread, e.g., using the [`thread::spawn`][`spawn`]\n///   function, and calling [`thread`][`JoinHandle::thread`] on the\n///   [`JoinHandle`].\n/// * By requesting the current thread, using the [`thread::current`] function.\n///\n/// The [`thread::current`] function is available even for threads not spawned\n/// by the APIs of this module.\n///\n/// There is usually no need to create a `Thread` struct yourself, one\n/// should instead use a function like `spawn` to create new threads, see the\n/// docs of [`Builder`] and [`spawn`] for more details.\n///\n/// [`Builder`]: ../../std/thread/struct.Builder.html\n/// [`JoinHandle::thread`]: ../../std/thread/struct.JoinHandle.html#method.thread\n/// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n/// [`thread::current`]: ../../std/thread/fn.current.html\n/// [`spawn`]: ../../std/thread/fn.spawn.html\n\npub struct Thread {\n    inner: Arc<Inner>,\n}\n\nimpl Thread {\n    // Used only internally to construct a thread object without spawning\n    // Panics if the name contains nuls.\n    pub(crate) fn new(name: Option<String>) -> Thread {\n}\n\n    /// Atomically makes the handle's token available if it is not already.\n    ///\n    /// Every thread is equipped with some basic low-level blocking support, via\n    /// the [`park`][park] function and the `unpark()` method. These can be\n    /// used as a more CPU-efficient implementation of a spinlock.\n    ///\n    /// See the [park documentation][park] for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    /// use std::time::Duration;\n    ///\n    /// let parked_thread = thread::Builder::new()\n    ///     .spawn(|| {\n    ///         println!(\"Parking thread\");\n    ///         thread::park();\n    ///         println!(\"Thread unparked\");\n    ///     })\n    ///     .unwrap();\n    ///\n    /// // Let some time pass for the thread to be spawned.\n    /// thread::sleep(Duration::from_millis(10));\n    ///\n    /// println!(\"Unpark the thread\");\n    /// parked_thread.thread().unpark();\n    ///\n    /// parked_thread.join().unwrap();\n    /// ```\n    ///\n    /// [park]: fn.park.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unpark(&self) {\n}\n\n    /// Gets the thread's unique identifier.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let other_thread = thread::spawn(|| {\n    ///     thread::current().id()\n    /// });\n    ///\n    /// let other_thread_id = other_thread.join().unwrap();\n    /// assert!(thread::current().id() != other_thread_id);\n    /// ```\n    #[stable(feature = \"thread_id\", since = \"1.19.0\")]\n    pub fn id(&self) -> ThreadId {\n}\n\n    /// Gets the thread's name.\n    ///\n    /// For more information about named threads, see\n    /// [this module-level documentation][naming-threads].\n    ///\n    /// # Examples\n    ///\n    /// Threads by default have no name specified:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     assert!(thread::current().name().is_none());\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// Thread with a specified name:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new()\n    ///     .name(\"foo\".into());\n    ///\n    /// let handler = builder.spawn(|| {\n    ///     assert_eq!(thread::current().name(), Some(\"foo\"))\n    /// }).unwrap();\n    ///\n    /// handler.join().unwrap();\n    /// ```\n    ///\n    /// [naming-threads]: ./index.html#naming-threads\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn name(&self) -> Option<&str> {\n}\n\n    fn cname(&self) -> Option<&CStr> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Thread {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// JoinHandle\n////////////////////////////////////////////////////////////////////////////////\n\n/// A specialized [`Result`] type for threads.\n///\n/// Indicates the manner in which a thread exited.\n///\n/// The value contained in the `Result::Err` variant\n/// is the value the thread panicked with;\n/// that is, the argument the `panic!` macro was called with.\n/// Unlike with normal errors, this value doesn't implement\n/// the [`Error`](crate::error::Error) trait.\n///\n/// Thus, a sensible way to handle a thread panic is to either:\n/// 1. `unwrap` the `Result<T>`, propagating the panic\n/// 2. or in case the thread is intended to be a subsystem boundary\n/// that is supposed to isolate system-level failures,\n/// match on the `Err` variant and handle the panic in an appropriate way.\n///\n/// A thread that completes without panicking is considered to exit successfully.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::thread;\n/// use std::fs;\n///\n/// fn copy_in_thread() -> thread::Result<()> {\n///     thread::spawn(move || { fs::copy(\"foo.txt\", \"bar.txt\").unwrap(); }).join()\n/// }\n///\n/// fn main() {\n///     match copy_in_thread() {\n///         Ok(_) => println!(\"this is fine\"),\n///         Err(_) => println!(\"thread panicked\"),\n///     }\n/// }\n/// ```\n///\n/// [`Result`]: ../../std/result/enum.Result.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result<T> = crate::result::Result<T, Box<dyn Any + Send + 'static>>;\n\n// This packet is used to communicate the return value between the child thread\n// and the parent thread. Memory is shared through the `Arc` within and there's\n// no need for a mutex here because synchronization happens with `join()` (the\n// parent thread never reads this packet until the child has exited).\n//\n// This packet itself is then stored into a `JoinInner` which in turns is placed\n// in `JoinHandle` and `JoinGuard`. Due to the usage of `UnsafeCell` we need to\n// manually worry about impls like Send and Sync. The type `T` should\n// already always be Send (otherwise the thread could not have been created) and\n// this type is inherently Sync because no methods take &self. Regardless,\n// however, we add inheriting impls for Send/Sync to this type to ensure it's\n// Send/Sync and that future modifications will still appropriately classify it.\nstruct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n\nunsafe impl<T: Send> Send for Packet<T> {}\nunsafe impl<T: Sync> Sync for Packet<T> {}\n\n/// Inner representation for JoinHandle\nstruct JoinInner<T> {\n    native: Option<imp::Thread>,\n    thread: Thread,\n    packet: Packet<T>,\n}\n\nimpl<T> JoinInner<T> {\n    fn join(&mut self) -> Result<T> {\n}\n}\n\n/// An owned permission to join on a thread (block on its termination).\n///\n/// A `JoinHandle` *detaches* the associated thread when it is dropped, which\n/// means that there is no longer any handle to thread and no way to `join`\n/// on it.\n///\n/// Due to platform restrictions, it is not possible to [`Clone`] this\n/// handle: the ability to join a thread is a uniquely-owned permission.\n///\n/// This `struct` is created by the [`thread::spawn`] function and the\n/// [`thread::Builder::spawn`] method.\n///\n/// # Examples\n///\n/// Creation from [`thread::spawn`]:\n///\n/// ```\n/// use std::thread;\n///\n/// let join_handle: thread::JoinHandle<_> = thread::spawn(|| {\n///     // some work here\n/// });\n/// ```\n///\n/// Creation from [`thread::Builder::spawn`]:\n///\n/// ```\n/// use std::thread;\n///\n/// let builder = thread::Builder::new();\n///\n/// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n///     // some work here\n/// }).unwrap();\n/// ```\n///\n/// Child being detached and outliving its parent:\n///\n/// ```no_run\n/// use std::thread;\n/// use std::time::Duration;\n///\n/// let original_thread = thread::spawn(|| {\n///     let _detached_thread = thread::spawn(|| {\n///         // Here we sleep to make sure that the first thread returns before.\n///         thread::sleep(Duration::from_millis(10));\n///         // This will be called, even though the JoinHandle is dropped.\n///         println!(\"♫ Still alive ♫\");\n///     });\n/// });\n///\n/// original_thread.join().expect(\"The thread being joined has panicked\");\n/// println!(\"Original thread is joined.\");\n///\n/// // We make sure that the new thread has time to run, before the main\n/// // thread returns.\n///\n/// thread::sleep(Duration::from_millis(1000));\n/// ```\n///\n/// [`Clone`]: ../../std/clone/trait.Clone.html\n/// [`thread::spawn`]: fn.spawn.html\n/// [`thread::Builder::spawn`]: struct.Builder.html#method.spawn\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct JoinHandle<T>(JoinInner<T>);\n\n#[stable(feature = \"joinhandle_impl_send_sync\", since = \"1.29.0\")]\nunsafe impl<T> Send for JoinHandle<T> {}\n#[stable(feature = \"joinhandle_impl_send_sync\", since = \"1.29.0\")]\nunsafe impl<T> Sync for JoinHandle<T> {}\n\nimpl<T> JoinHandle<T> {\n    /// Extracts a handle to the underlying thread.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n    ///     // some work here\n    /// }).unwrap();\n    ///\n    /// let thread = join_handle.thread();\n    /// println!(\"thread id: {:?}\", thread.id());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn thread(&self) -> &Thread {\n}\n\n    /// Waits for the associated thread to finish.\n    ///\n    /// In terms of [atomic memory orderings],  the completion of the associated\n    /// thread synchronizes with this function returning. In other words, all\n    /// operations performed by that thread are ordered before all\n    /// operations that happen after `join` returns.\n    ///\n    /// If the child thread panics, [`Err`] is returned with the parameter given\n    /// to [`panic`].\n    ///\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`panic`]: ../../std/macro.panic.html\n    /// [atomic memory orderings]: ../../std/sync/atomic/index.html\n    ///\n    /// # Panics\n    ///\n    /// This function may panic on some platforms if a thread attempts to join\n    /// itself or otherwise may create a deadlock with joining threads.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let builder = thread::Builder::new();\n    ///\n    /// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n    ///     // some work here\n    /// }).unwrap();\n    /// join_handle.join().expect(\"Couldn't join on the associated thread\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn join(mut self) -> Result<T> {\n}\n}\n\nimpl<T> AsInner<imp::Thread> for JoinHandle<T> {\n    fn as_inner(&self) -> &imp::Thread {\n}\n}\n\nimpl<T> IntoInner<imp::Thread> for JoinHandle<T> {\n    fn into_inner(self) -> imp::Thread {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T> fmt::Debug for JoinHandle<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nfn _assert_sync_and_send() {\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Tests\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use super::Builder;\n    use crate::any::Any;\n    use crate::mem;\n    use crate::result;\n    use crate::sync::mpsc::{channel, Sender};\n    use crate::thread::{self, ThreadId};\n    use crate::time::Duration;\n    use crate::u32;\n\n    // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n    // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n\n    #[test]\n    fn test_unnamed_thread() {\n}\n\n    #[test]\n    fn test_named_thread() {\n}\n\n    #[test]\n    #[should_panic]\n    fn test_invalid_named_thread() {\n}\n\n    #[test]\n    fn test_run_basic() {\n}\n\n    #[test]\n    fn test_join_panic() {\n}\n\n    #[test]\n    fn test_spawn_sched() {\n}\n\n    #[test]\n    fn test_spawn_sched_childs_on_default_sched() {\n}\n\n    fn avoid_copying_the_body<F>(spawnfn: F)\n    where\n        F: FnOnce(Box<dyn Fn() + Send>),\n    {\n}\n\n    #[test]\n    fn test_avoid_copying_the_body_spawn() {\n}\n\n    #[test]\n    fn test_avoid_copying_the_body_thread_spawn() {\n}\n\n    #[test]\n    fn test_avoid_copying_the_body_join() {\n}\n\n    #[test]\n    fn test_child_doesnt_ref_parent() {\n}\n\n    #[test]\n    fn test_simple_newsched_spawn() {\n}\n\n    #[test]\n    fn test_try_panic_message_static_str() {\n}\n\n    #[test]\n    fn test_try_panic_message_owned_str() {\n}\n\n    #[test]\n    fn test_try_panic_message_any() {\n}\n\n    #[test]\n    fn test_try_panic_message_unit_struct() {\n}\n\n    #[test]\n    fn test_park_timeout_unpark_before() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn test_park_timeout_unpark_not_called() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn test_park_timeout_unpark_called_other_thread() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn sleep_ms_smoke() {\n}\n\n    #[test]\n    fn test_size_of_option_thread_id() {\n}\n\n    #[test]\n    fn test_thread_id_equal() {\n}\n\n    #[test]\n    fn test_thread_id_not_equal() {\n}\n\n    // NOTE: the corresponding test for stderr is in ui/thread-stderr, due\n    // to the test harness apparently interfering with stderr configuration.\n}\n}\npub mod ascii {\n//! Operations on ASCII strings and characters.\n//!\n//! Most string operations in Rust act on UTF-8 strings. However, at times it\n//! makes more sense to only consider the ASCII character set for a specific\n//! operation.\n//!\n//! The [`AsciiExt`] trait provides methods that allow for character\n//! operations that only act on the ASCII subset and leave non-ASCII characters\n//! alone.\n//!\n//! The [`escape_default`] function provides an iterator over the bytes of an\n//! escaped version of the character given.\n//!\n//! [`AsciiExt`]: trait.AsciiExt.html\n//! [`escape_default`]: fn.escape_default.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::ascii::{escape_default, EscapeDefault};\n\n/// Extension methods for ASCII-subset only operations.\n///\n/// Be aware that operations on seemingly non-ASCII characters can sometimes\n/// have unexpected results. Consider this example:\n///\n/// ```\n/// use std::ascii::AsciiExt;\n///\n/// assert_eq!(AsciiExt::to_ascii_uppercase(\"café\"), \"CAFÉ\");\n/// assert_eq!(AsciiExt::to_ascii_uppercase(\"café\"), \"CAFé\");\n/// ```\n///\n/// In the first example, the lowercased string is represented `\"cafe\\u{301}\"`\n/// (the last character is an acute accent [combining character]). Unlike the\n/// other characters in the string, the combining character will not get mapped\n/// to an uppercase variant, resulting in `\"CAFE\\u{301}\"`. In the second\n/// example, the lowercased string is represented `\"caf\\u{e9}\"` (the last\n/// character is a single Unicode character representing an 'e' with an acute\n/// accent). Since the last character is defined outside the scope of ASCII,\n/// it will not get mapped to an uppercase variant, resulting in `\"CAF\\u{e9}\"`.\n///\n/// [combining character]: https://en.wikipedia.org/wiki/Combining_character\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\npub trait AsciiExt {\n    /// Container type for copied ASCII characters.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Owned;\n\n    /// Checks if the value is within the ASCII range.\n    ///\n    /// # Note\n    ///\n    /// This method will be deprecated in favor of the identically-named\n    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn is_ascii(&self) -> bool;\n\n    /// Makes a copy of the value in its ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n    ///\n    /// To uppercase ASCII characters in addition to non-ASCII characters, use\n    /// [`str::to_uppercase`].\n    ///\n    /// # Note\n    ///\n    /// This method will be deprecated in favor of the identically-named\n    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n    ///\n    /// [`make_ascii_uppercase`]: #tymethod.make_ascii_uppercase\n    /// [`str::to_uppercase`]: ../primitive.str.html#method.to_uppercase\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow(deprecated)]\n    fn to_ascii_uppercase(&self) -> Self::Owned;\n\n    /// Makes a copy of the value in its ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n    ///\n    /// To lowercase ASCII characters in addition to non-ASCII characters, use\n    /// [`str::to_lowercase`].\n    ///\n    /// # Note\n    ///\n    /// This method will be deprecated in favor of the identically-named\n    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n    ///\n    /// [`make_ascii_lowercase`]: #tymethod.make_ascii_lowercase\n    /// [`str::to_lowercase`]: ../primitive.str.html#method.to_lowercase\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow(deprecated)]\n    fn to_ascii_lowercase(&self) -> Self::Owned;\n\n    /// Checks that two values are an ASCII case-insensitive match.\n    ///\n    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n    /// but without allocating and copying temporaries.\n    ///\n    /// # Note\n    ///\n    /// This method will be deprecated in favor of the identically-named\n    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n\n    /// Converts this type to its ASCII upper case equivalent in-place.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new uppercased value without modifying the existing one, use\n    /// [`to_ascii_uppercase`].\n    ///\n    /// # Note\n    ///\n    /// This method will be deprecated in favor of the identically-named\n    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n    ///\n    /// [`to_ascii_uppercase`]: #tymethod.to_ascii_uppercase\n    #[stable(feature = \"ascii\", since = \"1.9.0\")]\n    fn make_ascii_uppercase(&mut self);\n\n    /// Converts this type to its ASCII lower case equivalent in-place.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new lowercased value without modifying the existing one, use\n    /// [`to_ascii_lowercase`].\n    ///\n    /// # Note\n    ///\n    /// This method will be deprecated in favor of the identically-named\n    /// inherent methods on `u8`, `char`, `[u8]` and `str`.\n    ///\n    /// [`to_ascii_lowercase`]: #tymethod.to_ascii_lowercase\n    #[stable(feature = \"ascii\", since = \"1.9.0\")]\n    fn make_ascii_lowercase(&mut self);\n}\n\nmacro_rules! delegating_ascii_methods {\n    () => {\n        #[inline]\n        fn is_ascii(&self) -> bool { }\n\n        #[inline]\n        fn to_ascii_uppercase(&self) -> Self::Owned { }\n\n        #[inline]\n        fn to_ascii_lowercase(&self) -> Self::Owned { }\n\n        #[inline]\n        fn eq_ignore_ascii_case(&self, o: &Self) -> bool { }\n\n        #[inline]\n        fn make_ascii_uppercase(&mut self) { }\n\n        #[inline]\n        fn make_ascii_lowercase(&mut self) { }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\nimpl AsciiExt for u8 {\n    type Owned = u8;\n\n    delegating_ascii_methods!();\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\nimpl AsciiExt for char {\n    type Owned = char;\n\n    delegating_ascii_methods!();\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\nimpl AsciiExt for [u8] {\n    type Owned = Vec<u8>;\n\n    delegating_ascii_methods!();\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\nimpl AsciiExt for str {\n    type Owned = String;\n\n    delegating_ascii_methods!();\n}\n}\npub mod backtrace {\n//! Support for capturing a stack backtrace of an OS thread\n//!\n//! This module contains the support necessary to capture a stack backtrace of a\n//! running OS thread from the OS thread itself. The `Backtrace` type supports\n//! capturing a stack trace via the `Backtrace::capture` and\n//! `Backtrace::force_capture` functions.\n//!\n//! A backtrace is typically quite handy to attach to errors (e.g. types\n//! implementing `std::error::Error`) to get a causal chain of where an error\n//! was generated.\n//!\n//! > **Note**: this module is unstable and is designed in [RFC 2504], and you\n//! > can learn more about its status in the [tracking issue].\n//!\n//! [RFC 2504]: https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md\n//! [tracking issue]: https://github.com/rust-lang/rust/issues/53487\n//!\n//! ## Accuracy\n//!\n//! Backtraces are attempted to be as accurate as possible, but no guarantees\n//! are provided about the exact accuracy of a backtrace. Instruction pointers,\n//! symbol names, filenames, line numbers, etc, may all be incorrect when\n//! reported. Accuracy is attempted on a best-effort basis, however, and bugs\n//! are always welcome to indicate areas of improvement!\n//!\n//! For most platforms a backtrace with a filename/line number requires that\n//! programs be compiled with debug information. Without debug information\n//! filenames/line numbers will not be reported.\n//!\n//! ## Platform support\n//!\n//! Not all platforms that libstd compiles for support capturing backtraces.\n//! Some platforms simply do nothing when capturing a backtrace. To check\n//! whether the platform supports capturing backtraces you can consult the\n//! `BacktraceStatus` enum as a result of `Backtrace::status`.\n//!\n//! Like above with accuracy platform support is done on a best effort basis.\n//! Sometimes libraries may not be available at runtime or something may go\n//! wrong which would cause a backtrace to not be captured. Please feel free to\n//! report issues with platforms where a backtrace cannot be captured though!\n//!\n//! ## Environment Variables\n//!\n//! The `Backtrace::capture` function may not actually capture a backtrace by\n//! default. Its behavior is governed by two environment variables:\n//!\n//! * `RUST_LIB_BACKTRACE` - if this is set to `0` then `Backtrace::capture`\n//!   will never capture a backtrace. Any other value this is set to will enable\n//!   `Backtrace::capture`.\n//!\n//! * `RUST_BACKTRACE` - if `RUST_LIB_BACKTRACE` is not set, then this variable\n//!   is consulted with the same rules of `RUST_LIB_BACKTRACE`.\n//!\n//! * If neither of the above env vars are set, then `Backtrace::capture` will\n//!   be disabled.\n//!\n//! Capturing a backtrace can be a quite expensive runtime operation, so the\n//! environment variables allow either forcibly disabling this runtime\n//! performance hit or allow selectively enabling it in some programs.\n//!\n//! Note that the `Backtrace::force_capture` function can be used to ignore\n//! these environment variables. Also note that the state of environment\n//! variables is cached once the first backtrace is created, so altering\n//! `RUST_LIB_BACKTRACE` or `RUST_BACKTRACE` at runtime may not actually change\n//! how backtraces are captured.\n\n#![unstable(feature = \"backtrace\", issue = \"53487\")]\n\n// NB: A note on resolution of a backtrace:\n//\n// Backtraces primarily happen in two steps, one is where we actually capture\n// the stack backtrace, giving us a list of instruction pointers corresponding\n// to stack frames. Next we take these instruction pointers and, one-by-one,\n// turn them into a human readable name (like `main`).\n//\n// The first phase can be somewhat expensive (walking the stack), especially\n// on MSVC where debug information is consulted to return inline frames each as\n// their own frame. The second phase, however, is almost always extremely\n// expensive (on the order of milliseconds sometimes) when it's consulting debug\n// information.\n//\n// We attempt to amortize this cost as much as possible by delaying resolution\n// of an address to a human readable name for as long as possible. When\n// `Backtrace::create` is called to capture a backtrace it doesn't actually\n// perform any symbol resolution, but rather we lazily resolve symbols only just\n// before they're needed for printing. This way we can make capturing a\n// backtrace and throwing it away much cheaper, but actually printing a\n// backtrace is still basically the same cost.\n//\n// This strategy comes at the cost of some synchronization required inside of a\n// `Backtrace`, but that's a relatively small price to pay relative to capturing\n// a backtrace or actually symbolizing it.\n\nuse crate::env;\nuse crate::fmt;\nuse crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\nuse crate::sync::Mutex;\nuse crate::sys_common::backtrace::{lock, output_filename};\nuse crate::vec::Vec;\nuse backtrace::BytesOrWideString;\nuse backtrace_rs as backtrace;\n\n/// A captured OS thread stack backtrace.\n///\n/// This type represents a stack backtrace for an OS thread captured at a\n/// previous point in time. In some instances the `Backtrace` type may\n/// internally be empty due to configuration. For more information see\n/// `Backtrace::capture`.\npub struct Backtrace {\n    inner: Inner,\n}\n\n/// The current status of a backtrace, indicating whether it was captured or\n/// whether it is empty for some other reason.\n#[non_exhaustive]\n#[derive(Debug, PartialEq, Eq)]\npub enum BacktraceStatus {\n    /// Capturing a backtrace is not supported, likely because it's not\n    /// implemented for the current platform.\n    Unsupported,\n    /// Capturing a backtrace has been disabled through either the\n    /// `RUST_LIB_BACKTRACE` or `RUST_BACKTRACE` environment variables.\n    Disabled,\n    /// A backtrace has been captured and the `Backtrace` should print\n    /// reasonable information when rendered.\n    Captured,\n}\n\nenum Inner {\n    Unsupported,\n    Disabled,\n    Captured(Mutex<Capture>),\n}\n\nstruct Capture {\n    actual_start: usize,\n    resolved: bool,\n    frames: Vec<BacktraceFrame>,\n}\n\nfn _assert_send_sync() {\n}\n\nstruct BacktraceFrame {\n    frame: backtrace::Frame,\n    symbols: Vec<BacktraceSymbol>,\n}\n\nstruct BacktraceSymbol {\n    name: Option<Vec<u8>>,\n    filename: Option<BytesOrWide>,\n    lineno: Option<u32>,\n}\n\nenum BytesOrWide {\n    Bytes(Vec<u8>),\n    Wide(Vec<u16>),\n}\n\nimpl Backtrace {\n    /// Returns whether backtrace captures are enabled through environment\n    /// variables.\n    fn enabled() -> bool {\n}\n\n    /// Capture a stack backtrace of the current thread.\n    ///\n    /// This function will capture a stack backtrace of the current OS thread of\n    /// execution, returning a `Backtrace` type which can be later used to print\n    /// the entire stack trace or render it to a string.\n    ///\n    /// This function will be a noop if the `RUST_BACKTRACE` or\n    /// `RUST_LIB_BACKTRACE` backtrace variables are both not set. If either\n    /// environment variable is set and enabled then this function will actually\n    /// capture a backtrace. Capturing a backtrace can be both memory intensive\n    /// and slow, so these environment variables allow liberally using\n    /// `Backtrace::capture` and only incurring a slowdown when the environment\n    /// variables are set.\n    ///\n    /// To forcibly capture a backtrace regardless of environment variables, use\n    /// the `Backtrace::force_capture` function.\n    #[inline(never)] // want to make sure there's a frame here to remove\n    pub fn capture() -> Backtrace {\n}\n\n    /// Forcibly captures a full backtrace, regardless of environment variable\n    /// configuration.\n    ///\n    /// This function behaves the same as `capture` except that it ignores the\n    /// values of the `RUST_BACKTRACE` and `RUST_LIB_BACKTRACE` environment\n    /// variables, always capturing a backtrace.\n    ///\n    /// Note that capturing a backtrace can be an expensive operation on some\n    /// platforms, so this should be used with caution in performance-sensitive\n    /// parts of code.\n    #[inline(never)] // want to make sure there's a frame here to remove\n    pub fn force_capture() -> Backtrace {\n}\n\n    // Capture a backtrace which start just before the function addressed by\n    // `ip`\n    fn create(ip: usize) -> Backtrace {\n}\n\n    /// Returns the status of this backtrace, indicating whether this backtrace\n    /// request was unsupported, disabled, or a stack trace was actually\n    /// captured.\n    pub fn status(&self) -> BacktraceStatus {\n}\n}\n\nimpl fmt::Display for Backtrace {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl fmt::Debug for Backtrace {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl Capture {\n    fn resolve(&mut self) {\n}\n}\n}\npub mod collections {\n//! Collection types.\n//!\n//! Rust's standard collection library provides efficient implementations of the\n//! most common general purpose programming data structures. By using the\n//! standard implementations, it should be possible for two libraries to\n//! communicate without significant data conversion.\n//!\n//! To get this out of the way: you should probably just use [`Vec`] or [`HashMap`].\n//! These two collections cover most use cases for generic data storage and\n//! processing. They are exceptionally good at doing what they do. All the other\n//! collections in the standard library have specific use cases where they are\n//! the optimal choice, but these cases are borderline *niche* in comparison.\n//! Even when `Vec` and `HashMap` are technically suboptimal, they're probably a\n//! good enough choice to get started.\n//!\n//! Rust's collections can be grouped into four major categories:\n//!\n//! * Sequences: [`Vec`], [`VecDeque`], [`LinkedList`]\n//! * Maps: [`HashMap`], [`BTreeMap`]\n//! * Sets: [`HashSet`], [`BTreeSet`]\n//! * Misc: [`BinaryHeap`]\n//!\n//! # When Should You Use Which Collection?\n//!\n//! These are fairly high-level and quick break-downs of when each collection\n//! should be considered. Detailed discussions of strengths and weaknesses of\n//! individual collections can be found on their own documentation pages.\n//!\n//! ### Use a `Vec` when:\n//! * You want to collect items up to be processed or sent elsewhere later, and\n//!   don't care about any properties of the actual values being stored.\n//! * You want a sequence of elements in a particular order, and will only be\n//!   appending to (or near) the end.\n//! * You want a stack.\n//! * You want a resizable array.\n//! * You want a heap-allocated array.\n//!\n//! ### Use a `VecDeque` when:\n//! * You want a [`Vec`] that supports efficient insertion at both ends of the\n//!   sequence.\n//! * You want a queue.\n//! * You want a double-ended queue (deque).\n//!\n//! ### Use a `LinkedList` when:\n//! * You want a [`Vec`] or [`VecDeque`] of unknown size, and can't tolerate\n//!   amortization.\n//! * You want to efficiently split and append lists.\n//! * You are *absolutely* certain you *really*, *truly*, want a doubly linked\n//!   list.\n//!\n//! ### Use a `HashMap` when:\n//! * You want to associate arbitrary keys with an arbitrary value.\n//! * You want a cache.\n//! * You want a map, with no extra functionality.\n//!\n//! ### Use a `BTreeMap` when:\n//! * You want a map sorted by its keys.\n//! * You want to be able to get a range of entries on-demand.\n//! * You're interested in what the smallest or largest key-value pair is.\n//! * You want to find the largest or smallest key that is smaller or larger\n//!   than something.\n//!\n//! ### Use the `Set` variant of any of these `Map`s when:\n//! * You just want to remember which keys you've seen.\n//! * There is no meaningful value to associate with your keys.\n//! * You just want a set.\n//!\n//! ### Use a `BinaryHeap` when:\n//!\n//! * You want to store a bunch of elements, but only ever want to process the\n//!   \"biggest\" or \"most important\" one at any given time.\n//! * You want a priority queue.\n//!\n//! # Performance\n//!\n//! Choosing the right collection for the job requires an understanding of what\n//! each collection is good at. Here we briefly summarize the performance of\n//! different collections for certain important operations. For further details,\n//! see each type's documentation, and note that the names of actual methods may\n//! differ from the tables below on certain collections.\n//!\n//! Throughout the documentation, we will follow a few conventions. For all\n//! operations, the collection's size is denoted by n. If another collection is\n//! involved in the operation, it contains m elements. Operations which have an\n//! *amortized* cost are suffixed with a `*`. Operations with an *expected*\n//! cost are suffixed with a `~`.\n//!\n//! All amortized costs are for the potential need to resize when capacity is\n//! exhausted. If a resize occurs it will take O(n) time. Our collections never\n//! automatically shrink, so removal operations aren't amortized. Over a\n//! sufficiently large series of operations, the average cost per operation will\n//! deterministically equal the given cost.\n//!\n//! Only [`HashMap`] has expected costs, due to the probabilistic nature of hashing.\n//! It is theoretically possible, though very unlikely, for [`HashMap`] to\n//! experience worse performance.\n//!\n//! ## Sequences\n//!\n//! |                | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n//! |----------------|----------------|-----------------|----------------|--------|----------------|\n//! | [`Vec`]        | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n//! | [`VecDeque`]   | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n//! | [`LinkedList`] | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n//!\n//! Note that where ties occur, [`Vec`] is generally going to be faster than [`VecDeque`], and\n//! [`VecDeque`] is generally going to be faster than [`LinkedList`].\n//!\n//! ## Maps\n//!\n//! For Sets, all operations have the cost of the equivalent Map operation.\n//!\n//! |              | get       | insert   | remove   | predecessor | append |\n//! |--------------|-----------|----------|----------|-------------|--------|\n//! | [`HashMap`]  | O(1)~     | O(1)~*   | O(1)~    | N/A         | N/A    |\n//! | [`BTreeMap`] | O(log n)  | O(log n) | O(log n) | O(log n)    | O(n+m) |\n//!\n//! # Correct and Efficient Usage of Collections\n//!\n//! Of course, knowing which collection is the right one for the job doesn't\n//! instantly permit you to use it correctly. Here are some quick tips for\n//! efficient and correct usage of the standard collections in general. If\n//! you're interested in how to use a specific collection in particular, consult\n//! its documentation for detailed discussion and code examples.\n//!\n//! ## Capacity Management\n//!\n//! Many collections provide several constructors and methods that refer to\n//! \"capacity\". These collections are generally built on top of an array.\n//! Optimally, this array would be exactly the right size to fit only the\n//! elements stored in the collection, but for the collection to do this would\n//! be very inefficient. If the backing array was exactly the right size at all\n//! times, then every time an element is inserted, the collection would have to\n//! grow the array to fit it. Due to the way memory is allocated and managed on\n//! most computers, this would almost surely require allocating an entirely new\n//! array and copying every single element from the old one into the new one.\n//! Hopefully you can see that this wouldn't be very efficient to do on every\n//! operation.\n//!\n//! Most collections therefore use an *amortized* allocation strategy. They\n//! generally let themselves have a fair amount of unoccupied space so that they\n//! only have to grow on occasion. When they do grow, they allocate a\n//! substantially larger array to move the elements into so that it will take a\n//! while for another grow to be required. While this strategy is great in\n//! general, it would be even better if the collection *never* had to resize its\n//! backing array. Unfortunately, the collection itself doesn't have enough\n//! information to do this itself. Therefore, it is up to us programmers to give\n//! it hints.\n//!\n//! Any `with_capacity` constructor will instruct the collection to allocate\n//! enough space for the specified number of elements. Ideally this will be for\n//! exactly that many elements, but some implementation details may prevent\n//! this. See collection-specific documentation for details. In general, use\n//! `with_capacity` when you know exactly how many elements will be inserted, or\n//! at least have a reasonable upper-bound on that number.\n//!\n//! When anticipating a large influx of elements, the `reserve` family of\n//! methods can be used to hint to the collection how much room it should make\n//! for the coming items. As with `with_capacity`, the precise behavior of\n//! these methods will be specific to the collection of interest.\n//!\n//! For optimal performance, collections will generally avoid shrinking\n//! themselves. If you believe that a collection will not soon contain any more\n//! elements, or just really need the memory, the `shrink_to_fit` method prompts\n//! the collection to shrink the backing array to the minimum size capable of\n//! holding its elements.\n//!\n//! Finally, if ever you're interested in what the actual capacity of the\n//! collection is, most collections provide a `capacity` method to query this\n//! information on demand. This can be useful for debugging purposes, or for\n//! use with the `reserve` methods.\n//!\n//! ## Iterators\n//!\n//! Iterators are a powerful and robust mechanism used throughout Rust's\n//! standard libraries. Iterators provide a sequence of values in a generic,\n//! safe, efficient and convenient way. The contents of an iterator are usually\n//! *lazily* evaluated, so that only the values that are actually needed are\n//! ever actually produced, and no allocation need be done to temporarily store\n//! them. Iterators are primarily consumed using a `for` loop, although many\n//! functions also take iterators where a collection or sequence of values is\n//! desired.\n//!\n//! All of the standard collections provide several iterators for performing\n//! bulk manipulation of their contents. The three primary iterators almost\n//! every collection should provide are `iter`, `iter_mut`, and `into_iter`.\n//! Some of these are not provided on collections where it would be unsound or\n//! unreasonable to provide them.\n//!\n//! `iter` provides an iterator of immutable references to all the contents of a\n//! collection in the most \"natural\" order. For sequence collections like [`Vec`],\n//! this means the items will be yielded in increasing order of index starting\n//! at 0. For ordered collections like [`BTreeMap`], this means that the items\n//! will be yielded in sorted order. For unordered collections like [`HashMap`],\n//! the items will be yielded in whatever order the internal representation made\n//! most convenient. This is great for reading through all the contents of the\n//! collection.\n//!\n//! ```\n//! let vec = vec![1, 2, 3, 4];\n//! for x in vec.iter() {\n//!    println!(\"vec contained {}\", x);\n//! }\n//! ```\n//!\n//! `iter_mut` provides an iterator of *mutable* references in the same order as\n//! `iter`. This is great for mutating all the contents of the collection.\n//!\n//! ```\n//! let mut vec = vec![1, 2, 3, 4];\n//! for x in vec.iter_mut() {\n//!    *x += 1;\n//! }\n//! ```\n//!\n//! `into_iter` transforms the actual collection into an iterator over its\n//! contents by-value. This is great when the collection itself is no longer\n//! needed, and the values are needed elsewhere. Using `extend` with `into_iter`\n//! is the main way that contents of one collection are moved into another.\n//! `extend` automatically calls `into_iter`, and takes any `T: `[`IntoIterator`].\n//! Calling `collect` on an iterator itself is also a great way to convert one\n//! collection into another. Both of these methods should internally use the\n//! capacity management tools discussed in the previous section to do this as\n//! efficiently as possible.\n//!\n//! ```\n//! let mut vec1 = vec![1, 2, 3, 4];\n//! let vec2 = vec![10, 20, 30, 40];\n//! vec1.extend(vec2);\n//! ```\n//!\n//! ```\n//! use std::collections::VecDeque;\n//!\n//! let vec = vec![1, 2, 3, 4];\n//! let buf: VecDeque<_> = vec.into_iter().collect();\n//! ```\n//!\n//! Iterators also provide a series of *adapter* methods for performing common\n//! threads to sequences. Among the adapters are functional favorites like `map`,\n//! `fold`, `skip` and `take`. Of particular interest to collections is the\n//! `rev` adapter, that reverses any iterator that supports this operation. Most\n//! collections provide reversible iterators as the way to iterate over them in\n//! reverse order.\n//!\n//! ```\n//! let vec = vec![1, 2, 3, 4];\n//! for x in vec.iter().rev() {\n//!    println!(\"vec contained {}\", x);\n//! }\n//! ```\n//!\n//! Several other collection methods also return iterators to yield a sequence\n//! of results but avoid allocating an entire collection to store the result in.\n//! This provides maximum flexibility as `collect` or `extend` can be called to\n//! \"pipe\" the sequence into any collection if desired. Otherwise, the sequence\n//! can be looped over with a `for` loop. The iterator can also be discarded\n//! after partial use, preventing the computation of the unused items.\n//!\n//! ## Entries\n//!\n//! The `entry` API is intended to provide an efficient mechanism for\n//! manipulating the contents of a map conditionally on the presence of a key or\n//! not. The primary motivating use case for this is to provide efficient\n//! accumulator maps. For instance, if one wishes to maintain a count of the\n//! number of times each key has been seen, they will have to perform some\n//! conditional logic on whether this is the first time the key has been seen or\n//! not. Normally, this would require a `find` followed by an `insert`,\n//! effectively duplicating the search effort on each insertion.\n//!\n//! When a user calls `map.entry(&key)`, the map will search for the key and\n//! then yield a variant of the `Entry` enum.\n//!\n//! If a `Vacant(entry)` is yielded, then the key *was not* found. In this case\n//! the only valid operation is to `insert` a value into the entry. When this is\n//! done, the vacant entry is consumed and converted into a mutable reference to\n//! the value that was inserted. This allows for further manipulation of the\n//! value beyond the lifetime of the search itself. This is useful if complex\n//! logic needs to be performed on the value regardless of whether the value was\n//! just inserted.\n//!\n//! If an `Occupied(entry)` is yielded, then the key *was* found. In this case,\n//! the user has several options: they can `get`, `insert` or `remove` the\n//! value of the occupied entry. Additionally, they can convert the occupied\n//! entry into a mutable reference to its value, providing symmetry to the\n//! vacant `insert` case.\n//!\n//! ### Examples\n//!\n//! Here are the two primary ways in which `entry` is used. First, a simple\n//! example where the logic performed on the values is trivial.\n//!\n//! #### Counting the number of times each character in a string occurs\n//!\n//! ```\n//! use std::collections::btree_map::BTreeMap;\n//!\n//! let mut count = BTreeMap::new();\n//! let message = \"she sells sea shells by the sea shore\";\n//!\n//! for c in message.chars() {\n//!     *count.entry(c).or_insert(0) += 1;\n//! }\n//!\n//! assert_eq!(count.get(&'s'), Some(&8));\n//!\n//! println!(\"Number of occurrences of each character\");\n//! for (char, count) in &count {\n//!     println!(\"{}: {}\", char, count);\n//! }\n//! ```\n//!\n//! When the logic to be performed on the value is more complex, we may simply\n//! use the `entry` API to ensure that the value is initialized and perform the\n//! logic afterwards.\n//!\n//! #### Tracking the inebriation of customers at a bar\n//!\n//! ```\n//! use std::collections::btree_map::BTreeMap;\n//!\n//! // A client of the bar. They have a blood alcohol level.\n//! struct Person { blood_alcohol: f32 }\n//!\n//! // All the orders made to the bar, by client ID.\n//! let orders = vec![1, 2, 1, 2, 3, 4, 1, 2, 2, 3, 4, 1, 1, 1];\n//!\n//! // Our clients.\n//! let mut blood_alcohol = BTreeMap::new();\n//!\n//! for id in orders {\n//!     // If this is the first time we've seen this customer, initialize them\n//!     // with no blood alcohol. Otherwise, just retrieve them.\n//!     let person = blood_alcohol.entry(id).or_insert(Person { blood_alcohol: 0.0 });\n//!\n//!     // Reduce their blood alcohol level. It takes time to order and drink a beer!\n//!     person.blood_alcohol *= 0.9;\n//!\n//!     // Check if they're sober enough to have another beer.\n//!     if person.blood_alcohol > 0.3 {\n//!         // Too drunk... for now.\n//!         println!(\"Sorry {}, I have to cut you off\", id);\n//!     } else {\n//!         // Have another!\n//!         person.blood_alcohol += 0.1;\n//!     }\n//! }\n//! ```\n//!\n//! # Insert and complex keys\n//!\n//! If we have a more complex key, calls to `insert` will\n//! not update the value of the key. For example:\n//!\n//! ```\n//! use std::cmp::Ordering;\n//! use std::collections::BTreeMap;\n//! use std::hash::{Hash, Hasher};\n//!\n//! #[derive(Debug)]\n//! struct Foo {\n//!     a: u32,\n//!     b: &'static str,\n//! }\n//!\n//! // we will compare `Foo`s by their `a` value only.\n//! impl PartialEq for Foo {\n//!     fn eq(&self, other: &Self) -> bool { self.a == other.a }\n//! }\n//!\n//! impl Eq for Foo {}\n//!\n//! // we will hash `Foo`s by their `a` value only.\n//! impl Hash for Foo {\n//!     fn hash<H: Hasher>(&self, h: &mut H) { self.a.hash(h); }\n//! }\n//!\n//! impl PartialOrd for Foo {\n//!     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { self.a.partial_cmp(&other.a) }\n//! }\n//!\n//! impl Ord for Foo {\n//!     fn cmp(&self, other: &Self) -> Ordering { self.a.cmp(&other.a) }\n//! }\n//!\n//! let mut map = BTreeMap::new();\n//! map.insert(Foo { a: 1, b: \"baz\" }, 99);\n//!\n//! // We already have a Foo with an a of 1, so this will be updating the value.\n//! map.insert(Foo { a: 1, b: \"xyz\" }, 100);\n//!\n//! // The value has been updated...\n//! assert_eq!(map.values().next().unwrap(), &100);\n//!\n//! // ...but the key hasn't changed. b is still \"baz\", not \"xyz\".\n//! assert_eq!(map.keys().next().unwrap().b, \"baz\");\n//! ```\n//!\n//! [`Vec`]: ../../std/vec/struct.Vec.html\n//! [`HashMap`]: ../../std/collections/struct.HashMap.html\n//! [`VecDeque`]: ../../std/collections/struct.VecDeque.html\n//! [`LinkedList`]: ../../std/collections/struct.LinkedList.html\n//! [`BTreeMap`]: ../../std/collections/struct.BTreeMap.html\n//! [`HashSet`]: ../../std/collections/struct.HashSet.html\n//! [`BTreeSet`]: ../../std/collections/struct.BTreeSet.html\n//! [`BinaryHeap`]: ../../std/collections/struct.BinaryHeap.html\n//! [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(reason = \"moved to `std::ops::Bound`\", since = \"1.26.0\")]\n#[doc(hidden)]\npub use crate::ops::Bound;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::collections::{binary_heap, btree_map, btree_set};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::collections::{linked_list, vec_deque};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::collections::{BTreeMap, BTreeSet, BinaryHeap};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::collections::{LinkedList, VecDeque};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::hash_map::HashMap;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::hash_set::HashSet;\n\n#[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\npub use alloc_crate::collections::TryReserveError;\n\nmod hash {\n//! Unordered containers, implemented as hash-tables\n\npub mod map {\n// ignore-tidy-filelength\n\nuse self::Entry::*;\n\nuse hashbrown::hash_map as base;\n\nuse crate::borrow::Borrow;\nuse crate::cell::Cell;\nuse crate::collections::TryReserveError;\nuse crate::fmt::{self, Debug};\n#[allow(deprecated)]\nuse crate::hash::{BuildHasher, Hash, Hasher, SipHasher13};\nuse crate::iter::{FromIterator, FusedIterator};\nuse crate::ops::Index;\nuse crate::sys;\n\n/// A hash map implemented with quadratic probing and SIMD lookup.\n///\n/// By default, `HashMap` uses a hashing algorithm selected to provide\n/// resistance against HashDoS attacks. The algorithm is randomly seeded, and a\n/// reasonable best-effort is made to generate this seed from a high quality,\n/// secure source of randomness provided by the host without blocking the\n/// program. Because of this, the randomness of the seed depends on the output\n/// quality of the system's random number generator when the seed is created.\n/// In particular, seeds generated when the system's entropy pool is abnormally\n/// low such as during system boot may be of a lower quality.\n///\n/// The default hashing algorithm is currently SipHash 1-3, though this is\n/// subject to change at any point in the future. While its performance is very\n/// competitive for medium sized keys, other hashing algorithms will outperform\n/// it for small keys such as integers as well as large keys such as long\n/// strings, though those algorithms will typically *not* protect against\n/// attacks such as HashDoS.\n///\n/// The hashing algorithm can be replaced on a per-`HashMap` basis using the\n/// [`default`], [`with_hasher`], and [`with_capacity_and_hasher`] methods. Many\n/// alternative algorithms are available on crates.io, such as the [`fnv`] crate.\n///\n/// It is required that the keys implement the [`Eq`] and [`Hash`] traits, although\n/// this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\n/// If you implement these yourself, it is important that the following\n/// property holds:\n///\n/// ```text\n/// k1 == k2 -> hash(k1) == hash(k2)\n/// ```\n///\n/// In other words, if two keys are equal, their hashes must be equal.\n///\n/// It is a logic error for a key to be modified in such a way that the key's\n/// hash, as determined by the [`Hash`] trait, or its equality, as determined by\n/// the [`Eq`] trait, changes while it is in the map. This is normally only\n/// possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n///\n/// The hash table implementation is a Rust port of Google's [SwissTable].\n/// The original C++ version of SwissTable can be found [here], and this\n/// [CppCon talk] gives an overview of how the algorithm works.\n///\n/// [SwissTable]: https://abseil.io/blog/20180927-swisstables\n/// [here]: https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h\n/// [CppCon talk]: https://www.youtube.com/watch?v=ncHmEUmJZf4\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// // Type inference lets us omit an explicit type signature (which\n/// // would be `HashMap<String, String>` in this example).\n/// let mut book_reviews = HashMap::new();\n///\n/// // Review some books.\n/// book_reviews.insert(\n///     \"Adventures of Huckleberry Finn\".to_string(),\n///     \"My favorite book.\".to_string(),\n/// );\n/// book_reviews.insert(\n///     \"Grimms' Fairy Tales\".to_string(),\n///     \"Masterpiece.\".to_string(),\n/// );\n/// book_reviews.insert(\n///     \"Pride and Prejudice\".to_string(),\n///     \"Very enjoyable.\".to_string(),\n/// );\n/// book_reviews.insert(\n///     \"The Adventures of Sherlock Holmes\".to_string(),\n///     \"Eye lyked it alot.\".to_string(),\n/// );\n///\n/// // Check for a specific one.\n/// // When collections store owned values (String), they can still be\n/// // queried using references (&str).\n/// if !book_reviews.contains_key(\"Les Misérables\") {\n///     println!(\"We've got {} reviews, but Les Misérables ain't one.\",\n///              book_reviews.len());\n/// }\n///\n/// // oops, this review has a lot of spelling mistakes, let's delete it.\n/// book_reviews.remove(\"The Adventures of Sherlock Holmes\");\n///\n/// // Look up the values associated with some keys.\n/// let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n/// for &book in &to_find {\n///     match book_reviews.get(book) {\n///         Some(review) => println!(\"{}: {}\", book, review),\n///         None => println!(\"{} is unreviewed.\", book)\n///     }\n/// }\n///\n/// // Look up the value for a key (will panic if the key is not found).\n/// println!(\"Review for Jane: {}\", book_reviews[\"Pride and Prejudice\"]);\n///\n/// // Iterate over everything.\n/// for (book, review) in &book_reviews {\n///     println!(\"{}: \\\"{}\\\"\", book, review);\n/// }\n/// ```\n///\n/// `HashMap` also implements an [`Entry API`](#method.entry), which allows\n/// for more complex methods of getting, setting, updating and removing keys and\n/// their values:\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// // type inference lets us omit an explicit type signature (which\n/// // would be `HashMap<&str, u8>` in this example).\n/// let mut player_stats = HashMap::new();\n///\n/// fn random_stat_buff() -> u8 {\n///     // could actually return some random value here - let's just return\n///     // some fixed value for now\n///     42\n/// }\n///\n/// // insert a key only if it doesn't already exist\n/// player_stats.entry(\"health\").or_insert(100);\n///\n/// // insert a key using a function that provides a new value only if it\n/// // doesn't already exist\n/// player_stats.entry(\"defence\").or_insert_with(random_stat_buff);\n///\n/// // update a key, guarding against the key possibly not being set\n/// let stat = player_stats.entry(\"attack\").or_insert(100);\n/// *stat += random_stat_buff();\n/// ```\n///\n/// The easiest way to use `HashMap` with a custom key type is to derive [`Eq`] and [`Hash`].\n/// We must also derive [`PartialEq`].\n///\n/// [`Eq`]: ../../std/cmp/trait.Eq.html\n/// [`Hash`]: ../../std/hash/trait.Hash.html\n/// [`PartialEq`]: ../../std/cmp/trait.PartialEq.html\n/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n/// [`Cell`]: ../../std/cell/struct.Cell.html\n/// [`default`]: #method.default\n/// [`with_hasher`]: #method.with_hasher\n/// [`with_capacity_and_hasher`]: #method.with_capacity_and_hasher\n/// [`fnv`]: https://crates.io/crates/fnv\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// #[derive(Hash, Eq, PartialEq, Debug)]\n/// struct Viking {\n///     name: String,\n///     country: String,\n/// }\n///\n/// impl Viking {\n///     /// Creates a new Viking.\n///     fn new(name: &str, country: &str) -> Viking {\n///         Viking { name: name.to_string(), country: country.to_string() }\n///     }\n/// }\n///\n/// // Use a HashMap to store the vikings' health points.\n/// let mut vikings = HashMap::new();\n///\n/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\n/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\n/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n///\n/// // Use derived implementation to print the status of the vikings.\n/// for (viking, health) in &vikings {\n///     println!(\"{:?} has {} hp\", viking, health);\n/// }\n/// ```\n///\n/// A `HashMap` with fixed list of elements can be initialized from an array:\n///\n/// ```\n/// use std::collections::HashMap;\n///\n/// let timber_resources: HashMap<&str, i32> = [(\"Norway\", 100), (\"Denmark\", 50), (\"Iceland\", 10)]\n///     .iter().cloned().collect();\n/// // use the values stored in map\n/// ```\n\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct HashMap<K, V, S = RandomState> {\n    base: base::HashMap<K, V, S>,\n}\n\nimpl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n    /// Creates an empty `HashMap`.\n    ///\n    /// The hash map is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// let mut map: HashMap<&str, i32> = HashMap::new();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> HashMap<K, V, RandomState> {\n}\n\n    /// Creates an empty `HashMap` with the specified capacity.\n    ///\n    /// The hash map will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// let mut map: HashMap<&str, i32> = HashMap::with_capacity(10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> {\n}\n}\n\nimpl<K, V, S> HashMap<K, V, S> {\n    /// Returns the number of elements the map can hold without reallocating.\n    ///\n    /// This number is a lower bound; the `HashMap<K, V>` might be able to hold\n    /// more, but is guaranteed to be able to hold at least this many.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// let map: HashMap<i32, i32> = HashMap::with_capacity(100);\n    /// assert!(map.capacity() >= 100);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n}\n\n    /// An iterator visiting all keys in arbitrary order.\n    /// The iterator element type is `&'a K`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// for key in map.keys() {\n    ///     println!(\"{}\", key);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn keys(&self) -> Keys<'_, K, V> {\n}\n\n    /// An iterator visiting all values in arbitrary order.\n    /// The iterator element type is `&'a V`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// for val in map.values() {\n    ///     println!(\"{}\", val);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn values(&self) -> Values<'_, K, V> {\n}\n\n    /// An iterator visiting all values mutably in arbitrary order.\n    /// The iterator element type is `&'a mut V`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    ///\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// for val in map.values_mut() {\n    ///     *val = *val + 10;\n    /// }\n    ///\n    /// for val in map.values() {\n    ///     println!(\"{}\", val);\n    /// }\n    /// ```\n    #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n    pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {\n}\n\n    /// An iterator visiting all key-value pairs in arbitrary order.\n    /// The iterator element type is `(&'a K, &'a V)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// for (key, val) in map.iter() {\n    ///     println!(\"key: {} val: {}\", key, val);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, K, V> {\n}\n\n    /// An iterator visiting all key-value pairs in arbitrary order,\n    /// with mutable references to the values.\n    /// The iterator element type is `(&'a K, &'a mut V)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// // Update all values\n    /// for (_, val) in map.iter_mut() {\n    ///     *val *= 2;\n    /// }\n    ///\n    /// for (key, val) in &map {\n    ///     println!(\"key: {} val: {}\", key, val);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n}\n\n    /// Returns the number of elements in the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// assert_eq!(a.len(), 0);\n    /// a.insert(1, \"a\");\n    /// assert_eq!(a.len(), 1);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n}\n\n    /// Returns `true` if the map contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// assert!(a.is_empty());\n    /// a.insert(1, \"a\");\n    /// assert!(!a.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n}\n\n    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n    /// allocated memory for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// a.insert(1, \"a\");\n    /// a.insert(2, \"b\");\n    ///\n    /// for (k, v) in a.drain().take(1) {\n    ///     assert!(k == 1 || k == 2);\n    ///     assert!(v == \"a\" || v == \"b\");\n    /// }\n    ///\n    /// assert!(a.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain(&mut self) -> Drain<'_, K, V> {\n}\n\n    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n    /// for reuse.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut a = HashMap::new();\n    /// a.insert(1, \"a\");\n    /// a.clear();\n    /// assert!(a.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn clear(&mut self) {\n}\n}\n\nimpl<K, V, S> HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher,\n{\n    /// Creates an empty `HashMap` which will use the given hash builder to hash\n    /// keys.\n    ///\n    /// The created map has the default initial capacity.\n    ///\n    /// Warning: `hash_builder` is normally randomly generated, and\n    /// is designed to allow HashMaps to be resistant to attacks that\n    /// cause many collisions and very poor performance. Setting it\n    /// manually using this function can expose a DoS attack vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mut map = HashMap::with_hasher(s);\n    /// map.insert(1, 2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> {\n}\n\n    /// Creates an empty `HashMap` with the specified capacity, using `hash_builder`\n    /// to hash the keys.\n    ///\n    /// The hash map will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n    ///\n    /// Warning: `hash_builder` is normally randomly generated, and\n    /// is designed to allow HashMaps to be resistant to attacks that\n    /// cause many collisions and very poor performance. Setting it\n    /// manually using this function can expose a DoS attack vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mut map = HashMap::with_capacity_and_hasher(10, s);\n    /// map.insert(1, 2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {\n}\n\n    /// Returns a reference to the map's [`BuildHasher`].\n    ///\n    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let hasher = RandomState::new();\n    /// let map: HashMap<i32, i32> = HashMap::with_hasher(hasher);\n    /// let hasher: &RandomState = map.hasher();\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n    pub fn hasher(&self) -> &S {\n}\n\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the `HashMap`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new allocation size overflows [`usize`].\n    ///\n    /// [`usize`]: ../../std/primitive.usize.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// let mut map: HashMap<&str, i32> = HashMap::new();\n    /// map.reserve(10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n}\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `HashMap<K,V>`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_reserve)]\n    /// use std::collections::HashMap;\n    /// let mut map: HashMap<&str, isize> = HashMap::new();\n    /// map.try_reserve(10).expect(\"why is the test harness OOMing on 10 bytes?\");\n    /// ```\n    #[inline]\n    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n}\n\n    /// Shrinks the capacity of the map as much as possible. It will drop\n    /// down as much as possible while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// assert!(map.capacity() >= 100);\n    /// map.shrink_to_fit();\n    /// assert!(map.capacity() >= 2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n}\n\n    /// Shrinks the capacity of the map with a lower limit. It will drop\n    /// down no lower than the supplied limit while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// Panics if the current capacity is smaller than the supplied\n    /// minimum capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(shrink_to)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = HashMap::with_capacity(100);\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// assert!(map.capacity() >= 100);\n    /// map.shrink_to(10);\n    /// assert!(map.capacity() >= 10);\n    /// map.shrink_to(0);\n    /// assert!(map.capacity() >= 2);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n}\n\n    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut letters = HashMap::new();\n    ///\n    /// for ch in \"a short treatise on fungi\".chars() {\n    ///     let counter = letters.entry(ch).or_insert(0);\n    ///     *counter += 1;\n    /// }\n    ///\n    /// assert_eq!(letters[&'s'], 2);\n    /// assert_eq!(letters[&'t'], 3);\n    /// assert_eq!(letters[&'u'], 1);\n    /// assert_eq!(letters.get(&'y'), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n}\n\n    /// Returns a reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n    /// [`Hash`]: ../../std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.get(&1), Some(&\"a\"));\n    /// assert_eq!(map.get(&2), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Returns the key-value pair corresponding to the supplied key.\n    ///\n    /// The supplied key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n    /// [`Hash`]: ../../std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\n    /// assert_eq!(map.get_key_value(&2), None);\n    /// ```\n    #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n    #[inline]\n    pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Returns `true` if the map contains a value for the specified key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n    /// [`Hash`]: ../../std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.contains_key(&1), true);\n    /// assert_eq!(map.contains_key(&2), false);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Returns a mutable reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n    /// [`Hash`]: ../../std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// if let Some(x) = map.get_mut(&1) {\n    ///     *x = \"b\";\n    /// }\n    /// assert_eq!(map[&1], \"b\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not have this key present, [`None`] is returned.\n    ///\n    /// If the map did have this key present, the value is updated, and the old\n    /// value is returned. The key is not updated, though; this matters for\n    /// types that can be `==` without being identical. See the [module-level\n    /// documentation] for more.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [module-level documentation]: index.html#insert-and-complex-keys\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// assert_eq!(map.insert(37, \"a\"), None);\n    /// assert_eq!(map.is_empty(), false);\n    ///\n    /// map.insert(37, \"b\");\n    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n    /// assert_eq!(map[&37], \"c\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n}\n\n    /// Removes a key from the map, returning the value at the key if the key\n    /// was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n    /// [`Hash`]: ../../std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.remove(&1), Some(\"a\"));\n    /// assert_eq!(map.remove(&1), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Removes a key from the map, returning the stored key and value if the\n    /// key was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the key type.\n    ///\n    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n    /// [`Hash`]: ../../std/hash/trait.Hash.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// # fn main() {\n    /// let mut map = HashMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.remove_entry(&1), Some((1, \"a\")));\n    /// assert_eq!(map.remove(&1), None);\n    /// # }\n    /// ```\n    #[stable(feature = \"hash_map_remove_entry\", since = \"1.27.0\")]\n    #[inline]\n    pub fn remove_entry<Q: ?Sized>(&mut self, k: &Q) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all pairs `(k, v)` such that `f(&k,&mut v)` returns `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<i32, i32> = (0..8).map(|x|(x, x*10)).collect();\n    /// map.retain(|&k, _| k % 2 == 0);\n    /// assert_eq!(map.len(), 4);\n    /// ```\n    #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n    #[inline]\n    pub fn retain<F>(&mut self, f: F)\n    where\n        F: FnMut(&K, &mut V) -> bool,\n    {\n}\n}\n\nimpl<K, V, S> HashMap<K, V, S>\nwhere\n    S: BuildHasher,\n{\n    /// Creates a raw entry builder for the HashMap.\n    ///\n    /// Raw entries provide the lowest level of control for searching and\n    /// manipulating a map. They must be manually initialized with a hash and\n    /// then manually searched. After this, insertions into a vacant entry\n    /// still require an owned key to be provided.\n    ///\n    /// Raw entries are useful for such exotic situations as:\n    ///\n    /// * Hash memoization\n    /// * Deferring the creation of an owned key until it is known to be required\n    /// * Using a search key that doesn't work with the Borrow trait\n    /// * Using custom comparison logic without newtype wrappers\n    ///\n    /// Because raw entries provide much more low-level control, it's much easier\n    /// to put the HashMap into an inconsistent state which, while memory-safe,\n    /// will cause the map to produce seemingly random results. Higher-level and\n    /// more foolproof APIs like `entry` should be preferred when possible.\n    ///\n    /// In particular, the hash used to initialized the raw entry must still be\n    /// consistent with the hash of the key that is ultimately stored in the entry.\n    /// This is because implementations of HashMap may need to recompute hashes\n    /// when resizing, at which point only the keys are available.\n    ///\n    /// Raw entries give mutable access to the keys. This must not be used\n    /// to modify how the key would compare or hash, as the map will not re-evaluate\n    /// where the key should go, meaning the keys may become \"lost\" if their\n    /// location does not reflect their state. For instance, if you change a key\n    /// so that the map now contains keys which compare equal, search may start\n    /// acting erratically, with two keys randomly masking each other. Implementations\n    /// are free to assume this doesn't happen (within the limits of memory-safety).\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<'_, K, V, S> {\n}\n\n    /// Creates a raw immutable entry builder for the HashMap.\n    ///\n    /// Raw entries provide the lowest level of control for searching and\n    /// manipulating a map. They must be manually initialized with a hash and\n    /// then manually searched.\n    ///\n    /// This is useful for\n    /// * Hash memoization\n    /// * Using a search key that doesn't work with the Borrow trait\n    /// * Using custom comparison logic without newtype wrappers\n    ///\n    /// Unless you are in such a situation, higher-level and more foolproof APIs like\n    /// `get` should be preferred.\n    ///\n    /// Immutable raw entries have very limited use; you might instead want `raw_entry_mut`.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn raw_entry(&self) -> RawEntryBuilder<'_, K, V, S> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> PartialEq for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    V: PartialEq,\n    S: BuildHasher,\n{\n    fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Eq for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Debug for HashMap<K, V, S>\nwhere\n    K: Eq + Hash + Debug,\n    V: Debug,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Default for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher + Default,\n{\n    /// Creates an empty `HashMap<K, V, S>`, with the `Default` value for the hasher.\n    #[inline]\n    fn default() -> HashMap<K, V, S> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, Q: ?Sized, V, S> Index<&Q> for HashMap<K, V, S>\nwhere\n    K: Eq + Hash + Borrow<Q>,\n    Q: Eq + Hash,\n    S: BuildHasher,\n{\n    type Output = V;\n\n    /// Returns a reference to the value corresponding to the supplied key.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the key is not present in the `HashMap`.\n    #[inline]\n    fn index(&self, key: &Q) -> &V {\n}\n}\n\n/// An iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`iter`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`iter`]: struct.HashMap.html#method.iter\n/// [`HashMap`]: struct.HashMap.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, K: 'a, V: 'a> {\n    base: base::Iter<'a, K, V>,\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Clone for Iter<'_, K, V> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: Debug, V: Debug> fmt::Debug for Iter<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A mutable iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`iter_mut`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`iter_mut`]: struct.HashMap.html#method.iter_mut\n/// [`HashMap`]: struct.HashMap.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IterMut<'a, K: 'a, V: 'a> {\n    base: base::IterMut<'a, K, V>,\n}\n\nimpl<'a, K, V> IterMut<'a, K, V> {\n    /// Returns a iterator of references over the remaining items.\n    #[inline]\n    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n}\n}\n\n/// An owning iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`HashMap`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`into_iter`]: struct.HashMap.html#method.into_iter\n/// [`HashMap`]: struct.HashMap.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<K, V> {\n    base: base::IntoIter<K, V>,\n}\n\nimpl<K, V> IntoIter<K, V> {\n    /// Returns a iterator of references over the remaining items.\n    #[inline]\n    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n}\n}\n\n/// An iterator over the keys of a `HashMap`.\n///\n/// This `struct` is created by the [`keys`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`keys`]: struct.HashMap.html#method.keys\n/// [`HashMap`]: struct.HashMap.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Keys<'a, K: 'a, V: 'a> {\n    inner: Iter<'a, K, V>,\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Clone for Keys<'_, K, V> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: Debug, V> fmt::Debug for Keys<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// An iterator over the values of a `HashMap`.\n///\n/// This `struct` is created by the [`values`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`values`]: struct.HashMap.html#method.values\n/// [`HashMap`]: struct.HashMap.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Values<'a, K: 'a, V: 'a> {\n    inner: Iter<'a, K, V>,\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Clone for Values<'_, K, V> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K, V: Debug> fmt::Debug for Values<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A draining iterator over the entries of a `HashMap`.\n///\n/// This `struct` is created by the [`drain`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`drain`]: struct.HashMap.html#method.drain\n/// [`HashMap`]: struct.HashMap.html\n#[stable(feature = \"drain\", since = \"1.6.0\")]\npub struct Drain<'a, K: 'a, V: 'a> {\n    base: base::Drain<'a, K, V>,\n}\n\nimpl<'a, K, V> Drain<'a, K, V> {\n    /// Returns a iterator of references over the remaining items.\n    #[inline]\n    pub(super) fn iter(&self) -> Iter<'_, K, V> {\n}\n}\n\n/// A mutable iterator over the values of a `HashMap`.\n///\n/// This `struct` is created by the [`values_mut`] method on [`HashMap`]. See its\n/// documentation for more.\n///\n/// [`values_mut`]: struct.HashMap.html#method.values_mut\n/// [`HashMap`]: struct.HashMap.html\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\npub struct ValuesMut<'a, K: 'a, V: 'a> {\n    inner: IterMut<'a, K, V>,\n}\n\n/// A builder for computing where in a HashMap a key-value pair would be stored.\n///\n/// See the [`HashMap::raw_entry_mut`] docs for usage examples.\n///\n/// [`HashMap::raw_entry_mut`]: struct.HashMap.html#method.raw_entry_mut\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n}\n\n/// A view into a single entry in a map, which may either be vacant or occupied.\n///\n/// This is a lower-level version of [`Entry`].\n///\n/// This `enum` is constructed through the [`raw_entry_mut`] method on [`HashMap`],\n/// then calling one of the methods of that [`RawEntryBuilderMut`].\n///\n/// [`HashMap`]: struct.HashMap.html\n/// [`Entry`]: enum.Entry.html\n/// [`raw_entry_mut`]: struct.HashMap.html#method.raw_entry_mut\n/// [`RawEntryBuilderMut`]: struct.RawEntryBuilderMut.html\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n}\n\n/// A view into an occupied entry in a `HashMap`.\n/// It is part of the [`RawEntryMut`] enum.\n///\n/// [`RawEntryMut`]: enum.RawEntryMut.html\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n}\n\n/// A view into a vacant entry in a `HashMap`.\n/// It is part of the [`RawEntryMut`] enum.\n///\n/// [`RawEntryMut`]: enum.RawEntryMut.html\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n}\n\n/// A builder for computing where in a HashMap a key-value pair would be stored.\n///\n/// See the [`HashMap::raw_entry`] docs for usage examples.\n///\n/// [`HashMap::raw_entry`]: struct.HashMap.html#method.raw_entry\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\npub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n}\n\nimpl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\nwhere\n    S: BuildHasher,\n{\n    /// Creates a `RawEntryMut` from the given key.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_key<Q: ?Sized>(self, k: &Q) -> RawEntryMut<'a, K, V, S>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Creates a `RawEntryMut` from the given key and its hash.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> RawEntryMut<'a, K, V, S>\n    where\n        K: Borrow<Q>,\n        Q: Eq,\n    {\n}\n\n    /// Creates a `RawEntryMut` from the given hash.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n    where\n        for<'b> F: FnMut(&'b K) -> bool,\n    {\n}\n}\n\nimpl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\nwhere\n    S: BuildHasher,\n{\n    /// Access an entry by key.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_key<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Access an entry by a key and its hash.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> Option<(&'a K, &'a V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Access an entry by hash.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n    where\n        F: FnMut(&K) -> bool,\n    {\n}\n}\n\nimpl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// mutable references to the key and value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_raw_entry)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 3);\n    /// assert_eq!(map[\"poneyland\"], 3);\n    ///\n    /// *map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 10).1 *= 2;\n    /// assert_eq!(map[\"poneyland\"], 6);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n}\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns mutable references to the key and value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_raw_entry)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, String> = HashMap::new();\n    ///\n    /// map.raw_entry_mut().from_key(\"poneyland\").or_insert_with(|| {\n    ///     (\"poneyland\", \"hoho\".to_string())\n    /// });\n    ///\n    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn or_insert_with<F>(self, default: F) -> (&'a mut K, &'a mut V)\n    where\n        F: FnOnce() -> (K, V),\n        K: Hash,\n        S: BuildHasher,\n    {\n}\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_raw_entry)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.raw_entry_mut()\n    ///    .from_key(\"poneyland\")\n    ///    .and_modify(|_k, v| { *v += 1 })\n    ///    .or_insert(\"poneyland\", 42);\n    /// assert_eq!(map[\"poneyland\"], 42);\n    ///\n    /// map.raw_entry_mut()\n    ///    .from_key(\"poneyland\")\n    ///    .and_modify(|_k, v| { *v += 1 })\n    ///    .or_insert(\"poneyland\", 0);\n    /// assert_eq!(map[\"poneyland\"], 43);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut K, &mut V),\n    {\n}\n}\n\nimpl<'a, K, V> RawOccupiedEntryMut<'a, K, V> {\n    /// Gets a reference to the key in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn key(&self) -> &K {\n}\n\n    /// Gets a mutable reference to the key in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn key_mut(&mut self) -> &mut K {\n}\n\n    /// Converts the entry into a mutable reference to the key in the entry\n    /// with a lifetime bound to the map itself.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn into_key(self) -> &'a mut K {\n}\n\n    /// Gets a reference to the value in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn get(&self) -> &V {\n}\n\n    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n    /// with a lifetime bound to the map itself.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn into_mut(self) -> &'a mut V {\n}\n\n    /// Gets a mutable reference to the value in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn get_mut(&mut self) -> &mut V {\n}\n\n    /// Gets a reference to the key and value in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn get_key_value(&mut self) -> (&K, &V) {\n}\n\n    /// Gets a mutable reference to the key and value in the entry.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn get_key_value_mut(&mut self) -> (&mut K, &mut V) {\n}\n\n    /// Converts the OccupiedEntry into a mutable reference to the key and value in the entry\n    /// with a lifetime bound to the map itself.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn into_key_value(self) -> (&'a mut K, &'a mut V) {\n}\n\n    /// Sets the value of the entry, and returns the entry's old value.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn insert(&mut self, value: V) -> V {\n}\n\n    /// Sets the value of the entry, and returns the entry's old value.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn insert_key(&mut self, key: K) -> K {\n}\n\n    /// Takes the value out of the entry, and returns it.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn remove(self) -> V {\n}\n\n    /// Take the ownership of the key and value from the map.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn remove_entry(self) -> (K, V) {\n}\n}\n\nimpl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n    /// Sets the value of the entry with the VacantEntry's key,\n    /// and returns a mutable reference to it.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n}\n\n    /// Sets the value of the entry with the VacantEntry's key,\n    /// and returns a mutable reference to it.\n    #[inline]\n    #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n    pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V)\n    where\n        K: Hash,\n        S: BuildHasher,\n    {\n}\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K, V, S> Debug for RawEntryBuilderMut<'_, K, V, S> {\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K: Debug, V: Debug, S> Debug for RawEntryMut<'_, K, V, S> {\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K: Debug, V: Debug> Debug for RawOccupiedEntryMut<'_, K, V> {\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K, V, S> Debug for RawVacantEntryMut<'_, K, V, S> {\n}\n\n#[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\nimpl<K, V, S> Debug for RawEntryBuilder<'_, K, V, S> {\n}\n\n/// A view into a single entry in a map, which may either be vacant or occupied.\n///\n/// This `enum` is constructed from the [`entry`] method on [`HashMap`].\n///\n/// [`HashMap`]: struct.HashMap.html\n/// [`entry`]: struct.HashMap.html#method.entry\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Entry<'a, K: 'a, V: 'a> {\n    /// An occupied entry.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n\n    /// A vacant entry.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n}\n\n#[stable(feature = \"debug_hash_map\", since = \"1.12.0\")]\nimpl<K: Debug, V: Debug> Debug for Entry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A view into an occupied entry in a `HashMap`.\n/// It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n    base: base::RustcOccupiedEntry<'a, K, V>,\n}\n\n#[stable(feature = \"debug_hash_map\", since = \"1.12.0\")]\nimpl<K: Debug, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A view into a vacant entry in a `HashMap`.\n/// It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct VacantEntry<'a, K: 'a, V: 'a> {\n    base: base::RustcVacantEntry<'a, K, V>,\n}\n\n#[stable(feature = \"debug_hash_map\", since = \"1.12.0\")]\nimpl<K: Debug, V> Debug for VacantEntry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S> {\n    type Item = (&'a K, &'a V);\n    type IntoIter = Iter<'a, K, V>;\n\n    #[inline]\n    fn into_iter(self) -> Iter<'a, K, V> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S> {\n    type Item = (&'a K, &'a mut V);\n    type IntoIter = IterMut<'a, K, V>;\n\n    #[inline]\n    fn into_iter(self) -> IterMut<'a, K, V> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> IntoIterator for HashMap<K, V, S> {\n    type Item = (K, V);\n    type IntoIter = IntoIter<K, V>;\n\n    /// Creates a consuming iterator, that is, one that moves each key-value\n    /// pair out of the map in arbitrary order. The map cannot be used after\n    /// calling this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// // Not possible with .iter()\n    /// let vec: Vec<(&str, i32)> = map.into_iter().collect();\n    /// ```\n    #[inline]\n    fn into_iter(self) -> IntoIter<K, V> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for Iter<'a, K, V> {\n    type Item = (&'a K, &'a V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for Iter<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Iter<'_, K, V> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for IterMut<'a, K, V> {\n    type Item = (&'a K, &'a mut V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for IterMut<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n}\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for IterMut<'_, K, V> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K, V> fmt::Debug for IterMut<'_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Iterator for IntoIter<K, V> {\n    type Item = (K, V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(K, V)> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for IntoIter<K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n}\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for IntoIter<K, V> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: Debug, V: Debug> fmt::Debug for IntoIter<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for Keys<'a, K, V> {\n    type Item = &'a K;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a K> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for Keys<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n}\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Keys<'_, K, V> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for Values<'a, K, V> {\n    type Item = &'a V;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a V> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for Values<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n}\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Values<'_, K, V> {}\n\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\nimpl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n    type Item = &'a mut V;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut V> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\nimpl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n}\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K, V> fmt::Debug for ValuesMut<'_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<'a, K, V> Iterator for Drain<'a, K, V> {\n    type Item = (K, V);\n\n    #[inline]\n    fn next(&mut self) -> Option<(K, V)> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<K, V> ExactSizeIterator for Drain<'_, K, V> {\n    #[inline]\n    fn len(&self) -> usize {\n}\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Drain<'_, K, V> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K, V> fmt::Debug for Drain<'_, K, V>\nwhere\n    K: fmt::Debug,\n    V: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<'a, K, V> Entry<'a, K, V> {\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.entry(\"poneyland\").or_insert(3);\n    /// assert_eq!(map[\"poneyland\"], 3);\n    ///\n    /// *map.entry(\"poneyland\").or_insert(10) *= 2;\n    /// assert_eq!(map[\"poneyland\"], 6);\n    /// ```\n    #[inline]\n    pub fn or_insert(self, default: V) -> &'a mut V {\n}\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, String> = HashMap::new();\n    /// let s = \"hoho\".to_string();\n    ///\n    /// map.entry(\"poneyland\").or_insert_with(|| s);\n    ///\n    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n    /// ```\n    #[inline]\n    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n}\n\n    /// Returns a reference to this entry's key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n    pub fn key(&self) -> &K {\n}\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// map.entry(\"poneyland\")\n    ///    .and_modify(|e| { *e += 1 })\n    ///    .or_insert(42);\n    /// assert_eq!(map[\"poneyland\"], 42);\n    ///\n    /// map.entry(\"poneyland\")\n    ///    .and_modify(|e| { *e += 1 })\n    ///    .or_insert(42);\n    /// assert_eq!(map[\"poneyland\"], 43);\n    /// ```\n    #[inline]\n    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),\n    {\n}\n\n    /// Sets the value of the entry, and returns an OccupiedEntry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(entry_insert)]\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, String> = HashMap::new();\n    /// let entry = map.entry(\"poneyland\").insert(\"hoho\".to_string());\n    ///\n    /// assert_eq!(entry.key(), &\"poneyland\");\n    /// ```\n    #[inline]\n    #[unstable(feature = \"entry_insert\", issue = \"65225\")]\n    pub fn insert(self, value: V) -> OccupiedEntry<'a, K, V> {\n}\n}\n\nimpl<'a, K, V: Default> Entry<'a, K, V> {\n    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n    /// Ensures a value is in the entry by inserting the default value if empty,\n    /// and returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # fn main() {\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, Option<u32>> = HashMap::new();\n    /// map.entry(\"poneyland\").or_default();\n    ///\n    /// assert_eq!(map[\"poneyland\"], None);\n    /// # }\n    /// ```\n    #[inline]\n    pub fn or_default(self) -> &'a mut V {\n}\n}\n\nimpl<'a, K, V> OccupiedEntry<'a, K, V> {\n    /// Gets a reference to the key in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n    pub fn key(&self) -> &K {\n}\n\n    /// Take the ownership of the key and value from the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     // We delete the entry from the map.\n    ///     o.remove_entry();\n    /// }\n    ///\n    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n    pub fn remove_entry(self) -> (K, V) {\n}\n\n    /// Gets a reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     assert_eq!(o.get(), &12);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get(&self) -> &V {\n}\n\n    /// Gets a mutable reference to the value in the entry.\n    ///\n    /// If you need a reference to the `OccupiedEntry` which may outlive the\n    /// destruction of the `Entry` value, see [`into_mut`].\n    ///\n    /// [`into_mut`]: #method.into_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// assert_eq!(map[\"poneyland\"], 12);\n    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n    ///     *o.get_mut() += 10;\n    ///     assert_eq!(*o.get(), 22);\n    ///\n    ///     // We can use the same Entry multiple times.\n    ///     *o.get_mut() += 2;\n    /// }\n    ///\n    /// assert_eq!(map[\"poneyland\"], 24);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut V {\n}\n\n    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n    /// with a lifetime bound to the map itself.\n    ///\n    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n    ///\n    /// [`get_mut`]: #method.get_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// assert_eq!(map[\"poneyland\"], 12);\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     *o.into_mut() += 10;\n    /// }\n    ///\n    /// assert_eq!(map[\"poneyland\"], 22);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_mut(self) -> &'a mut V {\n}\n\n    /// Sets the value of the entry, and returns the entry's old value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n    ///     assert_eq!(o.insert(15), 12);\n    /// }\n    ///\n    /// assert_eq!(map[\"poneyland\"], 15);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, value: V) -> V {\n}\n\n    /// Takes the value out of the entry, and returns it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     assert_eq!(o.remove(), 12);\n    /// }\n    ///\n    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove(self) -> V {\n}\n\n    /// Replaces the entry, returning the old key and value. The new key in the hash map will be\n    /// the key used to create this entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(map_entry_replace)]\n    /// use std::collections::hash_map::{Entry, HashMap};\n    /// use std::rc::Rc;\n    ///\n    /// let mut map: HashMap<Rc<String>, u32> = HashMap::new();\n    /// map.insert(Rc::new(\"Stringthing\".to_string()), 15);\n    ///\n    /// let my_key = Rc::new(\"Stringthing\".to_string());\n    ///\n    /// if let Entry::Occupied(entry) = map.entry(my_key) {\n    ///     // Also replace the key with a handle to our other key.\n    ///     let (old_key, old_value): (Rc<String>, u32) = entry.replace_entry(16);\n    /// }\n    ///\n    /// ```\n    #[inline]\n    #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n    pub fn replace_entry(self, value: V) -> (K, V) {\n}\n\n    /// Replaces the key in the hash map with the key used to create this entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(map_entry_replace)]\n    /// use std::collections::hash_map::{Entry, HashMap};\n    /// use std::rc::Rc;\n    ///\n    /// let mut map: HashMap<Rc<String>, u32> = HashMap::new();\n    /// let mut known_strings: Vec<Rc<String>> = Vec::new();\n    ///\n    /// // Initialise known strings, run program, etc.\n    ///\n    /// reclaim_memory(&mut map, &known_strings);\n    ///\n    /// fn reclaim_memory(map: &mut HashMap<Rc<String>, u32>, known_strings: &[Rc<String>] ) {\n    ///     for s in known_strings {\n    ///         if let Entry::Occupied(entry) = map.entry(s.clone()) {\n    ///             // Replaces the entry's key with our version of it in `known_strings`.\n    ///             entry.replace_key();\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n    pub fn replace_key(self) -> K {\n}\n}\n\nimpl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n    /// Gets a reference to the key that would be used when inserting a value\n    /// through the `VacantEntry`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n    pub fn key(&self) -> &K {\n}\n\n    /// Take ownership of the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n    ///     v.into_key();\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n    pub fn into_key(self) -> K {\n}\n\n    /// Sets the value of the entry with the VacantEntry's key,\n    /// and returns a mutable reference to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n    ///     o.insert(37);\n    /// }\n    /// assert_eq!(map[\"poneyland\"], 37);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(self, value: V) -> &'a mut V {\n}\n\n    /// Sets the value of the entry with the VacantEntry's key,\n    /// and returns an OccupiedEntry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashMap;\n    /// use std::collections::hash_map::Entry;\n    ///\n    /// let mut map: HashMap<&str, u32> = HashMap::new();\n    ///\n    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n    ///     o.insert(37);\n    /// }\n    /// assert_eq!(map[\"poneyland\"], 37);\n    /// ```\n    #[inline]\n    fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher + Default,\n{\n    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> HashMap<K, V, S> {\n}\n}\n\n/// Inserts all new key-values from the iterator and replaces values with existing\n/// keys with new values returned from the iterator.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\nwhere\n    K: Eq + Hash,\n    S: BuildHasher,\n{\n    #[inline]\n    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n}\n}\n\n#[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\nimpl<'a, K, V, S> Extend<(&'a K, &'a V)> for HashMap<K, V, S>\nwhere\n    K: Eq + Hash + Copy,\n    V: Copy,\n    S: BuildHasher,\n{\n    #[inline]\n    fn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T) {\n}\n}\n\n/// `RandomState` is the default state for [`HashMap`] types.\n///\n/// A particular instance `RandomState` will create the same instances of\n/// [`Hasher`], but the hashers created by two different `RandomState`\n/// instances are unlikely to produce the same result for the same values.\n///\n/// [`HashMap`]: struct.HashMap.html\n/// [`Hasher`]: ../../hash/trait.Hasher.html\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashMap;\n/// use std::collections::hash_map::RandomState;\n///\n/// let s = RandomState::new();\n/// let mut map = HashMap::with_hasher(s);\n/// map.insert(1, 2);\n/// ```\n#[derive(Clone)]\n#[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\npub struct RandomState {\n    k0: u64,\n    k1: u64,\n}\n\nimpl RandomState {\n    /// Constructs a new `RandomState` that is initialized with random keys.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// ```\n    #[inline]\n    #[allow(deprecated)]\n    // rand\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn new() -> RandomState {\n}\n}\n\n#[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\nimpl BuildHasher for RandomState {\n    type Hasher = DefaultHasher;\n    #[inline]\n    #[allow(deprecated)]\n    fn build_hasher(&self) -> DefaultHasher {\n}\n}\n\n/// The default [`Hasher`] used by [`RandomState`].\n///\n/// The internal algorithm is not specified, and so it and its hashes should\n/// not be relied upon over releases.\n///\n/// [`RandomState`]: struct.RandomState.html\n/// [`Hasher`]: ../../hash/trait.Hasher.html\n#[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n#[allow(deprecated)]\n#[derive(Clone, Debug)]\npub struct DefaultHasher(SipHasher13);\n\nimpl DefaultHasher {\n    /// Creates a new `DefaultHasher`.\n    ///\n    /// This hasher is not guaranteed to be the same as all other\n    /// `DefaultHasher` instances, but is the same as all other `DefaultHasher`\n    /// instances created through `new` or `default`.\n    #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n    #[allow(deprecated)]\n    pub fn new() -> DefaultHasher {\n}\n}\n\n#[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\nimpl Default for DefaultHasher {\n    // FIXME: here should link `new` to [DefaultHasher::new], but it occurs intra-doc link\n    // resolution failure when re-exporting libstd items. When #56922 fixed,\n    // link `new` to [DefaultHasher::new] again.\n    /// Creates a new `DefaultHasher` using `new`.\n    /// See its documentation for more.\n    fn default() -> DefaultHasher {\n}\n}\n\n#[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\nimpl Hasher for DefaultHasher {\n    #[inline]\n    fn write(&mut self, msg: &[u8]) {\n}\n\n    #[inline]\n    fn finish(&self) -> u64 {\n}\n}\n\n#[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\nimpl Default for RandomState {\n    /// Constructs a new `RandomState`.\n    #[inline]\n    fn default() -> RandomState {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for RandomState {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[inline]\nfn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K, V> {\n}\n\n#[inline]\nfn map_collection_alloc_err(err: hashbrown::CollectionAllocErr) -> TryReserveError {\n}\n\n#[inline]\nfn map_raw_entry<'a, K: 'a, V: 'a, S: 'a>(\n    raw: base::RawEntryMut<'a, K, V, S>,\n) -> RawEntryMut<'a, K, V, S> {\n}\n\n#[allow(dead_code)]\nfn assert_covariance() {\n}\n\n#[cfg(test)]\nmod test_map {\n}\n}\npub mod set {\nuse crate::borrow::Borrow;\nuse crate::collections::TryReserveError;\nuse crate::fmt;\nuse crate::hash::{BuildHasher, Hash};\nuse crate::iter::{Chain, FromIterator, FusedIterator};\nuse crate::ops::{BitAnd, BitOr, BitXor, Sub};\n\nuse super::map::{self, HashMap, Keys, RandomState};\n\n// Future Optimization (FIXME!)\n// ============================\n//\n// Iteration over zero sized values is a noop. There is no need\n// for `bucket.val` in the case of HashSet. I suppose we would need HKT\n// to get rid of it properly.\n\n/// A hash set implemented as a `HashMap` where the value is `()`.\n///\n/// As with the [`HashMap`] type, a `HashSet` requires that the elements\n/// implement the [`Eq`] and [`Hash`] traits. This can frequently be achieved by\n/// using `#[derive(PartialEq, Eq, Hash)]`. If you implement these yourself,\n/// it is important that the following property holds:\n///\n/// ```text\n/// k1 == k2 -> hash(k1) == hash(k2)\n/// ```\n///\n/// In other words, if two keys are equal, their hashes must be equal.\n///\n///\n/// It is a logic error for an item to be modified in such a way that the\n/// item's hash, as determined by the [`Hash`] trait, or its equality, as\n/// determined by the [`Eq`] trait, changes while it is in the set. This is\n/// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or\n/// unsafe code.\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::HashSet;\n/// // Type inference lets us omit an explicit type signature (which\n/// // would be `HashSet<String>` in this example).\n/// let mut books = HashSet::new();\n///\n/// // Add some books.\n/// books.insert(\"A Dance With Dragons\".to_string());\n/// books.insert(\"To Kill a Mockingbird\".to_string());\n/// books.insert(\"The Odyssey\".to_string());\n/// books.insert(\"The Great Gatsby\".to_string());\n///\n/// // Check for a specific one.\n/// if !books.contains(\"The Winds of Winter\") {\n///     println!(\"We have {} books, but The Winds of Winter ain't one.\",\n///              books.len());\n/// }\n///\n/// // Remove a book.\n/// books.remove(\"The Odyssey\");\n///\n/// // Iterate over everything.\n/// for book in &books {\n///     println!(\"{}\", book);\n/// }\n/// ```\n///\n/// The easiest way to use `HashSet` with a custom type is to derive\n/// [`Eq`] and [`Hash`]. We must also derive [`PartialEq`], this will in the\n/// future be implied by [`Eq`].\n///\n/// ```\n/// use std::collections::HashSet;\n/// #[derive(Hash, Eq, PartialEq, Debug)]\n/// struct Viking {\n///     name: String,\n///     power: usize,\n/// }\n///\n/// let mut vikings = HashSet::new();\n///\n/// vikings.insert(Viking { name: \"Einar\".to_string(), power: 9 });\n/// vikings.insert(Viking { name: \"Einar\".to_string(), power: 9 });\n/// vikings.insert(Viking { name: \"Olaf\".to_string(), power: 4 });\n/// vikings.insert(Viking { name: \"Harald\".to_string(), power: 8 });\n///\n/// // Use derived implementation to print the vikings.\n/// for x in &vikings {\n///     println!(\"{:?}\", x);\n/// }\n/// ```\n///\n/// A `HashSet` with fixed list of elements can be initialized from an array:\n///\n/// ```\n/// use std::collections::HashSet;\n///\n/// let viking_names: HashSet<&'static str> =\n///     [ \"Einar\", \"Olaf\", \"Harald\" ].iter().cloned().collect();\n/// // use the values stored in the set\n/// ```\n///\n/// [`Cell`]: ../../std/cell/struct.Cell.html\n/// [`Eq`]: ../../std/cmp/trait.Eq.html\n/// [`Hash`]: ../../std/hash/trait.Hash.html\n/// [`HashMap`]: struct.HashMap.html\n/// [`PartialEq`]: ../../std/cmp/trait.PartialEq.html\n/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct HashSet<T, S = RandomState> {\n    map: HashMap<T, (), S>,\n}\n\nimpl<T: Hash + Eq> HashSet<T, RandomState> {\n    /// Creates an empty `HashSet`.\n    ///\n    /// The hash set is initially created with a capacity of 0, so it will not allocate until it\n    /// is first inserted into.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let set: HashSet<i32> = HashSet::new();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> HashSet<T, RandomState> {\n}\n\n    /// Creates an empty `HashSet` with the specified capacity.\n    ///\n    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let set: HashSet<i32> = HashSet::with_capacity(10);\n    /// assert!(set.capacity() >= 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> {\n}\n}\n\nimpl<T, S> HashSet<T, S> {\n    /// Returns the number of elements the set can hold without reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let set: HashSet<i32> = HashSet::with_capacity(100);\n    /// assert!(set.capacity() >= 100);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n}\n\n    /// An iterator visiting all elements in arbitrary order.\n    /// The iterator element type is `&'a T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let mut set = HashSet::new();\n    /// set.insert(\"a\");\n    /// set.insert(\"b\");\n    ///\n    /// // Will print in an arbitrary order.\n    /// for x in set.iter() {\n    ///     println!(\"{}\", x);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, T> {\n}\n\n    /// Returns the number of elements in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// assert_eq!(v.len(), 0);\n    /// v.insert(1);\n    /// assert_eq!(v.len(), 1);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n}\n\n    /// Returns `true` if the set contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// assert!(v.is_empty());\n    /// v.insert(1);\n    /// assert!(!v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n}\n\n    /// Clears the set, returning all elements in an iterator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert!(!set.is_empty());\n    ///\n    /// // print 1, 2, 3 in an arbitrary order\n    /// for i in set.drain() {\n    ///     println!(\"{}\", i);\n    /// }\n    ///\n    /// assert!(set.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain(&mut self) -> Drain<'_, T> {\n}\n\n    /// Clears the set, removing all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut v = HashSet::new();\n    /// v.insert(1);\n    /// v.clear();\n    /// assert!(v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n}\n}\n\nimpl<T, S> HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    /// Creates a new empty hash set which will use the given hasher to hash\n    /// keys.\n    ///\n    /// The hash set is also created with the default initial capacity.\n    ///\n    /// Warning: `hasher` is normally randomly generated, and\n    /// is designed to allow `HashSet`s to be resistant to attacks that\n    /// cause many collisions and very poor performance. Setting it\n    /// manually using this function can expose a DoS attack vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mut set = HashSet::with_hasher(s);\n    /// set.insert(2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn with_hasher(hasher: S) -> HashSet<T, S> {\n}\n\n    /// Creates an empty `HashSet` with the specified capacity, using\n    /// `hasher` to hash the keys.\n    ///\n    /// The hash set will be able to hold at least `capacity` elements without\n    /// reallocating. If `capacity` is 0, the hash set will not allocate.\n    ///\n    /// Warning: `hasher` is normally randomly generated, and\n    /// is designed to allow `HashSet`s to be resistant to attacks that\n    /// cause many collisions and very poor performance. Setting it\n    /// manually using this function can expose a DoS attack vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let s = RandomState::new();\n    /// let mut set = HashSet::with_capacity_and_hasher(10, s);\n    /// set.insert(1);\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n    pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {\n}\n\n    /// Returns a reference to the set's [`BuildHasher`].\n    ///\n    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// use std::collections::hash_map::RandomState;\n    ///\n    /// let hasher = RandomState::new();\n    /// let set: HashSet<i32> = HashSet::with_hasher(hasher);\n    /// let hasher: &RandomState = set.hasher();\n    /// ```\n    #[inline]\n    #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n    pub fn hasher(&self) -> &S {\n}\n\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the `HashSet`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new allocation size overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let mut set: HashSet<i32> = HashSet::new();\n    /// set.reserve(10);\n    /// assert!(set.capacity() >= 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n}\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `HashSet<K,V>`. The collection may reserve more space to avoid\n    /// frequent reallocations.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_reserve)]\n    /// use std::collections::HashSet;\n    /// let mut set: HashSet<i32> = HashSet::new();\n    /// set.try_reserve(10).expect(\"why is the test harness OOMing on 10 bytes?\");\n    /// ```\n    #[inline]\n    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n}\n\n    /// Shrinks the capacity of the set as much as possible. It will drop\n    /// down as much as possible while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::with_capacity(100);\n    /// set.insert(1);\n    /// set.insert(2);\n    /// assert!(set.capacity() >= 100);\n    /// set.shrink_to_fit();\n    /// assert!(set.capacity() >= 2);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n}\n\n    /// Shrinks the capacity of the set with a lower limit. It will drop\n    /// down no lower than the supplied limit while maintaining the internal rules\n    /// and possibly leaving some space in accordance with the resize policy.\n    ///\n    /// Panics if the current capacity is smaller than the supplied\n    /// minimum capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(shrink_to)]\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::with_capacity(100);\n    /// set.insert(1);\n    /// set.insert(2);\n    /// assert!(set.capacity() >= 100);\n    /// set.shrink_to(10);\n    /// assert!(set.capacity() >= 10);\n    /// set.shrink_to(0);\n    /// assert!(set.capacity() >= 2);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n}\n\n    /// Visits the values representing the difference,\n    /// i.e., the values that are in `self` but not in `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// // Can be seen as `a - b`.\n    /// for x in a.difference(&b) {\n    ///     println!(\"{}\", x); // Print 1\n    /// }\n    ///\n    /// let diff: HashSet<_> = a.difference(&b).collect();\n    /// assert_eq!(diff, [1].iter().collect());\n    ///\n    /// // Note that difference is not symmetric,\n    /// // and `b - a` means something else:\n    /// let diff: HashSet<_> = b.difference(&a).collect();\n    /// assert_eq!(diff, [4].iter().collect());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n}\n\n    /// Visits the values representing the symmetric difference,\n    /// i.e., the values that are in `self` or in `other` but not in both.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// // Print 1, 4 in arbitrary order.\n    /// for x in a.symmetric_difference(&b) {\n    ///     println!(\"{}\", x);\n    /// }\n    ///\n    /// let diff1: HashSet<_> = a.symmetric_difference(&b).collect();\n    /// let diff2: HashSet<_> = b.symmetric_difference(&a).collect();\n    ///\n    /// assert_eq!(diff1, diff2);\n    /// assert_eq!(diff1, [1, 4].iter().collect());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn symmetric_difference<'a>(\n        &'a self,\n        other: &'a HashSet<T, S>,\n    ) -> SymmetricDifference<'a, T, S> {\n}\n\n    /// Visits the values representing the intersection,\n    /// i.e., the values that are both in `self` and `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// // Print 2, 3 in arbitrary order.\n    /// for x in a.intersection(&b) {\n    ///     println!(\"{}\", x);\n    /// }\n    ///\n    /// let intersection: HashSet<_> = a.intersection(&b).collect();\n    /// assert_eq!(intersection, [2, 3].iter().collect());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n}\n\n    /// Visits the values representing the union,\n    /// i.e., all the values in `self` or `other`, without duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// // Print 1, 2, 3, 4 in arbitrary order.\n    /// for x in a.union(&b) {\n    ///     println!(\"{}\", x);\n    /// }\n    ///\n    /// let union: HashSet<_> = a.union(&b).collect();\n    /// assert_eq!(union, [1, 2, 3, 4].iter().collect());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n}\n\n    /// Returns `true` if the set contains a value.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.contains(&1), true);\n    /// assert_eq!(set.contains(&4), false);\n    /// ```\n    ///\n    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n    /// [`Hash`]: ../../std/hash/trait.Hash.html\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Returns a reference to the value in the set, if any, that is equal to the given value.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.get(&2), Some(&2));\n    /// assert_eq!(set.get(&4), None);\n    /// ```\n    ///\n    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n    /// [`Hash`]: ../../std/hash/trait.Hash.html\n    #[inline]\n    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Inserts the given `value` into the set if it is not present, then\n    /// returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_set_entry)]\n    ///\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.len(), 3);\n    /// assert_eq!(set.get_or_insert(2), &2);\n    /// assert_eq!(set.get_or_insert(100), &100);\n    /// assert_eq!(set.len(), 4); // 100 was inserted\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n    pub fn get_or_insert(&mut self, value: T) -> &T {\n}\n\n    /// Inserts an owned copy of the given `value` into the set if it is not\n    /// present, then returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_set_entry)]\n    ///\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<String> = [\"cat\", \"dog\", \"horse\"]\n    ///     .iter().map(|&pet| pet.to_owned()).collect();\n    ///\n    /// assert_eq!(set.len(), 3);\n    /// for &pet in &[\"cat\", \"dog\", \"fish\"] {\n    ///     let value = set.get_or_insert_owned(pet);\n    ///     assert_eq!(value, pet);\n    /// }\n    /// assert_eq!(set.len(), 4); // a new \"fish\" was inserted\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n    pub fn get_or_insert_owned<Q: ?Sized>(&mut self, value: &Q) -> &T\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq + ToOwned<Owned = T>,\n    {\n}\n\n    /// Inserts a value computed from `f` into the set if the given `value` is\n    /// not present, then returns a reference to the value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(hash_set_entry)]\n    ///\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<String> = [\"cat\", \"dog\", \"horse\"]\n    ///     .iter().map(|&pet| pet.to_owned()).collect();\n    ///\n    /// assert_eq!(set.len(), 3);\n    /// for &pet in &[\"cat\", \"dog\", \"fish\"] {\n    ///     let value = set.get_or_insert_with(pet, str::to_owned);\n    ///     assert_eq!(value, pet);\n    /// }\n    /// assert_eq!(set.len(), 4); // a new \"fish\" was inserted\n    /// ```\n    #[inline]\n    #[unstable(feature = \"hash_set_entry\", issue = \"60896\")]\n    pub fn get_or_insert_with<Q: ?Sized, F>(&mut self, value: &Q, f: F) -> &T\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n        F: FnOnce(&Q) -> T,\n    {\n}\n\n    /// Returns `true` if `self` has no elements in common with `other`.\n    /// This is equivalent to checking for an empty intersection.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let mut b = HashSet::new();\n    ///\n    /// assert_eq!(a.is_disjoint(&b), true);\n    /// b.insert(4);\n    /// assert_eq!(a.is_disjoint(&b), true);\n    /// b.insert(1);\n    /// assert_eq!(a.is_disjoint(&b), false);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n}\n\n    /// Returns `true` if the set is a subset of another,\n    /// i.e., `other` contains at least all the values in `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let sup: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.is_subset(&sup), true);\n    /// set.insert(2);\n    /// assert_eq!(set.is_subset(&sup), true);\n    /// set.insert(4);\n    /// assert_eq!(set.is_subset(&sup), false);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {\n}\n\n    /// Returns `true` if the set is a superset of another,\n    /// i.e., `self` contains at least all the values in `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let sub: HashSet<_> = [1, 2].iter().cloned().collect();\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.is_superset(&sub), false);\n    ///\n    /// set.insert(0);\n    /// set.insert(1);\n    /// assert_eq!(set.is_superset(&sub), false);\n    ///\n    /// set.insert(2);\n    /// assert_eq!(set.is_superset(&sub), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {\n}\n\n    /// Adds a value to the set.\n    ///\n    /// If the set did not have this value present, `true` is returned.\n    ///\n    /// If the set did have this value present, `false` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    ///\n    /// assert_eq!(set.insert(2), true);\n    /// assert_eq!(set.insert(2), false);\n    /// assert_eq!(set.len(), 1);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, value: T) -> bool {\n}\n\n    /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n    /// one. Returns the replaced value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    /// set.insert(Vec::<i32>::new());\n    ///\n    /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 0);\n    /// set.replace(Vec::with_capacity(10));\n    /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n    pub fn replace(&mut self, value: T) -> Option<T> {\n}\n\n    /// Removes a value from the set. Returns whether the value was\n    /// present in the set.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set = HashSet::new();\n    ///\n    /// set.insert(2);\n    /// assert_eq!(set.remove(&2), true);\n    /// assert_eq!(set.remove(&2), false);\n    /// ```\n    ///\n    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n    /// [`Hash`]: ../../std/hash/trait.Hash.html\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Removes and returns the value in the set, if any, that is equal to the given one.\n    ///\n    /// The value may be any borrowed form of the set's value type, but\n    /// [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n    /// the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.take(&2), Some(2));\n    /// assert_eq!(set.take(&2), None);\n    /// ```\n    ///\n    /// [`Eq`]: ../../std/cmp/trait.Eq.html\n    /// [`Hash`]: ../../std/hash/trait.Hash.html\n    #[inline]\n    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n    where\n        T: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n}\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let xs = [1,2,3,4,5,6];\n    /// let mut set: HashSet<i32> = xs.iter().cloned().collect();\n    /// set.retain(|&k| k % 2 == 0);\n    /// assert_eq!(set.len(), 3);\n    /// ```\n    #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> bool,\n    {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> PartialEq for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    fn eq(&self, other: &HashSet<T, S>) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Eq for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> fmt::Debug for HashSet<T, S>\nwhere\n    T: Eq + Hash + fmt::Debug,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> FromIterator<T> for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher + Default,\n{\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> HashSet<T, S> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Extend<T> for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    #[inline]\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n}\n}\n\n#[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\nimpl<'a, T, S> Extend<&'a T> for HashSet<T, S>\nwhere\n    T: 'a + Eq + Hash + Copy,\n    S: BuildHasher,\n{\n    #[inline]\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Default for HashSet<T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher + Default,\n{\n    /// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\n    #[inline]\n    fn default() -> HashSet<T, S> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> BitOr<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the union of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let set = &a | &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2, 3, 4, 5];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> BitAnd<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n    ///\n    /// let set = &a & &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [2, 3];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitand(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> BitXor<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let set = &a ^ &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2, 4, 5];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn bitxor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Sub<&HashSet<T, S>> for &HashSet<T, S>\nwhere\n    T: Eq + Hash + Clone,\n    S: BuildHasher + Default,\n{\n    type Output = HashSet<T, S>;\n\n    /// Returns the difference of `self` and `rhs` as a new `HashSet<T, S>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    ///\n    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let set = &a - &b;\n    ///\n    /// let mut i = 0;\n    /// let expected = [1, 2];\n    /// for x in &set {\n    ///     assert!(expected.contains(x));\n    ///     i += 1;\n    /// }\n    /// assert_eq!(i, expected.len());\n    /// ```\n    fn sub(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n}\n}\n\n/// An iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`iter`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`iter`]: struct.HashSet.html#method.iter\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, K: 'a> {\n    iter: Keys<'a, K, ()>,\n}\n\n/// An owning iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`HashSet`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`into_iter`]: struct.HashSet.html#method.into_iter\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<K> {\n    iter: map::IntoIter<K, ()>,\n}\n\n/// A draining iterator over the items of a `HashSet`.\n///\n/// This `struct` is created by the [`drain`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`drain`]: struct.HashSet.html#method.drain\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Drain<'a, K: 'a> {\n    iter: map::Drain<'a, K, ()>,\n}\n\n/// A lazy iterator producing elements in the intersection of `HashSet`s.\n///\n/// This `struct` is created by the [`intersection`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`intersection`]: struct.HashSet.html#method.intersection\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Intersection<'a, T: 'a, S: 'a> {\n    // iterator of the first set\n    iter: Iter<'a, T>,\n    // the second set\n    other: &'a HashSet<T, S>,\n}\n\n/// A lazy iterator producing elements in the difference of `HashSet`s.\n///\n/// This `struct` is created by the [`difference`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`difference`]: struct.HashSet.html#method.difference\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Difference<'a, T: 'a, S: 'a> {\n    // iterator of the first set\n    iter: Iter<'a, T>,\n    // the second set\n    other: &'a HashSet<T, S>,\n}\n\n/// A lazy iterator producing elements in the symmetric difference of `HashSet`s.\n///\n/// This `struct` is created by the [`symmetric_difference`] method on\n/// [`HashSet`]. See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`symmetric_difference`]: struct.HashSet.html#method.symmetric_difference\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>,\n}\n\n/// A lazy iterator producing elements in the union of `HashSet`s.\n///\n/// This `struct` is created by the [`union`] method on [`HashSet`].\n/// See its documentation for more.\n///\n/// [`HashSet`]: struct.HashSet.html\n/// [`union`]: struct.HashSet.html#method.union\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Union<'a, T: 'a, S: 'a> {\n    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> IntoIterator for &'a HashSet<T, S> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    #[inline]\n    fn into_iter(self) -> Iter<'a, T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> IntoIterator for HashSet<T, S> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Creates a consuming iterator, that is, one that moves each value out\n    /// of the set in arbitrary order. The set cannot be used after calling\n    /// this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// let mut set = HashSet::new();\n    /// set.insert(\"a\".to_string());\n    /// set.insert(\"b\".to_string());\n    ///\n    /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n    /// let v: Vec<String> = set.into_iter().collect();\n    ///\n    /// // Will print in an arbitrary order.\n    /// for x in &v {\n    ///     println!(\"{}\", x);\n    /// }\n    /// ```\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> Clone for Iter<'_, K> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K> Iterator for Iter<'a, K> {\n    type Item = &'a K;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a K> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> ExactSizeIterator for Iter<'_, K> {\n    #[inline]\n    fn len(&self) -> usize {\n}\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K> FusedIterator for Iter<'_, K> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: fmt::Debug> fmt::Debug for Iter<'_, K> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> Iterator for IntoIter<K> {\n    type Item = K;\n\n    #[inline]\n    fn next(&mut self) -> Option<K> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> ExactSizeIterator for IntoIter<K> {\n    #[inline]\n    fn len(&self) -> usize {\n}\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K> FusedIterator for IntoIter<K> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: fmt::Debug> fmt::Debug for IntoIter<K> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K> Iterator for Drain<'a, K> {\n    type Item = K;\n\n    #[inline]\n    fn next(&mut self) -> Option<K> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K> ExactSizeIterator for Drain<'_, K> {\n    #[inline]\n    fn len(&self) -> usize {\n}\n}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K> FusedIterator for Drain<'_, K> {}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<K: fmt::Debug> fmt::Debug for Drain<'_, K> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for Intersection<'_, T, S> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> Iterator for Intersection<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T, S> fmt::Debug for Intersection<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, S> FusedIterator for Intersection<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for Difference<'_, T, S> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> Iterator for Difference<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, S> FusedIterator for Difference<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T, S> fmt::Debug for Difference<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for SymmetricDifference<'_, T, S> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, S> FusedIterator for SymmetricDifference<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T, S> fmt::Debug for SymmetricDifference<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, S> Clone for Union<'_, T, S> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, S> FusedIterator for Union<'_, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T, S> fmt::Debug for Union<'_, T, S>\nwhere\n    T: fmt::Debug + Eq + Hash,\n    S: BuildHasher,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, S> Iterator for Union<'a, T, S>\nwhere\n    T: Eq + Hash,\n    S: BuildHasher,\n{\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[allow(dead_code)]\nfn assert_covariance() {\n}\n\n#[cfg(test)]\nmod test_set {\n}\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod hash_map {\n    //! A hash map implemented with quadratic probing and SIMD lookup.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub use super::hash::map::*;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod hash_set {\n    //! A hash set implemented as a `HashMap` where the value is `()`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub use super::hash::set::*;\n}\n}\npub mod env {\n//! Inspection and manipulation of the process's environment.\n//!\n//! This module contains functions to inspect various aspects such as\n//! environment variables, process arguments, the current directory, and various\n//! other important directories.\n//!\n//! There are several functions and structs in this module that have a\n//! counterpart ending in `os`. Those ending in `os` will return an [`OsString`]\n//! and those without will return a [`String`].\n//!\n//! [`OsString`]: ../../std/ffi/struct.OsString.html\n//! [`String`]: ../string/struct.String.html\n\n#![stable(feature = \"env\", since = \"1.0.0\")]\n\nuse crate::error::Error;\nuse crate::ffi::{OsStr, OsString};\nuse crate::fmt;\nuse crate::io;\nuse crate::path::{Path, PathBuf};\nuse crate::sys;\nuse crate::sys::os as os_imp;\n\n/// Returns the current working directory as a [`PathBuf`].\n///\n/// # Errors\n///\n/// Returns an [`Err`] if the current working directory value is invalid.\n/// Possible cases:\n///\n/// * Current directory does not exist.\n/// * There are insufficient permissions to access the current directory.\n///\n/// [`PathBuf`]: ../../std/path/struct.PathBuf.html\n/// [`Err`]: ../../std/result/enum.Result.html#method.err\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// fn main() -> std::io::Result<()> {\n///     let path = env::current_dir()?;\n///     println!(\"The current directory is {}\", path.display());\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn current_dir() -> io::Result<PathBuf> {\n}\n\n/// Changes the current working directory to the specified path.\n///\n/// Returns an [`Err`] if the operation fails.\n///\n/// [`Err`]: ../../std/result/enum.Result.html#method.err\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n/// use std::path::Path;\n///\n/// let root = Path::new(\"/\");\n/// assert!(env::set_current_dir(&root).is_ok());\n/// println!(\"Successfully changed working directory to {}!\", root.display());\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn set_current_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n}\n\n/// An iterator over a snapshot of the environment variables of this process.\n///\n/// This structure is created by the [`std::env::vars`] function. See its\n/// documentation for more.\n///\n/// [`std::env::vars`]: fn.vars.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub struct Vars {\n    inner: VarsOs,\n}\n\n/// An iterator over a snapshot of the environment variables of this process.\n///\n/// This structure is created by the [`std::env::vars_os`] function. See\n/// its documentation for more.\n///\n/// [`std::env::vars_os`]: fn.vars_os.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub struct VarsOs {\n    inner: os_imp::Env,\n}\n\n/// Returns an iterator of (variable, value) pairs of strings, for all the\n/// environment variables of the current process.\n///\n/// The returned iterator contains a snapshot of the process's environment\n/// variables at the time of this invocation. Modifications to environment\n/// variables afterwards will not be reflected in the returned iterator.\n///\n/// # Panics\n///\n/// While iterating, the returned iterator will panic if any key or value in the\n/// environment is not valid unicode. If this is not desired, consider using the\n/// [`env::vars_os`] function.\n///\n/// [`env::vars_os`]: fn.vars_os.html\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// // We will iterate through the references to the element returned by\n/// // env::vars();\n/// for (key, value) in env::vars() {\n///     println!(\"{}: {}\", key, value);\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn vars() -> Vars {\n}\n\n/// Returns an iterator of (variable, value) pairs of OS strings, for all the\n/// environment variables of the current process.\n///\n/// The returned iterator contains a snapshot of the process's environment\n/// variables at the time of this invocation. Modifications to environment\n/// variables afterwards will not be reflected in the returned iterator.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// // We will iterate through the references to the element returned by\n/// // env::vars_os();\n/// for (key, value) in env::vars_os() {\n///     println!(\"{:?}: {:?}\", key, value);\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn vars_os() -> VarsOs {\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl Iterator for Vars {\n    type Item = (String, String);\n    fn next(&mut self) -> Option<(String, String)> {\n}\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Vars {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl Iterator for VarsOs {\n    type Item = (OsString, OsString);\n    fn next(&mut self) -> Option<(OsString, OsString)> {\n}\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for VarsOs {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// Fetches the environment variable `key` from the current process.\n///\n/// # Errors\n///\n/// * Environment variable is not present\n/// * Environment variable is not valid unicode\n///\n/// # Panics\n///\n/// This function may panic if `key` is empty, contains an ASCII equals sign\n/// `'='` or the NUL character `'\\0'`, or when the value contains the NUL\n/// character.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// let key = \"HOME\";\n/// match env::var(key) {\n///     Ok(val) => println!(\"{}: {:?}\", key, val),\n///     Err(e) => println!(\"couldn't interpret {}: {}\", key, e),\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn var<K: AsRef<OsStr>>(key: K) -> Result<String, VarError> {\n}\n\nfn _var(key: &OsStr) -> Result<String, VarError> {\n}\n\n/// Fetches the environment variable `key` from the current process, returning\n/// [`None`] if the variable isn't set.\n///\n/// [`None`]: ../option/enum.Option.html#variant.None\n///\n/// # Panics\n///\n/// This function may panic if `key` is empty, contains an ASCII equals sign\n/// `'='` or the NUL character `'\\0'`, or when the value contains the NUL\n/// character.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// let key = \"HOME\";\n/// match env::var_os(key) {\n///     Some(val) => println!(\"{}: {:?}\", key, val),\n///     None => println!(\"{} is not defined in the environment.\", key)\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn var_os<K: AsRef<OsStr>>(key: K) -> Option<OsString> {\n}\n\nfn _var_os(key: &OsStr) -> Option<OsString> {\n}\n\n/// The error type for operations interacting with environment variables.\n/// Possibly returned from the [`env::var`] function.\n///\n/// [`env::var`]: fn.var.html\n#[derive(Debug, PartialEq, Eq, Clone)]\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub enum VarError {\n    /// The specified environment variable was not present in the current\n    /// process's environment.\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    NotPresent,\n\n    /// The specified environment variable was found, but it did not contain\n    /// valid unicode data. The found data is returned as a payload of this\n    /// variant.\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    NotUnicode(#[stable(feature = \"env\", since = \"1.0.0\")] OsString),\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl fmt::Display for VarError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl Error for VarError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n}\n\n/// Sets the environment variable `k` to the value `v` for the currently running\n/// process.\n///\n/// Note that while concurrent access to environment variables is safe in Rust,\n/// some platforms only expose inherently unsafe non-threadsafe APIs for\n/// inspecting the environment. As a result, extra care needs to be taken when\n/// auditing calls to unsafe external FFI functions to ensure that any external\n/// environment accesses are properly synchronized with accesses in Rust.\n///\n/// Discussion of this unsafety on Unix may be found in:\n///\n///  - [Austin Group Bugzilla](http://austingroupbugs.net/view.php?id=188)\n///  - [GNU C library Bugzilla](https://sourceware.org/bugzilla/show_bug.cgi?id=15607#c2)\n///\n/// # Panics\n///\n/// This function may panic if `key` is empty, contains an ASCII equals sign\n/// `'='` or the NUL character `'\\0'`, or when the value contains the NUL\n/// character.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// let key = \"KEY\";\n/// env::set_var(key, \"VALUE\");\n/// assert_eq!(env::var(key), Ok(\"VALUE\".to_string()));\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn set_var<K: AsRef<OsStr>, V: AsRef<OsStr>>(k: K, v: V) {\n}\n\nfn _set_var(k: &OsStr, v: &OsStr) {\n}\n\n/// Removes an environment variable from the environment of the currently running process.\n///\n/// Note that while concurrent access to environment variables is safe in Rust,\n/// some platforms only expose inherently unsafe non-threadsafe APIs for\n/// inspecting the environment. As a result extra care needs to be taken when\n/// auditing calls to unsafe external FFI functions to ensure that any external\n/// environment accesses are properly synchronized with accesses in Rust.\n///\n/// Discussion of this unsafety on Unix may be found in:\n///\n///  - [Austin Group Bugzilla](http://austingroupbugs.net/view.php?id=188)\n///  - [GNU C library Bugzilla](https://sourceware.org/bugzilla/show_bug.cgi?id=15607#c2)\n///\n/// # Panics\n///\n/// This function may panic if `key` is empty, contains an ASCII equals sign\n/// `'='` or the NUL character `'\\0'`, or when the value contains the NUL\n/// character.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// let key = \"KEY\";\n/// env::set_var(key, \"VALUE\");\n/// assert_eq!(env::var(key), Ok(\"VALUE\".to_string()));\n///\n/// env::remove_var(key);\n/// assert!(env::var(key).is_err());\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn remove_var<K: AsRef<OsStr>>(k: K) {\n}\n\nfn _remove_var(k: &OsStr) {\n}\n\n/// An iterator that splits an environment variable into paths according to\n/// platform-specific conventions.\n///\n/// The iterator element type is [`PathBuf`].\n///\n/// This structure is created by the [`std::env::split_paths`] function. See its\n/// documentation for more.\n///\n/// [`PathBuf`]: ../../std/path/struct.PathBuf.html\n/// [`std::env::split_paths`]: fn.split_paths.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub struct SplitPaths<'a> {\n    inner: os_imp::SplitPaths<'a>,\n}\n\n/// Parses input according to platform conventions for the `PATH`\n/// environment variable.\n///\n/// Returns an iterator over the paths contained in `unparsed`. The iterator\n/// element type is [`PathBuf`].\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// let key = \"PATH\";\n/// match env::var_os(key) {\n///     Some(paths) => {\n///         for path in env::split_paths(&paths) {\n///             println!(\"'{}'\", path.display());\n///         }\n///     }\n///     None => println!(\"{} is not defined in the environment.\", key)\n/// }\n/// ```\n///\n/// [`PathBuf`]: ../../std/path/struct.PathBuf.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn split_paths<T: AsRef<OsStr> + ?Sized>(unparsed: &T) -> SplitPaths<'_> {\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl<'a> Iterator for SplitPaths<'a> {\n    type Item = PathBuf;\n    fn next(&mut self) -> Option<PathBuf> {\n}\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for SplitPaths<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// The error type for operations on the `PATH` variable. Possibly returned from\n/// the [`env::join_paths`] function.\n///\n/// [`env::join_paths`]: fn.join_paths.html\n#[derive(Debug)]\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub struct JoinPathsError {\n    inner: os_imp::JoinPathsError,\n}\n\n/// Joins a collection of [`Path`]s appropriately for the `PATH`\n/// environment variable.\n///\n/// # Errors\n///\n/// Returns an [`Err`][err] (containing an error message) if one of the input\n/// [`Path`]s contains an invalid character for constructing the `PATH`\n/// variable (a double quote on Windows or a colon on Unix).\n///\n/// [`Path`]: ../../std/path/struct.Path.html\n/// [`OsString`]: ../../std/ffi/struct.OsString.html\n/// [err]: ../../std/result/enum.Result.html#variant.Err\n///\n/// # Examples\n///\n/// Joining paths on a Unix-like platform:\n///\n/// ```\n/// use std::env;\n/// use std::ffi::OsString;\n/// use std::path::Path;\n///\n/// fn main() -> Result<(), env::JoinPathsError> {\n/// # if cfg!(unix) {\n///     let paths = [Path::new(\"/bin\"), Path::new(\"/usr/bin\")];\n///     let path_os_string = env::join_paths(paths.iter())?;\n///     assert_eq!(path_os_string, OsString::from(\"/bin:/usr/bin\"));\n/// # }\n///     Ok(())\n/// }\n/// ```\n///\n/// Joining a path containing a colon on a Unix-like platform results in an error:\n///\n/// ```\n/// # if cfg!(unix) {\n/// use std::env;\n/// use std::path::Path;\n///\n/// let paths = [Path::new(\"/bin\"), Path::new(\"/usr/bi:n\")];\n/// assert!(env::join_paths(paths.iter()).is_err());\n/// # }\n/// ```\n///\n/// Using `env::join_paths` with [`env::split_paths`] to append an item to the `PATH` environment\n/// variable:\n///\n/// ```\n/// use std::env;\n/// use std::path::PathBuf;\n///\n/// fn main() -> Result<(), env::JoinPathsError> {\n///     if let Some(path) = env::var_os(\"PATH\") {\n///         let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n///         paths.push(PathBuf::from(\"/home/xyz/bin\"));\n///         let new_path = env::join_paths(paths)?;\n///         env::set_var(\"PATH\", &new_path);\n///     }\n///\n///     Ok(())\n/// }\n/// ```\n///\n/// [`env::split_paths`]: fn.split_paths.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\nwhere\n    I: IntoIterator<Item = T>,\n    T: AsRef<OsStr>,\n{\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl fmt::Display for JoinPathsError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl Error for JoinPathsError {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n}\n}\n\n/// Returns the path of the current user's home directory if known.\n///\n/// # Unix\n///\n/// - Returns the value of the 'HOME' environment variable if it is set\n///   (including to an empty string).\n/// - Otherwise, it tries to determine the home directory by invoking the `getpwuid_r` function\n///   using the UID of the current user. An empty home directory field returned from the\n///   `getpwuid_r` function is considered to be a valid value.\n/// - Returns `None` if the current user has no entry in the /etc/passwd file.\n///\n/// # Windows\n///\n/// - Returns the value of the 'HOME' environment variable if it is set\n///   (including to an empty string).\n/// - Otherwise, returns the value of the 'USERPROFILE' environment variable if it is set\n///   (including to an empty string).\n/// - If both do not exist, [`GetUserProfileDirectory`][msdn] is used to return the path.\n///\n/// [msdn]: https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// match env::home_dir() {\n///     Some(path) => println!(\"Your home directory, probably: {}\", path.display()),\n///     None => println!(\"Impossible to get your home dir!\"),\n/// }\n/// ```\n#[rustc_deprecated(\n    since = \"1.29.0\",\n    reason = \"This function's behavior is unexpected and probably not what you want. \\\n              Consider using the home_dir function from https://crates.io/crates/dirs instead.\"\n)]\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn home_dir() -> Option<PathBuf> {\n}\n\n/// Returns the path of a temporary directory.\n///\n/// # Unix\n///\n/// Returns the value of the `TMPDIR` environment variable if it is\n/// set, otherwise for non-Android it returns `/tmp`. If Android, since there\n/// is no global temporary folder (it is usually allocated per-app), it returns\n/// `/data/local/tmp`.\n///\n/// # Windows\n///\n/// Returns the value of, in order, the `TMP`, `TEMP`,\n/// `USERPROFILE` environment variable if any are set and not the empty\n/// string. Otherwise, `temp_dir` returns the path of the Windows directory.\n/// This behavior is identical to that of [`GetTempPath`][msdn], which this\n/// function uses internally.\n///\n/// [msdn]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-gettemppatha\n///\n/// ```no_run\n/// use std::env;\n/// use std::fs::File;\n///\n/// fn main() -> std::io::Result<()> {\n///     let mut dir = env::temp_dir();\n///     dir.push(\"foo.txt\");\n///\n///     let f = File::create(dir)?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn temp_dir() -> PathBuf {\n}\n\n/// Returns the full filesystem path of the current running executable.\n///\n/// # Platform-specific behavior\n///\n/// If the executable was invoked through a symbolic link, some platforms will\n/// return the path of the symbolic link and other platforms will return the\n/// path of the symbolic link’s target.\n///\n/// # Errors\n///\n/// Acquiring the path of the current executable is a platform-specific operation\n/// that can fail for a good number of reasons. Some errors can include, but not\n/// be limited to, filesystem operations failing or general syscall failures.\n///\n/// # Security\n///\n/// The output of this function should not be used in anything that might have\n/// security implications. For example:\n///\n/// ```\n/// fn main() {\n///     println!(\"{:?}\", std::env::current_exe());\n/// }\n/// ```\n///\n/// On Linux systems, if this is compiled as `foo`:\n///\n/// ```bash\n/// $ rustc foo.rs\n/// $ ./foo\n/// Ok(\"/home/alex/foo\")\n/// ```\n///\n/// And you make a hard link of the program:\n///\n/// ```bash\n/// $ ln foo bar\n/// ```\n///\n/// When you run it, you won’t get the path of the original executable, you’ll\n/// get the path of the hard link:\n///\n/// ```bash\n/// $ ./bar\n/// Ok(\"/home/alex/bar\")\n/// ```\n///\n/// This sort of behavior has been known to [lead to privilege escalation] when\n/// used incorrectly.\n///\n/// [lead to privilege escalation]: https://securityvulns.com/Wdocument183.html\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// match env::current_exe() {\n///     Ok(exe_path) => println!(\"Path of this executable is: {}\",\n///                              exe_path.display()),\n///     Err(e) => println!(\"failed to get current exe path: {}\", e),\n/// };\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn current_exe() -> io::Result<PathBuf> {\n}\n\n/// An iterator over the arguments of a process, yielding a [`String`] value for\n/// each argument.\n///\n/// This struct is created by the [`std::env::args`] function. See its\n/// documentation for more.\n///\n/// The first element is traditionally the path of the executable, but it can be\n/// set to arbitrary text, and may not even exist. This means this property\n/// should not be relied upon for security purposes.\n///\n/// [`String`]: ../string/struct.String.html\n/// [`std::env::args`]: ./fn.args.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub struct Args {\n    inner: ArgsOs,\n}\n\n/// An iterator over the arguments of a process, yielding an [`OsString`] value\n/// for each argument.\n///\n/// This struct is created by the [`std::env::args_os`] function. See its\n/// documentation for more.\n///\n/// The first element is traditionally the path of the executable, but it can be\n/// set to arbitrary text, and may not even exist. This means this property\n/// should not be relied upon for security purposes.\n///\n/// [`OsString`]: ../ffi/struct.OsString.html\n/// [`std::env::args_os`]: ./fn.args_os.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub struct ArgsOs {\n    inner: sys::args::Args,\n}\n\n/// Returns the arguments which this program was started with (normally passed\n/// via the command line).\n///\n/// The first element is traditionally the path of the executable, but it can be\n/// set to arbitrary text, and may not even exist. This means this property should\n/// not be relied upon for security purposes.\n///\n/// On Unix systems shell usually expands unquoted arguments with glob patterns\n/// (such as `*` and `?`). On Windows this is not done, and such arguments are\n/// passed as-is.\n///\n/// On glibc Linux, arguments are retrieved by placing a function in .init_array.\n/// glibc passes argc, argv, and envp to functions in .init_array, as a non-standard extension.\n/// This allows `std::env::args` to work even in a `cdylib` or `staticlib`, as it does on macOS\n/// and Windows.\n///\n/// # Panics\n///\n/// The returned iterator will panic during iteration if any argument to the\n/// process is not valid unicode. If this is not desired,\n/// use the [`args_os`] function instead.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// // Prints each argument on a separate line\n/// for argument in env::args() {\n///     println!(\"{}\", argument);\n/// }\n/// ```\n///\n/// [`args_os`]: ./fn.args_os.html\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn args() -> Args {\n}\n\n/// Returns the arguments which this program was started with (normally passed\n/// via the command line).\n///\n/// The first element is traditionally the path of the executable, but it can be\n/// set to arbitrary text, and it may not even exist, so this property should\n/// not be relied upon for security purposes.\n///\n/// On glibc Linux, arguments are retrieved by placing a function in .init_array.\n/// glibc passes argc, argv, and envp to functions in .init_array, as a non-standard extension.\n/// This allows `std::env::args` to work even in a `cdylib` or `staticlib`, as it does on macOS\n/// and Windows.\n///\n/// # Examples\n///\n/// ```\n/// use std::env;\n///\n/// // Prints each argument on a separate line\n/// for argument in env::args_os() {\n///     println!(\"{:?}\", argument);\n/// }\n/// ```\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub fn args_os() -> ArgsOs {\n}\n\n#[stable(feature = \"env_unimpl_send_sync\", since = \"1.26.0\")]\nimpl !Send for Args {}\n\n#[stable(feature = \"env_unimpl_send_sync\", since = \"1.26.0\")]\nimpl !Sync for Args {}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl Iterator for Args {\n    type Item = String;\n    fn next(&mut self) -> Option<String> {\n}\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl ExactSizeIterator for Args {\n    fn len(&self) -> usize {\n}\n    fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"env_iterators\", since = \"1.12.0\")]\nimpl DoubleEndedIterator for Args {\n    fn next_back(&mut self) -> Option<String> {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Args {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"env_unimpl_send_sync\", since = \"1.26.0\")]\nimpl !Send for ArgsOs {}\n\n#[stable(feature = \"env_unimpl_send_sync\", since = \"1.26.0\")]\nimpl !Sync for ArgsOs {}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl Iterator for ArgsOs {\n    type Item = OsString;\n    fn next(&mut self) -> Option<OsString> {\n}\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"env\", since = \"1.0.0\")]\nimpl ExactSizeIterator for ArgsOs {\n    fn len(&self) -> usize {\n}\n    fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"env_iterators\", since = \"1.12.0\")]\nimpl DoubleEndedIterator for ArgsOs {\n    fn next_back(&mut self) -> Option<OsString> {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ArgsOs {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// Constants associated with the current target\n#[stable(feature = \"env\", since = \"1.0.0\")]\npub mod consts {\n    use crate::sys::env::os;\n\n    /// A string describing the architecture of the CPU that is currently\n    /// in use.\n    ///\n    /// Some possible values:\n    ///\n    /// - x86\n    /// - x86_64\n    /// - arm\n    /// - aarch64\n    /// - mips\n    /// - mips64\n    /// - powerpc\n    /// - powerpc64\n    /// - riscv64\n    /// - s390x\n    /// - sparc64\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const ARCH: &str = super::arch::ARCH;\n\n    /// The family of the operating system. Example value is `unix`.\n    ///\n    /// Some possible values:\n    ///\n    /// - unix\n    /// - windows\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const FAMILY: &str = os::FAMILY;\n\n    /// A string describing the specific operating system in use.\n    /// Example value is `linux`.\n    ///\n    /// Some possible values:\n    ///\n    /// - linux\n    /// - macos\n    /// - ios\n    /// - freebsd\n    /// - dragonfly\n    /// - netbsd\n    /// - openbsd\n    /// - solaris\n    /// - android\n    /// - windows\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const OS: &str = os::OS;\n\n    /// Specifies the filename prefix used for shared libraries on this\n    /// platform. Example value is `lib`.\n    ///\n    /// Some possible values:\n    ///\n    /// - lib\n    /// - `\"\"` (an empty string)\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const DLL_PREFIX: &str = os::DLL_PREFIX;\n\n    /// Specifies the filename suffix used for shared libraries on this\n    /// platform. Example value is `.so`.\n    ///\n    /// Some possible values:\n    ///\n    /// - .so\n    /// - .dylib\n    /// - .dll\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const DLL_SUFFIX: &str = os::DLL_SUFFIX;\n\n    /// Specifies the file extension used for shared libraries on this\n    /// platform that goes after the dot. Example value is `so`.\n    ///\n    /// Some possible values:\n    ///\n    /// - so\n    /// - dylib\n    /// - dll\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const DLL_EXTENSION: &str = os::DLL_EXTENSION;\n\n    /// Specifies the filename suffix used for executable binaries on this\n    /// platform. Example value is `.exe`.\n    ///\n    /// Some possible values:\n    ///\n    /// - .exe\n    /// - .nexe\n    /// - .pexe\n    /// - `\"\"` (an empty string)\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const EXE_SUFFIX: &str = os::EXE_SUFFIX;\n\n    /// Specifies the file extension, if any, used for executable binaries\n    /// on this platform. Example value is `exe`.\n    ///\n    /// Some possible values:\n    ///\n    /// - exe\n    /// - `\"\"` (an empty string)\n    #[stable(feature = \"env\", since = \"1.0.0\")]\n    pub const EXE_EXTENSION: &str = os::EXE_EXTENSION;\n}\n\n#[cfg(target_arch = \"x86\")]\nmod arch {\n    pub const ARCH: &str = \"x86\";\n}\n\n#[cfg(target_arch = \"x86_64\")]\nmod arch {\n    pub const ARCH: &str = \"x86_64\";\n}\n\n#[cfg(target_arch = \"arm\")]\nmod arch {\n    pub const ARCH: &str = \"arm\";\n}\n\n#[cfg(target_arch = \"aarch64\")]\nmod arch {\n    pub const ARCH: &str = \"aarch64\";\n}\n\n#[cfg(target_arch = \"mips\")]\nmod arch {\n    pub const ARCH: &str = \"mips\";\n}\n\n#[cfg(target_arch = \"mips64\")]\nmod arch {\n    pub const ARCH: &str = \"mips64\";\n}\n\n#[cfg(target_arch = \"powerpc\")]\nmod arch {\n    pub const ARCH: &str = \"powerpc\";\n}\n\n#[cfg(target_arch = \"powerpc64\")]\nmod arch {\n    pub const ARCH: &str = \"powerpc64\";\n}\n\n#[cfg(target_arch = \"s390x\")]\nmod arch {\n    pub const ARCH: &str = \"s390x\";\n}\n\n#[cfg(target_arch = \"sparc64\")]\nmod arch {\n    pub const ARCH: &str = \"sparc64\";\n}\n\n#[cfg(target_arch = \"le32\")]\nmod arch {\n    pub const ARCH: &str = \"le32\";\n}\n\n#[cfg(target_arch = \"asmjs\")]\nmod arch {\n    pub const ARCH: &str = \"asmjs\";\n}\n\n#[cfg(target_arch = \"wasm32\")]\nmod arch {\n    pub const ARCH: &str = \"wasm32\";\n}\n\n#[cfg(target_arch = \"hexagon\")]\nmod arch {\n    pub const ARCH: &'static str = \"hexagon\";\n}\n\n#[cfg(target_arch = \"riscv64\")]\nmod arch {\n    pub const ARCH: &'static str = \"riscv64\";\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\npub mod error {\n//! Traits for working with Errors.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n// A note about crates and the facade:\n//\n// Originally, the `Error` trait was defined in libcore, and the impls\n// were scattered about. However, coherence objected to this\n// arrangement, because to create the blanket impls for `Box` required\n// knowing that `&str: !Error`, and we have no means to deal with that\n// sort of conflict just now. Therefore, for the time being, we have\n// moved the `Error` trait into libstd. As we evolve a sol'n to the\n// coherence challenge (e.g., specialization, neg impls, etc) we can\n// reconsider what crate these items belong in.\n\nuse core::array;\n\nuse crate::alloc::{AllocErr, CannotReallocInPlace, LayoutErr};\nuse crate::any::TypeId;\nuse crate::backtrace::Backtrace;\nuse crate::borrow::Cow;\nuse crate::cell;\nuse crate::char;\nuse crate::fmt::{self, Debug, Display};\nuse crate::mem::transmute;\nuse crate::num;\nuse crate::str;\nuse crate::string;\n\n/// `Error` is a trait representing the basic expectations for error values,\n/// i.e., values of type `E` in [`Result<T, E>`]. Errors must describe\n/// themselves through the [`Display`] and [`Debug`] traits, and may provide\n/// cause chain information:\n///\n/// The [`source`] method is generally used when errors cross \"abstraction\n/// boundaries\". If one module must report an error that is caused by an error\n/// from a lower-level module, it can allow access to that error via the\n/// [`source`] method. This makes it possible for the high-level module to\n/// provide its own errors while also revealing some of the implementation for\n/// debugging via [`source`] chains.\n///\n/// [`Result<T, E>`]: ../result/enum.Result.html\n/// [`Display`]: ../fmt/trait.Display.html\n/// [`Debug`]: ../fmt/trait.Debug.html\n/// [`source`]: trait.Error.html#method.source\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Error: Debug + Display {\n    /// The lower-level source of this error, if any.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::fmt;\n    ///\n    /// #[derive(Debug)]\n    /// struct SuperError {\n    ///     side: SuperErrorSideKick,\n    /// }\n    ///\n    /// impl fmt::Display for SuperError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"SuperError is here!\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for SuperError {\n    ///     fn source(&self) -> Option<&(dyn Error + 'static)> {\n    ///         Some(&self.side)\n    ///     }\n    /// }\n    ///\n    /// #[derive(Debug)]\n    /// struct SuperErrorSideKick;\n    ///\n    /// impl fmt::Display for SuperErrorSideKick {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"SuperErrorSideKick is here!\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for SuperErrorSideKick {}\n    ///\n    /// fn get_super_error() -> Result<(), SuperError> {\n    ///     Err(SuperError { side: SuperErrorSideKick })\n    /// }\n    ///\n    /// fn main() {\n    ///     match get_super_error() {\n    ///         Err(e) => {\n    ///             println!(\"Error: {}\", e.description());\n    ///             println!(\"Caused by: {}\", e.source().unwrap());\n    ///         }\n    ///         _ => println!(\"No error\"),\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"error_source\", since = \"1.30.0\")]\n    fn source(&self) -> Option<&(dyn Error + 'static)> {\n}\n\n    /// Gets the `TypeId` of `self`.\n    #[doc(hidden)]\n    #[unstable(\n        feature = \"error_type_id\",\n        reason = \"this is memory-unsafe to override in user code\",\n        issue = \"60784\"\n    )]\n    fn type_id(&self, _: private::Internal) -> TypeId\n    where\n        Self: 'static,\n    {\n}\n\n    /// Returns a stack backtrace, if available, of where this error occurred.\n    ///\n    /// This function allows inspecting the location, in code, of where an error\n    /// happened. The returned `Backtrace` contains information about the stack\n    /// trace of the OS thread of execution of where the error originated from.\n    ///\n    /// Note that not all errors contain a `Backtrace`. Also note that a\n    /// `Backtrace` may actually be empty. For more information consult the\n    /// `Backtrace` type itself.\n    #[unstable(feature = \"backtrace\", issue = \"53487\")]\n    fn backtrace(&self) -> Option<&Backtrace> {\n}\n\n    /// ```\n    /// if let Err(e) = \"xc\".parse::<u32>() {\n    ///     // Print `e` itself, no need for description().\n    ///     eprintln!(\"Error: {}\", e);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.42.0\", reason = \"use the Display impl or to_string()\")]\n    fn description(&self) -> &str {\n}\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(\n        since = \"1.33.0\",\n        reason = \"replaced by Error::source, which can support downcasting\"\n    )]\n    #[allow(missing_docs)]\n    fn cause(&self) -> Option<&dyn Error> {\n}\n}\n\nmod private {\n    // This is a hack to prevent `type_id` from being overridden by `Error`\n    // implementations, since that can enable unsound downcasting.\n    #[unstable(feature = \"error_type_id\", issue = \"60784\")]\n    #[derive(Debug)]\n    pub struct Internal;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, E: Error + 'a> From<E> for Box<dyn Error + 'a> {\n    /// Converts a type of [`Error`] into a box of dyn [`Error`].\n    ///\n    /// [`Error`]: ../error/trait.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::fmt;\n    /// use std::mem;\n    ///\n    /// #[derive(Debug)]\n    /// struct AnError;\n    ///\n    /// impl fmt::Display for AnError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f , \"An error\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for AnError {}\n    ///\n    /// let an_error = AnError;\n    /// assert!(0 == mem::size_of_val(&an_error));\n    /// let a_boxed_error = Box::<dyn Error>::from(an_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: E) -> Box<dyn Error + 'a> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync + 'a> {\n    /// Converts a type of [`Error`] + [`Send`] + [`Sync`] into a box of\n    /// dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// [`Error`]: ../error/trait.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::fmt;\n    /// use std::mem;\n    ///\n    /// #[derive(Debug)]\n    /// struct AnError;\n    ///\n    /// impl fmt::Display for AnError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f , \"An error\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for AnError {}\n    ///\n    /// unsafe impl Send for AnError {}\n    ///\n    /// unsafe impl Sync for AnError {}\n    ///\n    /// let an_error = AnError;\n    /// assert!(0 == mem::size_of_val(&an_error));\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(an_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: E) -> Box<dyn Error + Send + Sync + 'a> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<String> for Box<dyn Error + Send + Sync> {\n    /// Converts a [`String`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// [`Error`]: ../error/trait.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    ///\n    /// let a_string_error = \"a string error\".to_string();\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_string_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    #[inline]\n    fn from(err: String) -> Box<dyn Error + Send + Sync> {\n}\n}\n\n#[stable(feature = \"string_box_error\", since = \"1.6.0\")]\nimpl From<String> for Box<dyn Error> {\n    /// Converts a [`String`] into a box of dyn [`Error`].\n    ///\n    /// [`Error`]: ../error/trait.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    ///\n    /// let a_string_error = \"a string error\".to_string();\n    /// let a_boxed_error = Box::<dyn Error>::from(a_string_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(str_err: String) -> Box<dyn Error> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n    /// Converts a [`str`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// [`Error`]: ../error/trait.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    ///\n    /// let a_str_error = \"a str error\";\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_str_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    #[inline]\n    fn from(err: &str) -> Box<dyn Error + Send + Sync + 'a> {\n}\n}\n\n#[stable(feature = \"string_box_error\", since = \"1.6.0\")]\nimpl From<&str> for Box<dyn Error> {\n    /// Converts a [`str`] into a box of dyn [`Error`].\n    ///\n    /// [`Error`]: ../error/trait.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    ///\n    /// let a_str_error = \"a str error\";\n    /// let a_boxed_error = Box::<dyn Error>::from(a_str_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: &str) -> Box<dyn Error> {\n}\n}\n\n#[stable(feature = \"cow_box_error\", since = \"1.22.0\")]\nimpl<'a, 'b> From<Cow<'b, str>> for Box<dyn Error + Send + Sync + 'a> {\n    /// Converts a [`Cow`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// [`Cow`]: ../borrow/enum.Cow.html\n    /// [`Error`]: ../error/trait.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    /// use std::borrow::Cow;\n    ///\n    /// let a_cow_str_error = Cow::from(\"a str error\");\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_cow_str_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: Cow<'b, str>) -> Box<dyn Error + Send + Sync + 'a> {\n}\n}\n\n#[stable(feature = \"cow_box_error\", since = \"1.22.0\")]\nimpl<'a> From<Cow<'a, str>> for Box<dyn Error> {\n    /// Converts a [`Cow`] into a box of dyn [`Error`].\n    ///\n    /// [`Cow`]: ../borrow/enum.Cow.html\n    /// [`Error`]: ../error/trait.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    /// use std::borrow::Cow;\n    ///\n    /// let a_cow_str_error = Cow::from(\"a str error\");\n    /// let a_boxed_error = Box::<dyn Error>::from(a_cow_str_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: Cow<'a, str>) -> Box<dyn Error> {\n}\n}\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl Error for ! {}}\npub mod ffi {\n//! Utilities related to FFI bindings.\n//!\n//! This module provides utilities to handle data across non-Rust\n//! interfaces, like other programming languages and the underlying\n//! operating system. It is mainly of use for FFI (Foreign Function\n//! Interface) bindings and code that needs to exchange C-like strings\n//! with other languages.\n//!\n//! # Overview\n//!\n//! Rust represents owned strings with the [`String`] type, and\n//! borrowed slices of strings with the [`str`] primitive. Both are\n//! always in UTF-8 encoding, and may contain nul bytes in the middle,\n//! i.e., if you look at the bytes that make up the string, there may\n//! be a `\\0` among them. Both `String` and `str` store their length\n//! explicitly; there are no nul terminators at the end of strings\n//! like in C.\n//!\n//! C strings are different from Rust strings:\n//!\n//! * **Encodings** - Rust strings are UTF-8, but C strings may use\n//! other encodings. If you are using a string from C, you should\n//! check its encoding explicitly, rather than just assuming that it\n//! is UTF-8 like you can do in Rust.\n//!\n//! * **Character size** - C strings may use `char` or `wchar_t`-sized\n//! characters; please **note** that C's `char` is different from Rust's.\n//! The C standard leaves the actual sizes of those types open to\n//! interpretation, but defines different APIs for strings made up of\n//! each character type. Rust strings are always UTF-8, so different\n//! Unicode characters will be encoded in a variable number of bytes\n//! each. The Rust type [`char`] represents a '[Unicode scalar\n//! value]', which is similar to, but not the same as, a '[Unicode\n//! code point]'.\n//!\n//! * **Nul terminators and implicit string lengths** - Often, C\n//! strings are nul-terminated, i.e., they have a `\\0` character at the\n//! end. The length of a string buffer is not stored, but has to be\n//! calculated; to compute the length of a string, C code must\n//! manually call a function like `strlen()` for `char`-based strings,\n//! or `wcslen()` for `wchar_t`-based ones. Those functions return\n//! the number of characters in the string excluding the nul\n//! terminator, so the buffer length is really `len+1` characters.\n//! Rust strings don't have a nul terminator; their length is always\n//! stored and does not need to be calculated. While in Rust\n//! accessing a string's length is a O(1) operation (because the\n//! length is stored); in C it is an O(length) operation because the\n//! length needs to be computed by scanning the string for the nul\n//! terminator.\n//!\n//! * **Internal nul characters** - When C strings have a nul\n//! terminator character, this usually means that they cannot have nul\n//! characters in the middle — a nul character would essentially\n//! truncate the string. Rust strings *can* have nul characters in\n//! the middle, because nul does not have to mark the end of the\n//! string in Rust.\n//!\n//! # Representations of non-Rust strings\n//!\n//! [`CString`] and [`CStr`] are useful when you need to transfer\n//! UTF-8 strings to and from languages with a C ABI, like Python.\n//!\n//! * **From Rust to C:** [`CString`] represents an owned, C-friendly\n//! string: it is nul-terminated, and has no internal nul characters.\n//! Rust code can create a [`CString`] out of a normal string (provided\n//! that the string doesn't have nul characters in the middle), and\n//! then use a variety of methods to obtain a raw `*mut `[`u8`] that can\n//! then be passed as an argument to functions which use the C\n//! conventions for strings.\n//!\n//! * **From C to Rust:** [`CStr`] represents a borrowed C string; it\n//! is what you would use to wrap a raw `*const `[`u8`] that you got from\n//! a C function. A [`CStr`] is guaranteed to be a nul-terminated array\n//! of bytes. Once you have a [`CStr`], you can convert it to a Rust\n//! [`&str`][`str`] if it's valid UTF-8, or lossily convert it by adding\n//! replacement characters.\n//!\n//! [`OsString`] and [`OsStr`] are useful when you need to transfer\n//! strings to and from the operating system itself, or when capturing\n//! the output of external commands. Conversions between [`OsString`],\n//! [`OsStr`] and Rust strings work similarly to those for [`CString`]\n//! and [`CStr`].\n//!\n//! * [`OsString`] represents an owned string in whatever\n//! representation the operating system prefers. In the Rust standard\n//! library, various APIs that transfer strings to/from the operating\n//! system use [`OsString`] instead of plain strings. For example,\n//! [`env::var_os()`] is used to query environment variables; it\n//! returns an [`Option`]`<`[`OsString`]`>`. If the environment variable\n//! exists you will get a [`Some`]`(os_string)`, which you can *then* try to\n//! convert to a Rust string. This yields a [`Result<>`], so that\n//! your code can detect errors in case the environment variable did\n//! not in fact contain valid Unicode data.\n//!\n//! * [`OsStr`] represents a borrowed reference to a string in a\n//! format that can be passed to the operating system. It can be\n//! converted into an UTF-8 Rust string slice in a similar way to\n//! [`OsString`].\n//!\n//! # Conversions\n//!\n//! ## On Unix\n//!\n//! On Unix, [`OsStr`] implements the\n//! `std::os::unix::ffi::`[`OsStrExt`][unix.OsStrExt] trait, which\n//! augments it with two methods, [`from_bytes`] and [`as_bytes`].\n//! These do inexpensive conversions from and to UTF-8 byte slices.\n//!\n//! Additionally, on Unix [`OsString`] implements the\n//! `std::os::unix::ffi::`[`OsStringExt`][unix.OsStringExt] trait,\n//! which provides [`from_vec`] and [`into_vec`] methods that consume\n//! their arguments, and take or produce vectors of [`u8`].\n//!\n//! ## On Windows\n//!\n//! On Windows, [`OsStr`] implements the\n//! `std::os::windows::ffi::`[`OsStrExt`][windows.OsStrExt] trait,\n//! which provides an [`encode_wide`] method. This provides an\n//! iterator that can be [`collect`]ed into a vector of [`u16`].\n//!\n//! Additionally, on Windows [`OsString`] implements the\n//! `std::os::windows:ffi::`[`OsStringExt`][windows.OsStringExt]\n//! trait, which provides a [`from_wide`] method. The result of this\n//! method is an [`OsString`] which can be round-tripped to a Windows\n//! string losslessly.\n//!\n//! [`String`]: ../string/struct.String.html\n//! [`str`]: ../primitive.str.html\n//! [`char`]: ../primitive.char.html\n//! [`u8`]: ../primitive.u8.html\n//! [`u16`]: ../primitive.u16.html\n//! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n//! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n//! [`CString`]: struct.CString.html\n//! [`CStr`]: struct.CStr.html\n//! [`OsString`]: struct.OsString.html\n//! [`OsStr`]: struct.OsStr.html\n//! [`env::set_var()`]: ../env/fn.set_var.html\n//! [`env::var_os()`]: ../env/fn.var_os.html\n//! [`Result<>`]: ../result/enum.Result.html\n//! [unix.OsStringExt]: ../os/unix/ffi/trait.OsStringExt.html\n//! [`from_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.from_vec\n//! [`into_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.into_vec\n//! [unix.OsStrExt]: ../os/unix/ffi/trait.OsStrExt.html\n//! [`from_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.from_bytes\n//! [`as_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.as_bytes\n//! [`OsStrExt`]: ../os/unix/ffi/trait.OsStrExt.html\n//! [windows.OsStrExt]: ../os/windows/ffi/trait.OsStrExt.html\n//! [`encode_wide`]: ../os/windows/ffi/trait.OsStrExt.html#tymethod.encode_wide\n//! [`collect`]: ../iter/trait.Iterator.html#method.collect\n//! [windows.OsStringExt]: ../os/windows/ffi/trait.OsStringExt.html\n//! [`from_wide`]: ../os/windows/ffi/trait.OsStringExt.html#tymethod.from_wide\n//! [`Option`]: ../option/enum.Option.html\n//! [`Some`]: ../option/enum.Option.html#variant.Some\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\npub use self::c_str::FromBytesWithNulError;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::c_str::{CStr, CString, IntoStringError, NulError};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::os_str::{OsStr, OsString};\n\n#[stable(feature = \"core_c_void\", since = \"1.30.0\")]\npub use core::ffi::c_void;\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\npub use core::ffi::{VaList, VaListImpl};\n\nmod c_str {\nuse crate::ascii;\nuse crate::borrow::{Borrow, Cow};\nuse crate::cmp::Ordering;\nuse crate::error::Error;\nuse crate::fmt::{self, Write};\nuse crate::io;\nuse crate::mem;\nuse crate::memchr;\nuse crate::ops;\nuse crate::os::raw::c_char;\nuse crate::ptr;\nuse crate::rc::Rc;\nuse crate::slice;\nuse crate::str::{self, Utf8Error};\nuse crate::sync::Arc;\nuse crate::sys;\n\n/// A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the\n/// middle.\n///\n/// This type serves the purpose of being able to safely generate a\n/// C-compatible string from a Rust byte slice or vector. An instance of this\n/// type is a static guarantee that the underlying bytes contain no interior 0\n/// bytes (\"nul characters\") and that the final byte is 0 (\"nul terminator\").\n///\n/// `CString` is to [`&CStr`] as [`String`] is to [`&str`]: the former\n/// in each pair are owned strings; the latter are borrowed\n/// references.\n///\n/// # Creating a `CString`\n///\n/// A `CString` is created from either a byte slice or a byte vector,\n/// or anything that implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>` (for\n/// example, you can build a `CString` straight out of a [`String`] or\n/// a [`&str`], since both implement that trait).\n///\n/// The [`new`] method will actually check that the provided `&[u8]`\n/// does not have 0 bytes in the middle, and return an error if it\n/// finds one.\n///\n/// # Extracting a raw pointer to the whole C string\n///\n/// `CString` implements a [`as_ptr`] method through the [`Deref`]\n/// trait. This method will give you a `*const c_char` which you can\n/// feed directly to extern functions that expect a nul-terminated\n/// string, like C's `strdup()`. Notice that [`as_ptr`] returns a\n/// read-only pointer; if the C code writes to it, that causes\n/// undefined behavior.\n///\n/// # Extracting a slice of the whole C string\n///\n/// Alternatively, you can obtain a `&[`[`u8`]`]` slice from a\n/// `CString` with the [`as_bytes`] method. Slices produced in this\n/// way do *not* contain the trailing nul terminator. This is useful\n/// when you will be calling an extern function that takes a `*const\n/// u8` argument which is not necessarily nul-terminated, plus another\n/// argument with the length of the string — like C's `strndup()`.\n/// You can of course get the slice's length with its\n/// [`len`][slice.len] method.\n///\n/// If you need a `&[`[`u8`]`]` slice *with* the nul terminator, you\n/// can use [`as_bytes_with_nul`] instead.\n///\n/// Once you have the kind of slice you need (with or without a nul\n/// terminator), you can call the slice's own\n/// [`as_ptr`][slice.as_ptr] method to get a read-only raw pointer to pass to\n/// extern functions. See the documentation for that function for a\n/// discussion on ensuring the lifetime of the raw pointer.\n///\n/// [`Into`]: ../convert/trait.Into.html\n/// [`Vec`]: ../vec/struct.Vec.html\n/// [`String`]: ../string/struct.String.html\n/// [`&str`]: ../primitive.str.html\n/// [`u8`]: ../primitive.u8.html\n/// [`new`]: #method.new\n/// [`as_bytes`]: #method.as_bytes\n/// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n/// [`as_ptr`]: #method.as_ptr\n/// [slice.as_ptr]: ../primitive.slice.html#method.as_ptr\n/// [slice.len]: ../primitive.slice.html#method.len\n/// [`Deref`]: ../ops/trait.Deref.html\n/// [`CStr`]: struct.CStr.html\n/// [`&CStr`]: struct.CStr.html\n///\n/// # Examples\n///\n/// ```ignore (extern-declaration)\n/// # fn main() {\n/// use std::ffi::CString;\n/// use std::os::raw::c_char;\n///\n/// extern {\n///     fn my_printer(s: *const c_char);\n/// }\n///\n/// // We are certain that our string doesn't have 0 bytes in the middle,\n/// // so we can .expect()\n/// let c_to_print = CString::new(\"Hello, world!\").expect(\"CString::new failed\");\n/// unsafe {\n///     my_printer(c_to_print.as_ptr());\n/// }\n/// # }\n/// ```\n///\n/// # Safety\n///\n/// `CString` is intended for working with traditional C-style strings\n/// (a sequence of non-nul bytes terminated by a single nul byte); the\n/// primary use case for these kinds of strings is interoperating with C-like\n/// code. Often you will need to transfer ownership to/from that external\n/// code. It is strongly recommended that you thoroughly read through the\n/// documentation of `CString` before use, as improper ownership management\n/// of `CString` instances can lead to invalid memory accesses, memory leaks,\n/// and other memory errors.\n\n#[derive(PartialEq, PartialOrd, Eq, Ord, Hash, Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct CString {\n    // Invariant 1: the slice ends with a zero byte and has a length of at least one.\n    // Invariant 2: the slice contains only one zero byte.\n    // Improper usage of unsafe function can break Invariant 2, but not Invariant 1.\n    inner: Box<[u8]>,\n}\n\n/// Representation of a borrowed C string.\n///\n/// This type represents a borrowed reference to a nul-terminated\n/// array of bytes. It can be constructed safely from a `&[`[`u8`]`]`\n/// slice, or unsafely from a raw `*const c_char`. It can then be\n/// converted to a Rust [`&str`] by performing UTF-8 validation, or\n/// into an owned [`CString`].\n///\n/// `&CStr` is to [`CString`] as [`&str`] is to [`String`]: the former\n/// in each pair are borrowed references; the latter are owned\n/// strings.\n///\n/// Note that this structure is **not** `repr(C)` and is not recommended to be\n/// placed in the signatures of FFI functions. Instead, safe wrappers of FFI\n/// functions may leverage the unsafe [`from_ptr`] constructor to provide a safe\n/// interface to other consumers.\n///\n/// # Examples\n///\n/// Inspecting a foreign C string:\n///\n/// ```ignore (extern-declaration)\n/// use std::ffi::CStr;\n/// use std::os::raw::c_char;\n///\n/// extern { fn my_string() -> *const c_char; }\n///\n/// unsafe {\n///     let slice = CStr::from_ptr(my_string());\n///     println!(\"string buffer size without nul terminator: {}\", slice.to_bytes().len());\n/// }\n/// ```\n///\n/// Passing a Rust-originating C string:\n///\n/// ```ignore (extern-declaration)\n/// use std::ffi::{CString, CStr};\n/// use std::os::raw::c_char;\n///\n/// fn work(data: &CStr) {\n///     extern { fn work_with(data: *const c_char); }\n///\n///     unsafe { work_with(data.as_ptr()) }\n/// }\n///\n/// let s = CString::new(\"data data data data\").expect(\"CString::new failed\");\n/// work(&s);\n/// ```\n///\n/// Converting a foreign C string into a Rust [`String`]:\n///\n/// ```ignore (extern-declaration)\n/// use std::ffi::CStr;\n/// use std::os::raw::c_char;\n///\n/// extern { fn my_string() -> *const c_char; }\n///\n/// fn my_string_safe() -> String {\n///     unsafe {\n///         CStr::from_ptr(my_string()).to_string_lossy().into_owned()\n///     }\n/// }\n///\n/// println!(\"string: {}\", my_string_safe());\n/// ```\n///\n/// [`u8`]: ../primitive.u8.html\n/// [`&str`]: ../primitive.str.html\n/// [`String`]: ../string/struct.String.html\n/// [`CString`]: struct.CString.html\n/// [`from_ptr`]: #method.from_ptr\n#[derive(Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n// FIXME:\n// `fn from` in `impl From<&CStr> for Box<CStr>` current implementation relies\n// on `CStr` being layout-compatible with `[u8]`.\n// When attribute privacy is implemented, `CStr` should be annotated as `#[repr(transparent)]`.\n// Anyway, `CStr` representation and layout are considered implementation detail, are\n// not documented and must not be relied upon.\npub struct CStr {\n    // FIXME: this should not be represented with a DST slice but rather with\n    //        just a raw `c_char` along with some form of marker to make\n    //        this an unsized type. Essentially `sizeof(&CStr)` should be the\n    //        same as `sizeof(&c_char)` but `CStr` should be an unsized type.\n    inner: [c_char],\n}\n\n/// An error indicating that an interior nul byte was found.\n///\n/// While Rust strings may contain nul bytes in the middle, C strings\n/// can't, as that byte would effectively truncate the string.\n///\n/// This error is created by the [`new`][`CString::new`] method on\n/// [`CString`]. See its documentation for more.\n///\n/// [`CString`]: struct.CString.html\n/// [`CString::new`]: struct.CString.html#method.new\n///\n/// # Examples\n///\n/// ```\n/// use std::ffi::{CString, NulError};\n///\n/// let _: NulError = CString::new(b\"f\\0oo\".to_vec()).unwrap_err();\n/// ```\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct NulError(usize, Vec<u8>);\n\n/// An error indicating that a nul byte was not in the expected position.\n///\n/// The slice used to create a [`CStr`] must have one and only one nul\n/// byte at the end of the slice.\n///\n/// This error is created by the\n/// [`from_bytes_with_nul`][`CStr::from_bytes_with_nul`] method on\n/// [`CStr`]. See its documentation for more.\n///\n/// [`CStr`]: struct.CStr.html\n/// [`CStr::from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n///\n/// # Examples\n///\n/// ```\n/// use std::ffi::{CStr, FromBytesWithNulError};\n///\n/// let _: FromBytesWithNulError = CStr::from_bytes_with_nul(b\"f\\0oo\").unwrap_err();\n/// ```\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\npub struct FromBytesWithNulError {\n    kind: FromBytesWithNulErrorKind,\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\nenum FromBytesWithNulErrorKind {\n    InteriorNul(usize),\n    NotNulTerminated,\n}\n\nimpl FromBytesWithNulError {\n    fn interior_nul(pos: usize) -> FromBytesWithNulError {\n}\n    fn not_nul_terminated() -> FromBytesWithNulError {\n}\n}\n\n/// An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].\n///\n/// `CString` is just a wrapper over a buffer of bytes with a nul\n/// terminator; [`into_string`][`CString::into_string`] performs UTF-8\n/// validation on those bytes and may return this error.\n///\n/// This `struct` is created by the\n/// [`into_string`][`CString::into_string`] method on [`CString`]. See\n/// its documentation for more.\n///\n/// [`String`]: ../string/struct.String.html\n/// [`CString`]: struct.CString.html\n/// [`CString::into_string`]: struct.CString.html#method.into_string\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\npub struct IntoStringError {\n    inner: CString,\n    error: Utf8Error,\n}\n\nimpl CString {\n    /// Creates a new C-compatible string from a container of bytes.\n    ///\n    /// This function will consume the provided data and use the\n    /// underlying bytes to construct a new string, ensuring that\n    /// there is a trailing 0 byte. This trailing 0 byte will be\n    /// appended by this function; the provided data should *not*\n    /// contain any 0 bytes in it.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore (extern-declaration)\n    /// use std::ffi::CString;\n    /// use std::os::raw::c_char;\n    ///\n    /// extern { fn puts(s: *const c_char); }\n    ///\n    /// let to_print = CString::new(\"Hello!\").expect(\"CString::new failed\");\n    /// unsafe {\n    ///     puts(to_print.as_ptr());\n    /// }\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the supplied bytes contain an\n    /// internal 0 byte. The [`NulError`] returned will contain the bytes as well as\n    /// the position of the nul byte.\n    ///\n    /// [`NulError`]: struct.NulError.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n}\n\n    fn _new(bytes: Vec<u8>) -> Result<CString, NulError> {\n}\n\n    /// Creates a C-compatible string by consuming a byte vector,\n    /// without checking for interior 0 bytes.\n    ///\n    /// This method is equivalent to [`new`] except that no runtime assertion\n    /// is made that `v` contains no 0 bytes, and it requires an actual\n    /// byte vector, not anything that can be converted to one with Into.\n    ///\n    /// [`new`]: #method.new\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let raw = b\"foo\".to_vec();\n    /// unsafe {\n    ///     let c_string = CString::from_vec_unchecked(raw);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString {\n}\n\n    /// Retakes ownership of a `CString` that was transferred to C via [`into_raw`].\n    ///\n    /// Additionally, the length of the string will be recalculated from the pointer.\n    ///\n    /// # Safety\n    ///\n    /// This should only ever be called with a pointer that was earlier\n    /// obtained by calling [`into_raw`] on a `CString`. Other usage (e.g., trying to take\n    /// ownership of a string that was allocated by foreign code) is likely to lead\n    /// to undefined behavior or allocator corruption.\n    ///\n    /// > **Note:** If you need to borrow a string that was allocated by\n    /// > foreign code, use [`CStr`]. If you need to take ownership of\n    /// > a string that was allocated by foreign code, you will need to\n    /// > make your own provisions for freeing it appropriately, likely\n    /// > with the foreign code's API to do that.\n    ///\n    /// [`into_raw`]: #method.into_raw\n    /// [`CStr`]: struct.CStr.html\n    ///\n    /// # Examples\n    ///\n    /// Creates a `CString`, pass ownership to an `extern` function (via raw pointer), then retake\n    /// ownership with `from_raw`:\n    ///\n    /// ```ignore (extern-declaration)\n    /// use std::ffi::CString;\n    /// use std::os::raw::c_char;\n    ///\n    /// extern {\n    ///     fn some_extern_function(s: *mut c_char);\n    /// }\n    ///\n    /// let c_string = CString::new(\"Hello!\").expect(\"CString::new failed\");\n    /// let raw = c_string.into_raw();\n    /// unsafe {\n    ///     some_extern_function(raw);\n    ///     let c_string = CString::from_raw(raw);\n    /// }\n    /// ```\n    #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n    pub unsafe fn from_raw(ptr: *mut c_char) -> CString {\n}\n\n    /// Consumes the `CString` and transfers ownership of the string to a C caller.\n    ///\n    /// The pointer which this function returns must be returned to Rust and reconstituted using\n    /// [`from_raw`] to be properly deallocated. Specifically, one\n    /// should *not* use the standard C `free()` function to deallocate\n    /// this string.\n    ///\n    /// Failure to call [`from_raw`] will lead to a memory leak.\n    ///\n    /// [`from_raw`]: #method.from_raw\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n    ///\n    /// let ptr = c_string.into_raw();\n    ///\n    /// unsafe {\n    ///     assert_eq!(b'f', *ptr as u8);\n    ///     assert_eq!(b'o', *ptr.offset(1) as u8);\n    ///     assert_eq!(b'o', *ptr.offset(2) as u8);\n    ///     assert_eq!(b'\\0', *ptr.offset(3) as u8);\n    ///\n    ///     // retake pointer to free memory\n    ///     let _ = CString::from_raw(ptr);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n    pub fn into_raw(self) -> *mut c_char {\n}\n\n    /// Converts the `CString` into a [`String`] if it contains valid UTF-8 data.\n    ///\n    /// On failure, ownership of the original `CString` is returned.\n    ///\n    /// [`String`]: ../string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let valid_utf8 = vec![b'f', b'o', b'o'];\n    /// let cstring = CString::new(valid_utf8).expect(\"CString::new failed\");\n    /// assert_eq!(cstring.into_string().expect(\"into_string() call failed\"), \"foo\");\n    ///\n    /// let invalid_utf8 = vec![b'f', 0xff, b'o', b'o'];\n    /// let cstring = CString::new(invalid_utf8).expect(\"CString::new failed\");\n    /// let err = cstring.into_string().err().expect(\"into_string().err() failed\");\n    /// assert_eq!(err.utf8_error().valid_up_to(), 1);\n    /// ```\n\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn into_string(self) -> Result<String, IntoStringError> {\n}\n\n    /// Consumes the `CString` and returns the underlying byte buffer.\n    ///\n    /// The returned buffer does **not** contain the trailing nul\n    /// terminator, and it is guaranteed to not have any interior nul\n    /// bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n    /// let bytes = c_string.into_bytes();\n    /// assert_eq!(bytes, vec![b'f', b'o', b'o']);\n    /// ```\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn into_bytes(self) -> Vec<u8> {\n}\n\n    /// Equivalent to the [`into_bytes`] function except that the returned vector\n    /// includes the trailing nul terminator.\n    ///\n    /// [`into_bytes`]: #method.into_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n    /// let bytes = c_string.into_bytes_with_nul();\n    /// assert_eq!(bytes, vec![b'f', b'o', b'o', b'\\0']);\n    /// ```\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn into_bytes_with_nul(self) -> Vec<u8> {\n}\n\n    /// Returns the contents of this `CString` as a slice of bytes.\n    ///\n    /// The returned slice does **not** contain the trailing nul\n    /// terminator, and it is guaranteed to not have any interior nul\n    /// bytes. If you need the nul terminator, use\n    /// [`as_bytes_with_nul`] instead.\n    ///\n    /// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n    /// let bytes = c_string.as_bytes();\n    /// assert_eq!(bytes, &[b'f', b'o', b'o']);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_bytes(&self) -> &[u8] {\n}\n\n    /// Equivalent to the [`as_bytes`] function except that the returned slice\n    /// includes the trailing nul terminator.\n    ///\n    /// [`as_bytes`]: #method.as_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(\"foo\").expect(\"CString::new failed\");\n    /// let bytes = c_string.as_bytes_with_nul();\n    /// assert_eq!(bytes, &[b'f', b'o', b'o', b'\\0']);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_bytes_with_nul(&self) -> &[u8] {\n}\n\n    /// Extracts a [`CStr`] slice containing the entire string.\n    ///\n    /// [`CStr`]: struct.CStr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{CString, CStr};\n    ///\n    /// let c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\n    /// let cstr = c_string.as_c_str();\n    /// assert_eq!(cstr,\n    ///            CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\"));\n    /// ```\n    #[inline]\n    #[stable(feature = \"as_c_str\", since = \"1.20.0\")]\n    pub fn as_c_str(&self) -> &CStr {\n}\n\n    /// Converts this `CString` into a boxed [`CStr`].\n    ///\n    /// [`CStr`]: struct.CStr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{CString, CStr};\n    ///\n    /// let c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\n    /// let boxed = c_string.into_boxed_c_str();\n    /// assert_eq!(&*boxed,\n    ///            CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\"));\n    /// ```\n    #[stable(feature = \"into_boxed_c_str\", since = \"1.20.0\")]\n    pub fn into_boxed_c_str(self) -> Box<CStr> {\n}\n\n    /// Bypass \"move out of struct which implements [`Drop`] trait\" restriction.\n    ///\n    /// [`Drop`]: ../ops/trait.Drop.html\n    fn into_inner(self) -> Box<[u8]> {\n}\n}\n\n// Turns this `CString` into an empty string to prevent\n// memory-unsafe code from working by accident. Inline\n// to prevent LLVM from optimizing it away in debug builds.\n#[stable(feature = \"cstring_drop\", since = \"1.13.0\")]\nimpl Drop for CString {\n    #[inline]\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Deref for CString {\n    type Target = CStr;\n\n    #[inline]\n    fn deref(&self) -> &CStr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for CString {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\nimpl From<CString> for Vec<u8> {\n    /// Converts a [`CString`] into a [`Vec`]`<u8>`.\n    ///\n    /// The conversion consumes the [`CString`], and removes the terminating NUL byte.\n    ///\n    /// [`Vec`]: ../vec/struct.Vec.html\n    /// [`CString`]: ../ffi/struct.CString.html\n    #[inline]\n    fn from(s: CString) -> Vec<u8> {\n}\n}\n\n#[stable(feature = \"cstr_debug\", since = \"1.3.0\")]\nimpl fmt::Debug for CStr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"cstr_default\", since = \"1.10.0\")]\nimpl Default for &CStr {\n    fn default() -> Self {\n}\n}\n\n#[stable(feature = \"cstr_default\", since = \"1.10.0\")]\nimpl Default for CString {\n    /// Creates an empty `CString`.\n    fn default() -> CString {\n}\n}\n\n#[stable(feature = \"cstr_borrow\", since = \"1.3.0\")]\nimpl Borrow<CStr> for CString {\n    #[inline]\n    fn borrow(&self) -> &CStr {\n}\n}\n\n#[stable(feature = \"cstring_from_cow_cstr\", since = \"1.28.0\")]\nimpl<'a> From<Cow<'a, CStr>> for CString {\n    #[inline]\n    fn from(s: Cow<'a, CStr>) -> Self {\n}\n}\n\n#[stable(feature = \"box_from_c_str\", since = \"1.17.0\")]\nimpl From<&CStr> for Box<CStr> {\n    fn from(s: &CStr) -> Box<CStr> {\n}\n}\n\n#[stable(feature = \"c_string_from_box\", since = \"1.18.0\")]\nimpl From<Box<CStr>> for CString {\n    /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n    ///\n    /// [`Box`]: ../boxed/struct.Box.html\n    /// [`CString`]: ../ffi/struct.CString.html\n    #[inline]\n    fn from(s: Box<CStr>) -> CString {\n}\n}\n\n#[stable(feature = \"more_box_slice_clone\", since = \"1.29.0\")]\nimpl Clone for Box<CStr> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"box_from_c_string\", since = \"1.20.0\")]\nimpl From<CString> for Box<CStr> {\n    /// Converts a [`CString`] into a [`Box`]`<CStr>` without copying or allocating.\n    ///\n    /// [`CString`]: ../ffi/struct.CString.html\n    /// [`Box`]: ../boxed/struct.Box.html\n    #[inline]\n    fn from(s: CString) -> Box<CStr> {\n}\n}\n\n#[stable(feature = \"cow_from_cstr\", since = \"1.28.0\")]\nimpl<'a> From<CString> for Cow<'a, CStr> {\n    #[inline]\n    fn from(s: CString) -> Cow<'a, CStr> {\n}\n}\n\n#[stable(feature = \"cow_from_cstr\", since = \"1.28.0\")]\nimpl<'a> From<&'a CStr> for Cow<'a, CStr> {\n    #[inline]\n    fn from(s: &'a CStr) -> Cow<'a, CStr> {\n}\n}\n\n#[stable(feature = \"cow_from_cstr\", since = \"1.28.0\")]\nimpl<'a> From<&'a CString> for Cow<'a, CStr> {\n    #[inline]\n    fn from(s: &'a CString) -> Cow<'a, CStr> {\n}\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<CString> for Arc<CStr> {\n    /// Converts a [`CString`] into a [`Arc`]`<CStr>` without copying or allocating.\n    ///\n    /// [`CString`]: ../ffi/struct.CString.html\n    /// [`Arc`]: ../sync/struct.Arc.html\n    #[inline]\n    fn from(s: CString) -> Arc<CStr> {\n}\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<&CStr> for Arc<CStr> {\n    #[inline]\n    fn from(s: &CStr) -> Arc<CStr> {\n}\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<CString> for Rc<CStr> {\n    /// Converts a [`CString`] into a [`Rc`]`<CStr>` without copying or allocating.\n    ///\n    /// [`CString`]: ../ffi/struct.CString.html\n    /// [`Rc`]: ../rc/struct.Rc.html\n    #[inline]\n    fn from(s: CString) -> Rc<CStr> {\n}\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<&CStr> for Rc<CStr> {\n    #[inline]\n    fn from(s: &CStr) -> Rc<CStr> {\n}\n}\n\n#[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\nimpl Default for Box<CStr> {\n    fn default() -> Box<CStr> {\n}\n}\n\nimpl NulError {\n    /// Returns the position of the nul byte in the slice that caused\n    /// [`CString::new`] to fail.\n    ///\n    /// [`CString::new`]: struct.CString.html#method.new\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let nul_error = CString::new(\"foo\\0bar\").unwrap_err();\n    /// assert_eq!(nul_error.nul_position(), 3);\n    ///\n    /// let nul_error = CString::new(\"foo bar\\0\").unwrap_err();\n    /// assert_eq!(nul_error.nul_position(), 7);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn nul_position(&self) -> usize {\n}\n\n    /// Consumes this error, returning the underlying vector of bytes which\n    /// generated the error in the first place.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let nul_error = CString::new(\"foo\\0bar\").unwrap_err();\n    /// assert_eq!(nul_error.into_vec(), b\"foo\\0bar\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_vec(self) -> Vec<u8> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Error for NulError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for NulError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<NulError> for io::Error {\n    /// Converts a [`NulError`] into a [`io::Error`].\n    ///\n    /// [`NulError`]: ../ffi/struct.NulError.html\n    /// [`io::Error`]: ../io/struct.Error.html\n    fn from(_: NulError) -> io::Error {\n}\n}\n\n#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\nimpl Error for FromBytesWithNulError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\nimpl fmt::Display for FromBytesWithNulError {\n    #[allow(deprecated, deprecated_in_future)]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl IntoStringError {\n    /// Consumes this error, returning original [`CString`] which generated the\n    /// error.\n    ///\n    /// [`CString`]: struct.CString.html\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn into_cstring(self) -> CString {\n}\n\n    /// Access the underlying UTF-8 error that was the cause of this error.\n    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n    pub fn utf8_error(&self) -> Utf8Error {\n}\n}\n\n#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\nimpl Error for IntoStringError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n\n    fn source(&self) -> Option<&(dyn Error + 'static)> {\n}\n}\n\n#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\nimpl fmt::Display for IntoStringError {\n    #[allow(deprecated, deprecated_in_future)]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl CStr {\n    /// Wraps a raw C string with a safe C string wrapper.\n    ///\n    /// This function will wrap the provided `ptr` with a `CStr` wrapper, which\n    /// allows inspection and interoperation of non-owned C strings. The total\n    /// size of the raw C string must be smaller than `isize::MAX` **bytes**\n    /// in memory due to calling the `slice::from_raw_parts` function.\n    /// This method is unsafe for a number of reasons:\n    ///\n    /// * There is no guarantee to the validity of `ptr`.\n    /// * The returned lifetime is not guaranteed to be the actual lifetime of\n    ///   `ptr`.\n    /// * There is no guarantee that the memory pointed to by `ptr` contains a\n    ///   valid nul terminator byte at the end of the string.\n    /// * It is not guaranteed that the memory pointed by `ptr` won't change\n    ///   before the `CStr` has been destroyed.\n    ///\n    /// > **Note**: This operation is intended to be a 0-cost cast but it is\n    /// > currently implemented with an up-front calculation of the length of\n    /// > the string. This is not guaranteed to always be the case.\n    ///\n    /// # Examples\n    ///\n    /// ```ignore (extern-declaration)\n    /// # fn main() {\n    /// use std::ffi::CStr;\n    /// use std::os::raw::c_char;\n    ///\n    /// extern {\n    ///     fn my_string() -> *const c_char;\n    /// }\n    ///\n    /// unsafe {\n    ///     let slice = CStr::from_ptr(my_string());\n    ///     println!(\"string returned: {}\", slice.to_str().unwrap());\n    /// }\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr {\n}\n\n    /// Creates a C string wrapper from a byte slice.\n    ///\n    /// This function will cast the provided `bytes` to a `CStr`\n    /// wrapper after ensuring that the byte slice is nul-terminated\n    /// and does not contain any interior nul bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"hello\\0\");\n    /// assert!(cstr.is_ok());\n    /// ```\n    ///\n    /// Creating a `CStr` without a trailing nul terminator is an error:\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"hello\");\n    /// assert!(cstr.is_err());\n    /// ```\n    ///\n    /// Creating a `CStr` with an interior nul byte is an error:\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"he\\0llo\\0\");\n    /// assert!(cstr.is_err());\n    /// ```\n    #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n    pub fn from_bytes_with_nul(bytes: &[u8]) -> Result<&CStr, FromBytesWithNulError> {\n}\n\n    /// Unsafely creates a C string wrapper from a byte slice.\n    ///\n    /// This function will cast the provided `bytes` to a `CStr` wrapper without\n    /// performing any sanity checks. The provided slice **must** be nul-terminated\n    /// and not contain any interior nul bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{CStr, CString};\n    ///\n    /// unsafe {\n    ///     let cstring = CString::new(\"hello\").expect(\"CString::new failed\");\n    ///     let cstr = CStr::from_bytes_with_nul_unchecked(cstring.to_bytes_with_nul());\n    ///     assert_eq!(cstr, &*cstring);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n    #[rustc_const_unstable(feature = \"const_cstr_unchecked\", issue = \"none\")]\n    pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n}\n\n    /// Returns the inner pointer to this C string.\n    ///\n    /// The returned pointer will be valid for as long as `self` is, and points\n    /// to a contiguous region of memory terminated with a 0 byte to represent\n    /// the end of the string.\n    ///\n    /// **WARNING**\n    ///\n    /// The returned pointer is read-only; writing to it (including passing it\n    /// to C code that writes to it) causes undefined behavior.\n    ///\n    /// It is your responsibility to make sure that the underlying memory is not\n    /// freed too early. For example, the following code will cause undefined\n    /// behavior when `ptr` is used inside the `unsafe` block:\n    ///\n    /// ```no_run\n    /// # #![allow(unused_must_use)]\n    /// use std::ffi::CString;\n    ///\n    /// let ptr = CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr();\n    /// unsafe {\n    ///     // `ptr` is dangling\n    ///     *ptr;\n    /// }\n    /// ```\n    ///\n    /// This happens because the pointer returned by `as_ptr` does not carry any\n    /// lifetime information and the [`CString`] is deallocated immediately after\n    /// the `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()` expression is evaluated.\n    /// To fix the problem, bind the `CString` to a local variable:\n    ///\n    /// ```no_run\n    /// # #![allow(unused_must_use)]\n    /// use std::ffi::CString;\n    ///\n    /// let hello = CString::new(\"Hello\").expect(\"CString::new failed\");\n    /// let ptr = hello.as_ptr();\n    /// unsafe {\n    ///     // `ptr` is valid because `hello` is in scope\n    ///     *ptr;\n    /// }\n    /// ```\n    ///\n    /// This way, the lifetime of the `CString` in `hello` encompasses\n    /// the lifetime of `ptr` and the `unsafe` block.\n    ///\n    /// [`CString`]: struct.CString.html\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_str_as_ptr\", since = \"1.32.0\")]\n    pub const fn as_ptr(&self) -> *const c_char {\n}\n\n    /// Converts this C string to a byte slice.\n    ///\n    /// The returned slice will **not** contain the trailing nul terminator that this C\n    /// string has.\n    ///\n    /// > **Note**: This method is currently implemented as a constant-time\n    /// > cast, but it is planned to alter its definition in the future to\n    /// > perform the length calculation whenever this method is called.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n    /// assert_eq!(cstr.to_bytes(), b\"foo\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_bytes(&self) -> &[u8] {\n}\n\n    /// Converts this C string to a byte slice containing the trailing 0 byte.\n    ///\n    /// This function is the equivalent of [`to_bytes`] except that it will retain\n    /// the trailing nul terminator instead of chopping it off.\n    ///\n    /// > **Note**: This method is currently implemented as a 0-cost cast, but\n    /// > it is planned to alter its definition in the future to perform the\n    /// > length calculation whenever this method is called.\n    ///\n    /// [`to_bytes`]: #method.to_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n    /// assert_eq!(cstr.to_bytes_with_nul(), b\"foo\\0\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_bytes_with_nul(&self) -> &[u8] {\n}\n\n    /// Yields a [`&str`] slice if the `CStr` contains valid UTF-8.\n    ///\n    /// If the contents of the `CStr` are valid UTF-8 data, this\n    /// function will return the corresponding [`&str`] slice. Otherwise,\n    /// it will return an error with details of where UTF-8 validation failed.\n    ///\n    /// [`&str`]: ../primitive.str.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n    /// assert_eq!(cstr.to_str(), Ok(\"foo\"));\n    /// ```\n    #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n    pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n}\n\n    /// Converts a `CStr` into a [`Cow`]`<`[`str`]`>`.\n    ///\n    /// If the contents of the `CStr` are valid UTF-8 data, this\n    /// function will return a [`Cow`]`::`[`Borrowed`]`(`[`&str`]`)`\n    /// with the corresponding [`&str`] slice. Otherwise, it will\n    /// replace any invalid UTF-8 sequences with\n    /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n    /// [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result.\n    ///\n    /// [`Cow`]: ../borrow/enum.Cow.html\n    /// [`Borrowed`]: ../borrow/enum.Cow.html#variant.Borrowed\n    /// [`Owned`]: ../borrow/enum.Cow.html#variant.Owned\n    /// [`str`]: ../primitive.str.html\n    /// [`String`]: ../string/struct.String.html\n    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n    ///\n    /// # Examples\n    ///\n    /// Calling `to_string_lossy` on a `CStr` containing valid UTF-8:\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"Hello World\\0\")\n    ///                  .expect(\"CStr::from_bytes_with_nul failed\");\n    /// assert_eq!(cstr.to_string_lossy(), Cow::Borrowed(\"Hello World\"));\n    /// ```\n    ///\n    /// Calling `to_string_lossy` on a `CStr` containing invalid UTF-8:\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    /// use std::ffi::CStr;\n    ///\n    /// let cstr = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\")\n    ///                  .expect(\"CStr::from_bytes_with_nul failed\");\n    /// assert_eq!(\n    ///     cstr.to_string_lossy(),\n    ///     Cow::Owned(String::from(\"Hello �World\")) as Cow<'_, str>\n    /// );\n    /// ```\n    #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n}\n\n    /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n    ///\n    /// [`Box`]: ../boxed/struct.Box.html\n    /// [`CString`]: struct.CString.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::CString;\n    ///\n    /// let c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\n    /// let boxed = c_string.into_boxed_c_str();\n    /// assert_eq!(boxed.into_c_string(), CString::new(\"foo\").expect(\"CString::new failed\"));\n    /// ```\n    #[stable(feature = \"into_boxed_c_str\", since = \"1.20.0\")]\n    pub fn into_c_string(self: Box<CStr>) -> CString {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for CStr {\n    fn eq(&self, other: &CStr) -> bool {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for CStr {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for CStr {\n    fn partial_cmp(&self, other: &CStr) -> Option<Ordering> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for CStr {\n    fn cmp(&self, other: &CStr) -> Ordering {\n}\n}\n\n#[stable(feature = \"cstr_borrow\", since = \"1.3.0\")]\nimpl ToOwned for CStr {\n    type Owned = CString;\n\n    fn to_owned(&self) -> CString {\n}\n}\n\n#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\nimpl From<&CStr> for CString {\n    fn from(s: &CStr) -> CString {\n}\n}\n\n#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\nimpl ops::Index<ops::RangeFull> for CString {\n    type Output = CStr;\n\n    #[inline]\n    fn index(&self, _index: ops::RangeFull) -> &CStr {\n}\n}\n\n#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\nimpl AsRef<CStr> for CStr {\n    #[inline]\n    fn as_ref(&self) -> &CStr {\n}\n}\n\n#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\nimpl AsRef<CStr> for CString {\n    #[inline]\n    fn as_ref(&self) -> &CStr {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod os_str {\nuse crate::borrow::{Borrow, Cow};\nuse crate::cmp;\nuse crate::fmt;\nuse crate::hash::{Hash, Hasher};\nuse crate::ops;\nuse crate::rc::Rc;\nuse crate::sync::Arc;\n\nuse crate::sys::os_str::{Buf, Slice};\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\n\n/// A type that can represent owned, mutable platform-native strings, but is\n/// cheaply inter-convertible with Rust strings.\n///\n/// The need for this type arises from the fact that:\n///\n/// * On Unix systems, strings are often arbitrary sequences of non-zero\n///   bytes, in many cases interpreted as UTF-8.\n///\n/// * On Windows, strings are often arbitrary sequences of non-zero 16-bit\n///   values, interpreted as UTF-16 when it is valid to do so.\n///\n/// * In Rust, strings are always valid UTF-8, which may contain zeros.\n///\n/// `OsString` and [`OsStr`] bridge this gap by simultaneously representing Rust\n/// and platform-native string values, and in particular allowing a Rust string\n/// to be converted into an \"OS\" string with no cost if possible. A consequence\n/// of this is that `OsString` instances are *not* `NUL` terminated; in order\n/// to pass to e.g., Unix system call, you should create a [`CStr`].\n///\n/// `OsString` is to [`&OsStr`] as [`String`] is to [`&str`]: the former\n/// in each pair are owned strings; the latter are borrowed\n/// references.\n///\n/// Note, `OsString` and [`OsStr`] internally do not necessarily hold strings in\n/// the form native to the platform; While on Unix, strings are stored as a\n/// sequence of 8-bit values, on Windows, where strings are 16-bit value based\n/// as just discussed, strings are also actually stored as a sequence of 8-bit\n/// values, encoded in a less-strict variant of UTF-8. This is useful to\n/// understand when handling capacity and length values.\n///\n/// # Creating an `OsString`\n///\n/// **From a Rust string**: `OsString` implements\n/// [`From`]`<`[`String`]`>`, so you can use `my_string.from` to\n/// create an `OsString` from a normal Rust string.\n///\n/// **From slices:** Just like you can start with an empty Rust\n/// [`String`] and then [`push_str`][String.push_str] `&str`\n/// sub-string slices into it, you can create an empty `OsString` with\n/// the [`new`] method and then push string slices into it with the\n/// [`push`] method.\n///\n/// # Extracting a borrowed reference to the whole OS string\n///\n/// You can use the [`as_os_str`] method to get an `&`[`OsStr`] from\n/// an `OsString`; this is effectively a borrowed reference to the\n/// whole string.\n///\n/// # Conversions\n///\n/// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n/// the traits which `OsString` implements for [conversions] from/to native representations.\n///\n/// [`OsStr`]: struct.OsStr.html\n/// [`&OsStr`]: struct.OsStr.html\n/// [`CStr`]: struct.CStr.html\n/// [`From`]: ../convert/trait.From.html\n/// [`String`]: ../string/struct.String.html\n/// [`&str`]: ../primitive.str.html\n/// [`u8`]: ../primitive.u8.html\n/// [`u16`]: ../primitive.u16.html\n/// [String.push_str]: ../string/struct.String.html#method.push_str\n/// [`new`]: #method.new\n/// [`push`]: #method.push\n/// [`as_os_str`]: #method.as_os_str\n/// [conversions]: index.html#conversions\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct OsString {\n    inner: Buf,\n}\n\n/// Borrowed reference to an OS string (see [`OsString`]).\n///\n/// This type represents a borrowed reference to a string in the operating system's preferred\n/// representation.\n///\n/// `&OsStr` is to [`OsString`] as [`&str`] is to [`String`]: the former in each pair are borrowed\n/// references; the latter are owned strings.\n///\n/// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n/// the traits which `OsStr` implements for [conversions] from/to native representations.\n///\n/// [`OsString`]: struct.OsString.html\n/// [`&str`]: ../primitive.str.html\n/// [`String`]: ../string/struct.String.html\n/// [conversions]: index.html#conversions\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n// FIXME:\n// `OsStr::from_inner` current implementation relies\n// on `OsStr` being layout-compatible with `Slice`.\n// When attribute privacy is implemented, `OsStr` should be annotated as `#[repr(transparent)]`.\n// Anyway, `OsStr` representation and layout are considered implementation detail, are\n// not documented and must not be relied upon.\npub struct OsStr {\n    inner: Slice,\n}\n\nimpl OsString {\n    /// Constructs a new empty `OsString`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let os_string = OsString::new();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> OsString {\n}\n\n    /// Converts to an [`OsStr`] slice.\n    ///\n    /// [`OsStr`]: struct.OsStr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{OsString, OsStr};\n    ///\n    /// let os_string = OsString::from(\"foo\");\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert_eq!(os_string.as_os_str(), os_str);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_os_str(&self) -> &OsStr {\n}\n\n    /// Converts the `OsString` into a [`String`] if it contains valid Unicode data.\n    ///\n    /// On failure, ownership of the original `OsString` is returned.\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let os_string = OsString::from(\"foo\");\n    /// let string = os_string.into_string();\n    /// assert_eq!(string, Ok(String::from(\"foo\")));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_string(self) -> Result<String, OsString> {\n}\n\n    /// Extends the string with the given [`&OsStr`] slice.\n    ///\n    /// [`&OsStr`]: struct.OsStr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut os_string = OsString::from(\"foo\");\n    /// os_string.push(\"bar\");\n    /// assert_eq!(&os_string, \"foobar\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push<T: AsRef<OsStr>>(&mut self, s: T) {\n}\n\n    /// Creates a new `OsString` with the given capacity.\n    ///\n    /// The string will be able to hold exactly `capacity` length units of other\n    /// OS strings without reallocating. If `capacity` is 0, the string will not\n    /// allocate.\n    ///\n    /// See main `OsString` documentation information about encoding.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut os_string = OsString::with_capacity(10);\n    /// let capacity = os_string.capacity();\n    ///\n    /// // This push is done without reallocating\n    /// os_string.push(\"foo\");\n    ///\n    /// assert_eq!(capacity, os_string.capacity());\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn with_capacity(capacity: usize) -> OsString {\n}\n\n    /// Truncates the `OsString` to zero length.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut os_string = OsString::from(\"foo\");\n    /// assert_eq!(&os_string, \"foo\");\n    ///\n    /// os_string.clear();\n    /// assert_eq!(&os_string, \"\");\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn clear(&mut self) {\n}\n\n    /// Returns the capacity this `OsString` can hold without reallocating.\n    ///\n    /// See `OsString` introduction for information about encoding.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let os_string = OsString::with_capacity(10);\n    /// assert!(os_string.capacity() >= 10);\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn capacity(&self) -> usize {\n}\n\n    /// Reserves capacity for at least `additional` more capacity to be inserted\n    /// in the given `OsString`.\n    ///\n    /// The collection may reserve more space to avoid frequent reallocations.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::new();\n    /// s.reserve(10);\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n}\n\n    /// Reserves the minimum capacity for exactly `additional` more capacity to\n    /// be inserted in the given `OsString`. Does nothing if the capacity is\n    /// already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it\n    /// requests. Therefore, capacity can not be relied upon to be precisely\n    /// minimal. Prefer reserve if future insertions are expected.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::new();\n    /// s.reserve_exact(10);\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn reserve_exact(&mut self, additional: usize) {\n}\n\n    /// Shrinks the capacity of the `OsString` to match its length.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::from(\"foo\");\n    ///\n    /// s.reserve(100);\n    /// assert!(s.capacity() >= 100);\n    ///\n    /// s.shrink_to_fit();\n    /// assert_eq!(3, s.capacity());\n    /// ```\n    #[stable(feature = \"osstring_shrink_to_fit\", since = \"1.19.0\")]\n    pub fn shrink_to_fit(&mut self) {\n}\n\n    /// Shrinks the capacity of the `OsString` with a lower bound.\n    ///\n    /// The capacity will remain at least as large as both the length\n    /// and the supplied value.\n    ///\n    /// Panics if the current capacity is smaller than the supplied\n    /// minimum capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(shrink_to)]\n    /// use std::ffi::OsString;\n    ///\n    /// let mut s = OsString::from(\"foo\");\n    ///\n    /// s.reserve(100);\n    /// assert!(s.capacity() >= 100);\n    ///\n    /// s.shrink_to(10);\n    /// assert!(s.capacity() >= 10);\n    /// s.shrink_to(0);\n    /// assert!(s.capacity() >= 3);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n}\n\n    /// Converts this `OsString` into a boxed [`OsStr`].\n    ///\n    /// [`OsStr`]: struct.OsStr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{OsString, OsStr};\n    ///\n    /// let s = OsString::from(\"hello\");\n    ///\n    /// let b: Box<OsStr> = s.into_boxed_os_str();\n    /// ```\n    #[stable(feature = \"into_boxed_os_str\", since = \"1.20.0\")]\n    pub fn into_boxed_os_str(self) -> Box<OsStr> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<String> for OsString {\n    /// Converts a [`String`] into a [`OsString`].\n    ///\n    /// The conversion copies the data, and includes an allocation on the heap.\n    ///\n    /// [`OsString`]: ../../std/ffi/struct.OsString.html\n    fn from(s: String) -> OsString {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + AsRef<OsStr>> From<&T> for OsString {\n    fn from(s: &T) -> OsString {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::RangeFull> for OsString {\n    type Output = OsStr;\n\n    #[inline]\n    fn index(&self, _index: ops::RangeFull) -> &OsStr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Deref for OsString {\n    type Target = OsStr;\n\n    #[inline]\n    fn deref(&self) -> &OsStr {\n}\n}\n\n#[stable(feature = \"osstring_default\", since = \"1.9.0\")]\nimpl Default for OsString {\n    /// Constructs an empty `OsString`.\n    #[inline]\n    fn default() -> OsString {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for OsString {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for OsString {\n    fn eq(&self, other: &OsString) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq<str> for OsString {\n    fn eq(&self, other: &str) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq<OsString> for str {\n    fn eq(&self, other: &OsString) -> bool {\n}\n}\n\n#[stable(feature = \"os_str_str_ref_eq\", since = \"1.29.0\")]\nimpl PartialEq<&str> for OsString {\n    fn eq(&self, other: &&str) -> bool {\n}\n}\n\n#[stable(feature = \"os_str_str_ref_eq\", since = \"1.29.0\")]\nimpl<'a> PartialEq<OsString> for &'a str {\n    fn eq(&self, other: &OsString) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for OsString {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for OsString {\n    #[inline]\n    fn partial_cmp(&self, other: &OsString) -> Option<cmp::Ordering> {\n}\n    #[inline]\n    fn lt(&self, other: &OsString) -> bool {\n}\n    #[inline]\n    fn le(&self, other: &OsString) -> bool {\n}\n    #[inline]\n    fn gt(&self, other: &OsString) -> bool {\n}\n    #[inline]\n    fn ge(&self, other: &OsString) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd<str> for OsString {\n    #[inline]\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for OsString {\n    #[inline]\n    fn cmp(&self, other: &OsString) -> cmp::Ordering {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Hash for OsString {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n}\n}\n\nimpl OsStr {\n    /// Coerces into an `OsStr` slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &OsStr {\n}\n\n    #[inline]\n    fn from_inner(inner: &Slice) -> &OsStr {\n}\n\n    /// Yields a [`&str`] slice if the `OsStr` is valid Unicode.\n    ///\n    /// This conversion may entail doing a check for UTF-8 validity.\n    ///\n    /// [`&str`]: ../../std/primitive.str.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert_eq!(os_str.to_str(), Some(\"foo\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_str(&self) -> Option<&str> {\n}\n\n    /// Converts an `OsStr` to a [`Cow`]`<`[`str`]`>`.\n    ///\n    /// Any non-Unicode sequences are replaced with\n    /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n    ///\n    /// [`Cow`]: ../../std/borrow/enum.Cow.html\n    /// [`str`]: ../../std/primitive.str.html\n    /// [U+FFFD]: ../../std/char/constant.REPLACEMENT_CHARACTER.html\n    ///\n    /// # Examples\n    ///\n    /// Calling `to_string_lossy` on an `OsStr` with invalid unicode:\n    ///\n    /// ```\n    /// // Note, due to differences in how Unix and Windows represent strings,\n    /// // we are forced to complicate this example, setting up example `OsStr`s\n    /// // with different source data and via different platform extensions.\n    /// // Understand that in reality you could end up with such example invalid\n    /// // sequences simply through collecting user command line arguments, for\n    /// // example.\n    ///\n    /// #[cfg(any(unix, target_os = \"redox\"))] {\n    ///     use std::ffi::OsStr;\n    ///     use std::os::unix::ffi::OsStrExt;\n    ///\n    ///     // Here, the values 0x66 and 0x6f correspond to 'f' and 'o'\n    ///     // respectively. The value 0x80 is a lone continuation byte, invalid\n    ///     // in a UTF-8 sequence.\n    ///     let source = [0x66, 0x6f, 0x80, 0x6f];\n    ///     let os_str = OsStr::from_bytes(&source[..]);\n    ///\n    ///     assert_eq!(os_str.to_string_lossy(), \"fo�o\");\n    /// }\n    /// #[cfg(windows)] {\n    ///     use std::ffi::OsString;\n    ///     use std::os::windows::prelude::*;\n    ///\n    ///     // Here the values 0x0066 and 0x006f correspond to 'f' and 'o'\n    ///     // respectively. The value 0xD800 is a lone surrogate half, invalid\n    ///     // in a UTF-16 sequence.\n    ///     let source = [0x0066, 0x006f, 0xD800, 0x006f];\n    ///     let os_string = OsString::from_wide(&source[..]);\n    ///     let os_str = os_string.as_os_str();\n    ///\n    ///     assert_eq!(os_str.to_string_lossy(), \"fo�o\");\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n}\n\n    /// Copies the slice into an owned [`OsString`].\n    ///\n    /// [`OsString`]: struct.OsString.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::{OsStr, OsString};\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// let os_string = os_str.to_os_string();\n    /// assert_eq!(os_string, OsString::from(\"foo\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_os_string(&self) -> OsString {\n}\n\n    /// Checks whether the `OsStr` is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"\");\n    /// assert!(os_str.is_empty());\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert!(!os_str.is_empty());\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n}\n\n    /// Returns the length of this `OsStr`.\n    ///\n    /// Note that this does **not** return the number of bytes in the string in\n    /// OS string form.\n    ///\n    /// The length returned is that of the underlying storage used by `OsStr`.\n    /// As discussed in the [`OsString`] introduction, [`OsString`] and `OsStr`\n    /// store strings in a form best suited for cheap inter-conversion between\n    /// native-platform and Rust string forms, which may differ significantly\n    /// from both of them, including in storage size and encoding.\n    ///\n    /// This number is simply useful for passing to other methods, like\n    /// [`OsString::with_capacity`] to avoid reallocations.\n    ///\n    /// [`OsString`]: struct.OsString.html\n    /// [`OsString::with_capacity`]: struct.OsString.html#method.with_capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ffi::OsStr;\n    ///\n    /// let os_str = OsStr::new(\"\");\n    /// assert_eq!(os_str.len(), 0);\n    ///\n    /// let os_str = OsStr::new(\"foo\");\n    /// assert_eq!(os_str.len(), 3);\n    /// ```\n    #[stable(feature = \"osstring_simple_functions\", since = \"1.9.0\")]\n    pub fn len(&self) -> usize {\n}\n\n    /// Converts a [`Box`]`<OsStr>` into an [`OsString`] without copying or allocating.\n    ///\n    /// [`Box`]: ../boxed/struct.Box.html\n    /// [`OsString`]: struct.OsString.html\n    #[stable(feature = \"into_boxed_os_str\", since = \"1.20.0\")]\n    pub fn into_os_string(self: Box<OsStr>) -> OsString {\n}\n\n    /// Gets the underlying byte representation.\n    ///\n    /// Note: it is *crucial* that this API is private, to avoid\n    /// revealing the internal, platform-specific encodings.\n    #[inline]\n    fn bytes(&self) -> &[u8] {\n}\n}\n\n#[stable(feature = \"box_from_os_str\", since = \"1.17.0\")]\nimpl From<&OsStr> for Box<OsStr> {\n    fn from(s: &OsStr) -> Box<OsStr> {\n}\n}\n\n#[stable(feature = \"os_string_from_box\", since = \"1.18.0\")]\nimpl From<Box<OsStr>> for OsString {\n    /// Converts a [`Box`]`<`[`OsStr`]`>` into a `OsString` without copying or\n    /// allocating.\n    ///\n    /// [`Box`]: ../boxed/struct.Box.html\n    /// [`OsStr`]: ../ffi/struct.OsStr.html\n    fn from(boxed: Box<OsStr>) -> OsString {\n}\n}\n\n#[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\nimpl From<OsString> for Box<OsStr> {\n    /// Converts a [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n    ///\n    /// [`Box`]: ../boxed/struct.Box.html\n    /// [`OsString`]: ../ffi/struct.OsString.html\n    fn from(s: OsString) -> Box<OsStr> {\n}\n}\n\n#[stable(feature = \"more_box_slice_clone\", since = \"1.29.0\")]\nimpl Clone for Box<OsStr> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<OsString> for Arc<OsStr> {\n    /// Converts a [`OsString`] into a [`Arc`]`<OsStr>` without copying or allocating.\n    ///\n    /// [`Arc`]: ../sync/struct.Arc.html\n    /// [`OsString`]: ../ffi/struct.OsString.html\n    #[inline]\n    fn from(s: OsString) -> Arc<OsStr> {\n}\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<&OsStr> for Arc<OsStr> {\n    #[inline]\n    fn from(s: &OsStr) -> Arc<OsStr> {\n}\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<OsString> for Rc<OsStr> {\n    /// Converts a [`OsString`] into a [`Rc`]`<OsStr>` without copying or allocating.\n    ///\n    /// [`Rc`]: ../rc/struct.Rc.html\n    /// [`OsString`]: ../ffi/struct.OsString.html\n    #[inline]\n    fn from(s: OsString) -> Rc<OsStr> {\n}\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<&OsStr> for Rc<OsStr> {\n    #[inline]\n    fn from(s: &OsStr) -> Rc<OsStr> {\n}\n}\n\n#[stable(feature = \"cow_from_osstr\", since = \"1.28.0\")]\nimpl<'a> From<OsString> for Cow<'a, OsStr> {\n    #[inline]\n    fn from(s: OsString) -> Cow<'a, OsStr> {\n}\n}\n\n#[stable(feature = \"cow_from_osstr\", since = \"1.28.0\")]\nimpl<'a> From<&'a OsStr> for Cow<'a, OsStr> {\n    #[inline]\n    fn from(s: &'a OsStr) -> Cow<'a, OsStr> {\n}\n}\n\n#[stable(feature = \"cow_from_osstr\", since = \"1.28.0\")]\nimpl<'a> From<&'a OsString> for Cow<'a, OsStr> {\n    #[inline]\n    fn from(s: &'a OsString) -> Cow<'a, OsStr> {\n}\n}\n\n#[stable(feature = \"osstring_from_cow_osstr\", since = \"1.28.0\")]\nimpl<'a> From<Cow<'a, OsStr>> for OsString {\n    #[inline]\n    fn from(s: Cow<'a, OsStr>) -> Self {\n}\n}\n\n#[stable(feature = \"box_default_extra\", since = \"1.17.0\")]\nimpl Default for Box<OsStr> {\n    fn default() -> Box<OsStr> {\n}\n}\n\n#[stable(feature = \"osstring_default\", since = \"1.9.0\")]\nimpl Default for &OsStr {\n    /// Creates an empty `OsStr`.\n    #[inline]\n    fn default() -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for OsStr {\n    #[inline]\n    fn eq(&self, other: &OsStr) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq<str> for OsStr {\n    #[inline]\n    fn eq(&self, other: &str) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq<OsStr> for str {\n    #[inline]\n    fn eq(&self, other: &OsStr) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for OsStr {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for OsStr {\n    #[inline]\n    fn partial_cmp(&self, other: &OsStr) -> Option<cmp::Ordering> {\n}\n    #[inline]\n    fn lt(&self, other: &OsStr) -> bool {\n}\n    #[inline]\n    fn le(&self, other: &OsStr) -> bool {\n}\n    #[inline]\n    fn gt(&self, other: &OsStr) -> bool {\n}\n    #[inline]\n    fn ge(&self, other: &OsStr) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd<str> for OsStr {\n    #[inline]\n    fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {\n}\n}\n\n// FIXME (#19470): cannot provide PartialOrd<OsStr> for str until we\n// have more flexible coherence rules.\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for OsStr {\n    #[inline]\n    fn cmp(&self, other: &OsStr) -> cmp::Ordering {\n}\n}\n\nmacro_rules! impl_cmp {\n    ($lhs:ty, $rhs: ty) => {\n        #[stable(feature = \"cmp_os_str\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialEq<$rhs> for $lhs {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool {\n}\n        }\n\n        #[stable(feature = \"cmp_os_str\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool {\n}\n        }\n\n        #[stable(feature = \"cmp_os_str\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$rhs> for $lhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$rhs) -> Option<cmp::Ordering> {\n}\n        }\n\n        #[stable(feature = \"cmp_os_str\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$lhs> for $rhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$lhs) -> Option<cmp::Ordering> {\n}\n        }\n    };\n}\n\nimpl_cmp!(OsString, OsStr);\nimpl_cmp!(OsString, &'a OsStr);\nimpl_cmp!(Cow<'a, OsStr>, OsStr);\nimpl_cmp!(Cow<'a, OsStr>, &'b OsStr);\nimpl_cmp!(Cow<'a, OsStr>, OsString);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Hash for OsStr {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for OsStr {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl OsStr {\n    pub(crate) fn display(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Borrow<OsStr> for OsString {\n    fn borrow(&self) -> &OsStr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToOwned for OsStr {\n    type Owned = OsString;\n    fn to_owned(&self) -> OsString {\n}\n    fn clone_into(&self, target: &mut OsString) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for OsStr {\n    fn as_ref(&self) -> &OsStr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for OsString {\n    #[inline]\n    fn as_ref(&self) -> &OsStr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for str {\n    #[inline]\n    fn as_ref(&self) -> &OsStr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for String {\n    #[inline]\n    fn as_ref(&self) -> &OsStr {\n}\n}\n\nimpl FromInner<Buf> for OsString {\n    fn from_inner(buf: Buf) -> OsString {\n}\n}\n\nimpl IntoInner<Buf> for OsString {\n    fn into_inner(self) -> Buf {\n}\n}\n\nimpl AsInner<Slice> for OsStr {\n    #[inline]\n    fn as_inner(&self) -> &Slice {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\n}\npub mod fs {\n// ignore-tidy-filelength\n\n//! Filesystem manipulation operations.\n//!\n//! This module contains basic methods to manipulate the contents of the local\n//! filesystem. All methods in this module represent cross-platform filesystem\n//! operations. Extra platform-specific functionality can be found in the\n//! extension traits of `std::os::$platform`.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::ffi::OsString;\nuse crate::fmt;\nuse crate::io::{self, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write};\nuse crate::path::{Path, PathBuf};\nuse crate::sys::fs as fs_imp;\nuse crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\nuse crate::time::SystemTime;\n\n/// A reference to an open file on the filesystem.\n///\n/// An instance of a `File` can be read and/or written depending on what options\n/// it was opened with. Files also implement [`Seek`] to alter the logical cursor\n/// that the file contains internally.\n///\n/// Files are automatically closed when they go out of scope.  Errors detected\n/// on closing are ignored by the implementation of `Drop`.  Use the method\n/// [`sync_all`] if these errors must be manually handled.\n///\n/// # Examples\n///\n/// Creates a new file and write bytes to it (you can also use [`write`]):\n///\n/// ```no_run\n/// use std::fs::File;\n/// use std::io::prelude::*;\n///\n/// fn main() -> std::io::Result<()> {\n///     let mut file = File::create(\"foo.txt\")?;\n///     file.write_all(b\"Hello, world!\")?;\n///     Ok(())\n/// }\n/// ```\n///\n/// Read the contents of a file into a [`String`] (you can also use [`read`]):\n///\n/// ```no_run\n/// use std::fs::File;\n/// use std::io::prelude::*;\n///\n/// fn main() -> std::io::Result<()> {\n///     let mut file = File::open(\"foo.txt\")?;\n///     let mut contents = String::new();\n///     file.read_to_string(&mut contents)?;\n///     assert_eq!(contents, \"Hello, world!\");\n///     Ok(())\n/// }\n/// ```\n///\n/// It can be more efficient to read the contents of a file with a buffered\n/// [`Read`]er. This can be accomplished with [`BufReader<R>`]:\n///\n/// ```no_run\n/// use std::fs::File;\n/// use std::io::BufReader;\n/// use std::io::prelude::*;\n///\n/// fn main() -> std::io::Result<()> {\n///     let file = File::open(\"foo.txt\")?;\n///     let mut buf_reader = BufReader::new(file);\n///     let mut contents = String::new();\n///     buf_reader.read_to_string(&mut contents)?;\n///     assert_eq!(contents, \"Hello, world!\");\n///     Ok(())\n/// }\n/// ```\n///\n/// Note that, although read and write methods require a `&mut File`, because\n/// of the interfaces for [`Read`] and [`Write`], the holder of a `&File` can\n/// still modify the file, either through methods that take `&File` or by\n/// retrieving the underlying OS object and modifying the file that way.\n/// Additionally, many operating systems allow concurrent modification of files\n/// by different processes. Avoid assuming that holding a `&File` means that the\n/// file will not change.\n///\n/// [`Seek`]: ../io/trait.Seek.html\n/// [`String`]: ../string/struct.String.html\n/// [`Read`]: ../io/trait.Read.html\n/// [`Write`]: ../io/trait.Write.html\n/// [`BufReader<R>`]: ../io/struct.BufReader.html\n/// [`sync_all`]: struct.File.html#method.sync_all\n/// [`read`]: fn.read.html\n/// [`write`]: fn.write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct File {\n    inner: fs_imp::File,\n}\n\n/// Metadata information about a file.\n///\n/// This structure is returned from the [`metadata`] or\n/// [`symlink_metadata`] function or method and represents known\n/// metadata about a file such as its permissions, size, modification\n/// times, etc.\n///\n/// [`metadata`]: fn.metadata.html\n/// [`symlink_metadata`]: fn.symlink_metadata.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct Metadata(fs_imp::FileAttr);\n\n/// Iterator over the entries in a directory.\n///\n/// This iterator is returned from the [`read_dir`] function of this module and\n/// will yield instances of [`io::Result`]`<`[`DirEntry`]`>`. Through a [`DirEntry`]\n/// information like the entry's path and possibly other metadata can be\n/// learned.\n///\n/// The order in which this iterator returns entries is platform and filesystem\n/// dependent.\n///\n/// # Errors\n///\n/// This [`io::Result`] will be an [`Err`] if there's some sort of intermittent\n/// IO error during iteration.\n///\n/// [`read_dir`]: fn.read_dir.html\n/// [`DirEntry`]: struct.DirEntry.html\n/// [`io::Result`]: ../io/type.Result.html\n/// [`Err`]: ../result/enum.Result.html#variant.Err\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct ReadDir(fs_imp::ReadDir);\n\n/// Entries returned by the [`ReadDir`] iterator.\n///\n/// [`ReadDir`]: struct.ReadDir.html\n///\n/// An instance of `DirEntry` represents an entry inside of a directory on the\n/// filesystem. Each entry can be inspected via methods to learn about the full\n/// path or possibly other metadata through per-platform extension traits.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct DirEntry(fs_imp::DirEntry);\n\n/// Options and flags which can be used to configure how a file is opened.\n///\n/// This builder exposes the ability to configure how a [`File`] is opened and\n/// what operations are permitted on the open file. The [`File::open`] and\n/// [`File::create`] methods are aliases for commonly used options using this\n/// builder.\n///\n/// [`File`]: struct.File.html\n/// [`File::open`]: struct.File.html#method.open\n/// [`File::create`]: struct.File.html#method.create\n///\n/// Generally speaking, when using `OpenOptions`, you'll first call [`new`],\n/// then chain calls to methods to set each option, then call [`open`],\n/// passing the path of the file you're trying to open. This will give you a\n/// [`io::Result`][result] with a [`File`][file] inside that you can further\n/// operate on.\n///\n/// [`new`]: struct.OpenOptions.html#method.new\n/// [`open`]: struct.OpenOptions.html#method.open\n/// [result]: ../io/type.Result.html\n/// [file]: struct.File.html\n///\n/// # Examples\n///\n/// Opening a file to read:\n///\n/// ```no_run\n/// use std::fs::OpenOptions;\n///\n/// let file = OpenOptions::new().read(true).open(\"foo.txt\");\n/// ```\n///\n/// Opening a file for both reading and writing, as well as creating it if it\n/// doesn't exist:\n///\n/// ```no_run\n/// use std::fs::OpenOptions;\n///\n/// let file = OpenOptions::new()\n///             .read(true)\n///             .write(true)\n///             .create(true)\n///             .open(\"foo.txt\");\n/// ```\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct OpenOptions(fs_imp::OpenOptions);\n\n/// Representation of the various permissions on a file.\n///\n/// This module only currently provides one bit of information, [`readonly`],\n/// which is exposed on all currently supported platforms. Unix-specific\n/// functionality, such as mode bits, is available through the\n/// [`PermissionsExt`] trait.\n///\n/// [`readonly`]: struct.Permissions.html#method.readonly\n/// [`PermissionsExt`]: ../os/unix/fs/trait.PermissionsExt.html\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Permissions(fs_imp::FilePermissions);\n\n/// A structure representing a type of file with accessors for each file type.\n/// It is returned by [`Metadata::file_type`] method.\n///\n/// [`Metadata::file_type`]: struct.Metadata.html#method.file_type\n#[stable(feature = \"file_type\", since = \"1.1.0\")]\n#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\npub struct FileType(fs_imp::FileType);\n\n/// A builder used to create directories in various manners.\n///\n/// This builder also supports platform-specific options.\n#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n#[derive(Debug)]\npub struct DirBuilder {\n    inner: fs_imp::DirBuilder,\n    recursive: bool,\n}\n\n/// Indicates how large a buffer to pre-allocate before reading the entire file.\nfn initial_buffer_size(file: &File) -> usize {\n}\n\n/// Read the entire contents of a file into a bytes vector.\n///\n/// This is a convenience function for using [`File::open`] and [`read_to_end`]\n/// with fewer imports and without an intermediate variable. It pre-allocates a\n/// buffer based on the file size when available, so it is generally faster than\n/// reading into a vector created with `Vec::new()`.\n///\n/// [`File::open`]: struct.File.html#method.open\n/// [`read_to_end`]: ../io/trait.Read.html#method.read_to_end\n///\n/// # Errors\n///\n/// This function will return an error if `path` does not already exist.\n/// Other errors may also be returned according to [`OpenOptions::open`].\n///\n/// [`OpenOptions::open`]: struct.OpenOptions.html#method.open\n///\n/// It will also return an error if it encounters while reading an error\n/// of a kind other than [`ErrorKind::Interrupted`].\n///\n/// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n/// use std::net::SocketAddr;\n///\n/// fn main() -> Result<(), Box<dyn std::error::Error + 'static>> {\n///     let foo: SocketAddr = String::from_utf8_lossy(&fs::read(\"address.txt\")?).parse()?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"fs_read_write_bytes\", since = \"1.26.0\")]\npub fn read<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {\n}\n\n/// Read the entire contents of a file into a string.\n///\n/// This is a convenience function for using [`File::open`] and [`read_to_string`]\n/// with fewer imports and without an intermediate variable. It pre-allocates a\n/// buffer based on the file size when available, so it is generally faster than\n/// reading into a string created with `String::new()`.\n///\n/// [`File::open`]: struct.File.html#method.open\n/// [`read_to_string`]: ../io/trait.Read.html#method.read_to_string\n///\n/// # Errors\n///\n/// This function will return an error if `path` does not already exist.\n/// Other errors may also be returned according to [`OpenOptions::open`].\n///\n/// [`OpenOptions::open`]: struct.OpenOptions.html#method.open\n///\n/// It will also return an error if it encounters while reading an error\n/// of a kind other than [`ErrorKind::Interrupted`],\n/// or if the contents of the file are not valid UTF-8.\n///\n/// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n/// use std::net::SocketAddr;\n///\n/// fn main() -> Result<(), Box<dyn std::error::Error + 'static>> {\n///     let foo: SocketAddr = fs::read_to_string(\"address.txt\")?.parse()?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"fs_read_write\", since = \"1.26.0\")]\npub fn read_to_string<P: AsRef<Path>>(path: P) -> io::Result<String> {\n}\n\n/// Write a slice as the entire contents of a file.\n///\n/// This function will create a file if it does not exist,\n/// and will entirely replace its contents if it does.\n///\n/// This is a convenience function for using [`File::create`] and [`write_all`]\n/// with fewer imports.\n///\n/// [`File::create`]: struct.File.html#method.create\n/// [`write_all`]: ../io/trait.Write.html#method.write_all\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::write(\"foo.txt\", b\"Lorem ipsum\")?;\n///     fs::write(\"bar.txt\", \"dolor sit\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"fs_read_write_bytes\", since = \"1.26.0\")]\npub fn write<P: AsRef<Path>, C: AsRef<[u8]>>(path: P, contents: C) -> io::Result<()> {\n}\n\nimpl File {\n    /// Attempts to open a file in read-only mode.\n    ///\n    /// See the [`OpenOptions::open`] method for more details.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if `path` does not already exist.\n    /// Other errors may also be returned according to [`OpenOptions::open`].\n    ///\n    /// [`OpenOptions::open`]: struct.OpenOptions.html#method.open\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn open<P: AsRef<Path>>(path: P) -> io::Result<File> {\n}\n\n    /// Opens a file in write-only mode.\n    ///\n    /// This function will create a file if it does not exist,\n    /// and will truncate it if it does.\n    ///\n    /// See the [`OpenOptions::open`] function for more details.\n    ///\n    /// [`OpenOptions::open`]: struct.OpenOptions.html#method.open\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::create(\"foo.txt\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn create<P: AsRef<Path>>(path: P) -> io::Result<File> {\n}\n\n    /// Returns a new OpenOptions object.\n    ///\n    /// This function returns a new OpenOptions object that you can use to\n    /// open or create a file with specific options if `open()` or `create()`\n    /// are not appropriate.\n    ///\n    /// It is equivalent to `OpenOptions::new()` but allows you to write more\n    /// readable code. Instead of `OpenOptions::new().read(true).open(\"foo.txt\")`\n    /// you can write `File::with_options().read(true).open(\"foo.txt\"). This\n    /// also avoids the need to import `OpenOptions`.\n    ///\n    /// See the [`OpenOptions::new`] function for more details.\n    ///\n    /// [`OpenOptions::new`]: struct.OpenOptions.html#method.new\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// #![feature(with_options)]\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::with_options().read(true).open(\"foo.txt\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[unstable(feature = \"with_options\", issue = \"65439\")]\n    pub fn with_options() -> OpenOptions {\n}\n\n    /// Attempts to sync all OS-internal metadata to disk.\n    ///\n    /// This function will attempt to ensure that all in-memory data reaches the\n    /// filesystem before returning.\n    ///\n    /// This can be used to handle errors that would otherwise only be caught\n    /// when the `File` is closed.  Dropping a file will ignore errors in\n    /// synchronizing this in-memory data.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::prelude::*;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::create(\"foo.txt\")?;\n    ///     f.write_all(b\"Hello, world!\")?;\n    ///\n    ///     f.sync_all()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn sync_all(&self) -> io::Result<()> {\n}\n\n    /// This function is similar to [`sync_all`], except that it may not\n    /// synchronize file metadata to the filesystem.\n    ///\n    /// This is intended for use cases that must synchronize content, but don't\n    /// need the metadata on disk. The goal of this method is to reduce disk\n    /// operations.\n    ///\n    /// Note that some platforms may simply implement this in terms of\n    /// [`sync_all`].\n    ///\n    /// [`sync_all`]: struct.File.html#method.sync_all\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::prelude::*;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::create(\"foo.txt\")?;\n    ///     f.write_all(b\"Hello, world!\")?;\n    ///\n    ///     f.sync_data()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn sync_data(&self) -> io::Result<()> {\n}\n\n    /// Truncates or extends the underlying file, updating the size of\n    /// this file to become `size`.\n    ///\n    /// If the `size` is less than the current file's size, then the file will\n    /// be shrunk. If it is greater than the current file's size, then the file\n    /// will be extended to `size` and have all of the intermediate data filled\n    /// in with 0s.\n    ///\n    /// The file's cursor isn't changed. In particular, if the cursor was at the\n    /// end and the file is shrunk using this operation, the cursor will now be\n    /// past the end.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the file is not opened for writing.\n    /// Also, std::io::ErrorKind::InvalidInput will be returned if the desired\n    /// length would cause an overflow due to the implementation specifics.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::create(\"foo.txt\")?;\n    ///     f.set_len(10)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Note that this method alters the content of the underlying file, even\n    /// though it takes `&self` rather than `&mut self`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set_len(&self, size: u64) -> io::Result<()> {\n}\n\n    /// Queries metadata about the underlying file.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let metadata = f.metadata()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn metadata(&self) -> io::Result<Metadata> {\n}\n\n    /// Creates a new `File` instance that shares the same underlying file handle\n    /// as the existing `File` instance. Reads, writes, and seeks will affect\n    /// both `File` instances simultaneously.\n    ///\n    /// # Examples\n    ///\n    /// Creates two handles for a file named `foo.txt`:\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///     let file_copy = file.try_clone()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Assuming there’s a file named `foo.txt` with contents `abcdef\\n`, create\n    /// two handles, seek one of them, and read the remaining bytes from the\n    /// other handle:\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::SeekFrom;\n    /// use std::io::prelude::*;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///     let mut file_copy = file.try_clone()?;\n    ///\n    ///     file.seek(SeekFrom::Start(3))?;\n    ///\n    ///     let mut contents = vec![];\n    ///     file_copy.read_to_end(&mut contents)?;\n    ///     assert_eq!(contents, b\"def\\n\");\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"file_try_clone\", since = \"1.9.0\")]\n    pub fn try_clone(&self) -> io::Result<File> {\n}\n\n    /// Changes the permissions on the underlying file.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// This function currently corresponds to the `fchmod` function on Unix and\n    /// the `SetFileInformationByHandle` function on Windows. Note that, this\n    /// [may change in the future][changes].\n    ///\n    /// [changes]: ../io/index.html#platform-specific-behavior\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the user lacks permission change\n    /// attributes on the underlying file. It may also return an error in other\n    /// os-specific unspecified cases.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// fn main() -> std::io::Result<()> {\n    ///     use std::fs::File;\n    ///\n    ///     let file = File::open(\"foo.txt\")?;\n    ///     let mut perms = file.metadata()?.permissions();\n    ///     perms.set_readonly(true);\n    ///     file.set_permissions(perms)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// Note that this method alters the permissions of the underlying file,\n    /// even though it takes `&self` rather than `&mut self`.\n    #[stable(feature = \"set_permissions_atomic\", since = \"1.16.0\")]\n    pub fn set_permissions(&self, perm: Permissions) -> io::Result<()> {\n}\n}\n\nimpl AsInner<fs_imp::File> for File {\n    fn as_inner(&self) -> &fs_imp::File {\n}\n}\nimpl FromInner<fs_imp::File> for File {\n    fn from_inner(f: fs_imp::File) -> File {\n}\n}\nimpl IntoInner<fs_imp::File> for File {\n    fn into_inner(self) -> fs_imp::File {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for File {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for File {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for File {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Seek for File {\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for &File {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for &File {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Seek for &File {\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n}\n}\n\nimpl OpenOptions {\n    /// Creates a blank new set of options ready for configuration.\n    ///\n    /// All options are initially set to `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let mut options = OpenOptions::new();\n    /// let file = options.read(true).open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> OpenOptions {\n}\n\n    /// Sets the option for read access.\n    ///\n    /// This option, when true, will indicate that the file should be\n    /// `read`-able if opened.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().read(true).open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn read(&mut self, read: bool) -> &mut OpenOptions {\n}\n\n    /// Sets the option for write access.\n    ///\n    /// This option, when true, will indicate that the file should be\n    /// `write`-able if opened.\n    ///\n    /// If the file already exists, any write calls on it will overwrite its\n    /// contents, without truncating it.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().write(true).open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write(&mut self, write: bool) -> &mut OpenOptions {\n}\n\n    /// Sets the option for the append mode.\n    ///\n    /// This option, when true, means that writes will append to a file instead\n    /// of overwriting previous contents.\n    /// Note that setting `.write(true).append(true)` has the same effect as\n    /// setting only `.append(true)`.\n    ///\n    /// For most filesystems, the operating system guarantees that all writes are\n    /// atomic: no writes get mangled because another process writes at the same\n    /// time.\n    ///\n    /// One maybe obvious note when using append-mode: make sure that all data\n    /// that belongs together is written to the file in one operation. This\n    /// can be done by concatenating strings before passing them to [`write()`],\n    /// or using a buffered writer (with a buffer of adequate size),\n    /// and calling [`flush()`] when the message is complete.\n    ///\n    /// If a file is opened with both read and append access, beware that after\n    /// opening, and after every write, the position for reading may be set at the\n    /// end of the file. So, before writing, save the current position (using\n    /// [`seek`]`(`[`SeekFrom`]`::`[`Current`]`(0))`), and restore it before the next read.\n    ///\n    /// ## Note\n    ///\n    /// This function doesn't create the file if it doesn't exist. Use the [`create`]\n    /// method to do so.\n    ///\n    /// [`write()`]: ../../std/fs/struct.File.html#method.write\n    /// [`flush()`]: ../../std/fs/struct.File.html#method.flush\n    /// [`seek`]: ../../std/fs/struct.File.html#method.seek\n    /// [`SeekFrom`]: ../../std/io/enum.SeekFrom.html\n    /// [`Current`]: ../../std/io/enum.SeekFrom.html#variant.Current\n    /// [`create`]: #method.create\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().append(true).open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn append(&mut self, append: bool) -> &mut OpenOptions {\n}\n\n    /// Sets the option for truncating a previous file.\n    ///\n    /// If a file is successfully opened with this option set it will truncate\n    /// the file to 0 length if it already exists.\n    ///\n    /// The file must be opened with write access for truncate to work.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().write(true).truncate(true).open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn truncate(&mut self, truncate: bool) -> &mut OpenOptions {\n}\n\n    /// Sets the option for creating a new file.\n    ///\n    /// This option indicates whether a new file will be created if the file\n    /// does not yet already exist.\n    ///\n    /// In order for the file to be created, [`write`] or [`append`] access must\n    /// be used.\n    ///\n    /// [`write`]: #method.write\n    /// [`append`]: #method.append\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().write(true).create(true).open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn create(&mut self, create: bool) -> &mut OpenOptions {\n}\n\n    /// Sets the option to always create a new file.\n    ///\n    /// This option indicates whether a new file will be created.\n    /// No file is allowed to exist at the target location, also no (dangling)\n    /// symlink.\n    ///\n    /// This option is useful because it is atomic. Otherwise between checking\n    /// whether a file exists and creating a new one, the file may have been\n    /// created by another process (a TOCTOU race condition / attack).\n    ///\n    /// If `.create_new(true)` is set, [`.create()`] and [`.truncate()`] are\n    /// ignored.\n    ///\n    /// The file must be opened with write or append access in order to create\n    /// a new file.\n    ///\n    /// [`.create()`]: #method.create\n    /// [`.truncate()`]: #method.truncate\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().write(true)\n    ///                              .create_new(true)\n    ///                              .open(\"foo.txt\");\n    /// ```\n    #[stable(feature = \"expand_open_options2\", since = \"1.9.0\")]\n    pub fn create_new(&mut self, create_new: bool) -> &mut OpenOptions {\n}\n\n    /// Opens a file at `path` with the options specified by `self`.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error under a number of different\n    /// circumstances. Some of these error conditions are listed here, together\n    /// with their [`ErrorKind`]. The mapping to [`ErrorKind`]s is not part of\n    /// the compatibility contract of the function, especially the `Other` kind\n    /// might change to more specific kinds in the future.\n    ///\n    /// * [`NotFound`]: The specified file does not exist and neither `create`\n    ///   or `create_new` is set.\n    /// * [`NotFound`]: One of the directory components of the file path does\n    ///   not exist.\n    /// * [`PermissionDenied`]: The user lacks permission to get the specified\n    ///   access rights for the file.\n    /// * [`PermissionDenied`]: The user lacks permission to open one of the\n    ///   directory components of the specified path.\n    /// * [`AlreadyExists`]: `create_new` was specified and the file already\n    ///   exists.\n    /// * [`InvalidInput`]: Invalid combinations of open options (truncate\n    ///   without write access, no access mode set, etc.).\n    /// * [`Other`]: One of the directory components of the specified file path\n    ///   was not, in fact, a directory.\n    /// * [`Other`]: Filesystem-level errors: full disk, write permission\n    ///   requested on a read-only file system, exceeded disk quota, too many\n    ///   open files, too long filename, too many symbolic links in the\n    ///   specified path (Unix-like systems only), etc.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::OpenOptions;\n    ///\n    /// let file = OpenOptions::new().read(true).open(\"foo.txt\");\n    /// ```\n    ///\n    /// [`ErrorKind`]: ../io/enum.ErrorKind.html\n    /// [`AlreadyExists`]: ../io/enum.ErrorKind.html#variant.AlreadyExists\n    /// [`InvalidInput`]: ../io/enum.ErrorKind.html#variant.InvalidInput\n    /// [`NotFound`]: ../io/enum.ErrorKind.html#variant.NotFound\n    /// [`Other`]: ../io/enum.ErrorKind.html#variant.Other\n    /// [`PermissionDenied`]: ../io/enum.ErrorKind.html#variant.PermissionDenied\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn open<P: AsRef<Path>>(&self, path: P) -> io::Result<File> {\n}\n\n    fn _open(&self, path: &Path) -> io::Result<File> {\n}\n}\n\nimpl AsInner<fs_imp::OpenOptions> for OpenOptions {\n    fn as_inner(&self) -> &fs_imp::OpenOptions {\n}\n}\n\nimpl AsInnerMut<fs_imp::OpenOptions> for OpenOptions {\n    fn as_inner_mut(&mut self) -> &mut fs_imp::OpenOptions {\n}\n}\n\nimpl Metadata {\n    /// Returns the file type for this metadata.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// fn main() -> std::io::Result<()> {\n    ///     use std::fs;\n    ///\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     println!(\"{:?}\", metadata.file_type());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"file_type\", since = \"1.1.0\")]\n    pub fn file_type(&self) -> FileType {\n}\n\n    /// Returns `true` if this metadata is for a directory. The\n    /// result is mutually exclusive to the result of\n    /// [`is_file`], and will be false for symlink metadata\n    /// obtained from [`symlink_metadata`].\n    ///\n    /// [`is_file`]: struct.Metadata.html#method.is_file\n    /// [`symlink_metadata`]: fn.symlink_metadata.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// fn main() -> std::io::Result<()> {\n    ///     use std::fs;\n    ///\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     assert!(!metadata.is_dir());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_dir(&self) -> bool {\n}\n\n    /// Returns `true` if this metadata is for a regular file. The\n    /// result is mutually exclusive to the result of\n    /// [`is_dir`], and will be false for symlink metadata\n    /// obtained from [`symlink_metadata`].\n    ///\n    /// [`is_dir`]: struct.Metadata.html#method.is_dir\n    /// [`symlink_metadata`]: fn.symlink_metadata.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     assert!(metadata.is_file());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_file(&self) -> bool {\n}\n\n    /// Returns the size of the file, in bytes, this metadata is for.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     assert_eq!(0, metadata.len());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> u64 {\n}\n\n    /// Returns the permissions of the file this metadata is for.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     assert!(!metadata.permissions().readonly());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn permissions(&self) -> Permissions {\n}\n\n    /// Returns the last modification time listed in this metadata.\n    ///\n    /// The returned value corresponds to the `mtime` field of `stat` on Unix\n    /// platforms and the `ftLastWriteTime` field on Windows platforms.\n    ///\n    /// # Errors\n    ///\n    /// This field may not be available on all platforms, and will return an\n    /// `Err` on platforms where it is not available.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     if let Ok(time) = metadata.modified() {\n    ///         println!(\"{:?}\", time);\n    ///     } else {\n    ///         println!(\"Not supported on this platform\");\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"fs_time\", since = \"1.10.0\")]\n    pub fn modified(&self) -> io::Result<SystemTime> {\n}\n\n    /// Returns the last access time of this metadata.\n    ///\n    /// The returned value corresponds to the `atime` field of `stat` on Unix\n    /// platforms and the `ftLastAccessTime` field on Windows platforms.\n    ///\n    /// Note that not all platforms will keep this field update in a file's\n    /// metadata, for example Windows has an option to disable updating this\n    /// time when files are accessed and Linux similarly has `noatime`.\n    ///\n    /// # Errors\n    ///\n    /// This field may not be available on all platforms, and will return an\n    /// `Err` on platforms where it is not available.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     if let Ok(time) = metadata.accessed() {\n    ///         println!(\"{:?}\", time);\n    ///     } else {\n    ///         println!(\"Not supported on this platform\");\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"fs_time\", since = \"1.10.0\")]\n    pub fn accessed(&self) -> io::Result<SystemTime> {\n}\n\n    /// Returns the creation time listed in this metadata.\n    ///\n    /// The returned value corresponds to the `btime` field of `statx` on\n    /// Linux kernel starting from to 4.11, the `birthtime` field of `stat` on other\n    /// Unix platforms, and the `ftCreationTime` field on Windows platforms.\n    ///\n    /// # Errors\n    ///\n    /// This field may not be available on all platforms, and will return an\n    /// `Err` on platforms or filesystems where it is not available.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///\n    ///     if let Ok(time) = metadata.created() {\n    ///         println!(\"{:?}\", time);\n    ///     } else {\n    ///         println!(\"Not supported on this platform or filesystem\");\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"fs_time\", since = \"1.10.0\")]\n    pub fn created(&self) -> io::Result<SystemTime> {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Metadata {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl AsInner<fs_imp::FileAttr> for Metadata {\n    fn as_inner(&self) -> &fs_imp::FileAttr {\n}\n}\n\nimpl FromInner<fs_imp::FileAttr> for Metadata {\n    fn from_inner(attr: fs_imp::FileAttr) -> Metadata {\n}\n}\n\nimpl Permissions {\n    /// Returns `true` if these permissions describe a readonly (unwritable) file.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut f = File::create(\"foo.txt\")?;\n    ///     let metadata = f.metadata()?;\n    ///\n    ///     assert_eq!(false, metadata.permissions().readonly());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn readonly(&self) -> bool {\n}\n\n    /// Modifies the readonly flag for this set of permissions. If the\n    /// `readonly` argument is `true`, using the resulting `Permission` will\n    /// update file permissions to forbid writing. Conversely, if it's `false`,\n    /// using the resulting `Permission` will update file permissions to allow\n    /// writing.\n    ///\n    /// This operation does **not** modify the filesystem. To modify the\n    /// filesystem use the [`fs::set_permissions`] function.\n    ///\n    /// [`fs::set_permissions`]: fn.set_permissions.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::create(\"foo.txt\")?;\n    ///     let metadata = f.metadata()?;\n    ///     let mut permissions = metadata.permissions();\n    ///\n    ///     permissions.set_readonly(true);\n    ///\n    ///     // filesystem doesn't change\n    ///     assert_eq!(false, metadata.permissions().readonly());\n    ///\n    ///     // just this particular `permissions`.\n    ///     assert_eq!(true, permissions.readonly());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set_readonly(&mut self, readonly: bool) {\n}\n}\n\nimpl FileType {\n    /// Tests whether this file type represents a directory. The\n    /// result is mutually exclusive to the results of\n    /// [`is_file`] and [`is_symlink`]; only zero or one of these\n    /// tests may pass.\n    ///\n    /// [`is_file`]: struct.FileType.html#method.is_file\n    /// [`is_symlink`]: struct.FileType.html#method.is_symlink\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// fn main() -> std::io::Result<()> {\n    ///     use std::fs;\n    ///\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///     let file_type = metadata.file_type();\n    ///\n    ///     assert_eq!(file_type.is_dir(), false);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"file_type\", since = \"1.1.0\")]\n    pub fn is_dir(&self) -> bool {\n}\n\n    /// Tests whether this file type represents a regular file.\n    /// The result is  mutually exclusive to the results of\n    /// [`is_dir`] and [`is_symlink`]; only zero or one of these\n    /// tests may pass.\n    ///\n    /// [`is_dir`]: struct.FileType.html#method.is_dir\n    /// [`is_symlink`]: struct.FileType.html#method.is_symlink\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// fn main() -> std::io::Result<()> {\n    ///     use std::fs;\n    ///\n    ///     let metadata = fs::metadata(\"foo.txt\")?;\n    ///     let file_type = metadata.file_type();\n    ///\n    ///     assert_eq!(file_type.is_file(), true);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"file_type\", since = \"1.1.0\")]\n    pub fn is_file(&self) -> bool {\n}\n\n    /// Tests whether this file type represents a symbolic link.\n    /// The result is mutually exclusive to the results of\n    /// [`is_dir`] and [`is_file`]; only zero or one of these\n    /// tests may pass.\n    ///\n    /// The underlying [`Metadata`] struct needs to be retrieved\n    /// with the [`fs::symlink_metadata`] function and not the\n    /// [`fs::metadata`] function. The [`fs::metadata`] function\n    /// follows symbolic links, so [`is_symlink`] would always\n    /// return `false` for the target file.\n    ///\n    /// [`Metadata`]: struct.Metadata.html\n    /// [`fs::metadata`]: fn.metadata.html\n    /// [`fs::symlink_metadata`]: fn.symlink_metadata.html\n    /// [`is_dir`]: struct.FileType.html#method.is_dir\n    /// [`is_file`]: struct.FileType.html#method.is_file\n    /// [`is_symlink`]: struct.FileType.html#method.is_symlink\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let metadata = fs::symlink_metadata(\"foo.txt\")?;\n    ///     let file_type = metadata.file_type();\n    ///\n    ///     assert_eq!(file_type.is_symlink(), false);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"file_type\", since = \"1.1.0\")]\n    pub fn is_symlink(&self) -> bool {\n}\n}\n\nimpl AsInner<fs_imp::FileType> for FileType {\n    fn as_inner(&self) -> &fs_imp::FileType {\n}\n}\n\nimpl FromInner<fs_imp::FilePermissions> for Permissions {\n    fn from_inner(f: fs_imp::FilePermissions) -> Permissions {\n}\n}\n\nimpl AsInner<fs_imp::FilePermissions> for Permissions {\n    fn as_inner(&self) -> &fs_imp::FilePermissions {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for ReadDir {\n    type Item = io::Result<DirEntry>;\n\n    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n}\n}\n\nimpl DirEntry {\n    /// Returns the full path to the file that this entry represents.\n    ///\n    /// The full path is created by joining the original path to `read_dir`\n    /// with the filename of this entry.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     for entry in fs::read_dir(\".\")? {\n    ///         let dir = entry?;\n    ///         println!(\"{:?}\", dir.path());\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// This prints output like:\n    ///\n    /// ```text\n    /// \"./whatever.txt\"\n    /// \"./foo.html\"\n    /// \"./hello_world.rs\"\n    /// ```\n    ///\n    /// The exact text, of course, depends on what files you have in `.`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn path(&self) -> PathBuf {\n}\n\n    /// Returns the metadata for the file that this entry points at.\n    ///\n    /// This function will not traverse symlinks if this entry points at a\n    /// symlink.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// On Windows this function is cheap to call (no extra system calls\n    /// needed), but on Unix platforms this function is the equivalent of\n    /// calling `symlink_metadata` on the path.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs;\n    ///\n    /// if let Ok(entries) = fs::read_dir(\".\") {\n    ///     for entry in entries {\n    ///         if let Ok(entry) = entry {\n    ///             // Here, `entry` is a `DirEntry`.\n    ///             if let Ok(metadata) = entry.metadata() {\n    ///                 // Now let's show our entry's permissions!\n    ///                 println!(\"{:?}: {:?}\", entry.path(), metadata.permissions());\n    ///             } else {\n    ///                 println!(\"Couldn't get metadata for {:?}\", entry.path());\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n    pub fn metadata(&self) -> io::Result<Metadata> {\n}\n\n    /// Returns the file type for the file that this entry points at.\n    ///\n    /// This function will not traverse symlinks if this entry points at a\n    /// symlink.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// On Windows and most Unix platforms this function is free (no extra\n    /// system calls needed), but some Unix platforms may require the equivalent\n    /// call to `symlink_metadata` to learn about the target file type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs;\n    ///\n    /// if let Ok(entries) = fs::read_dir(\".\") {\n    ///     for entry in entries {\n    ///         if let Ok(entry) = entry {\n    ///             // Here, `entry` is a `DirEntry`.\n    ///             if let Ok(file_type) = entry.file_type() {\n    ///                 // Now let's show our entry's file type!\n    ///                 println!(\"{:?}: {:?}\", entry.path(), file_type);\n    ///             } else {\n    ///                 println!(\"Couldn't get file type for {:?}\", entry.path());\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n    pub fn file_type(&self) -> io::Result<FileType> {\n}\n\n    /// Returns the bare file name of this directory entry without any other\n    /// leading path component.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs;\n    ///\n    /// if let Ok(entries) = fs::read_dir(\".\") {\n    ///     for entry in entries {\n    ///         if let Ok(entry) = entry {\n    ///             // Here, `entry` is a `DirEntry`.\n    ///             println!(\"{:?}\", entry.file_name());\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n    pub fn file_name(&self) -> OsString {\n}\n}\n\n#[stable(feature = \"dir_entry_debug\", since = \"1.13.0\")]\nimpl fmt::Debug for DirEntry {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl AsInner<fs_imp::DirEntry> for DirEntry {\n    fn as_inner(&self) -> &fs_imp::DirEntry {\n}\n}\n\n/// Removes a file from the filesystem.\n///\n/// Note that there is no\n/// guarantee that the file is immediately deleted (e.g., depending on\n/// platform, other open file descriptors may prevent immediate removal).\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `unlink` function on Unix\n/// and the `DeleteFile` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * `path` points to a directory.\n/// * The user lacks permissions to remove the file.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::remove_file(\"a.txt\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> {\n}\n\n/// Given a path, query the file system to get information about a file,\n/// directory, etc.\n///\n/// This function will traverse symbolic links to query information about the\n/// destination file.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `stat` function on Unix\n/// and the `GetFileAttributesEx` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * The user lacks permissions to perform `metadata` call on `path`.\n/// * `path` does not exist.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     let attr = fs::metadata(\"/some/file/path.txt\")?;\n///     // inspect attr ...\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n}\n\n/// Query the metadata about a file without following symlinks.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `lstat` function on Unix\n/// and the `GetFileAttributesEx` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * The user lacks permissions to perform `metadata` call on `path`.\n/// * `path` does not exist.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     let attr = fs::symlink_metadata(\"/some/file/path.txt\")?;\n///     // inspect attr ...\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"symlink_metadata\", since = \"1.1.0\")]\npub fn symlink_metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n}\n\n/// Rename a file or directory to a new name, replacing the original file if\n/// `to` already exists.\n///\n/// This will not work if the new name is on a different mount point.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `rename` function on Unix\n/// and the `MoveFileEx` function with the `MOVEFILE_REPLACE_EXISTING` flag on Windows.\n///\n/// Because of this, the behavior when both `from` and `to` exist differs. On\n/// Unix, if `from` is a directory, `to` must also be an (empty) directory. If\n/// `from` is not a directory, `to` must also be not a directory. In contrast,\n/// on Windows, `from` can be anything, but `to` must *not* be a directory.\n///\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * `from` does not exist.\n/// * The user lacks permissions to view contents.\n/// * `from` and `to` are on separate filesystems.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::rename(\"a.txt\", \"b.txt\")?; // Rename a.txt to b.txt\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()> {\n}\n\n/// Copies the contents of one file to another. This function will also\n/// copy the permission bits of the original file to the destination file.\n///\n/// This function will **overwrite** the contents of `to`.\n///\n/// Note that if `from` and `to` both point to the same file, then the file\n/// will likely get truncated by this operation.\n///\n/// On success, the total number of bytes copied is returned and it is equal to\n/// the length of the `to` file as reported by `metadata`.\n///\n/// If you’re wanting to copy the contents of one file to another and you’re\n/// working with [`File`]s, see the [`io::copy`] function.\n///\n/// [`io::copy`]: ../io/fn.copy.html\n/// [`File`]: ./struct.File.html\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `open` function in Unix\n/// with `O_RDONLY` for `from` and `O_WRONLY`, `O_CREAT`, and `O_TRUNC` for `to`.\n/// `O_CLOEXEC` is set for returned file descriptors.\n/// On Windows, this function currently corresponds to `CopyFileEx`. Alternate\n/// NTFS streams are copied but only the size of the main stream is returned by\n/// this function. On MacOS, this function corresponds to `fclonefileat` and\n/// `fcopyfile`.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * The `from` path is not a file.\n/// * The `from` file does not exist.\n/// * The current process does not have the permission rights to access\n///   `from` or write `to`.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::copy(\"foo.txt\", \"bar.txt\")?;  // Copy foo.txt to bar.txt\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n}\n\n/// Creates a new hard link on the filesystem.\n///\n/// The `dst` path will be a link pointing to the `src` path. Note that systems\n/// often require these two paths to both be located on the same filesystem.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `link` function on Unix\n/// and the `CreateHardLink` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * The `src` path is not a file or doesn't exist.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::hard_link(\"a.txt\", \"b.txt\")?; // Hard link a.txt to b.txt\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n}\n\n/// Creates a new symbolic link on the filesystem.\n///\n/// The `dst` path will be a symbolic link pointing to the `src` path.\n/// On Windows, this will be a file symlink, not a directory symlink;\n/// for this reason, the platform-specific [`std::os::unix::fs::symlink`]\n/// and [`std::os::windows::fs::symlink_file`] or [`symlink_dir`] should be\n/// used instead to make the intent explicit.\n///\n/// [`std::os::unix::fs::symlink`]: ../os/unix/fs/fn.symlink.html\n/// [`std::os::windows::fs::symlink_file`]: ../os/windows/fs/fn.symlink_file.html\n/// [`symlink_dir`]: ../os/windows/fs/fn.symlink_dir.html\n///\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::soft_link(\"a.txt\", \"b.txt\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"1.1.0\",\n    reason = \"replaced with std::os::unix::fs::symlink and \\\n              std::os::windows::fs::{symlink_file, symlink_dir}\"\n)]\npub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n}\n\n/// Reads a symbolic link, returning the file that the link points to.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `readlink` function on Unix\n/// and the `CreateFile` function with `FILE_FLAG_OPEN_REPARSE_POINT` and\n/// `FILE_FLAG_BACKUP_SEMANTICS` flags on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * `path` is not a symbolic link.\n/// * `path` does not exist.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     let path = fs::read_link(\"a.txt\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n}\n\n/// Returns the canonical, absolute form of a path with all intermediate\n/// components normalized and symbolic links resolved.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `realpath` function on Unix\n/// and the `CreateFile` and `GetFinalPathNameByHandle` functions on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// On Windows, this converts the path to use [extended length path][path]\n/// syntax, which allows your program to use longer path names, but means you\n/// can only join backslash-delimited paths to it, and it may be incompatible\n/// with other applications (if passed to the application on the command-line,\n/// or written to a file another application may read).\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n/// [path]: https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * `path` does not exist.\n/// * A non-final component in path is not a directory.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     let path = fs::canonicalize(\"../a/../foo.txt\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"fs_canonicalize\", since = \"1.5.0\")]\npub fn canonicalize<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n}\n\n/// Creates a new, empty directory at the provided path\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `mkdir` function on Unix\n/// and the `CreateDirectory` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// **NOTE**: If a parent of the given path doesn't exist, this function will\n/// return an error. To create a directory and all its missing parents at the\n/// same time, use the [`create_dir_all`] function.\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * User lacks permissions to create directory at `path`.\n/// * A parent of the given path doesn't exist. (To create a directory and all\n///   its missing parents at the same time, use the [`create_dir_all`]\n///   function.)\n/// * `path` already exists.\n///\n/// [`create_dir_all`]: fn.create_dir_all.html\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::create_dir(\"/some/dir\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n}\n\n/// Recursively create a directory and all of its parent components if they\n/// are missing.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `mkdir` function on Unix\n/// and the `CreateDirectory` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * If any directory in the path specified by `path`\n/// does not already exist and it could not be created otherwise. The specific\n/// error conditions for when a directory is being created (after it is\n/// determined to not exist) are outlined by [`fs::create_dir`].\n///\n/// Notable exception is made for situations where any of the directories\n/// specified in the `path` could not be created as it was being created concurrently.\n/// Such cases are considered to be successful. That is, calling `create_dir_all`\n/// concurrently from multiple threads or processes is guaranteed not to fail\n/// due to a race condition with itself.\n///\n/// [`fs::create_dir`]: fn.create_dir.html\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::create_dir_all(\"/some/dir\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n}\n\n/// Removes an existing, empty directory.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `rmdir` function on Unix\n/// and the `RemoveDirectory` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * The user lacks permissions to remove the directory at the provided `path`.\n/// * The directory isn't empty.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::remove_dir(\"/some/dir\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n}\n\n/// Removes a directory at this path, after removing all its contents. Use\n/// carefully!\n///\n/// This function does **not** follow symbolic links and it will simply remove the\n/// symbolic link itself.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to `opendir`, `lstat`, `rm` and `rmdir` functions on Unix\n/// and the `FindFirstFile`, `GetFileAttributesEx`, `DeleteFile`, and `RemoveDirectory` functions\n/// on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// # Errors\n///\n/// See [`fs::remove_file`] and [`fs::remove_dir`].\n///\n/// [`fs::remove_file`]:  fn.remove_file.html\n/// [`fs::remove_dir`]: fn.remove_dir.html\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     fs::remove_dir_all(\"/some/dir\")?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n}\n\n/// Returns an iterator over the entries within a directory.\n///\n/// The iterator will yield instances of [`io::Result`]`<`[`DirEntry`]`>`.\n/// New errors may be encountered after an iterator is initially constructed.\n///\n/// [`io::Result`]: ../io/type.Result.html\n/// [`DirEntry`]: struct.DirEntry.html\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `opendir` function on Unix\n/// and the `FindFirstFile` function on Windows. Advancing the iterator\n/// currently corresponds to `readdir` on Unix and `FindNextFile` on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// The order in which this iterator returns entries is platform and filesystem\n/// dependent.\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * The provided `path` doesn't exist.\n/// * The process lacks permissions to view the contents.\n/// * The `path` points at a non-directory file.\n///\n/// # Examples\n///\n/// ```\n/// use std::io;\n/// use std::fs::{self, DirEntry};\n/// use std::path::Path;\n///\n/// // one possible implementation of walking a directory only visiting files\n/// fn visit_dirs(dir: &Path, cb: &dyn Fn(&DirEntry)) -> io::Result<()> {\n///     if dir.is_dir() {\n///         for entry in fs::read_dir(dir)? {\n///             let entry = entry?;\n///             let path = entry.path();\n///             if path.is_dir() {\n///                 visit_dirs(&path, cb)?;\n///             } else {\n///                 cb(&entry);\n///             }\n///         }\n///     }\n///     Ok(())\n/// }\n/// ```\n///\n/// ```rust,no_run\n/// use std::{fs, io};\n///\n/// fn main() -> io::Result<()> {\n///     let mut entries = fs::read_dir(\".\")?\n///         .map(|res| res.map(|e| e.path()))\n///         .collect::<Result<Vec<_>, io::Error>>()?;\n///\n///     // The order in which `read_dir` returns entries is not guaranteed. If reproducible\n///     // ordering is required the entries should be explicitly sorted.\n///\n///     entries.sort();\n///\n///     // The entries have now been sorted by their path.\n///\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> {\n}\n\n/// Changes the permissions found on a file or a directory.\n///\n/// # Platform-specific behavior\n///\n/// This function currently corresponds to the `chmod` function on Unix\n/// and the `SetFileAttributes` function on Windows.\n/// Note that, this [may change in the future][changes].\n///\n/// [changes]: ../io/index.html#platform-specific-behavior\n///\n/// # Errors\n///\n/// This function will return an error in the following situations, but is not\n/// limited to just these cases:\n///\n/// * `path` does not exist.\n/// * The user lacks the permission to change attributes of the file.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::fs;\n///\n/// fn main() -> std::io::Result<()> {\n///     let mut perms = fs::metadata(\"foo.txt\")?.permissions();\n///     perms.set_readonly(true);\n///     fs::set_permissions(\"foo.txt\", perms)?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"set_permissions\", since = \"1.1.0\")]\npub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions) -> io::Result<()> {\n}\n\nimpl DirBuilder {\n    /// Creates a new set of options with default mode/security settings for all\n    /// platforms and also non-recursive.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs::DirBuilder;\n    ///\n    /// let builder = DirBuilder::new();\n    /// ```\n    #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n    pub fn new() -> DirBuilder {\n}\n\n    /// Indicates that directories should be created recursively, creating all\n    /// parent directories. Parents that do not exist are created with the same\n    /// security and permissions settings.\n    ///\n    /// This option defaults to `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fs::DirBuilder;\n    ///\n    /// let mut builder = DirBuilder::new();\n    /// builder.recursive(true);\n    /// ```\n    #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n    pub fn recursive(&mut self, recursive: bool) -> &mut Self {\n}\n\n    /// Creates the specified directory with the options configured in this\n    /// builder.\n    ///\n    /// It is considered an error if the directory already exists unless\n    /// recursive mode is enabled.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::{self, DirBuilder};\n    ///\n    /// let path = \"/tmp/foo/bar/baz\";\n    /// DirBuilder::new()\n    ///     .recursive(true)\n    ///     .create(path).unwrap();\n    ///\n    /// assert!(fs::metadata(path).unwrap().is_dir());\n    /// ```\n    #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n    pub fn create<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n}\n\n    fn _create(&self, path: &Path) -> io::Result<()> {\n}\n\n    fn create_dir_all(&self, path: &Path) -> io::Result<()> {\n}\n}\n\nimpl AsInnerMut<fs_imp::DirBuilder> for DirBuilder {\n    fn as_inner_mut(&mut self) -> &mut fs_imp::DirBuilder {\n}\n}\n\n#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\nmod tests {\n    use crate::io::prelude::*;\n\n    use crate::fs::{self, File, OpenOptions};\n    use crate::io::{ErrorKind, SeekFrom};\n    use crate::path::Path;\n    use crate::str;\n    use crate::sys_common::io::test::{tmpdir, TempDir};\n    use crate::thread;\n\n    use rand::{rngs::StdRng, RngCore, SeedableRng};\n\n    #[cfg(unix)]\n    use crate::os::unix::fs::symlink as symlink_dir;\n    #[cfg(unix)]\n    use crate::os::unix::fs::symlink as symlink_file;\n    #[cfg(unix)]\n    use crate::os::unix::fs::symlink as symlink_junction;\n    #[cfg(windows)]\n    use crate::os::windows::fs::{symlink_dir, symlink_file};\n    #[cfg(windows)]\n    use crate::sys::fs::symlink_junction;\n\n    macro_rules! check {\n        ($e:expr) => {\n            match $e {\n                Ok(t) => t,\n                Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n            }\n        };\n    }\n\n    #[cfg(windows)]\n    macro_rules! error {\n        ($e:expr, $s:expr) => {\n            match $e {\n                Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n                Err(ref err) => assert!(\n                    err.raw_os_error() == Some($s),\n                    format!(\"`{}` did not have a code of `{}`\", err, $s)\n                ),\n            }\n        };\n    }\n\n    #[cfg(unix)]\n    macro_rules! error {\n        ($e:expr, $s:expr) => {\n            error_contains!($e, $s)\n        };\n    }\n\n    macro_rules! error_contains {\n        ($e:expr, $s:expr) => {\n            match $e {\n                Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n                Err(ref err) => assert!(\n                    err.to_string().contains($s),\n                    format!(\"`{}` did not contain `{}`\", err, $s)\n                ),\n            }\n        };\n    }\n\n    // Several test fail on windows if the user does not have permission to\n    // create symlinks (the `SeCreateSymbolicLinkPrivilege`). Instead of\n    // disabling these test on Windows, use this function to test whether we\n    // have permission, and return otherwise. This way, we still don't run these\n    // tests most of the time, but at least we do if the user has the right\n    // permissions.\n    pub fn got_symlink_permission(tmpdir: &TempDir) -> bool {\n}\n\n    #[test]\n    fn file_test_io_smoke_test() {\n}\n\n    #[test]\n    fn invalid_path_raises() {\n}\n\n    #[test]\n    fn file_test_iounlinking_invalid_path_should_raise_condition() {\n}\n\n    #[test]\n    fn file_test_io_non_positional_read() {\n}\n\n    #[test]\n    fn file_test_io_seek_and_tell_smoke_test() {\n}\n\n    #[test]\n    fn file_test_io_seek_and_write() {\n}\n\n    #[test]\n    fn file_test_io_seek_shakedown() {\n}\n\n    #[test]\n    fn file_test_io_eof() {\n}\n\n    #[test]\n    #[cfg(unix)]\n    fn file_test_io_read_write_at() {\n}\n\n    #[test]\n    #[cfg(unix)]\n    fn set_get_unix_permissions() {\n}\n\n    #[test]\n    #[cfg(windows)]\n    fn file_test_io_seek_read_write() {\n}\n\n    #[test]\n    fn file_test_stat_is_correct_on_is_file() {\n}\n\n    #[test]\n    fn file_test_stat_is_correct_on_is_dir() {\n}\n\n    #[test]\n    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n}\n\n    #[test]\n    fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n}\n\n    #[test]\n    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n}\n\n    #[test]\n    fn file_test_directoryinfo_readdir() {\n}\n\n    #[test]\n    fn file_create_new_already_exists_error() {\n}\n\n    #[test]\n    fn mkdir_path_already_exists_error() {\n}\n\n    #[test]\n    fn recursive_mkdir() {\n}\n\n    #[test]\n    fn recursive_mkdir_failure() {\n}\n\n    #[test]\n    fn concurrent_recursive_mkdir() {\n}\n\n    #[test]\n    fn recursive_mkdir_slash() {\n}\n\n    #[test]\n    fn recursive_mkdir_dot() {\n}\n\n    #[test]\n    fn recursive_mkdir_empty() {\n}\n\n    #[test]\n    fn recursive_rmdir() {\n}\n\n    #[test]\n    fn recursive_rmdir_of_symlink() {\n}\n\n    #[test]\n    // only Windows makes a distinction between file and directory symlinks.\n    #[cfg(windows)]\n    fn recursive_rmdir_of_file_symlink() {\n}\n\n    #[test]\n    fn unicode_path_is_dir() {\n}\n\n    #[test]\n    fn unicode_path_exists() {\n}\n\n    #[test]\n    fn copy_file_does_not_exist() {\n}\n\n    #[test]\n    fn copy_src_does_not_exist() {\n}\n\n    #[test]\n    fn copy_file_ok() {\n}\n\n    #[test]\n    fn copy_file_dst_dir() {\n}\n\n    #[test]\n    fn copy_file_dst_exists() {\n}\n\n    #[test]\n    fn copy_file_src_dir() {\n}\n\n    #[test]\n    fn copy_file_preserves_perm_bits() {\n}\n\n    #[test]\n    #[cfg(windows)]\n    fn copy_file_preserves_streams() {\n}\n\n    #[test]\n    fn copy_file_returns_metadata_len() {\n}\n\n    #[test]\n    fn copy_file_follows_dst_symlink() {\n}\n\n    #[test]\n    fn symlinks_work() {\n}\n\n    #[test]\n    fn symlink_noexist() {\n}\n\n    #[test]\n    fn read_link() {\n}\n\n    #[test]\n    fn readlink_not_symlink() {\n}\n\n    #[test]\n    fn links_work() {\n}\n\n    #[test]\n    fn chmod_works() {\n}\n\n    #[test]\n    fn fchmod_works() {\n}\n\n    #[test]\n    fn sync_doesnt_kill_anything() {\n}\n\n    #[test]\n    fn truncate_works() {\n}\n\n    #[test]\n    fn open_flavors() {\n}\n\n    #[test]\n    fn _assert_send_sync() {\n}\n\n    #[test]\n    fn binary_file() {\n}\n\n    #[test]\n    fn write_then_read() {\n}\n\n    #[test]\n    fn file_try_clone() {\n}\n\n    #[test]\n    #[cfg(not(windows))]\n    fn unlink_readonly() {\n}\n\n    #[test]\n    fn mkdir_trailing_slash() {\n}\n\n    #[test]\n    fn canonicalize_works_simple() {\n}\n\n    #[test]\n    fn realpath_works() {\n}\n\n    #[test]\n    fn realpath_works_tricky() {\n}\n\n    #[test]\n    fn dir_entry_methods() {\n}\n\n    #[test]\n    fn dir_entry_debug() {\n}\n\n    #[test]\n    fn read_dir_not_found() {\n}\n\n    #[test]\n    fn create_dir_all_with_junctions() {\n}\n\n    #[test]\n    fn metadata_access_times() {\n}\n}\n}\npub mod io {\n//! Traits, helpers, and type definitions for core I/O functionality.\n//!\n//! The `std::io` module contains a number of common things you'll need\n//! when doing input and output. The most core part of this module is\n//! the [`Read`] and [`Write`] traits, which provide the\n//! most general interface for reading and writing input and output.\n//!\n//! # Read and Write\n//!\n//! Because they are traits, [`Read`] and [`Write`] are implemented by a number\n//! of other types, and you can implement them for your types too. As such,\n//! you'll see a few different types of I/O throughout the documentation in\n//! this module: [`File`]s, [`TcpStream`]s, and sometimes even [`Vec<T>`]s. For\n//! example, [`Read`] adds a [`read`][`Read::read`] method, which we can use on\n//! [`File`]s:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let mut f = File::open(\"foo.txt\")?;\n//!     let mut buffer = [0; 10];\n//!\n//!     // read up to 10 bytes\n//!     let n = f.read(&mut buffer)?;\n//!\n//!     println!(\"The bytes: {:?}\", &buffer[..n]);\n//!     Ok(())\n//! }\n//! ```\n//!\n//! [`Read`] and [`Write`] are so important, implementors of the two traits have a\n//! nickname: readers and writers. So you'll sometimes see 'a reader' instead\n//! of 'a type that implements the [`Read`] trait'. Much easier!\n//!\n//! ## Seek and BufRead\n//!\n//! Beyond that, there are two important traits that are provided: [`Seek`]\n//! and [`BufRead`]. Both of these build on top of a reader to control\n//! how the reading happens. [`Seek`] lets you control where the next byte is\n//! coming from:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::SeekFrom;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let mut f = File::open(\"foo.txt\")?;\n//!     let mut buffer = [0; 10];\n//!\n//!     // skip to the last 10 bytes of the file\n//!     f.seek(SeekFrom::End(-10))?;\n//!\n//!     // read up to 10 bytes\n//!     let n = f.read(&mut buffer)?;\n//!\n//!     println!(\"The bytes: {:?}\", &buffer[..n]);\n//!     Ok(())\n//! }\n//! ```\n//!\n//! [`BufRead`] uses an internal buffer to provide a number of other ways to read, but\n//! to show it off, we'll need to talk about buffers in general. Keep reading!\n//!\n//! ## BufReader and BufWriter\n//!\n//! Byte-based interfaces are unwieldy and can be inefficient, as we'd need to be\n//! making near-constant calls to the operating system. To help with this,\n//! `std::io` comes with two structs, [`BufReader`] and [`BufWriter`], which wrap\n//! readers and writers. The wrapper uses a buffer, reducing the number of\n//! calls and providing nicer methods for accessing exactly what you want.\n//!\n//! For example, [`BufReader`] works with the [`BufRead`] trait to add extra\n//! methods to any reader:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufReader;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let f = File::open(\"foo.txt\")?;\n//!     let mut reader = BufReader::new(f);\n//!     let mut buffer = String::new();\n//!\n//!     // read a line into buffer\n//!     reader.read_line(&mut buffer)?;\n//!\n//!     println!(\"{}\", buffer);\n//!     Ok(())\n//! }\n//! ```\n//!\n//! [`BufWriter`] doesn't add any new ways of writing; it just buffers every call\n//! to [`write`][`Write::write`]:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufWriter;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let f = File::create(\"foo.txt\")?;\n//!     {\n//!         let mut writer = BufWriter::new(f);\n//!\n//!         // write a byte to the buffer\n//!         writer.write(&[42])?;\n//!\n//!     } // the buffer is flushed once writer goes out of scope\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Standard input and output\n//!\n//! A very common source of input is standard input:\n//!\n//! ```no_run\n//! use std::io;\n//!\n//! fn main() -> io::Result<()> {\n//!     let mut input = String::new();\n//!\n//!     io::stdin().read_line(&mut input)?;\n//!\n//!     println!(\"You typed: {}\", input.trim());\n//!     Ok(())\n//! }\n//! ```\n//!\n//! Note that you cannot use the [`?` operator] in functions that do not return\n//! a [`Result<T, E>`][`Result`]. Instead, you can call [`.unwrap()`]\n//! or `match` on the return value to catch any possible errors:\n//!\n//! ```no_run\n//! use std::io;\n//!\n//! let mut input = String::new();\n//!\n//! io::stdin().read_line(&mut input).unwrap();\n//! ```\n//!\n//! And a very common source of output is standard output:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//!\n//! fn main() -> io::Result<()> {\n//!     io::stdout().write(&[42])?;\n//!     Ok(())\n//! }\n//! ```\n//!\n//! Of course, using [`io::stdout`] directly is less common than something like\n//! [`println!`].\n//!\n//! ## Iterator types\n//!\n//! A large number of the structures provided by `std::io` are for various\n//! ways of iterating over I/O. For example, [`Lines`] is used to split over\n//! lines:\n//!\n//! ```no_run\n//! use std::io;\n//! use std::io::prelude::*;\n//! use std::io::BufReader;\n//! use std::fs::File;\n//!\n//! fn main() -> io::Result<()> {\n//!     let f = File::open(\"foo.txt\")?;\n//!     let reader = BufReader::new(f);\n//!\n//!     for line in reader.lines() {\n//!         println!(\"{}\", line?);\n//!     }\n//!     Ok(())\n//! }\n//! ```\n//!\n//! ## Functions\n//!\n//! There are a number of [functions][functions-list] that offer access to various\n//! features. For example, we can use three of these functions to copy everything\n//! from standard input to standard output:\n//!\n//! ```no_run\n//! use std::io;\n//!\n//! fn main() -> io::Result<()> {\n//!     io::copy(&mut io::stdin(), &mut io::stdout())?;\n//!     Ok(())\n//! }\n//! ```\n//!\n//! [functions-list]: #functions-1\n//!\n//! ## io::Result\n//!\n//! Last, but certainly not least, is [`io::Result`]. This type is used\n//! as the return type of many `std::io` functions that can cause an error, and\n//! can be returned from your own functions as well. Many of the examples in this\n//! module use the [`?` operator]:\n//!\n//! ```\n//! use std::io;\n//!\n//! fn read_input() -> io::Result<()> {\n//!     let mut input = String::new();\n//!\n//!     io::stdin().read_line(&mut input)?;\n//!\n//!     println!(\"You typed: {}\", input.trim());\n//!\n//!     Ok(())\n//! }\n//! ```\n//!\n//! The return type of `read_input()`, [`io::Result<()>`][`io::Result`], is a very\n//! common type for functions which don't have a 'real' return value, but do want to\n//! return errors if they happen. In this case, the only purpose of this function is\n//! to read the line and print it, so we use `()`.\n//!\n//! ## Platform-specific behavior\n//!\n//! Many I/O functions throughout the standard library are documented to indicate\n//! what various library or syscalls they are delegated to. This is done to help\n//! applications both understand what's happening under the hood as well as investigate\n//! any possibly unclear semantics. Note, however, that this is informative, not a binding\n//! contract. The implementation of many of these functions are subject to change over\n//! time and may call fewer or more syscalls/library functions.\n//!\n//! [`Read`]: trait.Read.html\n//! [`Write`]: trait.Write.html\n//! [`Seek`]: trait.Seek.html\n//! [`BufRead`]: trait.BufRead.html\n//! [`File`]: ../fs/struct.File.html\n//! [`TcpStream`]: ../net/struct.TcpStream.html\n//! [`Vec<T>`]: ../vec/struct.Vec.html\n//! [`BufReader`]: struct.BufReader.html\n//! [`BufWriter`]: struct.BufWriter.html\n//! [`Write::write`]: trait.Write.html#tymethod.write\n//! [`io::stdout`]: fn.stdout.html\n//! [`println!`]: ../macro.println.html\n//! [`Lines`]: struct.Lines.html\n//! [`io::Result`]: type.Result.html\n//! [`?` operator]: ../../book/appendix-02-operators.html\n//! [`Read::read`]: trait.Read.html#tymethod.read\n//! [`Result`]: ../result/enum.Result.html\n//! [`.unwrap()`]: ../result/enum.Result.html#method.unwrap\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::cmp;\nuse crate::fmt;\nuse crate::memchr;\nuse crate::ops::{Deref, DerefMut};\nuse crate::ptr;\nuse crate::slice;\nuse crate::str;\nuse crate::sys;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::buffered::IntoInnerError;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::buffered::{BufReader, BufWriter, LineWriter};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::cursor::Cursor;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::error::{Error, ErrorKind, Result};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::stdio::{stderr, stdin, stdout, Stderr, Stdin, Stdout};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::stdio::{StderrLock, StdinLock, StdoutLock};\n#[unstable(feature = \"print_internals\", issue = \"none\")]\npub use self::stdio::{_};\n#[unstable(feature = \"libstd_io_internals\", issue = \"42788\")]\n#[doc(no_inline, hidden)]\npub use self::stdio::{s};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::util::{copy, empty, repeat, sink, Empty, Repeat, Sink};\n\nmod buffered {\n//! Buffering wrappers for I/O traits\n\nuse crate::io::prelude::*;\n\nuse crate::cmp;\nuse crate::error;\nuse crate::fmt;\nuse crate::io::{\n    self, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, SeekFrom, DEFAULT_BUF_SIZE,\n};\nuse crate::memchr;\n\n/// The `BufReader<R>` struct adds buffering to any reader.\n///\n/// It can be excessively inefficient to work directly with a [`Read`] instance.\n/// For example, every call to [`read`][`TcpStream::read`] on [`TcpStream`]\n/// results in a system call. A `BufReader<R>` performs large, infrequent reads on\n/// the underlying [`Read`] and maintains an in-memory buffer of the results.\n///\n/// `BufReader<R>` can improve the speed of programs that make *small* and\n/// *repeated* read calls to the same file or network socket. It does not\n/// help when reading very large amounts at once, or reading just one or a few\n/// times. It also provides no advantage when reading from a source that is\n/// already in memory, like a `Vec<u8>`.\n///\n/// When the `BufReader<R>` is dropped, the contents of its buffer will be\n/// discarded. Creating multiple instances of a `BufReader<R>` on the same\n/// stream can cause data loss. Reading from the underlying reader after\n/// unwrapping the `BufReader<R>` with `BufReader::into_inner` can also cause\n/// data loss.\n///\n/// [`Read`]: ../../std/io/trait.Read.html\n/// [`TcpStream::read`]: ../../std/net/struct.TcpStream.html#method.read\n/// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::io::BufReader;\n/// use std::fs::File;\n///\n/// fn main() -> std::io::Result<()> {\n///     let f = File::open(\"log.txt\")?;\n///     let mut reader = BufReader::new(f);\n///\n///     let mut line = String::new();\n///     let len = reader.read_line(&mut line)?;\n///     println!(\"First line is {} bytes long\", len);\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct BufReader<R> {\n    inner: R,\n    buf: Box<[u8]>,\n    pos: usize,\n    cap: usize,\n}\n\nimpl<R: Read> BufReader<R> {\n    /// Creates a new `BufReader<R>` with a default buffer capacity. The default is currently 8 KB,\n    /// but may change in the future.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::open(\"log.txt\")?;\n    ///     let reader = BufReader::new(f);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: R) -> BufReader<R> {\n}\n\n    /// Creates a new `BufReader<R>` with the specified buffer capacity.\n    ///\n    /// # Examples\n    ///\n    /// Creating a buffer with ten bytes of capacity:\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::open(\"log.txt\")?;\n    ///     let reader = BufReader::with_capacity(10, f);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize, inner: R) -> BufReader<R> {\n}\n}\n\nimpl<R> BufReader<R> {\n    /// Gets a reference to the underlying reader.\n    ///\n    /// It is inadvisable to directly read from the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f1 = File::open(\"log.txt\")?;\n    ///     let reader = BufReader::new(f1);\n    ///\n    ///     let f2 = reader.get_ref();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &R {\n}\n\n    /// Gets a mutable reference to the underlying reader.\n    ///\n    /// It is inadvisable to directly read from the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f1 = File::open(\"log.txt\")?;\n    ///     let mut reader = BufReader::new(f1);\n    ///\n    ///     let f2 = reader.get_mut();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut R {\n}\n\n    /// Returns a reference to the internally buffered data.\n    ///\n    /// Unlike `fill_buf`, this will not attempt to fill the buffer if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::{BufReader, BufRead};\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f = File::open(\"log.txt\")?;\n    ///     let mut reader = BufReader::new(f);\n    ///     assert!(reader.buffer().is_empty());\n    ///\n    ///     if reader.fill_buf()?.len() > 0 {\n    ///         assert!(!reader.buffer().is_empty());\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n    pub fn buffer(&self) -> &[u8] {\n}\n\n    /// Unwraps this `BufReader<R>`, returning the underlying reader.\n    ///\n    /// Note that any leftover data in the internal buffer is lost. Therefore,\n    /// a following read from the underlying reader may lead to data loss.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufReader;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let f1 = File::open(\"log.txt\")?;\n    ///     let reader = BufReader::new(f1);\n    ///\n    ///     let f2 = reader.into_inner();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> R {\n}\n\n    /// Invalidates all data in the internal buffer.\n    #[inline]\n    fn discard_buffer(&mut self) {\n}\n}\n\nimpl<R: Seek> BufReader<R> {\n    /// Seeks relative to the current position. If the new position lies within the buffer,\n    /// the buffer will not be flushed, allowing for more efficient seeks.\n    /// This method does not return the location of the underlying reader, so the caller\n    /// must track this information themselves if it is required.\n    #[unstable(feature = \"bufreader_seek_relative\", issue = \"31100\")]\n    pub fn seek_relative(&mut self, offset: i64) -> io::Result<()> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> Read for BufReader<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    // we can't skip unconditionally because of the large buffer case in read.\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> BufRead for BufReader<R> {\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n}\n\n    fn consume(&mut self, amt: usize) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R> fmt::Debug for BufReader<R>\nwhere\n    R: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Seek> Seek for BufReader<R> {\n    /// Seek to an offset, in bytes, in the underlying reader.\n    ///\n    /// The position used for seeking with `SeekFrom::Current(_)` is the\n    /// position the underlying reader would be at if the `BufReader<R>` had no\n    /// internal buffer.\n    ///\n    /// Seeking always discards the internal buffer, even if the seek position\n    /// would otherwise fall within it. This guarantees that calling\n    /// `.into_inner()` immediately after a seek yields the underlying reader\n    /// at the same position.\n    ///\n    /// To seek without discarding the internal buffer, use [`BufReader::seek_relative`].\n    ///\n    /// See [`std::io::Seek`] for more details.\n    ///\n    /// Note: In the edge case where you're seeking with `SeekFrom::Current(n)`\n    /// where `n` minus the internal buffer length overflows an `i64`, two\n    /// seeks will be performed instead of one. If the second seek returns\n    /// `Err`, the underlying reader will be left at the same position it would\n    /// have if you called `seek` with `SeekFrom::Current(0)`.\n    ///\n    /// [`BufReader::seek_relative`]: struct.BufReader.html#method.seek_relative\n    /// [`std::io::Seek`]: trait.Seek.html\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n}\n}\n\n/// Wraps a writer and buffers its output.\n///\n/// It can be excessively inefficient to work directly with something that\n/// implements [`Write`]. For example, every call to\n/// [`write`][`TcpStream::write`] on [`TcpStream`] results in a system call. A\n/// `BufWriter<W>` keeps an in-memory buffer of data and writes it to an underlying\n/// writer in large, infrequent batches.\n///\n/// `BufWriter<W>` can improve the speed of programs that make *small* and\n/// *repeated* write calls to the same file or network socket. It does not\n/// help when writing very large amounts at once, or writing just one or a few\n/// times. It also provides no advantage when writing to a destination that is\n/// in memory, like a `Vec<u8>`.\n///\n/// It is critical to call [`flush`] before `BufWriter<W>` is dropped. Though\n/// dropping will attempt to flush the the contents of the buffer, any errors\n/// that happen in the process of dropping will be ignored. Calling [`flush`]\n/// ensures that the buffer is empty and thus dropping will not even attempt\n/// file operations.\n///\n/// # Examples\n///\n/// Let's write the numbers one through ten to a [`TcpStream`]:\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::net::TcpStream;\n///\n/// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n///\n/// for i in 0..10 {\n///     stream.write(&[i+1]).unwrap();\n/// }\n/// ```\n///\n/// Because we're not buffering, we write each one in turn, incurring the\n/// overhead of a system call per byte written. We can fix this with a\n/// `BufWriter<W>`:\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::io::BufWriter;\n/// use std::net::TcpStream;\n///\n/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n///\n/// for i in 0..10 {\n///     stream.write(&[i+1]).unwrap();\n/// }\n/// stream.flush().unwrap();\n/// ```\n///\n/// By wrapping the stream with a `BufWriter<W>`, these ten writes are all grouped\n/// together by the buffer and will all be written out in one system call when\n/// the `stream` is flushed.\n///\n/// [`Write`]: ../../std/io/trait.Write.html\n/// [`TcpStream::write`]: ../../std/net/struct.TcpStream.html#method.write\n/// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n/// [`flush`]: #method.flush\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct BufWriter<W: Write> {\n    inner: Option<W>,\n    buf: Vec<u8>,\n    // #30888: If the inner writer panics in a call to write, we don't want to\n    // write the buffered data a second time in BufWriter's destructor. This\n    // flag tells the Drop impl if it should skip the flush.\n    panicked: bool,\n}\n\n/// An error returned by `into_inner` which combines an error that\n/// happened while writing out the buffer, and the buffered writer object\n/// which may be used to recover from the condition.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::BufWriter;\n/// use std::net::TcpStream;\n///\n/// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n///\n/// // do stuff with the stream\n///\n/// // we want to get our `TcpStream` back, so let's try:\n///\n/// let stream = match stream.into_inner() {\n///     Ok(s) => s,\n///     Err(e) => {\n///         // Here, e is an IntoInnerError\n///         panic!(\"An error occurred\");\n///     }\n/// };\n/// ```\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoInnerError<W>(W, Error);\n\nimpl<W: Write> BufWriter<W> {\n    /// Creates a new `BufWriter<W>` with a default buffer capacity. The default is currently 8 KB,\n    /// but may change in the future.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: W) -> BufWriter<W> {\n}\n\n    /// Creates a new `BufWriter<W>` with the specified buffer capacity.\n    ///\n    /// # Examples\n    ///\n    /// Creating a buffer with a buffer of a hundred bytes.\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n    /// let mut buffer = BufWriter::with_capacity(100, stream);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize, inner: W) -> BufWriter<W> {\n}\n\n    fn flush_buf(&mut self) -> io::Result<()> {\n}\n\n    /// Gets a reference to the underlying writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // we can use reference just like buffer\n    /// let reference = buffer.get_ref();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &W {\n}\n\n    /// Gets a mutable reference to the underlying writer.\n    ///\n    /// It is inadvisable to directly write to the underlying writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // we can use reference just like buffer\n    /// let reference = buffer.get_mut();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut W {\n}\n\n    /// Returns a reference to the internally buffered data.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // See how many bytes are currently buffered\n    /// let bytes_buffered = buf_writer.buffer().len();\n    /// ```\n    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n    pub fn buffer(&self) -> &[u8] {\n}\n\n    /// Unwraps this `BufWriter<W>`, returning the underlying writer.\n    ///\n    /// The buffer is written out before returning the writer.\n    ///\n    /// # Errors\n    ///\n    /// An `Err` will be returned if an error occurs while flushing the buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // unwrap the TcpStream and flush the buffer\n    /// let stream = buffer.into_inner().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> Write for BufWriter<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> fmt::Debug for BufWriter<W>\nwhere\n    W: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write + Seek> Seek for BufWriter<W> {\n    /// Seek to the offset, in bytes, in the underlying writer.\n    ///\n    /// Seeking always writes out the internal buffer before seeking.\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> Drop for BufWriter<W> {\n    fn drop(&mut self) {\n}\n}\n\nimpl<W> IntoInnerError<W> {\n    /// Returns the error which caused the call to `into_inner()` to fail.\n    ///\n    /// This error was returned when attempting to write the internal buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // do stuff with the stream\n    ///\n    /// // we want to get our `TcpStream` back, so let's try:\n    ///\n    /// let stream = match stream.into_inner() {\n    ///     Ok(s) => s,\n    ///     Err(e) => {\n    ///         // Here, e is an IntoInnerError, let's log the inner error.\n    ///         //\n    ///         // We'll just 'log' to stdout for this example.\n    ///         println!(\"{}\", e.error());\n    ///\n    ///         panic!(\"An unexpected error occurred.\");\n    ///     }\n    /// };\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn error(&self) -> &Error {\n}\n\n    /// Returns the buffered writer instance which generated the error.\n    ///\n    /// The returned object can be used for error recovery, such as\n    /// re-inspecting the buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::BufWriter;\n    /// use std::net::TcpStream;\n    ///\n    /// let mut stream = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n    ///\n    /// // do stuff with the stream\n    ///\n    /// // we want to get our `TcpStream` back, so let's try:\n    ///\n    /// let stream = match stream.into_inner() {\n    ///     Ok(s) => s,\n    ///     Err(e) => {\n    ///         // Here, e is an IntoInnerError, let's re-examine the buffer:\n    ///         let buffer = e.into_inner();\n    ///\n    ///         // do stuff to try to recover\n    ///\n    ///         // afterwards, let's just return the stream\n    ///         buffer.into_inner().unwrap()\n    ///     }\n    /// };\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> W {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W> From<IntoInnerError<W>> for Error {\n    fn from(iie: IntoInnerError<W>) -> Error {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Send + fmt::Debug> error::Error for IntoInnerError<W> {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W> fmt::Display for IntoInnerError<W> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// Wraps a writer and buffers output to it, flushing whenever a newline\n/// (`0x0a`, `'\\n'`) is detected.\n///\n/// The [`BufWriter`][bufwriter] struct wraps a writer and buffers its output.\n/// But it only does this batched write when it goes out of scope, or when the\n/// internal buffer is full. Sometimes, you'd prefer to write each line as it's\n/// completed, rather than the entire buffer at once. Enter `LineWriter`. It\n/// does exactly that.\n///\n/// Like [`BufWriter`][bufwriter], a `LineWriter`’s buffer will also be flushed when the\n/// `LineWriter` goes out of scope or when its internal buffer is full.\n///\n/// [bufwriter]: struct.BufWriter.html\n///\n/// If there's still a partial line in the buffer when the `LineWriter` is\n/// dropped, it will flush those contents.\n///\n/// # Examples\n///\n/// We can use `LineWriter` to write one line at a time, significantly\n/// reducing the number of actual writes to the file.\n///\n/// ```no_run\n/// use std::fs::{self, File};\n/// use std::io::prelude::*;\n/// use std::io::LineWriter;\n///\n/// fn main() -> std::io::Result<()> {\n///     let road_not_taken = b\"I shall be telling this with a sigh\n/// Somewhere ages and ages hence:\n/// Two roads diverged in a wood, and I -\n/// I took the one less traveled by,\n/// And that has made all the difference.\";\n///\n///     let file = File::create(\"poem.txt\")?;\n///     let mut file = LineWriter::new(file);\n///\n///     file.write_all(b\"I shall be telling this with a sigh\")?;\n///\n///     // No bytes are written until a newline is encountered (or\n///     // the internal buffer is filled).\n///     assert_eq!(fs::read_to_string(\"poem.txt\")?, \"\");\n///     file.write_all(b\"\\n\")?;\n///     assert_eq!(\n///         fs::read_to_string(\"poem.txt\")?,\n///         \"I shall be telling this with a sigh\\n\",\n///     );\n///\n///     // Write the rest of the poem.\n///     file.write_all(b\"Somewhere ages and ages hence:\n/// Two roads diverged in a wood, and I -\n/// I took the one less traveled by,\n/// And that has made all the difference.\")?;\n///\n///     // The last line of the poem doesn't end in a newline, so\n///     // we have to flush or drop the `LineWriter` to finish\n///     // writing.\n///     file.flush()?;\n///\n///     // Confirm the whole poem was written.\n///     assert_eq!(fs::read(\"poem.txt\")?, &road_not_taken[..]);\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct LineWriter<W: Write> {\n    inner: BufWriter<W>,\n    need_flush: bool,\n}\n\nimpl<W: Write> LineWriter<W> {\n    /// Creates a new `LineWriter`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///     let file = LineWriter::new(file);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: W) -> LineWriter<W> {\n}\n\n    /// Creates a new `LineWriter` with a specified capacity for the internal\n    /// buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///     let file = LineWriter::with_capacity(100, file);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize, inner: W) -> LineWriter<W> {\n}\n\n    /// Gets a reference to the underlying writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///     let file = LineWriter::new(file);\n    ///\n    ///     let reference = file.get_ref();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &W {\n}\n\n    /// Gets a mutable reference to the underlying writer.\n    ///\n    /// Caution must be taken when calling methods on the mutable reference\n    /// returned as extra writes could corrupt the output stream.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///     let mut file = LineWriter::new(file);\n    ///\n    ///     // we can use reference just like file\n    ///     let reference = file.get_mut();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut W {\n}\n\n    /// Unwraps this `LineWriter`, returning the underlying writer.\n    ///\n    /// The internal buffer is written out before returning the writer.\n    ///\n    /// # Errors\n    ///\n    /// An `Err` will be returned if an error occurs while flushing the buffer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs::File;\n    /// use std::io::LineWriter;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let file = File::create(\"poem.txt\")?;\n    ///\n    ///     let writer: LineWriter<File> = LineWriter::new(file);\n    ///\n    ///     let file: File = writer.into_inner()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> Write for LineWriter<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    // Vectored writes are very similar to the writes above, but adjusted for\n    // the list of buffers that we have to write.\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write> fmt::Debug for LineWriter<W>\nwhere\n    W: fmt::Debug,\n{\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod cursor {\nuse crate::io::prelude::*;\n\nuse crate::cmp;\nuse crate::io::{self, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, SeekFrom};\n\nuse core::convert::TryInto;\n\n/// A `Cursor` wraps an in-memory buffer and provides it with a\n/// [`Seek`] implementation.\n///\n/// `Cursor`s are used with in-memory buffers, anything implementing\n/// `AsRef<[u8]>`, to allow them to implement [`Read`] and/or [`Write`],\n/// allowing these buffers to be used anywhere you might use a reader or writer\n/// that does actual I/O.\n///\n/// The standard library implements some I/O traits on various types which\n/// are commonly used as a buffer, like `Cursor<`[`Vec`]`<u8>>` and\n/// `Cursor<`[`&[u8]`][bytes]`>`.\n///\n/// # Examples\n///\n/// We may want to write bytes to a [`File`] in our production\n/// code, but use an in-memory buffer in our tests. We can do this with\n/// `Cursor`:\n///\n/// [`Seek`]: trait.Seek.html\n/// [`Read`]: ../../std/io/trait.Read.html\n/// [`Write`]: ../../std/io/trait.Write.html\n/// [`Vec`]: ../../std/vec/struct.Vec.html\n/// [bytes]: ../../std/primitive.slice.html\n/// [`File`]: ../fs/struct.File.html\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::io::{self, SeekFrom};\n/// use std::fs::File;\n///\n/// // a library function we've written\n/// fn write_ten_bytes_at_end<W: Write + Seek>(writer: &mut W) -> io::Result<()> {\n///     writer.seek(SeekFrom::End(-10))?;\n///\n///     for i in 0..10 {\n///         writer.write(&[i])?;\n///     }\n///\n///     // all went well\n///     Ok(())\n/// }\n///\n/// # fn foo() -> io::Result<()> {\n/// // Here's some code that uses this library function.\n/// //\n/// // We might want to use a BufReader here for efficiency, but let's\n/// // keep this example focused.\n/// let mut file = File::create(\"foo.txt\")?;\n///\n/// write_ten_bytes_at_end(&mut file)?;\n/// # Ok(())\n/// # }\n///\n/// // now let's write a test\n/// #[test]\n/// fn test_writes_bytes() {\n///     // setting up a real File is much slower than an in-memory buffer,\n///     // let's use a cursor instead\n///     use std::io::Cursor;\n///     let mut buff = Cursor::new(vec![0; 15]);\n///\n///     write_ten_bytes_at_end(&mut buff).unwrap();\n///\n///     assert_eq!(&buff.get_ref()[5..15], &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone, Debug, Default, Eq, PartialEq)]\npub struct Cursor<T> {\n    inner: T,\n    pos: u64,\n}\n\nimpl<T> Cursor<T> {\n    /// Creates a new cursor wrapping the provided underlying in-memory buffer.\n    ///\n    /// Cursor initial position is `0` even if underlying buffer (e.g., `Vec`)\n    /// is not empty. So writing to cursor starts with overwriting `Vec`\n    /// content, not with appending to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let buff = Cursor::new(Vec::new());\n    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n    /// # force_inference(&buff);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(inner: T) -> Cursor<T> {\n}\n\n    /// Consumes this cursor, returning the underlying value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let buff = Cursor::new(Vec::new());\n    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n    /// # force_inference(&buff);\n    ///\n    /// let vec = buff.into_inner();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_inner(self) -> T {\n}\n\n    /// Gets a reference to the underlying value in this cursor.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let buff = Cursor::new(Vec::new());\n    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n    /// # force_inference(&buff);\n    ///\n    /// let reference = buff.get_ref();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_ref(&self) -> &T {\n}\n\n    /// Gets a mutable reference to the underlying value in this cursor.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying value as it may corrupt this cursor's position.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let mut buff = Cursor::new(Vec::new());\n    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n    /// # force_inference(&buff);\n    ///\n    /// let reference = buff.get_mut();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut T {\n}\n\n    /// Returns the current position of this cursor.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    /// use std::io::prelude::*;\n    /// use std::io::SeekFrom;\n    ///\n    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n    ///\n    /// assert_eq!(buff.position(), 0);\n    ///\n    /// buff.seek(SeekFrom::Current(2)).unwrap();\n    /// assert_eq!(buff.position(), 2);\n    ///\n    /// buff.seek(SeekFrom::Current(-1)).unwrap();\n    /// assert_eq!(buff.position(), 1);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn position(&self) -> u64 {\n}\n\n    /// Sets the position of this cursor.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Cursor;\n    ///\n    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n    ///\n    /// assert_eq!(buff.position(), 0);\n    ///\n    /// buff.set_position(2);\n    /// assert_eq!(buff.position(), 2);\n    ///\n    /// buff.set_position(4);\n    /// assert_eq!(buff.position(), 4);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set_position(&mut self, pos: u64) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> io::Seek for Cursor<T>\nwhere\n    T: AsRef<[u8]>,\n{\n    fn seek(&mut self, style: SeekFrom) -> io::Result<u64> {\n}\n\n    fn stream_len(&mut self) -> io::Result<u64> {\n}\n\n    fn stream_position(&mut self) -> io::Result<u64> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Read for Cursor<T>\nwhere\n    T: AsRef<[u8]>,\n{\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> BufRead for Cursor<T>\nwhere\n    T: AsRef<[u8]>,\n{\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n}\n    fn consume(&mut self, amt: usize) {\n}\n}\n\n// Non-resizing write implementation\n#[inline]\nfn slice_write(pos_mut: &mut u64, slice: &mut [u8], buf: &[u8]) -> io::Result<usize> {\n}\n\n#[inline]\nfn slice_write_vectored(\n    pos_mut: &mut u64,\n    slice: &mut [u8],\n    bufs: &[IoSlice<'_>],\n) -> io::Result<usize> {\n}\n\n// Resizing write implementation\nfn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usize> {\n}\n\nfn vec_write_vectored(\n    pos_mut: &mut u64,\n    vec: &mut Vec<u8>,\n    bufs: &[IoSlice<'_>],\n) -> io::Result<usize> {\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Cursor<&mut [u8]> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\n#[stable(feature = \"cursor_mut_vec\", since = \"1.25.0\")]\nimpl Write for Cursor<&mut Vec<u8>> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Cursor<Vec<u8>> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\n#[stable(feature = \"cursor_box_slice\", since = \"1.5.0\")]\nimpl Write for Cursor<Box<[u8]>> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod error {\nuse crate::convert::From;\nuse crate::error;\nuse crate::fmt;\nuse crate::result;\nuse crate::sys;\n\n/// A specialized [`Result`](../result/enum.Result.html) type for I/O\n/// operations.\n///\n/// This type is broadly used across [`std::io`] for any operation which may\n/// produce an error.\n///\n/// This typedef is generally used to avoid writing out [`io::Error`] directly and\n/// is otherwise a direct mapping to [`Result`].\n///\n/// While usual Rust style is to import types directly, aliases of [`Result`]\n/// often are not, to make it easier to distinguish between them. [`Result`] is\n/// generally assumed to be [`std::result::Result`][`Result`], and so users of this alias\n/// will generally use `io::Result` instead of shadowing the prelude's import\n/// of [`std::result::Result`][`Result`].\n///\n/// [`std::io`]: ../io/index.html\n/// [`io::Error`]: ../io/struct.Error.html\n/// [`Result`]: ../result/enum.Result.html\n///\n/// # Examples\n///\n/// A convenience function that bubbles an `io::Result` to its caller:\n///\n/// ```\n/// use std::io;\n///\n/// fn get_string() -> io::Result<String> {\n///     let mut buffer = String::new();\n///\n///     io::stdin().read_line(&mut buffer)?;\n///\n///     Ok(buffer)\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result<T> = result::Result<T, Error>;\n\n/// The error type for I/O operations of the [`Read`], [`Write`], [`Seek`], and\n/// associated traits.\n///\n/// Errors mostly originate from the underlying OS, but custom instances of\n/// `Error` can be created with crafted error messages and a particular value of\n/// [`ErrorKind`].\n///\n/// [`Read`]: ../io/trait.Read.html\n/// [`Write`]: ../io/trait.Write.html\n/// [`Seek`]: ../io/trait.Seek.html\n/// [`ErrorKind`]: enum.ErrorKind.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Error {\n    repr: Repr,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nenum Repr {\n    Os(i32),\n    Simple(ErrorKind),\n    Custom(Box<Custom>),\n}\n\n#[derive(Debug)]\nstruct Custom {\n    kind: ErrorKind,\n    error: Box<dyn error::Error + Send + Sync>,\n}\n\n/// A list specifying general categories of I/O error.\n///\n/// This list is intended to grow over time and it is not recommended to\n/// exhaustively match against it.\n///\n/// It is used with the [`io::Error`] type.\n///\n/// [`io::Error`]: struct.Error.html\n#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\n#[non_exhaustive]\npub enum ErrorKind {\n    /// An entity was not found, often a file.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    NotFound,\n    /// The operation lacked the necessary privileges to complete.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    PermissionDenied,\n    /// The connection was refused by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionRefused,\n    /// The connection was reset by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionReset,\n    /// The connection was aborted (terminated) by the remote server.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ConnectionAborted,\n    /// The network operation failed because it was not connected yet.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    NotConnected,\n    /// A socket address could not be bound because the address is already in\n    /// use elsewhere.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AddrInUse,\n    /// A nonexistent interface was requested or the requested address was not\n    /// local.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AddrNotAvailable,\n    /// The operation failed because a pipe was closed.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    BrokenPipe,\n    /// An entity already exists, often a file.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AlreadyExists,\n    /// The operation needs to block to complete, but the blocking operation was\n    /// requested to not occur.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    WouldBlock,\n    /// A parameter was incorrect.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    InvalidInput,\n    /// Data not valid for the operation were encountered.\n    ///\n    /// Unlike [`InvalidInput`], this typically means that the operation\n    /// parameters were valid, however the error was caused by malformed\n    /// input data.\n    ///\n    /// For example, a function that reads a file into a string will error with\n    /// `InvalidData` if the file's contents are not valid UTF-8.\n    ///\n    /// [`InvalidInput`]: #variant.InvalidInput\n    #[stable(feature = \"io_invalid_data\", since = \"1.2.0\")]\n    InvalidData,\n    /// The I/O operation's timeout expired, causing it to be canceled.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    TimedOut,\n    /// An error returned when an operation could not be completed because a\n    /// call to [`write`] returned [`Ok(0)`].\n    ///\n    /// This typically means that an operation could only succeed if it wrote a\n    /// particular number of bytes but only a smaller number of bytes could be\n    /// written.\n    ///\n    /// [`write`]: ../../std/io/trait.Write.html#tymethod.write\n    /// [`Ok(0)`]: ../../std/io/type.Result.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    WriteZero,\n    /// This operation was interrupted.\n    ///\n    /// Interrupted operations can typically be retried.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Interrupted,\n    /// Any I/O error not part of this list.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Other,\n\n    /// An error returned when an operation could not be completed because an\n    /// \"end of file\" was reached prematurely.\n    ///\n    /// This typically means that an operation could only succeed if it read a\n    /// particular number of bytes but only a smaller number of bytes could be\n    /// read.\n    #[stable(feature = \"read_exact\", since = \"1.6.0\")]\n    UnexpectedEof,\n}\n\nimpl ErrorKind {\n    pub(crate) fn as_str(&self) -> &'static str {\n}\n}\n\n/// Intended for use for errors not exposed to the user, where allocating onto\n/// the heap (for normal construction via Error::new) is too costly.\n#[stable(feature = \"io_error_from_errorkind\", since = \"1.14.0\")]\nimpl From<ErrorKind> for Error {\n    /// Converts an [`ErrorKind`] into an [`Error`].\n    ///\n    /// This conversion allocates a new error with a simple representation of error kind.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// let not_found = ErrorKind::NotFound;\n    /// let error = Error::from(not_found);\n    /// assert_eq!(\"entity not found\", format!(\"{}\", error));\n    /// ```\n    ///\n    /// [`ErrorKind`]: ../../std/io/enum.ErrorKind.html\n    /// [`Error`]: ../../std/io/struct.Error.html\n    #[inline]\n    fn from(kind: ErrorKind) -> Error {\n}\n}\n\nimpl Error {\n    /// Creates a new I/O error from a known kind of error as well as an\n    /// arbitrary error payload.\n    ///\n    /// This function is used to generically create I/O errors which do not\n    /// originate from the OS itself. The `error` argument is an arbitrary\n    /// payload which will be contained in this `Error`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// // errors can be created from strings\n    /// let custom_error = Error::new(ErrorKind::Other, \"oh no!\");\n    ///\n    /// // errors can also be created from other errors\n    /// let custom_error2 = Error::new(ErrorKind::Interrupted, custom_error);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<E>(kind: ErrorKind, error: E) -> Error\n    where\n        E: Into<Box<dyn error::Error + Send + Sync>>,\n    {\n}\n\n    fn _new(kind: ErrorKind, error: Box<dyn error::Error + Send + Sync>) -> Error {\n}\n\n    /// Returns an error representing the last OS error which occurred.\n    ///\n    /// This function reads the value of `errno` for the target platform (e.g.\n    /// `GetLastError` on Windows) and will return a corresponding instance of\n    /// `Error` for the error code.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::Error;\n    ///\n    /// println!(\"last OS error: {:?}\", Error::last_os_error());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn last_os_error() -> Error {\n}\n\n    /// Creates a new instance of an `Error` from a particular OS error code.\n    ///\n    /// # Examples\n    ///\n    /// On Linux:\n    ///\n    /// ```\n    /// # if cfg!(target_os = \"linux\") {\n    /// use std::io;\n    ///\n    /// let error = io::Error::from_raw_os_error(22);\n    /// assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n    /// # }\n    /// ```\n    ///\n    /// On Windows:\n    ///\n    /// ```\n    /// # if cfg!(windows) {\n    /// use std::io;\n    ///\n    /// let error = io::Error::from_raw_os_error(10022);\n    /// assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n    /// # }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_raw_os_error(code: i32) -> Error {\n}\n\n    /// Returns the OS error that this error represents (if any).\n    ///\n    /// If this `Error` was constructed via `last_os_error` or\n    /// `from_raw_os_error`, then this function will return `Some`, otherwise\n    /// it will return `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_os_error(err: &Error) {\n    ///     if let Some(raw_os_err) = err.raw_os_error() {\n    ///         println!(\"raw OS error: {:?}\", raw_os_err);\n    ///     } else {\n    ///         println!(\"Not an OS error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"raw OS error: ...\".\n    ///     print_os_error(&Error::last_os_error());\n    ///     // Will print \"Not an OS error\".\n    ///     print_os_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn raw_os_error(&self) -> Option<i32> {\n}\n\n    /// Returns a reference to the inner error wrapped by this error (if any).\n    ///\n    /// If this `Error` was constructed via `new` then this function will\n    /// return `Some`, otherwise it will return `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: &Error) {\n    ///     if let Some(inner_err) = err.get_ref() {\n    ///         println!(\"Inner error: {:?}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(&Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    pub fn get_ref(&self) -> Option<&(dyn error::Error + Send + Sync + 'static)> {\n}\n\n    /// Returns a mutable reference to the inner error wrapped by this error\n    /// (if any).\n    ///\n    /// If this `Error` was constructed via `new` then this function will\n    /// return `Some`, otherwise it will return `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    /// use std::{error, fmt};\n    /// use std::fmt::Display;\n    ///\n    /// #[derive(Debug)]\n    /// struct MyError {\n    ///     v: String,\n    /// }\n    ///\n    /// impl MyError {\n    ///     fn new() -> MyError {\n    ///         MyError {\n    ///             v: \"oh no!\".to_string()\n    ///         }\n    ///     }\n    ///\n    ///     fn change_message(&mut self, new_message: &str) {\n    ///         self.v = new_message.to_string();\n    ///     }\n    /// }\n    ///\n    /// impl error::Error for MyError {}\n    ///\n    /// impl Display for MyError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"MyError: {}\", &self.v)\n    ///     }\n    /// }\n    ///\n    /// fn change_error(mut err: Error) -> Error {\n    ///     if let Some(inner_err) = err.get_mut() {\n    ///         inner_err.downcast_mut::<MyError>().unwrap().change_message(\"I've been changed!\");\n    ///     }\n    ///     err\n    /// }\n    ///\n    /// fn print_error(err: &Error) {\n    ///     if let Some(inner_err) = err.get_ref() {\n    ///         println!(\"Inner error: {}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(&change_error(Error::last_os_error()));\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(&change_error(Error::new(ErrorKind::Other, MyError::new())));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    pub fn get_mut(&mut self) -> Option<&mut (dyn error::Error + Send + Sync + 'static)> {\n}\n\n    /// Consumes the `Error`, returning its inner error (if any).\n    ///\n    /// If this `Error` was constructed via `new` then this function will\n    /// return `Some`, otherwise it will return `None`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: Error) {\n    ///     if let Some(inner_err) = err.into_inner() {\n    ///         println!(\"Inner error: {}\", inner_err);\n    ///     } else {\n    ///         println!(\"No inner error\");\n    ///     }\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(Error::new(ErrorKind::Other, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"io_error_inner\", since = \"1.3.0\")]\n    pub fn into_inner(self) -> Option<Box<dyn error::Error + Send + Sync>> {\n}\n\n    /// Returns the corresponding `ErrorKind` for this error.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{Error, ErrorKind};\n    ///\n    /// fn print_error(err: Error) {\n    ///     println!(\"{:?}\", err.kind());\n    /// }\n    ///\n    /// fn main() {\n    ///     // Will print \"No inner error\".\n    ///     print_error(Error::last_os_error());\n    ///     // Will print \"Inner error: ...\".\n    ///     print_error(Error::new(ErrorKind::AddrInUse, \"oh no!\"));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn kind(&self) -> ErrorKind {\n}\n}\n\nimpl fmt::Debug for Repr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Error {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl error::Error for Error {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n}\n\n    #[allow(deprecated)]\n    fn cause(&self) -> Option<&dyn error::Error> {\n}\n\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n}\n}\n\nfn _assert_error_is_sync_send() {\n}\n\n#[cfg(test)]\nmod test {\n}\n}\nmod impls {\nuse crate::cmp;\nuse crate::fmt;\nuse crate::io::{\n    self, BufRead, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write,\n};\nuse crate::mem;\n\n// =============================================================================\n// Forwarding implementations\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read + ?Sized> Read for &mut R {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write + ?Sized> Write for &mut W {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n}\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n}\n\n    #[inline]\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<S: Seek + ?Sized> Seek for &mut S {\n    #[inline]\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead + ?Sized> BufRead for &mut B {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n}\n\n    #[inline]\n    fn consume(&mut self, amt: usize) {\n}\n\n    #[inline]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read + ?Sized> Read for Box<R> {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<W: Write + ?Sized> Write for Box<W> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n}\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n}\n\n    #[inline]\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<S: Seek + ?Sized> Seek for Box<S> {\n    #[inline]\n    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead + ?Sized> BufRead for Box<B> {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n}\n\n    #[inline]\n    fn consume(&mut self, amt: usize) {\n}\n\n    #[inline]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n}\n}\n\n// Used by panicking::default_hook\n#[cfg(test)]\n/// This impl is only used by printing logic, so any error returned is always\n/// of kind `Other`, and should be ignored.\nimpl Write for Box<dyn (::realstd::io::Write) + Send> {\n}\n\n// =============================================================================\n// In-memory buffer implementations\n\n/// Read is implemented for `&[u8]` by copying from the slice.\n///\n/// Note that reading updates the slice to point to the yet unread part.\n/// The slice will be empty when EOF is reached.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for &[u8] {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n\n    #[inline]\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n}\n\n    #[inline]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl BufRead for &[u8] {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n}\n\n    #[inline]\n    fn consume(&mut self, amt: usize) {\n}\n}\n\n/// Write is implemented for `&mut [u8]` by copying into the slice, overwriting\n/// its data.\n///\n/// Note that writing updates the slice to point to the yet unwritten part.\n/// The slice will be empty when it has been completely overwritten.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for &mut [u8] {\n    #[inline]\n    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn write_all(&mut self, data: &[u8]) -> io::Result<()> {\n}\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\n/// Write is implemented for `Vec<u8>` by appending to the vector.\n/// The vector will grow as needed.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Vec<u8> {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n}\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod lazy {\nuse crate::cell::Cell;\nuse crate::ptr;\nuse crate::sync::Arc;\nuse crate::sys_common;\nuse crate::sys_common::mutex::Mutex;\n\npub struct Lazy<T> {\n    // We never call `lock.init()`, so it is UB to attempt to acquire this mutex reentrantly!\n    lock: Mutex,\n    ptr: Cell<*mut Arc<T>>,\n}\n\n#[inline]\nconst fn done<T>() -> *mut Arc<T> {\n}\n\nunsafe impl<T> Sync for Lazy<T> {}\n\nimpl<T> Lazy<T> {\n    pub const fn new() -> Lazy<T> {\n}\n}\n\nimpl<T: Send + Sync + 'static> Lazy<T> {\n    /// Safety: `init` must not call `get` on the variable that is being\n    /// initialized.\n    pub unsafe fn get(&'static self, init: fn() -> Arc<T>) -> Option<Arc<T>> {\n}\n\n    // Must only be called with `lock` held\n    unsafe fn init(&'static self, init: fn() -> Arc<T>) -> Arc<T> {\n}\n}\n}\npub mod prelude {\n//! The I/O Prelude\n//!\n//! The purpose of this module is to alleviate imports of many common I/O traits\n//! by adding a glob import to the top of I/O heavy modules:\n//!\n//! ```\n//! # #![allow(unused_imports)]\n//! use std::io::prelude::*;\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use super::{BufRead, Read, Seek, Write};\n}\nmod stdio {\n#![cfg_attr(test, allow(unused))]\n\nuse crate::io::prelude::*;\n\nuse crate::cell::RefCell;\nuse crate::fmt;\nuse crate::io::lazy::Lazy;\nuse crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\nuse crate::sync::{Arc, Mutex, MutexGuard};\nuse crate::sys::stdio;\nuse crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\nuse crate::thread::LocalKey;\n\nthread_local! {\n    /// Stdout used by print! and println! macros\n    static LOCAL_STDOUT: RefCell<Option<Box<dyn Write + Send>>> = {\n        RefCell::new(None)\n    }\n}\n\nthread_local! {\n    /// Stderr used by eprint! and eprintln! macros, and panics\n    static LOCAL_STDERR: RefCell<Option<Box<dyn Write + Send>>> = {\n        RefCell::new(None)\n    }\n}\n\n/// A handle to a raw instance of the standard input stream of this process.\n///\n/// This handle is not synchronized or buffered in any fashion. Constructed via\n/// the `std::io::stdio::stdin_raw` function.\nstruct StdinRaw(stdio::Stdin);\n\n/// A handle to a raw instance of the standard output stream of this process.\n///\n/// This handle is not synchronized or buffered in any fashion. Constructed via\n/// the `std::io::stdio::stdout_raw` function.\nstruct StdoutRaw(stdio::Stdout);\n\n/// A handle to a raw instance of the standard output stream of this process.\n///\n/// This handle is not synchronized or buffered in any fashion. Constructed via\n/// the `std::io::stdio::stderr_raw` function.\nstruct StderrRaw(stdio::Stderr);\n\n/// Constructs a new raw handle to the standard input of this process.\n///\n/// The returned handle does not interact with any other handles created nor\n/// handles returned by `std::io::stdin`. Data buffered by the `std::io::stdin`\n/// handles is **not** available to raw handles returned from this function.\n///\n/// The returned handle has no external synchronization or buffering.\nfn stdin_raw() -> io::Result<StdinRaw> {\n}\n\n/// Constructs a new raw handle to the standard output stream of this process.\n///\n/// The returned handle does not interact with any other handles created nor\n/// handles returned by `std::io::stdout`. Note that data is buffered by the\n/// `std::io::stdout` handles so writes which happen via this raw handle may\n/// appear before previous writes.\n///\n/// The returned handle has no external synchronization or buffering layered on\n/// top.\nfn stdout_raw() -> io::Result<StdoutRaw> {\n}\n\n/// Constructs a new raw handle to the standard error stream of this process.\n///\n/// The returned handle does not interact with any other handles created nor\n/// handles returned by `std::io::stderr`.\n///\n/// The returned handle has no external synchronization or buffering layered on\n/// top.\nfn stderr_raw() -> io::Result<StderrRaw> {\n}\n\nimpl Read for StdinRaw {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\nimpl Write for StdoutRaw {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\nimpl Write for StderrRaw {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\nenum Maybe<T> {\n    Real(T),\n    Fake,\n}\n\nimpl<W: io::Write> io::Write for Maybe<W> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\nimpl<R: io::Read> io::Read for Maybe<R> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n}\n\nfn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n}\n\n/// A handle to the standard input stream of a process.\n///\n/// Each handle is a shared reference to a global buffer of input data to this\n/// process. A handle can be `lock`'d to gain full access to [`BufRead`] methods\n/// (e.g., `.lines()`). Reads to this handle are otherwise locked with respect\n/// to other reads.\n///\n/// This handle implements the `Read` trait, but beware that concurrent reads\n/// of `Stdin` must be executed with care.\n///\n/// Created by the [`io::stdin`] method.\n///\n/// [`io::stdin`]: fn.stdin.html\n/// [`BufRead`]: trait.BufRead.html\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n/// an error.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Stdin {\n    inner: Arc<Mutex<BufReader<Maybe<StdinRaw>>>>,\n}\n\n/// A locked reference to the `Stdin` handle.\n///\n/// This handle implements both the [`Read`] and [`BufRead`] traits, and\n/// is constructed via the [`Stdin::lock`] method.\n///\n/// [`Read`]: trait.Read.html\n/// [`BufRead`]: trait.BufRead.html\n/// [`Stdin::lock`]: struct.Stdin.html#method.lock\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n/// an error.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct StdinLock<'a> {\n    inner: MutexGuard<'a, BufReader<Maybe<StdinRaw>>>,\n}\n\n/// Constructs a new handle to the standard input of the current process.\n///\n/// Each handle returned is a reference to a shared global buffer whose access\n/// is synchronized via a mutex. If you need more explicit control over\n/// locking, see the [`Stdin::lock`] method.\n///\n/// [`Stdin::lock`]: struct.Stdin.html#method.lock\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// Using implicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Read};\n///\n/// fn main() -> io::Result<()> {\n///     let mut buffer = String::new();\n///     io::stdin().read_to_string(&mut buffer)?;\n///     Ok(())\n/// }\n/// ```\n///\n/// Using explicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Read};\n///\n/// fn main() -> io::Result<()> {\n///     let mut buffer = String::new();\n///     let stdin = io::stdin();\n///     let mut handle = stdin.lock();\n///\n///     handle.read_to_string(&mut buffer)?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn stdin() -> Stdin {\n}\n\nimpl Stdin {\n    /// Locks this handle to the standard input stream, returning a readable\n    /// guard.\n    ///\n    /// The lock is released when the returned lock goes out of scope. The\n    /// returned guard also implements the [`Read`] and [`BufRead`] traits for\n    /// accessing the underlying data.\n    ///\n    /// [`Read`]: trait.Read.html\n    /// [`BufRead`]: trait.BufRead.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::{self, Read};\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut buffer = String::new();\n    ///     let stdin = io::stdin();\n    ///     let mut handle = stdin.lock();\n    ///\n    ///     handle.read_to_string(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> StdinLock<'_> {\n}\n\n    /// Locks this handle and reads a line of input into the specified buffer.\n    ///\n    /// For detailed semantics of this method, see the documentation on\n    /// [`BufRead::read_line`].\n    ///\n    /// [`BufRead::read_line`]: trait.BufRead.html#method.read_line\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    ///\n    /// let mut input = String::new();\n    /// match io::stdin().read_line(&mut input) {\n    ///     Ok(n) => {\n    ///         println!(\"{} bytes read\", n);\n    ///         println!(\"{}\", input);\n    ///     }\n    ///     Err(error) => println!(\"error: {}\", error),\n    /// }\n    /// ```\n    ///\n    /// You can run the example one of two ways:\n    ///\n    /// - Pipe some text to it, e.g., `printf foo | path/to/executable`\n    /// - Give it text interactively by running the executable directly,\n    ///   in which case it will wait for the Enter key to be pressed before\n    ///   continuing\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn read_line(&self, buf: &mut String) -> io::Result<usize> {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stdin {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for Stdin {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n}\n    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n}\n    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for StdinLock<'_> {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl BufRead for StdinLock<'_> {\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n}\n    fn consume(&mut self, n: usize) {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for StdinLock<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A handle to the global standard output stream of the current process.\n///\n/// Each handle shares a global buffer of data to be written to the standard\n/// output stream. Access is also synchronized via a lock and explicit control\n/// over locking is available via the [`lock`] method.\n///\n/// Created by the [`io::stdout`] method.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// [`lock`]: #method.lock\n/// [`io::stdout`]: fn.stdout.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Stdout {\n    // FIXME: this should be LineWriter or BufWriter depending on the state of\n    //        stdout (tty or not). Note that if this is not line buffered it\n    //        should also flush-on-panic or some form of flush-on-abort.\n    inner: Arc<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>>,\n}\n\n/// A locked reference to the `Stdout` handle.\n///\n/// This handle implements the [`Write`] trait, and is constructed via\n/// the [`Stdout::lock`] method.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// [`Write`]: trait.Write.html\n/// [`Stdout::lock`]: struct.Stdout.html#method.lock\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct StdoutLock<'a> {\n    inner: ReentrantMutexGuard<'a, RefCell<LineWriter<Maybe<StdoutRaw>>>>,\n}\n\n/// Constructs a new handle to the standard output of the current process.\n///\n/// Each handle returned is a reference to a shared global buffer whose access\n/// is synchronized via a mutex. If you need more explicit control over\n/// locking, see the [`Stdout::lock`] method.\n///\n/// [`Stdout::lock`]: struct.Stdout.html#method.lock\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// Using implicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Write};\n///\n/// fn main() -> io::Result<()> {\n///     io::stdout().write_all(b\"hello world\")?;\n///\n///     Ok(())\n/// }\n/// ```\n///\n/// Using explicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Write};\n///\n/// fn main() -> io::Result<()> {\n///     let stdout = io::stdout();\n///     let mut handle = stdout.lock();\n///\n///     handle.write_all(b\"hello world\")?;\n///\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn stdout() -> Stdout {\n}\n\nimpl Stdout {\n    /// Locks this handle to the standard output stream, returning a writable\n    /// guard.\n    ///\n    /// The lock is released when the returned lock goes out of scope. The\n    /// returned guard also implements the `Write` trait for writing data.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::{self, Write};\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let stdout = io::stdout();\n    ///     let mut handle = stdout.lock();\n    ///\n    ///     handle.write_all(b\"hello world\")?;\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> StdoutLock<'_> {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stdout {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Stdout {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n    fn flush(&mut self) -> io::Result<()> {\n}\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n}\n    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> io::Result<()> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for StdoutLock<'_> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for StdoutLock<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A handle to the standard error stream of a process.\n///\n/// For more information, see the [`io::stderr`] method.\n///\n/// [`io::stderr`]: fn.stderr.html\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Stderr {\n    inner: Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>>,\n}\n\n/// A locked reference to the `Stderr` handle.\n///\n/// This handle implements the `Write` trait and is constructed via\n/// the [`Stderr::lock`] method.\n///\n/// [`Stderr::lock`]: struct.Stderr.html#method.lock\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct StderrLock<'a> {\n    inner: ReentrantMutexGuard<'a, RefCell<Maybe<StderrRaw>>>,\n}\n\n/// Constructs a new handle to the standard error of the current process.\n///\n/// This handle is not buffered.\n///\n/// ### Note: Windows Portability Consideration\n/// When operating in a console, the Windows implementation of this stream does not support\n/// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n/// an error.\n///\n/// # Examples\n///\n/// Using implicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Write};\n///\n/// fn main() -> io::Result<()> {\n///     io::stderr().write_all(b\"hello world\")?;\n///\n///     Ok(())\n/// }\n/// ```\n///\n/// Using explicit synchronization:\n///\n/// ```no_run\n/// use std::io::{self, Write};\n///\n/// fn main() -> io::Result<()> {\n///     let stderr = io::stderr();\n///     let mut handle = stderr.lock();\n///\n///     handle.write_all(b\"hello world\")?;\n///\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn stderr() -> Stderr {\n}\n\nimpl Stderr {\n    /// Locks this handle to the standard error stream, returning a writable\n    /// guard.\n    ///\n    /// The lock is released when the returned lock goes out of scope. The\n    /// returned guard also implements the `Write` trait for writing data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Write};\n    ///\n    /// fn foo() -> io::Result<()> {\n    ///     let stderr = io::stderr();\n    ///     let mut handle = stderr.lock();\n    ///\n    ///     handle.write_all(b\"hello world\")?;\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> StderrLock<'_> {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stderr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Stderr {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n    fn flush(&mut self) -> io::Result<()> {\n}\n    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n}\n    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> io::Result<()> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for StderrLock<'_> {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for StderrLock<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// Resets the thread-local stderr handle to the specified writer\n///\n/// This will replace the current thread's stderr handle, returning the old\n/// handle. All future calls to `panic!` and friends will emit their output to\n/// this specified handle.\n///\n/// Note that this does not need to be called for all new threads; the default\n/// output handle is to the process's stderr stream.\n#[unstable(\n    feature = \"set_stdio\",\n    reason = \"this function may disappear completely or be replaced \\\n                     with a more general mechanism\",\n    issue = \"none\"\n)]\n#[doc(hidden)]\npub fn set_panic(sink: Option<Box<dyn Write + Send>>) -> Option<Box<dyn Write + Send>> {\n}\n\n/// Resets the thread-local stdout handle to the specified writer\n///\n/// This will replace the current thread's stdout handle, returning the old\n/// handle. All future calls to `print!` and friends will emit their output to\n/// this specified handle.\n///\n/// Note that this does not need to be called for all new threads; the default\n/// output handle is to the process's stdout stream.\n#[unstable(\n    feature = \"set_stdio\",\n    reason = \"this function may disappear completely or be replaced \\\n                     with a more general mechanism\",\n    issue = \"none\"\n)]\n#[doc(hidden)]\npub fn set_print(sink: Option<Box<dyn Write + Send>>) -> Option<Box<dyn Write + Send>> {\n}\n\n/// Write `args` to output stream `local_s` if possible, `global_s`\n/// otherwise. `label` identifies the stream in a panic message.\n///\n/// This function is used to print error messages, so it takes extra\n/// care to avoid causing a panic when `local_s` is unusable.\n/// For instance, if the TLS key for the local stream is\n/// already destroyed, or if the local stream is locked by another\n/// thread, it will just fall back to the global stream.\n///\n/// However, if the actual I/O causes an error, this function does panic.\nfn print_to<T>(\n    args: fmt::Arguments<'_>,\n    local_s: &'static LocalKey<RefCell<Option<Box<dyn Write + Send>>>>,\n    global_s: fn() -> T,\n    label: &str,\n) where\n    T: Write,\n{\n}\n\n#[unstable(\n    feature = \"print_internals\",\n    reason = \"implementation detail which may disappear or be replaced at any time\",\n    issue = \"none\"\n)]\n#[doc(hidden)]\n#[cfg(not(test))]\npub fn _print(args: fmt::Arguments<'_>) {\n}\n\n#[unstable(\n    feature = \"print_internals\",\n    reason = \"implementation detail which may disappear or be replaced at any time\",\n    issue = \"none\"\n)]\n#[doc(hidden)]\n#[cfg(not(test))]\npub fn _eprint(args: fmt::Arguments<'_>) {\n}\n\n#[cfg(test)]\npub use realstd::io::{_};\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod util {\n#![allow(missing_copy_implementations)]\n\nuse crate::fmt;\nuse crate::io::{self, BufRead, ErrorKind, Initializer, IoSlice, IoSliceMut, Read, Write};\nuse crate::mem::MaybeUninit;\n\n/// Copies the entire contents of a reader into a writer.\n///\n/// This function will continuously read data from `reader` and then\n/// write it into `writer` in a streaming fashion until `reader`\n/// returns EOF.\n///\n/// On success, the total number of bytes that were copied from\n/// `reader` to `writer` is returned.\n///\n/// If you’re wanting to copy the contents of one file to another and you’re\n/// working with filesystem paths, see the [`fs::copy`] function.\n///\n/// [`fs::copy`]: ../fs/fn.copy.html\n///\n/// # Errors\n///\n/// This function will return an error immediately if any call to `read` or\n/// `write` returns an error. All instances of `ErrorKind::Interrupted` are\n/// handled by this function and the underlying operation is retried.\n///\n/// # Examples\n///\n/// ```\n/// use std::io;\n///\n/// fn main() -> io::Result<()> {\n///     let mut reader: &[u8] = b\"hello\";\n///     let mut writer: Vec<u8> = vec![];\n///\n///     io::copy(&mut reader, &mut writer)?;\n///\n///     assert_eq!(&b\"hello\"[..], &writer[..]);\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\nwhere\n    R: Read,\n    W: Write,\n{\n}\n\n/// A reader which is always at EOF.\n///\n/// This struct is generally created by calling [`empty`]. Please see\n/// the documentation of [`empty()`][`empty`] for more details.\n///\n/// [`empty`]: fn.empty.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Empty {\n    _priv: (),\n}\n\n/// Constructs a new handle to an empty reader.\n///\n/// All reads from the returned reader will return [`Ok`]`(0)`.\n///\n/// [`Ok`]: ../result/enum.Result.html#variant.Ok\n///\n/// # Examples\n///\n/// A slightly sad example of not reading anything into a buffer:\n///\n/// ```\n/// use std::io::{self, Read};\n///\n/// let mut buffer = String::new();\n/// io::empty().read_to_string(&mut buffer).unwrap();\n/// assert!(buffer.is_empty());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn empty() -> Empty {\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for Empty {\n    #[inline]\n    fn read(&mut self, _buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl BufRead for Empty {\n    #[inline]\n    fn fill_buf(&mut self) -> io::Result<&[u8]> {\n}\n    #[inline]\n    fn consume(&mut self, _n: usize) {}}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Empty {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A reader which yields one byte over and over and over and over and over and...\n///\n/// This struct is generally created by calling [`repeat`][repeat]. Please\n/// see the documentation of `repeat()` for more details.\n///\n/// [repeat]: fn.repeat.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Repeat {\n    byte: u8,\n}\n\n/// Creates an instance of a reader that infinitely repeats one byte.\n///\n/// All reads from this reader will succeed by filling the specified buffer with\n/// the given byte.\n///\n/// # Examples\n///\n/// ```\n/// use std::io::{self, Read};\n///\n/// let mut buffer = [0; 3];\n/// io::repeat(0b101).read_exact(&mut buffer).unwrap();\n/// assert_eq!(buffer, [0b101, 0b101, 0b101]);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn repeat(byte: u8) -> Repeat {\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for Repeat {\n    #[inline]\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Repeat {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A writer which will move data into the void.\n///\n/// This struct is generally created by calling [`sink`][sink]. Please\n/// see the documentation of `sink()` for more details.\n///\n/// [sink]: fn.sink.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Sink {\n    _priv: (),\n}\n\n/// Creates an instance of a writer which will successfully consume all data.\n///\n/// All calls to `write` on the returned instance will return `Ok(buf.len())`\n/// and the contents of the buffer will not be inspected.\n///\n/// # Examples\n///\n/// ```rust\n/// use std::io::{self, Write};\n///\n/// let buffer = vec![1, 2, 3, 5, 8];\n/// let num_bytes = io::sink().write(&buffer).unwrap();\n/// assert_eq!(num_bytes, 5);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn sink() -> Sink {\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for Sink {\n    #[inline]\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Sink {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\n\nconst DEFAULT_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n\nstruct Guard<'a> {\n    buf: &'a mut Vec<u8>,\n    len: usize,\n}\n\nimpl Drop for Guard<'_> {\n    fn drop(&mut self) {\n}\n}\n\n// A few methods below (read_to_string, read_line) will append data into a\n// `String` buffer, but we need to be pretty careful when doing this. The\n// implementation will just call `.as_mut_vec()` and then delegate to a\n// byte-oriented reading method, but we must ensure that when returning we never\n// leave `buf` in a state such that it contains invalid UTF-8 in its bounds.\n//\n// To this end, we use an RAII guard (to protect against panics) which updates\n// the length of the string when it is dropped. This guard initially truncates\n// the string to the prior length and only after we've validated that the\n// new contents are valid UTF-8 do we allow it to set a longer length.\n//\n// The unsafety in this function is twofold:\n//\n// 1. We're looking at the raw bytes of `buf`, so we take on the burden of UTF-8\n//    checks.\n// 2. We're passing a raw buffer to the function `f`, and it is expected that\n//    the function only *appends* bytes to the buffer. We'll get undefined\n//    behavior if existing bytes are overwritten to have non-UTF-8 data.\nfn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\nwhere\n    F: FnOnce(&mut Vec<u8>) -> Result<usize>,\n{\n}\n\n// This uses an adaptive system to extend the vector when it fills. We want to\n// avoid paying to allocate and zero a huge chunk of memory if the reader only\n// has 4 bytes while still making large reads if the reader does have a ton\n// of data to return. Simply tacking on an extra DEFAULT_BUF_SIZE space every\n// time is 4,500 times (!) slower than a default reservation size of 32 if the\n// reader has a very small amount of data to return.\n//\n// Because we're extending the buffer with uninitialized data for trusted\n// readers, we need to make sure to truncate that if any of this panics.\nfn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n}\n\nfn read_to_end_with_reservation<R, F>(\n    r: &mut R,\n    buf: &mut Vec<u8>,\n    mut reservation_size: F,\n) -> Result<usize>\nwhere\n    R: Read + ?Sized,\n    F: FnMut(&R) -> usize,\n{\n}\n\npub(crate) fn default_read_vectored<F>(read: F, bufs: &mut [IoSliceMut<'_>]) -> Result<usize>\nwhere\n    F: FnOnce(&mut [u8]) -> Result<usize>,\n{\n}\n\npub(crate) fn default_write_vectored<F>(write: F, bufs: &[IoSlice<'_>]) -> Result<usize>\nwhere\n    F: FnOnce(&[u8]) -> Result<usize>,\n{\n}\n\n/// The `Read` trait allows for reading bytes from a source.\n///\n/// Implementors of the `Read` trait are called 'readers'.\n///\n/// Readers are defined by one required method, [`read()`]. Each call to [`read()`]\n/// will attempt to pull bytes from this source into a provided buffer. A\n/// number of other methods are implemented in terms of [`read()`], giving\n/// implementors a number of ways to read bytes while only needing to implement\n/// a single method.\n///\n/// Readers are intended to be composable with one another. Many implementors\n/// throughout [`std::io`] take and provide types which implement the `Read`\n/// trait.\n///\n/// Please note that each call to [`read()`] may involve a system call, and\n/// therefore, using something that implements [`BufRead`], such as\n/// [`BufReader`], will be more efficient.\n///\n/// # Examples\n///\n/// [`File`]s implement `Read`:\n///\n/// ```no_run\n/// use std::io;\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// fn main() -> io::Result<()> {\n///     let mut f = File::open(\"foo.txt\")?;\n///     let mut buffer = [0; 10];\n///\n///     // read up to 10 bytes\n///     f.read(&mut buffer)?;\n///\n///     let mut buffer = Vec::new();\n///     // read the whole file\n///     f.read_to_end(&mut buffer)?;\n///\n///     // read into a String, so that you don't need to do the conversion.\n///     let mut buffer = String::new();\n///     f.read_to_string(&mut buffer)?;\n///\n///     // and more! See the other methods for more details.\n///     Ok(())\n/// }\n/// ```\n///\n/// Read from [`&str`] because [`&[u8]`][slice] implements `Read`:\n///\n/// ```no_run\n/// # use std::io;\n/// use std::io::prelude::*;\n///\n/// fn main() -> io::Result<()> {\n///     let mut b = \"This string will be read\".as_bytes();\n///     let mut buffer = [0; 10];\n///\n///     // read up to 10 bytes\n///     b.read(&mut buffer)?;\n///\n///     // etc... it works exactly as a File does!\n///     Ok(())\n/// }\n/// ```\n///\n/// [`read()`]: trait.Read.html#tymethod.read\n/// [`std::io`]: ../../std/io/index.html\n/// [`File`]: ../fs/struct.File.html\n/// [`BufRead`]: trait.BufRead.html\n/// [`BufReader`]: struct.BufReader.html\n/// [`&str`]: ../../std/primitive.str.html\n/// [slice]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(spotlight)]\npub trait Read {\n    /// Pull some bytes from this source into the specified buffer, returning\n    /// how many bytes were read.\n    ///\n    /// This function does not provide any guarantees about whether it blocks\n    /// waiting for data, but if an object needs to block for a read but cannot\n    /// it will typically signal this via an [`Err`] return value.\n    ///\n    /// If the return value of this method is [`Ok(n)`], then it must be\n    /// guaranteed that `0 <= n <= buf.len()`. A nonzero `n` value indicates\n    /// that the buffer `buf` has been filled in with `n` bytes of data from this\n    /// source. If `n` is `0`, then it can indicate one of two scenarios:\n    ///\n    /// 1. This reader has reached its \"end of file\" and will likely no longer\n    ///    be able to produce bytes. Note that this does not mean that the\n    ///    reader will *always* no longer be able to produce bytes.\n    /// 2. The buffer specified was 0 bytes in length.\n    ///\n    /// No guarantees are provided about the contents of `buf` when this\n    /// function is called, implementations cannot rely on any property of the\n    /// contents of `buf` being true. It is recommended that *implementations*\n    /// only write data to `buf` instead of reading its contents.\n    ///\n    /// Correspondingly, however, *callers* of this method may not assume any guarantees\n    /// about how the implementation uses `buf`. The trait is safe to implement,\n    /// so it is possible that the code that's supposed to write to the buffer might also read\n    /// from it. It is your responsibility to make sure that `buf` is initialized\n    /// before calling `read`. Calling `read` with an uninitialized `buf` (of the kind one\n    /// obtains via [`MaybeUninit<T>`]) is not safe, and can lead to undefined behavior.\n    ///\n    /// [`MaybeUninit<T>`]: ../mem/union.MaybeUninit.html\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters any form of I/O or other error, an error\n    /// variant will be returned. If an error is returned then it must be\n    /// guaranteed that no bytes were read.\n    ///\n    /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the read\n    /// operation should be retried if there is nothing else to do.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`Ok(n)`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n    /// [`File`]: ../fs/struct.File.html\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = [0; 10];\n    ///\n    ///     // read up to 10 bytes\n    ///     let n = f.read(&mut buffer[..])?;\n    ///\n    ///     println!(\"The bytes: {:?}\", &buffer[..n]);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n\n    /// Like `read`, except that it reads into a slice of buffers.\n    ///\n    /// Data is copied to fill each buffer in order, with the final buffer\n    /// written to possibly being only partially filled. This method must behave\n    /// as a single call to `read` with the buffers concatenated would.\n    ///\n    /// The default implementation calls `read` with either the first nonempty\n    /// buffer provided, or an empty one if none exists.\n    #[stable(feature = \"iovec\", since = \"1.36.0\")]\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> Result<usize> {\n        default_read_vectored(|b| self.read(b), bufs)\n    }\n\n    /// Determines if this `Read`er can work with buffers of uninitialized\n    /// memory.\n    ///\n    /// The default implementation returns an initializer which will zero\n    /// buffers.\n    ///\n    /// If a `Read`er guarantees that it can work properly with uninitialized\n    /// memory, it should call [`Initializer::nop()`]. See the documentation for\n    /// [`Initializer`] for details.\n    ///\n    /// The behavior of this method must be independent of the state of the\n    /// `Read`er - the method only takes `&self` so that it can be used through\n    /// trait objects.\n    ///\n    /// # Safety\n    ///\n    /// This method is unsafe because a `Read`er could otherwise return a\n    /// non-zeroing `Initializer` from another `Read` type without an `unsafe`\n    /// block.\n    ///\n    /// [`Initializer::nop()`]: ../../std/io/struct.Initializer.html#method.nop\n    /// [`Initializer`]: ../../std/io/struct.Initializer.html\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n\n    /// Read all bytes until EOF in this source, placing them into `buf`.\n    ///\n    /// All bytes read from this source will be appended to the specified buffer\n    /// `buf`. This function will continuously call [`read()`] to append more data to\n    /// `buf` until [`read()`] returns either [`Ok(0)`] or an error of\n    /// non-[`ErrorKind::Interrupted`] kind.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters an error of the kind\n    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n    /// will continue.\n    ///\n    /// If any other read error is encountered then this function immediately\n    /// returns. Any bytes which have already been read will be appended to\n    /// `buf`.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`read()`]: trait.Read.html#tymethod.read\n    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n    /// [`File`]: ../fs/struct.File.html\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = Vec::new();\n    ///\n    ///     // read the whole file\n    ///     f.read_to_end(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// (See also the [`std::fs::read`] convenience function for reading from a\n    /// file.)\n    ///\n    /// [`std::fs::read`]: ../fs/fn.read.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n}\n\n    /// Read all bytes until EOF in this source, appending them to `buf`.\n    ///\n    /// If successful, this function returns the number of bytes which were read\n    /// and appended to `buf`.\n    ///\n    /// # Errors\n    ///\n    /// If the data in this stream is *not* valid UTF-8 then an error is\n    /// returned and `buf` is unchanged.\n    ///\n    /// See [`read_to_end`][readtoend] for other error semantics.\n    ///\n    /// [readtoend]: #method.read_to_end\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = String::new();\n    ///\n    ///     f.read_to_string(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// (See also the [`std::fs::read_to_string`] convenience function for\n    /// reading from a file.)\n    ///\n    /// [`std::fs::read_to_string`]: ../fs/fn.read_to_string.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n}\n\n    /// Read the exact number of bytes required to fill `buf`.\n    ///\n    /// This function reads as many bytes as necessary to completely fill the\n    /// specified buffer `buf`.\n    ///\n    /// No guarantees are provided about the contents of `buf` when this\n    /// function is called, implementations cannot rely on any property of the\n    /// contents of `buf` being true. It is recommended that implementations\n    /// only write data to `buf` instead of reading its contents.\n    ///\n    /// # Errors\n    ///\n    /// If this function encounters an error of the kind\n    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n    /// will continue.\n    ///\n    /// If this function encounters an \"end of file\" before completely filling\n    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n    /// The contents of `buf` are unspecified in this case.\n    ///\n    /// If any other read error is encountered then this function immediately\n    /// returns. The contents of `buf` are unspecified in this case.\n    ///\n    /// If this function returns an error, it is unspecified how many bytes it\n    /// has read, but it will never read more than would be necessary to\n    /// completely fill the buffer.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: ../fs/struct.File.html\n    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n    /// [`ErrorKind::UnexpectedEof`]: ../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = [0; 10];\n    ///\n    ///     // read exactly 10 bytes\n    ///     f.read_exact(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"read_exact\", since = \"1.6.0\")]\n    fn read_exact(&mut self, mut buf: &mut [u8]) -> Result<()> {\n}\n\n    /// Creates a \"by reference\" adaptor for this instance of `Read`.\n    ///\n    /// The returned adaptor also implements `Read` and will simply borrow this\n    /// current reader.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::Read;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = Vec::new();\n    ///     let mut other_buffer = Vec::new();\n    ///\n    ///     {\n    ///         let reference = f.by_ref();\n    ///\n    ///         // read at most 5 bytes\n    ///         reference.take(5).read_to_end(&mut buffer)?;\n    ///\n    ///     } // drop our &mut reference so we can use f again\n    ///\n    ///     // original file still usable, read the rest\n    ///     f.read_to_end(&mut other_buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn by_ref(&mut self) -> &mut Self\n    where\n        Self: Sized,\n    {\n}\n\n    /// Transforms this `Read` instance to an [`Iterator`] over its bytes.\n    ///\n    /// The returned type implements [`Iterator`] where the `Item` is\n    /// [`Result`]`<`[`u8`]`, `[`io::Error`]`>`.\n    /// The yielded item is [`Ok`] if a byte was successfully read and [`Err`]\n    /// otherwise. EOF is mapped to returning [`None`] from this iterator.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    /// [`Iterator`]: ../../std/iter/trait.Iterator.html\n    /// [`Result`]: ../../std/result/enum.Result.html\n    /// [`io::Error`]: ../../std/io/struct.Error.html\n    /// [`u8`]: ../../std/primitive.u8.html\n    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///\n    ///     for byte in f.bytes() {\n    ///         println!(\"{}\", byte.unwrap());\n    ///     }\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn bytes(self) -> Bytes<Self>\n    where\n        Self: Sized,\n    {\n}\n\n    /// Creates an adaptor which will chain this stream with another.\n    ///\n    /// The returned `Read` instance will first read all bytes from this object\n    /// until EOF is encountered. Afterwards the output is equivalent to the\n    /// output of `next`.\n    ///\n    /// # Examples\n    ///\n    /// [`File`][file]s implement `Read`:\n    ///\n    /// [file]: ../fs/struct.File.html\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f1 = File::open(\"foo.txt\")?;\n    ///     let mut f2 = File::open(\"bar.txt\")?;\n    ///\n    ///     let mut handle = f1.chain(f2);\n    ///     let mut buffer = String::new();\n    ///\n    ///     // read the value into a String. We could use any Read method here,\n    ///     // this is just one example.\n    ///     handle.read_to_string(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn chain<R: Read>(self, next: R) -> Chain<Self, R>\n    where\n        Self: Sized,\n    {\n}\n\n    /// Creates an adaptor which will read at most `limit` bytes from it.\n    ///\n    /// This function returns a new instance of `Read` which will read at most\n    /// `limit` bytes, after which it will always return EOF ([`Ok(0)`]). Any\n    /// read errors will not count towards the number of bytes read and future\n    /// calls to [`read()`] may succeed.\n    ///\n    /// # Examples\n    ///\n    /// [`File`]s implement `Read`:\n    ///\n    /// [`File`]: ../fs/struct.File.html\n    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`read()`]: trait.Read.html#tymethod.read\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///     let mut buffer = [0; 5];\n    ///\n    ///     // read at most five bytes\n    ///     let mut handle = f.take(5);\n    ///\n    ///     handle.read(&mut buffer)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn take(self, limit: u64) -> Take<Self>\n    where\n        Self: Sized,\n    {\n}\n}\n\n/// A buffer type used with `Read::read_vectored`.\n///\n/// It is semantically a wrapper around an `&mut [u8]`, but is guaranteed to be\n/// ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on\n/// Windows.\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\n#[repr(transparent)]\npub struct IoSliceMut<'a>(sys::io::IoSliceMut<'a>);\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> fmt::Debug for IoSliceMut<'a> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<'a> IoSliceMut<'a> {\n    /// Creates a new `IoSliceMut` wrapping a byte slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics on Windows if the slice is larger than 4GB.\n    #[stable(feature = \"iovec\", since = \"1.36.0\")]\n    #[inline]\n    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n}\n\n    /// Advance the internal cursor of the slice.\n    ///\n    /// # Notes\n    ///\n    /// Elements in the slice may be modified if the cursor is not advanced to\n    /// the end of the slice. For example if we have a slice of buffers with 2\n    /// `IoSliceMut`s, both of length 8, and we advance the cursor by 10 bytes\n    /// the first `IoSliceMut` will be untouched however the second will be\n    /// modified to remove the first 2 bytes (10 - 8).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(io_slice_advance)]\n    ///\n    /// use std::io::IoSliceMut;\n    /// use std::ops::Deref;\n    ///\n    /// let mut buf1 = [1; 8];\n    /// let mut buf2 = [2; 16];\n    /// let mut buf3 = [3; 8];\n    /// let mut bufs = &mut [\n    ///     IoSliceMut::new(&mut buf1),\n    ///     IoSliceMut::new(&mut buf2),\n    ///     IoSliceMut::new(&mut buf3),\n    /// ][..];\n    ///\n    /// // Mark 10 bytes as read.\n    /// bufs = IoSliceMut::advance(bufs, 10);\n    /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n    /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n    /// ```\n    #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n    #[inline]\n    pub fn advance<'b>(bufs: &'b mut [IoSliceMut<'a>], n: usize) -> &'b mut [IoSliceMut<'a>] {\n}\n}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> Deref for IoSliceMut<'a> {\n    type Target = [u8];\n\n    #[inline]\n    fn deref(&self) -> &[u8] {\n}\n}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> DerefMut for IoSliceMut<'a> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut [u8] {\n}\n}\n\n/// A buffer type used with `Write::write_vectored`.\n///\n/// It is semantically a wrapper around an `&[u8]`, but is guaranteed to be\n/// ABI compatible with the `iovec` type on Unix platforms and `WSABUF` on\n/// Windows.\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\n#[repr(transparent)]\npub struct IoSlice<'a>(sys::io::IoSlice<'a>);\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> fmt::Debug for IoSlice<'a> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<'a> IoSlice<'a> {\n    /// Creates a new `IoSlice` wrapping a byte slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics on Windows if the slice is larger than 4GB.\n    #[stable(feature = \"iovec\", since = \"1.36.0\")]\n    #[inline]\n    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n}\n\n    /// Advance the internal cursor of the slice.\n    ///\n    /// # Notes\n    ///\n    /// Elements in the slice may be modified if the cursor is not advanced to\n    /// the end of the slice. For example if we have a slice of buffers with 2\n    /// `IoSlice`s, both of length 8, and we advance the cursor by 10 bytes the\n    /// first `IoSlice` will be untouched however the second will be modified to\n    /// remove the first 2 bytes (10 - 8).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(io_slice_advance)]\n    ///\n    /// use std::io::IoSlice;\n    /// use std::ops::Deref;\n    ///\n    /// let buf1 = [1; 8];\n    /// let buf2 = [2; 16];\n    /// let buf3 = [3; 8];\n    /// let mut bufs = &mut [\n    ///     IoSlice::new(&buf1),\n    ///     IoSlice::new(&buf2),\n    ///     IoSlice::new(&buf3),\n    /// ][..];\n    ///\n    /// // Mark 10 bytes as written.\n    /// bufs = IoSlice::advance(bufs, 10);\n    /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n    /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n    #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n    #[inline]\n    pub fn advance<'b>(bufs: &'b mut [IoSlice<'a>], n: usize) -> &'b mut [IoSlice<'a>] {\n}\n}\n\n#[stable(feature = \"iovec\", since = \"1.36.0\")]\nimpl<'a> Deref for IoSlice<'a> {\n    type Target = [u8];\n\n    #[inline]\n    fn deref(&self) -> &[u8] {\n}\n}\n\n/// A type used to conditionally initialize buffers passed to `Read` methods.\n#[unstable(feature = \"read_initializer\", issue = \"42788\")]\n#[derive(Debug)]\npub struct Initializer(bool);\n\nimpl Initializer {\n    /// Returns a new `Initializer` which will zero out buffers.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn zeroing() -> Initializer {\n}\n\n    /// Returns a new `Initializer` which will not zero out buffers.\n    ///\n    /// # Safety\n    ///\n    /// This may only be called by `Read`ers which guarantee that they will not\n    /// read from buffers passed to `Read` methods, and that the return value of\n    /// the method accurately reflects the number of bytes that have been\n    /// written to the head of the buffer.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub unsafe fn nop() -> Initializer {\n}\n\n    /// Indicates if a buffer should be initialized.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn should_initialize(&self) -> bool {\n}\n\n    /// Initializes a buffer if necessary.\n    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n    #[inline]\n    pub fn initialize(&self, buf: &mut [u8]) {\n}\n}\n\n/// A trait for objects which are byte-oriented sinks.\n///\n/// Implementors of the `Write` trait are sometimes called 'writers'.\n///\n/// Writers are defined by two required methods, [`write`] and [`flush`]:\n///\n/// * The [`write`] method will attempt to write some data into the object,\n///   returning how many bytes were successfully written.\n///\n/// * The [`flush`] method is useful for adaptors and explicit buffers\n///   themselves for ensuring that all buffered data has been pushed out to the\n///   'true sink'.\n///\n/// Writers are intended to be composable with one another. Many implementors\n/// throughout [`std::io`] take and provide types which implement the `Write`\n/// trait.\n///\n/// [`write`]: #tymethod.write\n/// [`flush`]: #tymethod.flush\n/// [`std::io`]: index.html\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// fn main() -> std::io::Result<()> {\n///     let data = b\"some bytes\";\n///\n///     let mut pos = 0;\n///     let mut buffer = File::create(\"foo.txt\")?;\n///\n///     while pos < data.len() {\n///         let bytes_written = buffer.write(&data[pos..])?;\n///         pos += bytes_written;\n///     }\n///     Ok(())\n/// }\n/// ```\n///\n/// The trait also provides convenience methods like [`write_all`], which calls\n/// `write` in a loop until its entire input has been written.\n///\n/// [`write_all`]: #method.write_all\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(spotlight)]\npub trait Write {\n    /// Write a buffer into this writer, returning how many bytes were written.\n    ///\n    /// This function will attempt to write the entire contents of `buf`, but\n    /// the entire write may not succeed, or the write may also generate an\n    /// error. A call to `write` represents *at most one* attempt to write to\n    /// any wrapped object.\n    ///\n    /// Calls to `write` are not guaranteed to block waiting for data to be\n    /// written, and a write which would otherwise block can be indicated through\n    /// an [`Err`] variant.\n    ///\n    /// If the return value is [`Ok(n)`] then it must be guaranteed that\n    /// `n <= buf.len()`. A return value of `0` typically means that the\n    /// underlying object is no longer able to accept bytes and will likely not\n    /// be able to in the future as well, or that the buffer provided is empty.\n    ///\n    /// # Errors\n    ///\n    /// Each call to `write` may generate an I/O error indicating that the\n    /// operation could not be completed. If an error is returned then no bytes\n    /// in the buffer were written to this writer.\n    ///\n    /// It is **not** considered an error if the entire buffer could not be\n    /// written to this writer.\n    ///\n    /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the\n    /// write operation should be retried if there is nothing else to do.\n    ///\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`Ok(n)`]:  ../../std/result/enum.Result.html#variant.Ok\n    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    ///     // Writes some prefix of the byte string, not necessarily all of it.\n    ///     buffer.write(b\"some bytes\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n\n    /// Like `write`, except that it writes from a slice of buffers.\n    ///\n    /// Data is copied from each buffer in order, with the final buffer\n    /// read from possibly being only partially consumed. This method must\n    /// behave as a call to `write` with the buffers concatenated would.\n    ///\n    /// The default implementation calls `write` with either the first nonempty\n    /// buffer provided, or an empty one if none exists.\n    #[stable(feature = \"iovec\", since = \"1.36.0\")]\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> Result<usize> {\n        default_write_vectored(|b| self.write(b), bufs)\n    }\n\n    /// Flush this output stream, ensuring that all intermediately buffered\n    /// contents reach their destination.\n    ///\n    /// # Errors\n    ///\n    /// It is considered an error if not all bytes could be written due to\n    /// I/O errors or EOF being reached.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::prelude::*;\n    /// use std::io::BufWriter;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = BufWriter::new(File::create(\"foo.txt\")?);\n    ///\n    ///     buffer.write_all(b\"some bytes\")?;\n    ///     buffer.flush()?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn flush(&mut self) -> Result<()>;\n\n    /// Attempts to write an entire buffer into this writer.\n    ///\n    /// This method will continuously call [`write`] until there is no more data\n    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n    /// returned. This method will not return until the entire buffer has been\n    /// successfully written or such an error occurs. The first error that is\n    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be\n    /// returned.\n    ///\n    /// # Errors\n    ///\n    /// This function will return the first error of\n    /// non-[`ErrorKind::Interrupted`] kind that [`write`] returns.\n    ///\n    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n    /// [`write`]: #tymethod.write\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    ///     buffer.write_all(b\"some bytes\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n}\n\n    /// Writes a formatted string into this writer, returning any error\n    /// encountered.\n    ///\n    /// This method is primarily used to interface with the\n    /// [`format_args!`][formatargs] macro, but it is rare that this should\n    /// explicitly be called. The [`write!`][write] macro should be favored to\n    /// invoke this method instead.\n    ///\n    /// [formatargs]: ../macro.format_args.html\n    /// [write]: ../macro.write.html\n    ///\n    /// This function internally uses the [`write_all`][writeall] method on\n    /// this trait and hence will continuously write data so long as no errors\n    /// are received. This also means that partial writes are not indicated in\n    /// this signature.\n    ///\n    /// [writeall]: #method.write_all\n    ///\n    /// # Errors\n    ///\n    /// This function will return any I/O error reported while formatting.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    ///     // this call\n    ///     write!(buffer, \"{:.*}\", 2, 1.234567)?;\n    ///     // turns into this:\n    ///     buffer.write_fmt(format_args!(\"{:.*}\", 2, 1.234567))?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> Result<()> {\n}\n\n    /// Creates a \"by reference\" adaptor for this instance of `Write`.\n    ///\n    /// The returned adaptor also implements `Write` and will simply borrow this\n    /// current writer.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io::Write;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> std::io::Result<()> {\n    ///     let mut buffer = File::create(\"foo.txt\")?;\n    ///\n    ///     let reference = buffer.by_ref();\n    ///\n    ///     // we can use reference just like our original buffer\n    ///     reference.write_all(b\"some bytes\")?;\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn by_ref(&mut self) -> &mut Self\n    where\n        Self: Sized,\n    {\n}\n}\n\n/// The `Seek` trait provides a cursor which can be moved within a stream of\n/// bytes.\n///\n/// The stream typically has a fixed size, allowing seeking relative to either\n/// end or the current offset.\n///\n/// # Examples\n///\n/// [`File`][file]s implement `Seek`:\n///\n/// [file]: ../fs/struct.File.html\n///\n/// ```no_run\n/// use std::io;\n/// use std::io::prelude::*;\n/// use std::fs::File;\n/// use std::io::SeekFrom;\n///\n/// fn main() -> io::Result<()> {\n///     let mut f = File::open(\"foo.txt\")?;\n///\n///     // move the cursor 42 bytes from the start of the file\n///     f.seek(SeekFrom::Start(42))?;\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Seek {\n    /// Seek to an offset, in bytes, in a stream.\n    ///\n    /// A seek beyond the end of a stream is allowed, but behavior is defined\n    /// by the implementation.\n    ///\n    /// If the seek operation completed successfully,\n    /// this method returns the new position from the start of the stream.\n    /// That position can be used later with [`SeekFrom::Start`].\n    ///\n    /// # Errors\n    ///\n    /// Seeking to a negative offset is considered an error.\n    ///\n    /// [`SeekFrom::Start`]: enum.SeekFrom.html#variant.Start\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n\n    /// Returns the length of this stream (in bytes).\n    ///\n    /// This method is implemented using up to three seek operations. If this\n    /// method returns successfully, the seek position is unchanged (i.e. the\n    /// position before calling this method is the same as afterwards).\n    /// However, if this method returns an error, the seek position is\n    /// unspecified.\n    ///\n    /// If you need to obtain the length of *many* streams and you don't care\n    /// about the seek position afterwards, you can reduce the number of seek\n    /// operations by simply calling `seek(SeekFrom::End(0))` and using its\n    /// return value (it is also the stream length).\n    ///\n    /// Note that length of a stream can change over time (for example, when\n    /// data is appended to a file). So calling this method multiple times does\n    /// not necessarily return the same length each time.\n    ///\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// #![feature(seek_convenience)]\n    /// use std::{\n    ///     io::{self, Seek},\n    ///     fs::File,\n    /// };\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = File::open(\"foo.txt\")?;\n    ///\n    ///     let len = f.stream_len()?;\n    ///     println!(\"The file is currently {} bytes long\", len);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[unstable(feature = \"seek_convenience\", issue = \"59359\")]\n    fn stream_len(&mut self) -> Result<u64> {\n}\n\n    /// Returns the current seek position from the start of the stream.\n    ///\n    /// This is equivalent to `self.seek(SeekFrom::Current(0))`.\n    ///\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// #![feature(seek_convenience)]\n    /// use std::{\n    ///     io::{self, BufRead, BufReader, Seek},\n    ///     fs::File,\n    /// };\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n    ///\n    ///     let before = f.stream_position()?;\n    ///     f.read_line(&mut String::new())?;\n    ///     let after = f.stream_position()?;\n    ///\n    ///     println!(\"The first line was {} bytes long\", after - before);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[unstable(feature = \"seek_convenience\", issue = \"59359\")]\n    fn stream_position(&mut self) -> Result<u64> {\n}\n}\n\n/// Enumeration of possible methods to seek within an I/O object.\n///\n/// It is used by the [`Seek`] trait.\n///\n/// [`Seek`]: trait.Seek.html\n#[derive(Copy, PartialEq, Eq, Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum SeekFrom {\n    /// Sets the offset to the provided number of bytes.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Start(#[stable(feature = \"rust1\", since = \"1.0.0\")] u64),\n\n    /// Sets the offset to the size of this object plus the specified number of\n    /// bytes.\n    ///\n    /// It is possible to seek beyond the end of an object, but it's an error to\n    /// seek before byte 0.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    End(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n\n    /// Sets the offset to the current position plus the specified number of\n    /// bytes.\n    ///\n    /// It is possible to seek beyond the end of an object, but it's an error to\n    /// seek before byte 0.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Current(#[stable(feature = \"rust1\", since = \"1.0.0\")] i64),\n}\n\nfn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> Result<usize> {\n}\n\n/// A `BufRead` is a type of `Read`er which has an internal buffer, allowing it\n/// to perform extra ways of reading.\n///\n/// For example, reading line-by-line is inefficient without using a buffer, so\n/// if you want to read by line, you'll need `BufRead`, which includes a\n/// [`read_line`] method as well as a [`lines`] iterator.\n///\n/// # Examples\n///\n/// A locked standard input implements `BufRead`:\n///\n/// ```no_run\n/// use std::io;\n/// use std::io::prelude::*;\n///\n/// let stdin = io::stdin();\n/// for line in stdin.lock().lines() {\n///     println!(\"{}\", line.unwrap());\n/// }\n/// ```\n///\n/// If you have something that implements [`Read`], you can use the [`BufReader`\n/// type][`BufReader`] to turn it into a `BufRead`.\n///\n/// For example, [`File`] implements [`Read`], but not `BufRead`.\n/// [`BufReader`] to the rescue!\n///\n/// [`BufReader`]: struct.BufReader.html\n/// [`File`]: ../fs/struct.File.html\n/// [`read_line`]: #method.read_line\n/// [`lines`]: #method.lines\n/// [`Read`]: trait.Read.html\n///\n/// ```no_run\n/// use std::io::{self, BufReader};\n/// use std::io::prelude::*;\n/// use std::fs::File;\n///\n/// fn main() -> io::Result<()> {\n///     let f = File::open(\"foo.txt\")?;\n///     let f = BufReader::new(f);\n///\n///     for line in f.lines() {\n///         println!(\"{}\", line.unwrap());\n///     }\n///\n///     Ok(())\n/// }\n/// ```\n///\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait BufRead: Read {\n    /// Returns the contents of the internal buffer, filling it with more data\n    /// from the inner reader if it is empty.\n    ///\n    /// This function is a lower-level call. It needs to be paired with the\n    /// [`consume`] method to function properly. When calling this\n    /// method, none of the contents will be \"read\" in the sense that later\n    /// calling `read` may return the same contents. As such, [`consume`] must\n    /// be called with the number of bytes that are consumed from this buffer to\n    /// ensure that the bytes are never returned twice.\n    ///\n    /// [`consume`]: #tymethod.consume\n    ///\n    /// An empty buffer returned indicates that the stream has reached EOF.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an I/O error if the underlying reader was\n    /// read, but returned an error.\n    ///\n    /// # Examples\n    ///\n    /// A locked standard input implements `BufRead`:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    ///\n    /// let stdin = io::stdin();\n    /// let mut stdin = stdin.lock();\n    ///\n    /// let buffer = stdin.fill_buf().unwrap();\n    ///\n    /// // work with buffer\n    /// println!(\"{:?}\", buffer);\n    ///\n    /// // ensure the bytes we worked with aren't returned again later\n    /// let length = buffer.len();\n    /// stdin.consume(length);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fill_buf(&mut self) -> Result<&[u8]>;\n\n    /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n    /// so they should no longer be returned in calls to `read`.\n    ///\n    /// This function is a lower-level call. It needs to be paired with the\n    /// [`fill_buf`] method to function properly. This function does\n    /// not perform any I/O, it simply informs this object that some amount of\n    /// its buffer, returned from [`fill_buf`], has been consumed and should\n    /// no longer be returned. As such, this function may do odd things if\n    /// [`fill_buf`] isn't called before calling it.\n    ///\n    /// The `amt` must be `<=` the number of bytes in the buffer returned by\n    /// [`fill_buf`].\n    ///\n    /// # Examples\n    ///\n    /// Since `consume()` is meant to be used with [`fill_buf`],\n    /// that method's example includes an example of `consume()`.\n    ///\n    /// [`fill_buf`]: #tymethod.fill_buf\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn consume(&mut self, amt: usize);\n\n    /// Read all bytes into `buf` until the delimiter `byte` or EOF is reached.\n    ///\n    /// This function will read bytes from the underlying stream until the\n    /// delimiter or EOF is found. Once found, all bytes up to, and including,\n    /// the delimiter (if found) will be appended to `buf`.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// # Errors\n    ///\n    /// This function will ignore all instances of [`ErrorKind::Interrupted`] and\n    /// will otherwise return any errors returned by [`fill_buf`].\n    ///\n    /// If an I/O error is encountered then all bytes read so far will be\n    /// present in `buf` and its length will have been adjusted appropriately.\n    ///\n    /// [`fill_buf`]: #tymethod.fill_buf\n    /// [`ErrorKind::Interrupted`]: enum.ErrorKind.html#variant.Interrupted\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to read all the bytes in a byte slice\n    /// in hyphen delimited segments:\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let mut cursor = io::Cursor::new(b\"lorem-ipsum\");\n    /// let mut buf = vec![];\n    ///\n    /// // cursor is at 'l'\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 6);\n    /// assert_eq!(buf, b\"lorem-\");\n    /// buf.clear();\n    ///\n    /// // cursor is at 'i'\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 5);\n    /// assert_eq!(buf, b\"ipsum\");\n    /// buf.clear();\n    ///\n    /// // cursor is at EOF\n    /// let num_bytes = cursor.read_until(b'-', &mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 0);\n    /// assert_eq!(buf, b\"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> {\n}\n\n    /// Read all bytes until a newline (the 0xA byte) is reached, and append\n    /// them to the provided buffer.\n    ///\n    /// This function will read bytes from the underlying stream until the\n    /// newline delimiter (the 0xA byte) or EOF is found. Once found, all bytes\n    /// up to, and including, the delimiter (if found) will be appended to\n    /// `buf`.\n    ///\n    /// If successful, this function will return the total number of bytes read.\n    ///\n    /// If this function returns `Ok(0)`, the stream has reached EOF.\n    ///\n    /// # Errors\n    ///\n    /// This function has the same error semantics as [`read_until`] and will\n    /// also return an error if the read bytes are not valid UTF-8. If an I/O\n    /// error is encountered then `buf` may contain some bytes already read in\n    /// the event that all data read so far was valid UTF-8.\n    ///\n    /// [`read_until`]: #method.read_until\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to read all the lines in a byte slice:\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let mut cursor = io::Cursor::new(b\"foo\\nbar\");\n    /// let mut buf = String::new();\n    ///\n    /// // cursor is at 'f'\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 4);\n    /// assert_eq!(buf, \"foo\\n\");\n    /// buf.clear();\n    ///\n    /// // cursor is at 'b'\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 3);\n    /// assert_eq!(buf, \"bar\");\n    /// buf.clear();\n    ///\n    /// // cursor is at EOF\n    /// let num_bytes = cursor.read_line(&mut buf)\n    ///     .expect(\"reading from cursor won't fail\");\n    /// assert_eq!(num_bytes, 0);\n    /// assert_eq!(buf, \"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn read_line(&mut self, buf: &mut String) -> Result<usize> {\n}\n\n    /// Returns an iterator over the contents of this reader split on the byte\n    /// `byte`.\n    ///\n    /// The iterator returned from this function will return instances of\n    /// [`io::Result`]`<`[`Vec<u8>`]`>`. Each vector returned will *not* have\n    /// the delimiter byte at the end.\n    ///\n    /// This function will yield errors whenever [`read_until`] would have\n    /// also yielded an error.\n    ///\n    /// [`io::Result`]: type.Result.html\n    /// [`Vec<u8>`]: ../vec/struct.Vec.html\n    /// [`read_until`]: #method.read_until\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to iterate over all hyphen delimited\n    /// segments in a byte slice\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let cursor = io::Cursor::new(b\"lorem-ipsum-dolor\");\n    ///\n    /// let mut split_iter = cursor.split(b'-').map(|l| l.unwrap());\n    /// assert_eq!(split_iter.next(), Some(b\"lorem\".to_vec()));\n    /// assert_eq!(split_iter.next(), Some(b\"ipsum\".to_vec()));\n    /// assert_eq!(split_iter.next(), Some(b\"dolor\".to_vec()));\n    /// assert_eq!(split_iter.next(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn split(self, byte: u8) -> Split<Self>\n    where\n        Self: Sized,\n    {\n}\n\n    /// Returns an iterator over the lines of this reader.\n    ///\n    /// The iterator returned from this function will yield instances of\n    /// [`io::Result`]`<`[`String`]`>`. Each string returned will *not* have a newline\n    /// byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.\n    ///\n    /// [`io::Result`]: type.Result.html\n    /// [`String`]: ../string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n    /// this example, we use [`Cursor`] to iterate over all the lines in a byte\n    /// slice.\n    ///\n    /// [`Cursor`]: struct.Cursor.html\n    ///\n    /// ```\n    /// use std::io::{self, BufRead};\n    ///\n    /// let cursor = io::Cursor::new(b\"lorem\\nipsum\\r\\ndolor\");\n    ///\n    /// let mut lines_iter = cursor.lines().map(|l| l.unwrap());\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"lorem\")));\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"ipsum\")));\n    /// assert_eq!(lines_iter.next(), Some(String::from(\"dolor\")));\n    /// assert_eq!(lines_iter.next(), None);\n    /// ```\n    ///\n    /// # Errors\n    ///\n    /// Each line of the iterator has the same error semantics as [`BufRead::read_line`].\n    ///\n    /// [`BufRead::read_line`]: trait.BufRead.html#method.read_line\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn lines(self) -> Lines<Self>\n    where\n        Self: Sized,\n    {\n}\n}\n\n/// Adaptor to chain together two readers.\n///\n/// This struct is generally created by calling [`chain`] on a reader.\n/// Please see the documentation of [`chain`] for more details.\n///\n/// [`chain`]: trait.Read.html#method.chain\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Chain<T, U> {\n    first: T,\n    second: U,\n    done_first: bool,\n}\n\nimpl<T, U> Chain<T, U> {\n    /// Consumes the `Chain`, returning the wrapped readers.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut foo_file = File::open(\"foo.txt\")?;\n    ///     let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    ///     let chain = foo_file.chain(bar_file);\n    ///     let (foo_file, bar_file) = chain.into_inner();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn into_inner(self) -> (T, U) {\n}\n\n    /// Gets references to the underlying readers in this `Chain`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut foo_file = File::open(\"foo.txt\")?;\n    ///     let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    ///     let chain = foo_file.chain(bar_file);\n    ///     let (foo_file, bar_file) = chain.get_ref();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_ref(&self) -> (&T, &U) {\n}\n\n    /// Gets mutable references to the underlying readers in this `Chain`.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying readers as doing so may corrupt the internal state of this\n    /// `Chain`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut foo_file = File::open(\"foo.txt\")?;\n    ///     let mut bar_file = File::open(\"bar.txt\")?;\n    ///\n    ///     let mut chain = foo_file.chain(bar_file);\n    ///     let (foo_file, bar_file) = chain.get_mut();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_mut(&mut self) -> (&mut T, &mut U) {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T: fmt::Debug, U: fmt::Debug> fmt::Debug for Chain<T, U> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Read, U: Read> Read for Chain<T, U> {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n}\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> Result<usize> {\n}\n\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\n\n#[stable(feature = \"chain_bufread\", since = \"1.9.0\")]\nimpl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n    fn fill_buf(&mut self) -> Result<&[u8]> {\n}\n\n    fn consume(&mut self, amt: usize) {\n}\n}\n\n/// Reader adaptor which limits the bytes read from an underlying reader.\n///\n/// This struct is generally created by calling [`take`] on a reader.\n/// Please see the documentation of [`take`] for more details.\n///\n/// [`take`]: trait.Read.html#method.take\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Take<T> {\n    inner: T,\n    limit: u64,\n}\n\nimpl<T> Take<T> {\n    /// Returns the number of bytes that can be read before this instance will\n    /// return EOF.\n    ///\n    /// # Note\n    ///\n    /// This instance may reach `EOF` after reading fewer bytes than indicated by\n    /// this method if the underlying [`Read`] instance reaches EOF.\n    ///\n    /// [`Read`]: ../../std/io/trait.Read.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let f = File::open(\"foo.txt\")?;\n    ///\n    ///     // read at most five bytes\n    ///     let handle = f.take(5);\n    ///\n    ///     println!(\"limit: {}\", handle.limit());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn limit(&self) -> u64 {\n}\n\n    /// Sets the number of bytes that can be read before this instance will\n    /// return EOF. This is the same as constructing a new `Take` instance, so\n    /// the amount of bytes read and the previous limit value don't matter when\n    /// calling this method.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let f = File::open(\"foo.txt\")?;\n    ///\n    ///     // read at most five bytes\n    ///     let mut handle = f.take(5);\n    ///     handle.set_limit(10);\n    ///\n    ///     assert_eq!(handle.limit(), 10);\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"take_set_limit\", since = \"1.27.0\")]\n    pub fn set_limit(&mut self, limit: u64) {\n}\n\n    /// Consumes the `Take`, returning the wrapped reader.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///\n    ///     let mut buffer = [0; 5];\n    ///     let mut handle = file.take(5);\n    ///     handle.read(&mut buffer)?;\n    ///\n    ///     let file = handle.into_inner();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"io_take_into_inner\", since = \"1.15.0\")]\n    pub fn into_inner(self) -> T {\n}\n\n    /// Gets a reference to the underlying reader.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///\n    ///     let mut buffer = [0; 5];\n    ///     let mut handle = file.take(5);\n    ///     handle.read(&mut buffer)?;\n    ///\n    ///     let file = handle.get_ref();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_ref(&self) -> &T {\n}\n\n    /// Gets a mutable reference to the underlying reader.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying reader as doing so may corrupt the internal limit of this\n    /// `Take`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::io::prelude::*;\n    /// use std::fs::File;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let mut file = File::open(\"foo.txt\")?;\n    ///\n    ///     let mut buffer = [0; 5];\n    ///     let mut handle = file.take(5);\n    ///     handle.read(&mut buffer)?;\n    ///\n    ///     let file = handle.get_mut();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"more_io_inner_methods\", since = \"1.20.0\")]\n    pub fn get_mut(&mut self) -> &mut T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Read> Read for Take<T> {\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n}\n\n    unsafe fn initializer(&self) -> Initializer {\n}\n\n    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: BufRead> BufRead for Take<T> {\n    fn fill_buf(&mut self) -> Result<&[u8]> {\n}\n\n    fn consume(&mut self, amt: usize) {\n}\n}\n\n/// An iterator over `u8` values of a reader.\n///\n/// This struct is generally created by calling [`bytes`] on a reader.\n/// Please see the documentation of [`bytes`] for more details.\n///\n/// [`bytes`]: trait.Read.html#method.bytes\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Bytes<R> {\n    inner: R,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<R: Read> Iterator for Bytes<R> {\n    type Item = Result<u8>;\n\n    fn next(&mut self) -> Option<Result<u8>> {\n}\n}\n\n/// An iterator over the contents of an instance of `BufRead` split on a\n/// particular byte.\n///\n/// This struct is generally created by calling [`split`] on a `BufRead`.\n/// Please see the documentation of [`split`] for more details.\n///\n/// [`split`]: trait.BufRead.html#method.split\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Split<B> {\n    buf: B,\n    delim: u8,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead> Iterator for Split<B> {\n    type Item = Result<Vec<u8>>;\n\n    fn next(&mut self) -> Option<Result<Vec<u8>>> {\n}\n}\n\n/// An iterator over the lines of an instance of `BufRead`.\n///\n/// This struct is generally created by calling [`lines`] on a `BufRead`.\n/// Please see the documentation of [`lines`] for more details.\n///\n/// [`lines`]: trait.BufRead.html#method.lines\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Lines<B> {\n    buf: B,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: BufRead> Iterator for Lines<B> {\n    type Item = Result<String>;\n\n    fn next(&mut self) -> Option<Result<String>> {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\npub mod net {\n//! Networking primitives for TCP/UDP communication.\n//!\n//! This module provides networking functionality for the Transmission Control and User\n//! Datagram Protocols, as well as types for IP and socket addresses.\n//!\n//! # Organization\n//!\n//! * [`TcpListener`] and [`TcpStream`] provide functionality for communication over TCP\n//! * [`UdpSocket`] provides functionality for communication over UDP\n//! * [`IpAddr`] represents IP addresses of either IPv4 or IPv6; [`Ipv4Addr`] and\n//!   [`Ipv6Addr`] are respectively IPv4 and IPv6 addresses\n//! * [`SocketAddr`] represents socket addresses of either IPv4 or IPv6; [`SocketAddrV4`]\n//!   and [`SocketAddrV6`] are respectively IPv4 and IPv6 socket addresses\n//! * [`ToSocketAddrs`] is a trait that used for generic address resolution when interacting\n//!   with networking objects like [`TcpListener`], [`TcpStream`] or [`UdpSocket`]\n//! * Other types are return or parameter types for various methods in this module\n//!\n//! [`IpAddr`]: ../../std/net/enum.IpAddr.html\n//! [`Ipv4Addr`]: ../../std/net/struct.Ipv4Addr.html\n//! [`Ipv6Addr`]: ../../std/net/struct.Ipv6Addr.html\n//! [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n//! [`SocketAddrV4`]: ../../std/net/struct.SocketAddrV4.html\n//! [`SocketAddrV6`]: ../../std/net/struct.SocketAddrV6.html\n//! [`TcpListener`]: ../../std/net/struct.TcpListener.html\n//! [`TcpStream`]: ../../std/net/struct.TcpStream.html\n//! [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n//! [`UdpSocket`]: ../../std/net/struct.UdpSocket.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::io::{self, Error, ErrorKind};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::addr::{SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::ip::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::parser::AddrParseError;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::tcp::{Incoming, TcpListener, TcpStream};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::udp::UdpSocket;\n\nmod addr {\nuse crate::convert::TryInto;\nuse crate::fmt;\nuse crate::hash;\nuse crate::io;\nuse crate::iter;\nuse crate::mem;\nuse crate::net::{htons, ntohs, IpAddr, Ipv4Addr, Ipv6Addr};\nuse crate::option;\nuse crate::slice;\nuse crate::sys::net::netc as c;\nuse crate::sys_common::net::LookupHost;\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\nuse crate::vec;\n\n/// An internet socket address, either IPv4 or IPv6.\n///\n/// Internet socket addresses consist of an [IP address], a 16-bit port number, as well\n/// as possibly some version-dependent additional information. See [`SocketAddrV4`]'s and\n/// [`SocketAddrV6`]'s respective documentation for more details.\n///\n/// The size of a `SocketAddr` instance may vary depending on the target operating\n/// system.\n///\n/// [IP address]: ../../std/net/enum.IpAddr.html\n/// [`SocketAddrV4`]: ../../std/net/struct.SocketAddrV4.html\n/// [`SocketAddrV6`]: ../../std/net/struct.SocketAddrV6.html\n///\n/// # Examples\n///\n/// ```\n/// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n///\n/// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n///\n/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n/// assert_eq!(socket.port(), 8080);\n/// assert_eq!(socket.is_ipv4(), true);\n/// ```\n#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum SocketAddr {\n    /// An IPv4 socket address.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    V4(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV4),\n    /// An IPv6 socket address.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    V6(#[stable(feature = \"rust1\", since = \"1.0.0\")] SocketAddrV6),\n}\n\n/// An IPv4 socket address.\n///\n/// IPv4 socket addresses consist of an [IPv4 address] and a 16-bit port number, as\n/// stated in [IETF RFC 793].\n///\n/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n///\n/// The size of a `SocketAddrV4` struct may vary depending on the target operating\n/// system.\n///\n/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n/// [IPv4 address]: ../../std/net/struct.Ipv4Addr.html\n/// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n///\n/// # Examples\n///\n/// ```\n/// use std::net::{Ipv4Addr, SocketAddrV4};\n///\n/// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n///\n/// assert_eq!(\"127.0.0.1:8080\".parse(), Ok(socket));\n/// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n/// assert_eq!(socket.port(), 8080);\n/// ```\n#[derive(Copy)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SocketAddrV4 {\n    inner: c::sockaddr_in,\n}\n\n/// An IPv6 socket address.\n///\n/// IPv6 socket addresses consist of an [Ipv6 address], a 16-bit port number, as well\n/// as fields containing the traffic class, the flow label, and a scope identifier\n/// (see [IETF RFC 2553, Section 3.3] for more details).\n///\n/// See [`SocketAddr`] for a type encompassing both IPv4 and IPv6 socket addresses.\n///\n/// The size of a `SocketAddrV6` struct may vary depending on the target operating\n/// system.\n///\n/// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n/// [IPv6 address]: ../../std/net/struct.Ipv6Addr.html\n/// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n///\n/// # Examples\n///\n/// ```\n/// use std::net::{Ipv6Addr, SocketAddrV6};\n///\n/// let socket = SocketAddrV6::new(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n///\n/// assert_eq!(\"[2001:db8::1]:8080\".parse(), Ok(socket));\n/// assert_eq!(socket.ip(), &Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1));\n/// assert_eq!(socket.port(), 8080);\n/// ```\n#[derive(Copy)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SocketAddrV6 {\n    inner: c::sockaddr_in6,\n}\n\nimpl SocketAddr {\n    /// Creates a new socket address from an [IP address] and a port number.\n    ///\n    /// [IP address]: ../../std/net/enum.IpAddr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n    ///\n    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n    /// assert_eq!(socket.port(), 8080);\n    /// ```\n    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n    pub fn new(ip: IpAddr, port: u16) -> SocketAddr {\n}\n\n    /// Returns the IP address associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n    ///\n    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n    /// ```\n    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n    pub fn ip(&self) -> IpAddr {\n}\n\n    /// Changes the IP address associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n    ///\n    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    /// socket.set_ip(IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n    /// assert_eq!(socket.ip(), IpAddr::V4(Ipv4Addr::new(10, 10, 0, 1)));\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_ip(&mut self, new_ip: IpAddr) {\n}\n\n    /// Returns the port number associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n    ///\n    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    /// assert_eq!(socket.port(), 8080);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn port(&self) -> u16 {\n}\n\n    /// Changes the port number associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n    ///\n    /// let mut socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    /// socket.set_port(1025);\n    /// assert_eq!(socket.port(), 1025);\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_port(&mut self, new_port: u16) {\n}\n\n    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n    /// [IPv4 address], and [`false`] otherwise.\n    ///\n    /// [`true`]: ../../std/primitive.bool.html\n    /// [`false`]: ../../std/primitive.bool.html\n    /// [IP address]: ../../std/net/enum.IpAddr.html\n    /// [IPv4 address]: ../../std/net/enum.IpAddr.html#variant.V4\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n    ///\n    /// let socket = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 8080);\n    /// assert_eq!(socket.is_ipv4(), true);\n    /// assert_eq!(socket.is_ipv6(), false);\n    /// ```\n    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n    pub fn is_ipv4(&self) -> bool {\n}\n\n    /// Returns [`true`] if the [IP address] in this `SocketAddr` is an\n    /// [IPv6 address], and [`false`] otherwise.\n    ///\n    /// [`true`]: ../../std/primitive.bool.html\n    /// [`false`]: ../../std/primitive.bool.html\n    /// [IP address]: ../../std/net/enum.IpAddr.html\n    /// [IPv6 address]: ../../std/net/enum.IpAddr.html#variant.V6\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv6Addr, SocketAddr};\n    ///\n    /// let socket = SocketAddr::new(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 0, 1)), 8080);\n    /// assert_eq!(socket.is_ipv4(), false);\n    /// assert_eq!(socket.is_ipv6(), true);\n    /// ```\n    #[stable(feature = \"sockaddr_checker\", since = \"1.16.0\")]\n    pub fn is_ipv6(&self) -> bool {\n}\n}\n\nimpl SocketAddrV4 {\n    /// Creates a new socket address from an [IPv4 address] and a port number.\n    ///\n    /// [IPv4 address]: ../../std/net/struct.Ipv4Addr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV4, Ipv4Addr};\n    ///\n    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(ip: Ipv4Addr, port: u16) -> SocketAddrV4 {\n}\n\n    /// Returns the IP address associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV4, Ipv4Addr};\n    ///\n    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n    /// assert_eq!(socket.ip(), &Ipv4Addr::new(127, 0, 0, 1));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ip(&self) -> &Ipv4Addr {\n}\n\n    /// Changes the IP address associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV4, Ipv4Addr};\n    ///\n    /// let mut socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n    /// socket.set_ip(Ipv4Addr::new(192, 168, 0, 1));\n    /// assert_eq!(socket.ip(), &Ipv4Addr::new(192, 168, 0, 1));\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_ip(&mut self, new_ip: Ipv4Addr) {\n}\n\n    /// Returns the port number associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV4, Ipv4Addr};\n    ///\n    /// let socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n    /// assert_eq!(socket.port(), 8080);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn port(&self) -> u16 {\n}\n\n    /// Changes the port number associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV4, Ipv4Addr};\n    ///\n    /// let mut socket = SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080);\n    /// socket.set_port(4242);\n    /// assert_eq!(socket.port(), 4242);\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_port(&mut self, new_port: u16) {\n}\n}\n\nimpl SocketAddrV6 {\n    /// Creates a new socket address from an [IPv6 address], a 16-bit port number,\n    /// and the `flowinfo` and `scope_id` fields.\n    ///\n    /// For more information on the meaning and layout of the `flowinfo` and `scope_id`\n    /// parameters, see [IETF RFC 2553, Section 3.3].\n    ///\n    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n    /// [IPv6 address]: ../../std/net/struct.Ipv6Addr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(ip: Ipv6Addr, port: u16, flowinfo: u32, scope_id: u32) -> SocketAddrV6 {\n}\n\n    /// Returns the IP address associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n    /// assert_eq!(socket.ip(), &Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ip(&self) -> &Ipv6Addr {\n}\n\n    /// Changes the IP address associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n    /// socket.set_ip(Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n    /// assert_eq!(socket.ip(), &Ipv6Addr::new(76, 45, 0, 0, 0, 0, 0, 0));\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_ip(&mut self, new_ip: Ipv6Addr) {\n}\n\n    /// Returns the port number associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n    /// assert_eq!(socket.port(), 8080);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn port(&self) -> u16 {\n}\n\n    /// Changes the port number associated with this socket address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 0);\n    /// socket.set_port(4242);\n    /// assert_eq!(socket.port(), 4242);\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_port(&mut self, new_port: u16) {\n}\n\n    /// Returns the flow information associated with this address.\n    ///\n    /// This information corresponds to the `sin6_flowinfo` field in C's `netinet/in.h`,\n    /// as specified in [IETF RFC 2553, Section 3.3].\n    /// It combines information about the flow label and the traffic class as specified\n    /// in [IETF RFC 2460], respectively [Section 6] and [Section 7].\n    ///\n    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n    /// [IETF RFC 2460]: https://tools.ietf.org/html/rfc2460\n    /// [Section 6]: https://tools.ietf.org/html/rfc2460#section-6\n    /// [Section 7]: https://tools.ietf.org/html/rfc2460#section-7\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 10, 0);\n    /// assert_eq!(socket.flowinfo(), 10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn flowinfo(&self) -> u32 {\n}\n\n    /// Changes the flow information associated with this socket address.\n    ///\n    /// See the [`flowinfo`] method's documentation for more details.\n    ///\n    /// [`flowinfo`]: #method.flowinfo\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 10, 0);\n    /// socket.set_flowinfo(56);\n    /// assert_eq!(socket.flowinfo(), 56);\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_flowinfo(&mut self, new_flowinfo: u32) {\n}\n\n    /// Returns the scope ID associated with this address.\n    ///\n    /// This information corresponds to the `sin6_scope_id` field in C's `netinet/in.h`,\n    /// as specified in [IETF RFC 2553, Section 3.3].\n    ///\n    /// [IETF RFC 2553, Section 3.3]: https://tools.ietf.org/html/rfc2553#section-3.3\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 78);\n    /// assert_eq!(socket.scope_id(), 78);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn scope_id(&self) -> u32 {\n}\n\n    /// Changes the scope ID associated with this socket address.\n    ///\n    /// See the [`scope_id`] method's documentation for more details.\n    ///\n    /// [`scope_id`]: #method.scope_id\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{SocketAddrV6, Ipv6Addr};\n    ///\n    /// let mut socket = SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), 8080, 0, 78);\n    /// socket.set_scope_id(42);\n    /// assert_eq!(socket.scope_id(), 42);\n    /// ```\n    #[stable(feature = \"sockaddr_setters\", since = \"1.9.0\")]\n    pub fn set_scope_id(&mut self, new_scope_id: u32) {\n}\n}\n\nimpl FromInner<c::sockaddr_in> for SocketAddrV4 {\n    fn from_inner(addr: c::sockaddr_in) -> SocketAddrV4 {\n}\n}\n\nimpl FromInner<c::sockaddr_in6> for SocketAddrV6 {\n    fn from_inner(addr: c::sockaddr_in6) -> SocketAddrV6 {\n}\n}\n\n#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\nimpl From<SocketAddrV4> for SocketAddr {\n    /// Converts a [`SocketAddrV4`] into a [`SocketAddr::V4`].\n    ///\n    /// [`SocketAddrV4`]: ../../std/net/struct.SocketAddrV4.html\n    /// [`SocketAddr::V4`]: ../../std/net/enum.SocketAddr.html#variant.V4\n    fn from(sock4: SocketAddrV4) -> SocketAddr {\n}\n}\n\n#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\nimpl From<SocketAddrV6> for SocketAddr {\n    /// Converts a [`SocketAddrV6`] into a [`SocketAddr::V6`].\n    ///\n    /// [`SocketAddrV6`]: ../../std/net/struct.SocketAddrV6.html\n    /// [`SocketAddr::V6`]: ../../std/net/enum.SocketAddr.html#variant.V6\n    fn from(sock6: SocketAddrV6) -> SocketAddr {\n}\n}\n\n#[stable(feature = \"addr_from_into_ip\", since = \"1.17.0\")]\nimpl<I: Into<IpAddr>> From<(I, u16)> for SocketAddr {\n    /// Converts a tuple struct (Into<[`IpAddr`]>, `u16`) into a [`SocketAddr`].\n    ///\n    /// This conversion creates a [`SocketAddr::V4`] for a [`IpAddr::V4`]\n    /// and creates a [`SocketAddr::V6`] for a [`IpAddr::V6`].\n    ///\n    /// `u16` is treated as port of the newly created [`SocketAddr`].\n    ///\n    /// [`IpAddr`]: ../../std/net/enum.IpAddr.html\n    /// [`IpAddr::V4`]: ../../std/net/enum.IpAddr.html#variant.V4\n    /// [`IpAddr::V6`]: ../../std/net/enum.IpAddr.html#variant.V6\n    /// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n    /// [`SocketAddr::V4`]: ../../std/net/enum.SocketAddr.html#variant.V4\n    /// [`SocketAddr::V6`]: ../../std/net/enum.SocketAddr.html#variant.V6\n    fn from(pieces: (I, u16)) -> SocketAddr {\n}\n}\n\nimpl<'a> IntoInner<(*const c::sockaddr, c::socklen_t)> for &'a SocketAddr {\n    fn into_inner(self) -> (*const c::sockaddr, c::socklen_t) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for SocketAddr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for SocketAddrV4 {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for SocketAddrV4 {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for SocketAddrV6 {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for SocketAddrV6 {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for SocketAddrV4 {\n    fn clone(&self) -> SocketAddrV4 {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for SocketAddrV6 {\n    fn clone(&self) -> SocketAddrV6 {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for SocketAddrV4 {\n    fn eq(&self, other: &SocketAddrV4) -> bool {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for SocketAddrV6 {\n    fn eq(&self, other: &SocketAddrV6) -> bool {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for SocketAddrV4 {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for SocketAddrV6 {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl hash::Hash for SocketAddrV4 {\n    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl hash::Hash for SocketAddrV6 {\n    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n}\n}\n\n/// A trait for objects which can be converted or resolved to one or more\n/// [`SocketAddr`] values.\n///\n/// This trait is used for generic address resolution when constructing network\n/// objects. By default it is implemented for the following types:\n///\n///  * [`SocketAddr`]: [`to_socket_addrs`] is the identity function.\n///\n///  * [`SocketAddrV4`], [`SocketAddrV6`], `(`[`IpAddr`]`, `[`u16`]`)`,\n///    `(`[`Ipv4Addr`]`, `[`u16`]`)`, `(`[`Ipv6Addr`]`, `[`u16`]`)`:\n///    [`to_socket_addrs`] constructs a [`SocketAddr`] trivially.\n///\n///  * `(`[`&str`]`, `[`u16`]`)`: the string should be either a string representation\n///    of an [`IpAddr`] address as expected by [`FromStr`] implementation or a host\n///    name.\n///\n///  * [`&str`]: the string should be either a string representation of a\n///    [`SocketAddr`] as expected by its [`FromStr`] implementation or a string like\n///    `<host_name>:<port>` pair where `<port>` is a [`u16`] value.\n///\n/// This trait allows constructing network objects like [`TcpStream`] or\n/// [`UdpSocket`] easily with values of various types for the bind/connection\n/// address. It is needed because sometimes one type is more appropriate than\n/// the other: for simple uses a string like `\"localhost:12345\"` is much nicer\n/// than manual construction of the corresponding [`SocketAddr`], but sometimes\n/// [`SocketAddr`] value is *the* main source of the address, and converting it to\n/// some other type (e.g., a string) just for it to be converted back to\n/// [`SocketAddr`] in constructor methods is pointless.\n///\n/// Addresses returned by the operating system that are not IP addresses are\n/// silently ignored.\n///\n/// [`FromStr`]: ../../std/str/trait.FromStr.html\n/// [`IpAddr`]: ../../std/net/enum.IpAddr.html\n/// [`Ipv4Addr`]: ../../std/net/struct.Ipv4Addr.html\n/// [`Ipv6Addr`]: ../../std/net/struct.Ipv6Addr.html\n/// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n/// [`SocketAddrV4`]: ../../std/net/struct.SocketAddrV4.html\n/// [`SocketAddrV6`]: ../../std/net/struct.SocketAddrV6.html\n/// [`&str`]: ../../std/primitive.str.html\n/// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n/// [`to_socket_addrs`]: #tymethod.to_socket_addrs\n/// [`UdpSocket`]: ../../std/net/struct.UdpSocket.html\n/// [`u16`]: ../../std/primitive.u16.html\n///\n/// # Examples\n///\n/// Creating a [`SocketAddr`] iterator that yields one item:\n///\n/// ```\n/// use std::net::{ToSocketAddrs, SocketAddr};\n///\n/// let addr = SocketAddr::from(([127, 0, 0, 1], 443));\n/// let mut addrs_iter = addr.to_socket_addrs().unwrap();\n///\n/// assert_eq!(Some(addr), addrs_iter.next());\n/// assert!(addrs_iter.next().is_none());\n/// ```\n///\n/// Creating a [`SocketAddr`] iterator from a hostname:\n///\n/// ```no_run\n/// use std::net::{SocketAddr, ToSocketAddrs};\n///\n/// // assuming 'localhost' resolves to 127.0.0.1\n/// let mut addrs_iter = \"localhost:443\".to_socket_addrs().unwrap();\n/// assert_eq!(addrs_iter.next(), Some(SocketAddr::from(([127, 0, 0, 1], 443))));\n/// assert!(addrs_iter.next().is_none());\n///\n/// // assuming 'foo' does not resolve\n/// assert!(\"foo:443\".to_socket_addrs().is_err());\n/// ```\n///\n/// Creating a [`SocketAddr`] iterator that yields multiple items:\n///\n/// ```\n/// use std::net::{SocketAddr, ToSocketAddrs};\n///\n/// let addr1 = SocketAddr::from(([0, 0, 0, 0], 80));\n/// let addr2 = SocketAddr::from(([127, 0, 0, 1], 443));\n/// let addrs = vec![addr1, addr2];\n///\n/// let mut addrs_iter = (&addrs[..]).to_socket_addrs().unwrap();\n///\n/// assert_eq!(Some(addr1), addrs_iter.next());\n/// assert_eq!(Some(addr2), addrs_iter.next());\n/// assert!(addrs_iter.next().is_none());\n/// ```\n///\n/// Attempting to create a [`SocketAddr`] iterator from an improperly formatted\n/// socket address `&str` (missing the port):\n///\n/// ```\n/// use std::io;\n/// use std::net::ToSocketAddrs;\n///\n/// let err = \"127.0.0.1\".to_socket_addrs().unwrap_err();\n/// assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n/// ```\n///\n/// [`TcpStream::connect`] is an example of an function that utilizes\n/// `ToSocketAddrs` as a trait bound on its parameter in order to accept\n/// different types:\n///\n/// ```no_run\n/// use std::net::{TcpStream, Ipv4Addr};\n///\n/// let stream = TcpStream::connect((\"127.0.0.1\", 443));\n/// // or\n/// let stream = TcpStream::connect(\"127.0.0.1:443\");\n/// // or\n/// let stream = TcpStream::connect((Ipv4Addr::new(127, 0, 0, 1), 443));\n/// ```\n///\n/// [`TcpStream::connect`]: ../../std/net/struct.TcpStream.html#method.connect\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait ToSocketAddrs {\n    /// Returned iterator over socket addresses which this type may correspond\n    /// to.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Iter: Iterator<Item = SocketAddr>;\n\n    /// Converts this object to an iterator of resolved `SocketAddr`s.\n    ///\n    /// The returned iterator may not actually yield any values depending on the\n    /// outcome of any resolution performed.\n    ///\n    /// Note that this function may block the current thread while resolution is\n    /// performed.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn to_socket_addrs(&self) -> io::Result<Self::Iter>;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for SocketAddr {\n    type Iter = option::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for SocketAddrV4 {\n    type Iter = option::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for SocketAddrV6 {\n    type Iter = option::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for (IpAddr, u16) {\n    type Iter = option::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for (Ipv4Addr, u16) {\n    type Iter = option::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for (Ipv6Addr, u16) {\n    type Iter = option::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<option::IntoIter<SocketAddr>> {\n}\n}\n\nfn resolve_socket_addr(lh: LookupHost) -> io::Result<vec::IntoIter<SocketAddr>> {\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for (&str, u16) {\n    type Iter = vec::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n}\n}\n\n// accepts strings like 'localhost:12345'\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToSocketAddrs for str {\n    type Iter = vec::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n}\n}\n\n#[stable(feature = \"slice_to_socket_addrs\", since = \"1.8.0\")]\nimpl<'a> ToSocketAddrs for &'a [SocketAddr] {\n    type Iter = iter::Cloned<slice::Iter<'a, SocketAddr>>;\n\n    fn to_socket_addrs(&self) -> io::Result<Self::Iter> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ToSocketAddrs + ?Sized> ToSocketAddrs for &T {\n    type Iter = T::Iter;\n    fn to_socket_addrs(&self) -> io::Result<T::Iter> {\n}\n}\n\n#[stable(feature = \"string_to_socket_addrs\", since = \"1.16.0\")]\nimpl ToSocketAddrs for String {\n    type Iter = vec::IntoIter<SocketAddr>;\n    fn to_socket_addrs(&self) -> io::Result<vec::IntoIter<SocketAddr>> {\n}\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use crate::net::test::{sa4, sa6, tsa};\n    use crate::net::*;\n\n    #[test]\n    fn to_socket_addr_ipaddr_u16() {\n}\n\n    #[test]\n    fn to_socket_addr_str_u16() {\n}\n\n    #[test]\n    fn to_socket_addr_str() {\n}\n\n    #[test]\n    fn to_socket_addr_string() {\n}\n\n    // FIXME: figure out why this fails on openbsd and fix it\n    #[test]\n    #[cfg(not(any(windows, target_os = \"openbsd\")))]\n    fn to_socket_addr_str_bad() {\n}\n\n    #[test]\n    fn set_ip() {\n}\n\n    #[test]\n    fn set_port() {\n}\n\n    #[test]\n    fn set_flowinfo() {\n}\n\n    #[test]\n    fn set_scope_id() {\n}\n\n    #[test]\n    fn is_v4() {\n}\n\n    #[test]\n    fn is_v6() {\n}\n}\n}\nmod ip {\n#![unstable(\n    feature = \"ip\",\n    reason = \"extra functionality has not been \\\n                                      scrutinized to the level that it should \\\n                                      be to be stable\",\n    issue = \"27709\"\n)]\n\nuse crate::cmp::Ordering;\nuse crate::fmt;\nuse crate::hash;\nuse crate::io::Write;\nuse crate::sys::net::netc as c;\nuse crate::sys_common::{AsInner, FromInner};\n\n/// An IP address, either IPv4 or IPv6.\n///\n/// This enum can contain either an [`Ipv4Addr`] or an [`Ipv6Addr`], see their\n/// respective documentation for more details.\n///\n/// The size of an `IpAddr` instance may vary depending on the target operating\n/// system.\n///\n/// [`Ipv4Addr`]: ../../std/net/struct.Ipv4Addr.html\n/// [`Ipv6Addr`]: ../../std/net/struct.Ipv6Addr.html\n///\n/// # Examples\n///\n/// ```\n/// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n///\n/// let localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));\n/// let localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n///\n/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost_v4));\n/// assert_eq!(\"::1\".parse(), Ok(localhost_v6));\n///\n/// assert_eq!(localhost_v4.is_ipv6(), false);\n/// assert_eq!(localhost_v4.is_ipv4(), true);\n/// ```\n#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n#[derive(Copy, Clone, Eq, PartialEq, Debug, Hash, PartialOrd, Ord)]\npub enum IpAddr {\n    /// An IPv4 address.\n    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n    V4(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv4Addr),\n    /// An IPv6 address.\n    #[stable(feature = \"ip_addr\", since = \"1.7.0\")]\n    V6(#[stable(feature = \"ip_addr\", since = \"1.7.0\")] Ipv6Addr),\n}\n\n/// An IPv4 address.\n///\n/// IPv4 addresses are defined as 32-bit integers in [IETF RFC 791].\n/// They are usually represented as four octets.\n///\n/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n///\n/// The size of an `Ipv4Addr` struct may vary depending on the target operating\n/// system.\n///\n/// [IETF RFC 791]: https://tools.ietf.org/html/rfc791\n/// [`IpAddr`]: ../../std/net/enum.IpAddr.html\n///\n/// # Textual representation\n///\n/// `Ipv4Addr` provides a [`FromStr`] implementation. The four octets are in decimal\n/// notation, divided by `.` (this is called \"dot-decimal notation\").\n///\n/// [`FromStr`]: ../../std/str/trait.FromStr.html\n///\n/// # Examples\n///\n/// ```\n/// use std::net::Ipv4Addr;\n///\n/// let localhost = Ipv4Addr::new(127, 0, 0, 1);\n/// assert_eq!(\"127.0.0.1\".parse(), Ok(localhost));\n/// assert_eq!(localhost.is_loopback(), true);\n/// ```\n#[derive(Copy)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Ipv4Addr {\n    inner: c::in_addr,\n}\n\n/// An IPv6 address.\n///\n/// IPv6 addresses are defined as 128-bit integers in [IETF RFC 4291].\n/// They are usually represented as eight 16-bit segments.\n///\n/// See [`IpAddr`] for a type encompassing both IPv4 and IPv6 addresses.\n///\n/// The size of an `Ipv6Addr` struct may vary depending on the target operating\n/// system.\n///\n/// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n/// [`IpAddr`]: ../../std/net/enum.IpAddr.html\n///\n/// # Textual representation\n///\n/// `Ipv6Addr` provides a [`FromStr`] implementation. There are many ways to represent\n/// an IPv6 address in text, but in general, each segments is written in hexadecimal\n/// notation, and segments are separated by `:`. For more information, see\n/// [IETF RFC 5952].\n///\n/// [`FromStr`]: ../../std/str/trait.FromStr.html\n/// [IETF RFC 5952]: https://tools.ietf.org/html/rfc5952\n///\n/// # Examples\n///\n/// ```\n/// use std::net::Ipv6Addr;\n///\n/// let localhost = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n/// assert_eq!(\"::1\".parse(), Ok(localhost));\n/// assert_eq!(localhost.is_loopback(), true);\n/// ```\n#[derive(Copy)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Ipv6Addr {\n    inner: c::in6_addr,\n}\n\n#[allow(missing_docs)]\n#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\npub enum Ipv6MulticastScope {\n    InterfaceLocal,\n    LinkLocal,\n    RealmLocal,\n    AdminLocal,\n    SiteLocal,\n    OrganizationLocal,\n    Global,\n}\n\nimpl IpAddr {\n    /// Returns [`true`] for the special 'unspecified' address.\n    ///\n    /// See the documentation for [`Ipv4Addr::is_unspecified`][IPv4] and\n    /// [`Ipv6Addr::is_unspecified`][IPv6] for more details.\n    ///\n    /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_unspecified\n    /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_unspecified\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(0, 0, 0, 0)).is_unspecified(), true);\n    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)).is_unspecified(), true);\n    /// ```\n    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n    pub fn is_unspecified(&self) -> bool {\n}\n\n    /// Returns [`true`] if this is a loopback address.\n    ///\n    /// See the documentation for [`Ipv4Addr::is_loopback`][IPv4] and\n    /// [`Ipv6Addr::is_loopback`][IPv6] for more details.\n    ///\n    /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_loopback\n    /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_loopback\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)).is_loopback(), true);\n    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1)).is_loopback(), true);\n    /// ```\n    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n    pub fn is_loopback(&self) -> bool {\n}\n\n    /// Returns [`true`] if the address appears to be globally routable.\n    ///\n    /// See the documentation for [`Ipv4Addr::is_global`][IPv4] and\n    /// [`Ipv6Addr::is_global`][IPv6] for more details.\n    ///\n    /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_global\n    /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_global\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(80, 9, 12, 3)).is_global(), true);\n    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1)).is_global(), true);\n    /// ```\n    pub fn is_global(&self) -> bool {\n}\n\n    /// Returns [`true`] if this is a multicast address.\n    ///\n    /// See the documentation for [`Ipv4Addr::is_multicast`][IPv4] and\n    /// [`Ipv6Addr::is_multicast`][IPv6] for more details.\n    ///\n    /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_multicast\n    /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_multicast\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(224, 254, 0, 0)).is_multicast(), true);\n    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0)).is_multicast(), true);\n    /// ```\n    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n    pub fn is_multicast(&self) -> bool {\n}\n\n    /// Returns [`true`] if this address is in a range designated for documentation.\n    ///\n    /// See the documentation for [`Ipv4Addr::is_documentation`][IPv4] and\n    /// [`Ipv6Addr::is_documentation`][IPv6] for more details.\n    ///\n    /// [IPv4]: ../../std/net/struct.Ipv4Addr.html#method.is_documentation\n    /// [IPv6]: ../../std/net/struct.Ipv6Addr.html#method.is_documentation\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_documentation(), true);\n    /// assert_eq!(\n    ///     IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_documentation(),\n    ///     true\n    /// );\n    /// ```\n    pub fn is_documentation(&self) -> bool {\n}\n\n    /// Returns [`true`] if this address is an [IPv4 address], and [`false`] otherwise.\n    ///\n    /// [`true`]: ../../std/primitive.bool.html\n    /// [`false`]: ../../std/primitive.bool.html\n    /// [IPv4 address]: #variant.V4\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv4(), true);\n    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv4(), false);\n    /// ```\n    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n    pub fn is_ipv4(&self) -> bool {\n}\n\n    /// Returns [`true`] if this address is an [IPv6 address], and [`false`] otherwise.\n    ///\n    /// [`true`]: ../../std/primitive.bool.html\n    /// [`false`]: ../../std/primitive.bool.html\n    /// [IPv6 address]: #variant.V6\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(203, 0, 113, 6)).is_ipv6(), false);\n    /// assert_eq!(IpAddr::V6(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0)).is_ipv6(), true);\n    /// ```\n    #[stable(feature = \"ipaddr_checker\", since = \"1.16.0\")]\n    pub fn is_ipv6(&self) -> bool {\n}\n}\n\nimpl Ipv4Addr {\n    /// Creates a new IPv4 address from four eight-bit octets.\n    ///\n    /// The result will represent the IP address `a`.`b`.`c`.`d`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.32.0\")]\n    pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n}\n\n    /// An IPv4 address with the address pointing to localhost: 127.0.0.1.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::LOCALHOST;\n    /// assert_eq!(addr, Ipv4Addr::new(127, 0, 0, 1));\n    /// ```\n    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n    pub const LOCALHOST: Self = Ipv4Addr::new(127, 0, 0, 1);\n\n    /// An IPv4 address representing an unspecified address: 0.0.0.0\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::UNSPECIFIED;\n    /// assert_eq!(addr, Ipv4Addr::new(0, 0, 0, 0));\n    /// ```\n    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n    pub const UNSPECIFIED: Self = Ipv4Addr::new(0, 0, 0, 0);\n\n    /// An IPv4 address representing the broadcast address: 255.255.255.255\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::BROADCAST;\n    /// assert_eq!(addr, Ipv4Addr::new(255, 255, 255, 255));\n    /// ```\n    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n    pub const BROADCAST: Self = Ipv4Addr::new(255, 255, 255, 255);\n\n    /// Returns the four eight-bit integers that make up this address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::new(127, 0, 0, 1);\n    /// assert_eq!(addr.octets(), [127, 0, 0, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn octets(&self) -> [u8; 4] {\n}\n\n    /// Returns [`true`] for the special 'unspecified' address (0.0.0.0).\n    ///\n    /// This property is defined in _UNIX Network Programming, Second Edition_,\n    /// W. Richard Stevens, p. 891; see also [ip7].\n    ///\n    /// [ip7]: http://man7.org/linux/man-pages/man7/ip.7.html\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_unspecified(), true);\n    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_unspecified(), false);\n    /// ```\n    #[stable(feature = \"ip_shared\", since = \"1.12.0\")]\n    #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.32.0\")]\n    pub const fn is_unspecified(&self) -> bool {\n}\n\n    /// Returns [`true`] if this is a loopback address (127.0.0.0/8).\n    ///\n    /// This property is defined by [IETF RFC 1122].\n    ///\n    /// [IETF RFC 1122]: https://tools.ietf.org/html/rfc1122\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_loopback(), true);\n    /// assert_eq!(Ipv4Addr::new(45, 22, 13, 197).is_loopback(), false);\n    /// ```\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    pub fn is_loopback(&self) -> bool {\n}\n\n    /// Returns [`true`] if this is a private address.\n    ///\n    /// The private address ranges are defined in [IETF RFC 1918] and include:\n    ///\n    ///  - 10.0.0.0/8\n    ///  - 172.16.0.0/12\n    ///  - 192.168.0.0/16\n    ///\n    /// [IETF RFC 1918]: https://tools.ietf.org/html/rfc1918\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(10, 0, 0, 1).is_private(), true);\n    /// assert_eq!(Ipv4Addr::new(10, 10, 10, 10).is_private(), true);\n    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 10).is_private(), true);\n    /// assert_eq!(Ipv4Addr::new(172, 29, 45, 14).is_private(), true);\n    /// assert_eq!(Ipv4Addr::new(172, 32, 0, 2).is_private(), false);\n    /// assert_eq!(Ipv4Addr::new(192, 168, 0, 2).is_private(), true);\n    /// assert_eq!(Ipv4Addr::new(192, 169, 0, 2).is_private(), false);\n    /// ```\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    pub fn is_private(&self) -> bool {\n}\n\n    /// Returns [`true`] if the address is link-local (169.254.0.0/16).\n    ///\n    /// This property is defined by [IETF RFC 3927].\n    ///\n    /// [IETF RFC 3927]: https://tools.ietf.org/html/rfc3927\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(169, 254, 0, 0).is_link_local(), true);\n    /// assert_eq!(Ipv4Addr::new(169, 254, 10, 65).is_link_local(), true);\n    /// assert_eq!(Ipv4Addr::new(16, 89, 10, 65).is_link_local(), false);\n    /// ```\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    pub fn is_link_local(&self) -> bool {\n}\n\n    /// Returns [`true`] if the address appears to be globally routable.\n    /// See [iana-ipv4-special-registry][ipv4-sr].\n    ///\n    /// The following return false:\n    ///\n    /// - private addresses (see [`is_private()`](#method.is_private))\n    /// - the loopback address (see [`is_loopback()`](#method.is_loopback))\n    /// - the link-local address (see [`is_link_local()`](#method.is_link_local))\n    /// - the broadcast address (see [`is_broadcast()`](#method.is_broadcast))\n    /// - addresses used for documentation (see [`is_documentation()`](#method.is_documentation))\n    /// - the unspecified address (see [`is_unspecified()`](#method.is_unspecified)), and the whole\n    ///   0.0.0.0/8 block\n    /// - addresses reserved for future protocols (see\n    /// [`is_ietf_protocol_assignment()`](#method.is_ietf_protocol_assignment), except\n    /// `192.0.0.9/32` and `192.0.0.10/32` which are globally routable\n    /// - addresses reserved for future use (see [`is_reserved()`](#method.is_reserved)\n    /// - addresses reserved for networking devices benchmarking (see\n    /// [`is_benchmarking`](#method.is_benchmarking))\n    ///\n    /// [ipv4-sr]: https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv4Addr;\n    ///\n    /// // private addresses are not global\n    /// assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n    /// assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n    ///\n    /// // the 0.0.0.0/8 block is not global\n    /// assert_eq!(Ipv4Addr::new(0, 1, 2, 3).is_global(), false);\n    /// // in particular, the unspecified address is not global\n    /// assert_eq!(Ipv4Addr::new(0, 0, 0, 0).is_global(), false);\n    ///\n    /// // the loopback address is not global\n    /// assert_eq!(Ipv4Addr::new(127, 0, 0, 1).is_global(), false);\n    ///\n    /// // link local addresses are not global\n    /// assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n    ///\n    /// // the broadcast address is not global\n    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_global(), false);\n    ///\n    /// // the address space designated for documentation is not global\n    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n    ///\n    /// // shared addresses are not global\n    /// assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n    ///\n    /// // addresses reserved for protocol assignment are not global\n    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_global(), false);\n    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_global(), false);\n    ///\n    /// // addresses reserved for future use are not global\n    /// assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n    ///\n    /// // addresses reserved for network devices benchmarking are not global\n    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n    ///\n    /// // All the other addresses are global\n    /// assert_eq!(Ipv4Addr::new(1, 1, 1, 1).is_global(), true);\n    /// assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n    /// ```\n    pub fn is_global(&self) -> bool {\n}\n\n    /// Returns [`true`] if this address is part of the Shared Address Space defined in\n    /// [IETF RFC 6598] (`100.64.0.0/10`).\n    ///\n    /// [IETF RFC 6598]: https://tools.ietf.org/html/rfc6598\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(100, 64, 0, 0).is_shared(), true);\n    /// assert_eq!(Ipv4Addr::new(100, 127, 255, 255).is_shared(), true);\n    /// assert_eq!(Ipv4Addr::new(100, 128, 0, 0).is_shared(), false);\n    /// ```\n    pub fn is_shared(&self) -> bool {\n}\n\n    /// Returns [`true`] if this address is part of `192.0.0.0/24`, which is reserved to\n    /// IANA for IETF protocol assignments, as documented in [IETF RFC 6890].\n    ///\n    /// Note that parts of this block are in use:\n    ///\n    /// - `192.0.0.8/32` is the \"IPv4 dummy address\" (see [IETF RFC 7600])\n    /// - `192.0.0.9/32` is the \"Port Control Protocol Anycast\" (see [IETF RFC 7723])\n    /// - `192.0.0.10/32` is used for NAT traversal (see [IETF RFC 8155])\n    ///\n    /// [IETF RFC 6890]: https://tools.ietf.org/html/rfc6890\n    /// [IETF RFC 7600]: https://tools.ietf.org/html/rfc7600\n    /// [IETF RFC 7723]: https://tools.ietf.org/html/rfc7723\n    /// [IETF RFC 8155]: https://tools.ietf.org/html/rfc8155\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 0).is_ietf_protocol_assignment(), true);\n    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 8).is_ietf_protocol_assignment(), true);\n    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 9).is_ietf_protocol_assignment(), true);\n    /// assert_eq!(Ipv4Addr::new(192, 0, 0, 255).is_ietf_protocol_assignment(), true);\n    /// assert_eq!(Ipv4Addr::new(192, 0, 1, 0).is_ietf_protocol_assignment(), false);\n    /// assert_eq!(Ipv4Addr::new(191, 255, 255, 255).is_ietf_protocol_assignment(), false);\n    /// ```\n    pub fn is_ietf_protocol_assignment(&self) -> bool {\n}\n\n    /// Returns [`true`] if this address part of the `198.18.0.0/15` range, which is reserved for\n    /// network devices benchmarking. This range is defined in [IETF RFC 2544] as `192.18.0.0`\n    /// through `198.19.255.255` but [errata 423] corrects it to `198.18.0.0/15`.\n    ///\n    /// [IETF RFC 2544]: https://tools.ietf.org/html/rfc2544\n    /// [errata 423]: https://www.rfc-editor.org/errata/eid423\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(198, 17, 255, 255).is_benchmarking(), false);\n    /// assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_benchmarking(), true);\n    /// assert_eq!(Ipv4Addr::new(198, 19, 255, 255).is_benchmarking(), true);\n    /// assert_eq!(Ipv4Addr::new(198, 20, 0, 0).is_benchmarking(), false);\n    /// ```\n    pub fn is_benchmarking(&self) -> bool {\n}\n\n    /// Returns [`true`] if this address is reserved by IANA for future use. [IETF RFC 1112]\n    /// defines the block of reserved addresses as `240.0.0.0/4`. This range normally includes the\n    /// broadcast address `255.255.255.255`, but this implementation explicitely excludes it, since\n    /// it is obviously not reserved for future use.\n    ///\n    /// [IETF RFC 1112]: https://tools.ietf.org/html/rfc1112\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Warning\n    ///\n    /// As IANA assigns new addresses, this method will be\n    /// updated. This may result in non-reserved addresses being\n    /// treated as reserved in code that relies on an outdated version\n    /// of this method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(240, 0, 0, 0).is_reserved(), true);\n    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 254).is_reserved(), true);\n    ///\n    /// assert_eq!(Ipv4Addr::new(239, 255, 255, 255).is_reserved(), false);\n    /// // The broadcast address is not considered as reserved for future use by this implementation\n    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_reserved(), false);\n    /// ```\n    pub fn is_reserved(&self) -> bool {\n}\n\n    /// Returns [`true`] if this is a multicast address (224.0.0.0/4).\n    ///\n    /// Multicast addresses have a most significant octet between 224 and 239,\n    /// and is defined by [IETF RFC 5771].\n    ///\n    /// [IETF RFC 5771]: https://tools.ietf.org/html/rfc5771\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(224, 254, 0, 0).is_multicast(), true);\n    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_multicast(), true);\n    /// assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_multicast(), false);\n    /// ```\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    pub fn is_multicast(&self) -> bool {\n}\n\n    /// Returns [`true`] if this is a broadcast address (255.255.255.255).\n    ///\n    /// A broadcast address has all octets set to 255 as defined in [IETF RFC 919].\n    ///\n    /// [IETF RFC 919]: https://tools.ietf.org/html/rfc919\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(255, 255, 255, 255).is_broadcast(), true);\n    /// assert_eq!(Ipv4Addr::new(236, 168, 10, 65).is_broadcast(), false);\n    /// ```\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    pub fn is_broadcast(&self) -> bool {\n}\n\n    /// Returns [`true`] if this address is in a range designated for documentation.\n    ///\n    /// This is defined in [IETF RFC 5737]:\n    ///\n    /// - 192.0.2.0/24 (TEST-NET-1)\n    /// - 198.51.100.0/24 (TEST-NET-2)\n    /// - 203.0.113.0/24 (TEST-NET-3)\n    ///\n    /// [IETF RFC 5737]: https://tools.ietf.org/html/rfc5737\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_documentation(), true);\n    /// assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_documentation(), true);\n    /// assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_documentation(), true);\n    /// assert_eq!(Ipv4Addr::new(193, 34, 17, 19).is_documentation(), false);\n    /// ```\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    pub fn is_documentation(&self) -> bool {\n}\n\n    /// Converts this address to an IPv4-compatible [IPv6 address].\n    ///\n    /// a.b.c.d becomes ::a.b.c.d\n    ///\n    /// [IPv6 address]: ../../std/net/struct.Ipv6Addr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(\n    ///     Ipv4Addr::new(192, 0, 2, 255).to_ipv6_compatible(),\n    ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 767)\n    /// );\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_ipv6_compatible(&self) -> Ipv6Addr {\n}\n\n    /// Converts this address to an IPv4-mapped [IPv6 address].\n    ///\n    /// a.b.c.d becomes ::ffff:a.b.c.d\n    ///\n    /// [IPv6 address]: ../../std/net/struct.Ipv6Addr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(Ipv4Addr::new(192, 0, 2, 255).to_ipv6_mapped(),\n    ///            Ipv6Addr::new(0, 0, 0, 0, 0, 65535, 49152, 767));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_ipv6_mapped(&self) -> Ipv6Addr {\n}\n}\n\n#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\nimpl fmt::Display for IpAddr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\nimpl From<Ipv4Addr> for IpAddr {\n    fn from(ipv4: Ipv4Addr) -> IpAddr {\n}\n}\n\n#[stable(feature = \"ip_from_ip\", since = \"1.16.0\")]\nimpl From<Ipv6Addr> for IpAddr {\n    fn from(ipv6: Ipv6Addr) -> IpAddr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Ipv4Addr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Ipv4Addr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for Ipv4Addr {\n    fn clone(&self) -> Ipv4Addr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for Ipv4Addr {\n    fn eq(&self, other: &Ipv4Addr) -> bool {\n}\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialEq<Ipv4Addr> for IpAddr {\n    fn eq(&self, other: &Ipv4Addr) -> bool {\n}\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialEq<IpAddr> for Ipv4Addr {\n    fn eq(&self, other: &IpAddr) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for Ipv4Addr {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl hash::Hash for Ipv4Addr {\n    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for Ipv4Addr {\n    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n}\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialOrd<Ipv4Addr> for IpAddr {\n    fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n}\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialOrd<IpAddr> for Ipv4Addr {\n    fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for Ipv4Addr {\n    fn cmp(&self, other: &Ipv4Addr) -> Ordering {\n}\n}\n\nimpl AsInner<c::in_addr> for Ipv4Addr {\n    fn as_inner(&self) -> &c::in_addr {\n}\n}\nimpl FromInner<c::in_addr> for Ipv4Addr {\n    fn from_inner(addr: c::in_addr) -> Ipv4Addr {\n}\n}\n\n#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\nimpl From<Ipv4Addr> for u32 {\n    /// Converts an `Ipv4Addr` into a host byte order `u32`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::new(13, 12, 11, 10);\n    /// assert_eq!(0x0d0c0b0au32, u32::from(addr));\n    /// ```\n    fn from(ip: Ipv4Addr) -> u32 {\n}\n}\n\n#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\nimpl From<u32> for Ipv4Addr {\n    /// Converts a host byte order `u32` into an `Ipv4Addr`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::from(0x0d0c0b0au32);\n    /// assert_eq!(Ipv4Addr::new(13, 12, 11, 10), addr);\n    /// ```\n    fn from(ip: u32) -> Ipv4Addr {\n}\n}\n\n#[stable(feature = \"from_slice_v4\", since = \"1.9.0\")]\nimpl From<[u8; 4]> for Ipv4Addr {\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv4Addr;\n    ///\n    /// let addr = Ipv4Addr::from([13u8, 12u8, 11u8, 10u8]);\n    /// assert_eq!(Ipv4Addr::new(13, 12, 11, 10), addr);\n    /// ```\n    fn from(octets: [u8; 4]) -> Ipv4Addr {\n}\n}\n\n#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\nimpl From<[u8; 4]> for IpAddr {\n    /// Creates an `IpAddr::V4` from a four element byte array.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv4Addr};\n    ///\n    /// let addr = IpAddr::from([13u8, 12u8, 11u8, 10u8]);\n    /// assert_eq!(IpAddr::V4(Ipv4Addr::new(13, 12, 11, 10)), addr);\n    /// ```\n    fn from(octets: [u8; 4]) -> IpAddr {\n}\n}\n\nimpl Ipv6Addr {\n    /// Creates a new IPv6 address from eight 16-bit segments.\n    ///\n    /// The result will represent the IP address `a:b:c:d:e:f:g:h`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.32.0\")]\n    pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {\n}\n\n    /// An IPv6 address representing localhost: `::1`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let addr = Ipv6Addr::LOCALHOST;\n    /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n    /// ```\n    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n    pub const LOCALHOST: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n\n    /// An IPv6 address representing the unspecified address: `::`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let addr = Ipv6Addr::UNSPECIFIED;\n    /// assert_eq!(addr, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n    /// ```\n    #[stable(feature = \"ip_constructors\", since = \"1.30.0\")]\n    pub const UNSPECIFIED: Self = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0);\n\n    /// Returns the eight 16-bit segments that make up this address.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).segments(),\n    ///            [0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn segments(&self) -> [u16; 8] {\n}\n\n    /// Returns [`true`] for the special 'unspecified' address (::).\n    ///\n    /// This property is defined in [IETF RFC 4291].\n    ///\n    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unspecified(), false);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), true);\n    /// ```\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    pub fn is_unspecified(&self) -> bool {\n}\n\n    /// Returns [`true`] if this is a loopback address (::1).\n    ///\n    /// This property is defined in [IETF RFC 4291].\n    ///\n    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_loopback(), false);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_loopback(), true);\n    /// ```\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    pub fn is_loopback(&self) -> bool {\n}\n\n    /// Returns [`true`] if the address appears to be globally routable.\n    ///\n    /// The following return [`false`]:\n    ///\n    /// - the loopback address\n    /// - link-local and unique local unicast addresses\n    /// - interface-, link-, realm-, admin- and site-local multicast addresses\n    ///\n    /// [`true`]: ../../std/primitive.bool.html\n    /// [`false`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), true);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_global(), false);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1).is_global(), true);\n    /// ```\n    pub fn is_global(&self) -> bool {\n}\n\n    /// Returns [`true`] if this is a unique local address (`fc00::/7`).\n    ///\n    /// This property is defined in [IETF RFC 4193].\n    ///\n    /// [IETF RFC 4193]: https://tools.ietf.org/html/rfc4193\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(), false);\n    /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n    /// ```\n    pub fn is_unique_local(&self) -> bool {\n}\n\n    /// Returns [`true`] if the address is a unicast link-local address (`fe80::/64`).\n    ///\n    /// A common mis-conception is to think that \"unicast link-local addresses start with\n    /// `fe80::`\", but the [IETF RFC 4291] actually defines a stricter format for these addresses:\n    ///\n    /// ```no_rust\n    /// |   10     |\n    /// |  bits    |         54 bits         |          64 bits           |\n    /// +----------+-------------------------+----------------------------+\n    /// |1111111010|           0             |       interface ID         |\n    /// +----------+-------------------------+----------------------------+\n    /// ```\n    ///\n    /// This method validates the format defined in the RFC and won't recognize the following\n    /// addresses such as `fe80:0:0:1::` or `fe81::` as unicast link-local addresses for example.\n    /// If you need a less strict validation use [`is_unicast_link_local()`] instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0);\n    /// assert!(ip.is_unicast_link_local_strict());\n    ///\n    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0xffff, 0xffff, 0xffff, 0xffff);\n    /// assert!(ip.is_unicast_link_local_strict());\n    ///\n    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0);\n    /// assert!(!ip.is_unicast_link_local_strict());\n    /// assert!(ip.is_unicast_link_local());\n    ///\n    /// let ip = Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0);\n    /// assert!(!ip.is_unicast_link_local_strict());\n    /// assert!(ip.is_unicast_link_local());\n    /// ```\n    ///\n    /// # See also\n    ///\n    /// - [IETF RFC 4291 section 2.5.6]\n    /// - [RFC 4291 errata 4406]\n    /// - [`is_unicast_link_local()`]\n    ///\n    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n    /// [IETF RFC 4291 section 2.5.6]: https://tools.ietf.org/html/rfc4291#section-2.5.6\n    /// [`true`]: ../../std/primitive.bool.html\n    /// [RFC 4291 errata 4406]: https://www.rfc-editor.org/errata/eid4406\n    /// [`is_unicast_link_local()`]: ../../std/net/struct.Ipv6Addr.html#method.is_unicast_link_local\n    ///\n    pub fn is_unicast_link_local_strict(&self) -> bool {\n}\n\n    /// Returns [`true`] if the address is a unicast link-local address (`fe80::/10`).\n    ///\n    /// This method returns [`true`] for addresses in the range reserved by [RFC 4291 section 2.4],\n    /// i.e. addresses with the following format:\n    ///\n    /// ```no_rust\n    /// |   10     |\n    /// |  bits    |         54 bits         |          64 bits           |\n    /// +----------+-------------------------+----------------------------+\n    /// |1111111010|    arbitratry value     |       interface ID         |\n    /// +----------+-------------------------+----------------------------+\n    /// ```\n    ///\n    /// As a result, this method consider addresses such as `fe80:0:0:1::` or `fe81::` to be\n    /// unicast link-local addresses, whereas [`is_unicast_link_local_strict()`] does not. If you\n    /// need a strict validation fully compliant with the RFC, use\n    /// [`is_unicast_link_local_strict()`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0, 0, 0, 0);\n    /// assert!(ip.is_unicast_link_local());\n    ///\n    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 0, 0xffff, 0xffff, 0xffff, 0xffff);\n    /// assert!(ip.is_unicast_link_local());\n    ///\n    /// let ip = Ipv6Addr::new(0xfe80, 0, 0, 1, 0, 0, 0, 0);\n    /// assert!(ip.is_unicast_link_local());\n    /// assert!(!ip.is_unicast_link_local_strict());\n    ///\n    /// let ip = Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 0);\n    /// assert!(ip.is_unicast_link_local());\n    /// assert!(!ip.is_unicast_link_local_strict());\n    /// ```\n    ///\n    /// # See also\n    ///\n    /// - [IETF RFC 4291 section 2.4]\n    /// - [RFC 4291 errata 4406]\n    ///\n    /// [IETF RFC 4291 section 2.4]: https://tools.ietf.org/html/rfc4291#section-2.4\n    /// [`true`]: ../../std/primitive.bool.html\n    /// [RFC 4291 errata 4406]: https://www.rfc-editor.org/errata/eid4406\n    /// [`is_unicast_link_local_strict()`]: ../../std/net/struct.Ipv6Addr.html#method.is_unicast_link_local_strict\n    ///\n    pub fn is_unicast_link_local(&self) -> bool {\n}\n\n    /// Returns [`true`] if this is a deprecated unicast site-local address (fec0::/10). The\n    /// unicast site-local address format is defined in [RFC 4291 section 2.5.7] as:\n    ///\n    /// ```no_rust\n    /// |   10     |\n    /// |  bits    |         54 bits         |         64 bits            |\n    /// +----------+-------------------------+----------------------------+\n    /// |1111111011|        subnet ID        |       interface ID         |\n    /// +----------+-------------------------+----------------------------+\n    /// ```\n    ///\n    /// [`true`]: ../../std/primitive.bool.html\n    /// [RFC 4291 section 2.5.7]: https://tools.ietf.org/html/rfc4291#section-2.5.7\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(\n    ///     Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_site_local(),\n    ///     false\n    /// );\n    /// assert_eq!(Ipv6Addr::new(0xfec2, 0, 0, 0, 0, 0, 0, 0).is_unicast_site_local(), true);\n    /// ```\n    ///\n    /// # Warning\n    ///\n    /// As per [RFC 3879], the whole `FEC0::/10` prefix is\n    /// deprecated. New software must not support site-local\n    /// addresses.\n    ///\n    /// [RFC 3879]: https://tools.ietf.org/html/rfc3879\n    pub fn is_unicast_site_local(&self) -> bool {\n}\n\n    /// Returns [`true`] if this is an address reserved for documentation\n    /// (2001:db8::/32).\n    ///\n    /// This property is defined in [IETF RFC 3849].\n    ///\n    /// [IETF RFC 3849]: https://tools.ietf.org/html/rfc3849\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(), false);\n    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n    /// ```\n    pub fn is_documentation(&self) -> bool {\n}\n\n    /// Returns [`true`] if the address is a globally routable unicast address.\n    ///\n    /// The following return false:\n    ///\n    /// - the loopback address\n    /// - the link-local addresses\n    /// - unique local addresses\n    /// - the unspecified address\n    /// - the address range reserved for documentation\n    ///\n    /// This method returns [`true`] for site-local addresses as per [RFC 4291 section 2.5.7]\n    ///\n    /// ```no_rust\n    /// The special behavior of [the site-local unicast] prefix defined in [RFC3513] must no longer\n    /// be supported in new implementations (i.e., new implementations must treat this prefix as\n    /// Global Unicast).\n    /// ```\n    ///\n    /// [`true`]: ../../std/primitive.bool.html\n    /// [RFC 4291 section 2.5.7]: https://tools.ietf.org/html/rfc4291#section-2.5.7\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(), true);\n    /// ```\n    pub fn is_unicast_global(&self) -> bool {\n}\n\n    /// Returns the address's multicast scope if the address is multicast.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(ip)]\n    ///\n    /// use std::net::{Ipv6Addr, Ipv6MulticastScope};\n    ///\n    /// assert_eq!(\n    ///     Ipv6Addr::new(0xff0e, 0, 0, 0, 0, 0, 0, 0).multicast_scope(),\n    ///     Some(Ipv6MulticastScope::Global)\n    /// );\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n    /// ```\n    pub fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n}\n\n    /// Returns [`true`] if this is a multicast address (ff00::/8).\n    ///\n    /// This property is defined by [IETF RFC 4291].\n    ///\n    /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n    /// [`true`]: ../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_multicast(), true);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_multicast(), false);\n    /// ```\n    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n    pub fn is_multicast(&self) -> bool {\n}\n\n    /// Converts this address to an [IPv4 address]. Returns [`None`] if this address is\n    /// neither IPv4-compatible or IPv4-mapped.\n    ///\n    /// ::a.b.c.d and ::ffff:a.b.c.d become a.b.c.d\n    ///\n    /// [IPv4 address]: ../../std/net/struct.Ipv4Addr.html\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{Ipv4Addr, Ipv6Addr};\n    ///\n    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).to_ipv4(), None);\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).to_ipv4(),\n    ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n    /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4(),\n    ///            Some(Ipv4Addr::new(0, 0, 0, 1)));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_ipv4(&self) -> Option<Ipv4Addr> {\n}\n\n    /// Returns the sixteen eight-bit integers the IPv6 address consists of.\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).octets(),\n    ///            [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    /// ```\n    #[stable(feature = \"ipv6_to_octets\", since = \"1.12.0\")]\n    #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.32.0\")]\n    pub const fn octets(&self) -> [u8; 16] {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Ipv6Addr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Ipv6Addr {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for Ipv6Addr {\n    fn clone(&self) -> Ipv6Addr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for Ipv6Addr {\n    fn eq(&self, other: &Ipv6Addr) -> bool {\n}\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialEq<IpAddr> for Ipv6Addr {\n    fn eq(&self, other: &IpAddr) -> bool {\n}\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialEq<Ipv6Addr> for IpAddr {\n    fn eq(&self, other: &Ipv6Addr) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for Ipv6Addr {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl hash::Hash for Ipv6Addr {\n    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for Ipv6Addr {\n    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n}\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialOrd<Ipv6Addr> for IpAddr {\n    fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {\n}\n}\n\n#[stable(feature = \"ip_cmp\", since = \"1.16.0\")]\nimpl PartialOrd<IpAddr> for Ipv6Addr {\n    fn partial_cmp(&self, other: &IpAddr) -> Option<Ordering> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for Ipv6Addr {\n    fn cmp(&self, other: &Ipv6Addr) -> Ordering {\n}\n}\n\nimpl AsInner<c::in6_addr> for Ipv6Addr {\n    fn as_inner(&self) -> &c::in6_addr {\n}\n}\nimpl FromInner<c::in6_addr> for Ipv6Addr {\n    fn from_inner(addr: c::in6_addr) -> Ipv6Addr {\n}\n}\n\n#[stable(feature = \"i128\", since = \"1.26.0\")]\nimpl From<Ipv6Addr> for u128 {\n    /// Convert an `Ipv6Addr` into a host byte order `u128`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let addr = Ipv6Addr::new(\n    ///     0x1020, 0x3040, 0x5060, 0x7080,\n    ///     0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n    /// );\n    /// assert_eq!(0x102030405060708090A0B0C0D0E0F00D_u128, u128::from(addr));\n    /// ```\n    fn from(ip: Ipv6Addr) -> u128 {\n}\n}\n#[stable(feature = \"i128\", since = \"1.26.0\")]\nimpl From<u128> for Ipv6Addr {\n    /// Convert a host byte order `u128` into an `Ipv6Addr`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::Ipv6Addr;\n    ///\n    /// let addr = Ipv6Addr::from(0x102030405060708090A0B0C0D0E0F00D_u128);\n    /// assert_eq!(\n    ///     Ipv6Addr::new(\n    ///         0x1020, 0x3040, 0x5060, 0x7080,\n    ///         0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n    ///     ),\n    ///     addr);\n    /// ```\n    fn from(ip: u128) -> Ipv6Addr {\n}\n}\n\n#[stable(feature = \"ipv6_from_octets\", since = \"1.9.0\")]\nimpl From<[u8; 16]> for Ipv6Addr {\n    fn from(octets: [u8; 16]) -> Ipv6Addr {\n}\n}\n\n#[stable(feature = \"ipv6_from_segments\", since = \"1.16.0\")]\nimpl From<[u16; 8]> for Ipv6Addr {\n    fn from(segments: [u16; 8]) -> Ipv6Addr {\n}\n}\n\n#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\nimpl From<[u8; 16]> for IpAddr {\n    /// Creates an `IpAddr::V6` from a sixteen element byte array.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv6Addr};\n    ///\n    /// let addr = IpAddr::from([\n    ///     25u8, 24u8, 23u8, 22u8, 21u8, 20u8, 19u8, 18u8,\n    ///     17u8, 16u8, 15u8, 14u8, 13u8, 12u8, 11u8, 10u8,\n    /// ]);\n    /// assert_eq!(\n    ///     IpAddr::V6(Ipv6Addr::new(\n    ///         0x1918, 0x1716,\n    ///         0x1514, 0x1312,\n    ///         0x1110, 0x0f0e,\n    ///         0x0d0c, 0x0b0a\n    ///     )),\n    ///     addr\n    /// );\n    /// ```\n    fn from(octets: [u8; 16]) -> IpAddr {\n}\n}\n\n#[stable(feature = \"ip_from_slice\", since = \"1.17.0\")]\nimpl From<[u16; 8]> for IpAddr {\n    /// Creates an `IpAddr::V6` from an eight element 16-bit array.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::net::{IpAddr, Ipv6Addr};\n    ///\n    /// let addr = IpAddr::from([\n    ///     525u16, 524u16, 523u16, 522u16,\n    ///     521u16, 520u16, 519u16, 518u16,\n    /// ]);\n    /// assert_eq!(\n    ///     IpAddr::V6(Ipv6Addr::new(\n    ///         0x20d, 0x20c,\n    ///         0x20b, 0x20a,\n    ///         0x209, 0x208,\n    ///         0x207, 0x206\n    ///     )),\n    ///     addr\n    /// );\n    /// ```\n    fn from(segments: [u16; 8]) -> IpAddr {\n}\n}\n\n// Tests for this module\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use crate::net::test::{sa4, sa6, tsa};\n    use crate::net::*;\n    use crate::str::FromStr;\n\n    #[test]\n    fn test_from_str_ipv4() {\n}\n\n    #[test]\n    fn test_from_str_ipv6() {\n}\n\n    #[test]\n    fn test_from_str_ipv4_in_ipv6() {\n}\n\n    #[test]\n    fn test_from_str_socket_addr() {\n}\n\n    #[test]\n    fn ipv4_addr_to_string() {\n}\n\n    #[test]\n    fn ipv6_addr_to_string() {\n}\n\n    #[test]\n    fn ipv4_to_ipv6() {\n}\n\n    #[test]\n    fn ipv6_to_ipv4() {\n}\n\n    #[test]\n    fn ip_properties() {\n}\n\n    #[test]\n    fn ipv4_properties() {\n}\n\n    #[test]\n    fn ipv6_properties() {\n}\n\n    #[test]\n    fn to_socket_addr_socketaddr() {\n}\n\n    #[test]\n    fn test_ipv4_to_int() {\n}\n\n    #[test]\n    fn test_int_to_ipv4() {\n}\n\n    #[test]\n    fn test_ipv6_to_int() {\n}\n\n    #[test]\n    fn test_int_to_ipv6() {\n}\n\n    #[test]\n    fn ipv4_from_constructors() {\n}\n\n    #[test]\n    fn ipv6_from_contructors() {\n}\n\n    #[test]\n    fn ipv4_from_octets() {\n}\n\n    #[test]\n    fn ipv6_from_segments() {\n}\n\n    #[test]\n    fn ipv6_from_octets() {\n}\n\n    #[test]\n    fn cmp() {\n}\n\n    #[test]\n    fn is_v4() {\n}\n\n    #[test]\n    fn is_v6() {\n}\n}\n}\nmod parser {\n//! A private parser implementation of IPv4, IPv6, and socket addresses.\n//!\n//! This module is \"publicly exported\" through the `FromStr` implementations\n//! below.\n\nuse crate::error::Error;\nuse crate::fmt;\nuse crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\nuse crate::str::FromStr;\n\nstruct Parser<'a> {\n    // parsing as ASCII, so can use byte array\n    s: &'a [u8],\n    pos: usize,\n}\n\nimpl<'a> Parser<'a> {\n    fn new(s: &'a str) -> Parser<'a> {\n}\n\n    fn is_eof(&self) -> bool {\n}\n\n    // Commit only if parser returns Some\n    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T>\n    where\n        F: FnOnce(&mut Parser<'_>) -> Option<T>,\n    {\n}\n\n    // Commit only if parser read till EOF\n    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T>\n    where\n        F: FnOnce(&mut Parser<'_>) -> Option<T>,\n    {\n}\n\n    // Apply 3 parsers sequentially\n    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self, pa: PA, pb: PB, pc: PC) -> Option<(A, B, C)>\n    where\n        PA: FnOnce(&mut Parser<'_>) -> Option<A>,\n        PB: FnOnce(&mut Parser<'_>) -> Option<B>,\n        PC: FnOnce(&mut Parser<'_>) -> Option<C>,\n    {\n}\n\n    // Read next char\n    fn read_char(&mut self) -> Option<char> {\n}\n\n    // Return char and advance iff next char is equal to requested\n    fn read_given_char(&mut self, c: char) -> Option<char> {\n}\n\n    // Read digit\n    fn read_digit(&mut self, radix: u8) -> Option<u8> {\n}\n\n    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n}\n\n    // Read number, failing if max_digits of number value exceeded\n    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n}\n\n    fn read_ipv4_addr_impl(&mut self) -> Option<Ipv4Addr> {\n}\n\n    // Read IPv4 address\n    fn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> {\n}\n\n    fn read_ipv6_addr_impl(&mut self) -> Option<Ipv6Addr> {\n}\n\n    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> {\n}\n\n    fn read_ip_addr(&mut self) -> Option<IpAddr> {\n}\n\n    fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> {\n}\n\n    fn read_socket_addr_v6(&mut self) -> Option<SocketAddrV6> {\n}\n\n    fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n}\n}\n\n#[stable(feature = \"ip_addr\", since = \"1.7.0\")]\nimpl FromStr for IpAddr {\n    type Err = AddrParseError;\n    fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromStr for Ipv4Addr {\n    type Err = AddrParseError;\n    fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromStr for Ipv6Addr {\n    type Err = AddrParseError;\n    fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> {\n}\n}\n\n#[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\nimpl FromStr for SocketAddrV4 {\n    type Err = AddrParseError;\n    fn from_str(s: &str) -> Result<SocketAddrV4, AddrParseError> {\n}\n}\n\n#[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\nimpl FromStr for SocketAddrV6 {\n    type Err = AddrParseError;\n    fn from_str(s: &str) -> Result<SocketAddrV6, AddrParseError> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromStr for SocketAddr {\n    type Err = AddrParseError;\n    fn from_str(s: &str) -> Result<SocketAddr, AddrParseError> {\n}\n}\n\n/// An error which can be returned when parsing an IP address or a socket address.\n///\n/// This error is used as the error type for the [`FromStr`] implementation for\n/// [`IpAddr`], [`Ipv4Addr`], [`Ipv6Addr`], [`SocketAddr`], [`SocketAddrV4`], and\n/// [`SocketAddrV6`].\n///\n/// # Potential causes\n///\n/// `AddrParseError` may be thrown because the provided string does not parse as the given type,\n/// often because it includes information only handled by a different address type.\n///\n/// ```should_panic\n/// use std::net::IpAddr;\n/// let _foo: IpAddr = \"127.0.0.1:8080\".parse().expect(\"Cannot handle the socket port\");\n/// ```\n///\n/// [`IpAddr`] doesn't handle the port. Use [`SocketAddr`] instead.\n///\n/// ```\n/// use std::net::SocketAddr;\n///\n/// // No problem, the `panic!` message has disappeared.\n/// let _foo: SocketAddr = \"127.0.0.1:8080\".parse().expect(\"unreachable panic\");\n/// ```\n///\n/// [`FromStr`]: ../../std/str/trait.FromStr.html\n/// [`IpAddr`]: ../../std/net/enum.IpAddr.html\n/// [`Ipv4Addr`]: ../../std/net/struct.Ipv4Addr.html\n/// [`Ipv6Addr`]: ../../std/net/struct.Ipv6Addr.html\n/// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n/// [`SocketAddrV4`]: ../../std/net/struct.SocketAddrV4.html\n/// [`SocketAddrV6`]: ../../std/net/struct.SocketAddrV6.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct AddrParseError(());\n\n#[stable(feature = \"addr_parse_error_error\", since = \"1.4.0\")]\nimpl fmt::Display for AddrParseError {\n    #[allow(deprecated, deprecated_in_future)]\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"addr_parse_error_error\", since = \"1.4.0\")]\nimpl Error for AddrParseError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n}\n}\nmod tcp {\nuse crate::io::prelude::*;\n\nuse crate::fmt;\nuse crate::io::{self, Initializer, IoSlice, IoSliceMut};\nuse crate::net::{Shutdown, SocketAddr, ToSocketAddrs};\nuse crate::sys_common::net as net_imp;\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\nuse crate::time::Duration;\n\n/// A TCP stream between a local and a remote socket.\n///\n/// After creating a `TcpStream` by either [`connect`]ing to a remote host or\n/// [`accept`]ing a connection on a [`TcpListener`], data can be transmitted\n/// by [reading] and [writing] to it.\n///\n/// The connection will be closed when the value is dropped. The reading and writing\n/// portions of the connection can also be shut down individually with the [`shutdown`]\n/// method.\n///\n/// The Transmission Control Protocol is specified in [IETF RFC 793].\n///\n/// [`accept`]: ../../std/net/struct.TcpListener.html#method.accept\n/// [`connect`]: #method.connect\n/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n/// [reading]: ../../std/io/trait.Read.html\n/// [`shutdown`]: #method.shutdown\n/// [`TcpListener`]: ../../std/net/struct.TcpListener.html\n/// [writing]: ../../std/io/trait.Write.html\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::io::prelude::*;\n/// use std::net::TcpStream;\n///\n/// fn main() -> std::io::Result<()> {\n///     let mut stream = TcpStream::connect(\"127.0.0.1:34254\")?;\n///\n///     stream.write(&[1])?;\n///     stream.read(&mut [0; 128])?;\n///     Ok(())\n/// } // the stream is closed here\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct TcpStream(net_imp::TcpStream);\n\n/// A TCP socket server, listening for connections.\n///\n/// After creating a `TcpListener` by [`bind`]ing it to a socket address, it listens\n/// for incoming TCP connections. These can be accepted by calling [`accept`] or by\n/// iterating over the [`Incoming`] iterator returned by [`incoming`][`TcpListener::incoming`].\n///\n/// The socket will be closed when the value is dropped.\n///\n/// The Transmission Control Protocol is specified in [IETF RFC 793].\n///\n/// [`accept`]: #method.accept\n/// [`bind`]: #method.bind\n/// [IETF RFC 793]: https://tools.ietf.org/html/rfc793\n/// [`Incoming`]: ../../std/net/struct.Incoming.html\n/// [`TcpListener::incoming`]: #method.incoming\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::net::{TcpListener, TcpStream};\n///\n/// fn handle_client(stream: TcpStream) {\n///     // ...\n/// }\n///\n/// fn main() -> std::io::Result<()> {\n///     let listener = TcpListener::bind(\"127.0.0.1:80\")?;\n///\n///     // accept connections and process them serially\n///     for stream in listener.incoming() {\n///         handle_client(stream?);\n///     }\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct TcpListener(net_imp::TcpListener);\n\n/// An iterator that infinitely [`accept`]s connections on a [`TcpListener`].\n///\n/// This `struct` is created by the [`incoming`] method on [`TcpListener`].\n/// See its documentation for more.\n///\n/// [`accept`]: ../../std/net/struct.TcpListener.html#method.accept\n/// [`incoming`]: ../../std/net/struct.TcpListener.html#method.incoming\n/// [`TcpListener`]: ../../std/net/struct.TcpListener.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Incoming<'a> {\n    listener: &'a TcpListener,\n}\n\nimpl TcpStream {\n    /// Opens a TCP connection to a remote host.\n    ///\n    /// `addr` is an address of the remote host. Anything which implements\n    /// [`ToSocketAddrs`] trait can be supplied for the address; see this trait\n    /// documentation for concrete examples.\n    ///\n    /// If `addr` yields multiple addresses, `connect` will be attempted with\n    /// each of the addresses until a connection is successful. If none of\n    /// the addresses result in a successful connection, the error returned from\n    /// the last connection attempt (the last address) is returned.\n    ///\n    /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n    ///\n    /// # Examples\n    ///\n    /// Open a TCP connection to `127.0.0.1:8080`:\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// if let Ok(stream) = TcpStream::connect(\"127.0.0.1:8080\") {\n    ///     println!(\"Connected to the server!\");\n    /// } else {\n    ///     println!(\"Couldn't connect to server...\");\n    /// }\n    /// ```\n    ///\n    /// Open a TCP connection to `127.0.0.1:8080`. If the connection fails, open\n    /// a TCP connection to `127.0.0.1:8081`:\n    ///\n    /// ```no_run\n    /// use std::net::{SocketAddr, TcpStream};\n    ///\n    /// let addrs = [\n    ///     SocketAddr::from(([127, 0, 0, 1], 8080)),\n    ///     SocketAddr::from(([127, 0, 0, 1], 8081)),\n    /// ];\n    /// if let Ok(stream) = TcpStream::connect(&addrs[..]) {\n    ///     println!(\"Connected to the server!\");\n    /// } else {\n    ///     println!(\"Couldn't connect to server...\");\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn connect<A: ToSocketAddrs>(addr: A) -> io::Result<TcpStream> {\n}\n\n    /// Opens a TCP connection to a remote host with a timeout.\n    ///\n    /// Unlike `connect`, `connect_timeout` takes a single [`SocketAddr`] since\n    /// timeout must be applied to individual addresses.\n    ///\n    /// It is an error to pass a zero `Duration` to this function.\n    ///\n    /// Unlike other methods on `TcpStream`, this does not correspond to a\n    /// single system call. It instead calls `connect` in nonblocking mode and\n    /// then uses an OS-specific mechanism to await the completion of the\n    /// connection request.\n    ///\n    /// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n    #[stable(feature = \"tcpstream_connect_timeout\", since = \"1.21.0\")]\n    pub fn connect_timeout(addr: &SocketAddr, timeout: Duration) -> io::Result<TcpStream> {\n}\n\n    /// Returns the socket address of the remote peer of this TCP connection.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, TcpStream};\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// assert_eq!(stream.peer_addr().unwrap(),\n    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080)));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n}\n\n    /// Returns the socket address of the local half of this TCP connection.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::{IpAddr, Ipv4Addr, TcpStream};\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// assert_eq!(stream.local_addr().unwrap().ip(),\n    ///            IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n}\n\n    /// Shuts down the read, write, or both halves of this connection.\n    ///\n    /// This function will cause all pending and future I/O on the specified\n    /// portions to return immediately with an appropriate value (see the\n    /// documentation of [`Shutdown`]).\n    ///\n    /// [`Shutdown`]: ../../std/net/enum.Shutdown.html\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Calling this function multiple times may result in different behavior,\n    /// depending on the operating system. On Linux, the second call will\n    /// return `Ok(())`, but on macOS, it will return `ErrorKind::NotConnected`.\n    /// This may change in the future.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::{Shutdown, TcpStream};\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.shutdown(Shutdown::Both).expect(\"shutdown call failed\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n}\n\n    /// Creates a new independently owned handle to the underlying socket.\n    ///\n    /// The returned `TcpStream` is a reference to the same stream that this\n    /// object references. Both handles will read and write the same stream of\n    /// data, and options set on one stream will be propagated to the other\n    /// stream.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// let stream_clone = stream.try_clone().expect(\"clone failed...\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn try_clone(&self) -> io::Result<TcpStream> {\n}\n\n    /// Sets the read timeout to the timeout specified.\n    ///\n    /// If the value specified is [`None`], then [`read`] calls will block\n    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n    /// passed to this method.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Platforms may return a different error code whenever a read times out as\n    /// a result of setting this option. For example Unix typically returns an\n    /// error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`read`]: ../../std/io/trait.Read.html#tymethod.read\n    /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n    /// [`TimedOut`]: ../../std/io/enum.ErrorKind.html#variant.TimedOut\n    /// [`Duration`]: ../../std/time/struct.Duration.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n    /// ```\n    ///\n    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n    /// method:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::net::TcpStream;\n    /// use std::time::Duration;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n    /// let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n}\n\n    /// Sets the write timeout to the timeout specified.\n    ///\n    /// If the value specified is [`None`], then [`write`] calls will block\n    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n    /// passed to this method.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Platforms may return a different error code whenever a write times out\n    /// as a result of setting this option. For example Unix typically returns\n    /// an error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`write`]: ../../std/io/trait.Write.html#tymethod.write\n    /// [`Duration`]: ../../std/time/struct.Duration.html\n    /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n    /// [`TimedOut`]: ../../std/io/enum.ErrorKind.html#variant.TimedOut\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n    /// ```\n    ///\n    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n    /// method:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::net::TcpStream;\n    /// use std::time::Duration;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n    /// let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n}\n\n    /// Returns the read timeout of this socket.\n    ///\n    /// If the timeout is [`None`], then [`read`] calls will block indefinitely.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Some platforms do not provide access to the current timeout.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`read`]: ../../std/io/trait.Read.html#tymethod.read\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n    /// assert_eq!(stream.read_timeout().unwrap(), None);\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n}\n\n    /// Returns the write timeout of this socket.\n    ///\n    /// If the timeout is [`None`], then [`write`] calls will block indefinitely.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Some platforms do not provide access to the current timeout.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`write`]: ../../std/io/trait.Write.html#tymethod.write\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n    /// assert_eq!(stream.write_timeout().unwrap(), None);\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n}\n\n    /// Receives data on the socket from the remote address to which it is\n    /// connected, without removing that data from the queue. On success,\n    /// returns the number of bytes peeked.\n    ///\n    /// Successive calls return the same data. This is accomplished by passing\n    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8000\")\n    ///                        .expect(\"couldn't bind to address\");\n    /// let mut buf = [0; 10];\n    /// let len = stream.peek(&mut buf).expect(\"peek failed\");\n    /// ```\n    #[stable(feature = \"peek\", since = \"1.18.0\")]\n    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    /// Sets the value of the `TCP_NODELAY` option on this socket.\n    ///\n    /// If set, this option disables the Nagle algorithm. This means that\n    /// segments are always sent as soon as possible, even if there is only a\n    /// small amount of data. When not set, data is buffered until there is a\n    /// sufficient amount to send out, thereby avoiding the frequent sending of\n    /// small packets.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_nodelay(true).expect(\"set_nodelay call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n}\n\n    /// Gets the value of the `TCP_NODELAY` option on this socket.\n    ///\n    /// For more information about this option, see [`set_nodelay`][link].\n    ///\n    /// [link]: #method.set_nodelay\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_nodelay(true).expect(\"set_nodelay call failed\");\n    /// assert_eq!(stream.nodelay().unwrap_or(false), true);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn nodelay(&self) -> io::Result<bool> {\n}\n\n    /// Sets the value for the `IP_TTL` option on this socket.\n    ///\n    /// This value sets the time-to-live field that is used in every packet sent\n    /// from this socket.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_ttl(100).expect(\"set_ttl call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n}\n\n    /// Gets the value of the `IP_TTL` option for this socket.\n    ///\n    /// For more information about this option, see [`set_ttl`][link].\n    ///\n    /// [link]: #method.set_ttl\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.set_ttl(100).expect(\"set_ttl call failed\");\n    /// assert_eq!(stream.ttl().unwrap_or(0), 100);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn ttl(&self) -> io::Result<u32> {\n}\n\n    /// Gets the value of the `SO_ERROR` option on this socket.\n    ///\n    /// This will retrieve the stored error in the underlying socket, clearing\n    /// the field in the process. This can be useful for checking errors between\n    /// calls.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpStream;\n    ///\n    /// let stream = TcpStream::connect(\"127.0.0.1:8080\")\n    ///                        .expect(\"Couldn't connect to the server...\");\n    /// stream.take_error().expect(\"No error was expected...\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n}\n\n    /// Moves this TCP stream into or out of nonblocking mode.\n    ///\n    /// This will result in `read`, `write`, `recv` and `send` operations\n    /// becoming nonblocking, i.e., immediately returning from their calls.\n    /// If the IO operation is successful, `Ok` is returned and no further\n    /// action is required. If the IO operation could not be completed and needs\n    /// to be retried, an error with kind [`io::ErrorKind::WouldBlock`] is\n    /// returned.\n    ///\n    /// On Unix platforms, calling this method corresponds to calling `fcntl`\n    /// `FIONBIO`. On Windows calling this method corresponds to calling\n    /// `ioctlsocket` `FIONBIO`.\n    ///\n    /// # Examples\n    ///\n    /// Reading bytes from a TCP stream in non-blocking mode:\n    ///\n    /// ```no_run\n    /// use std::io::{self, Read};\n    /// use std::net::TcpStream;\n    ///\n    /// let mut stream = TcpStream::connect(\"127.0.0.1:7878\")\n    ///     .expect(\"Couldn't connect to the server...\");\n    /// stream.set_nonblocking(true).expect(\"set_nonblocking call failed\");\n    ///\n    /// # fn wait_for_fd() { unimplemented!() }\n    /// let mut buf = vec![];\n    /// loop {\n    ///     match stream.read_to_end(&mut buf) {\n    ///         Ok(_) => break,\n    ///         Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n    ///             // wait until network socket is ready, typically implemented\n    ///             // via platform-specific APIs such as epoll or IOCP\n    ///             wait_for_fd();\n    ///         }\n    ///         Err(e) => panic!(\"encountered IO error: {}\", e),\n    ///     };\n    /// };\n    /// println!(\"bytes: {:?}\", buf);\n    /// ```\n    ///\n    /// [`io::ErrorKind::WouldBlock`]: ../io/enum.ErrorKind.html#variant.WouldBlock\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for TcpStream {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for TcpStream {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Read for &TcpStream {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Write for &TcpStream {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\nimpl AsInner<net_imp::TcpStream> for TcpStream {\n    fn as_inner(&self) -> &net_imp::TcpStream {\n}\n}\n\nimpl FromInner<net_imp::TcpStream> for TcpStream {\n    fn from_inner(inner: net_imp::TcpStream) -> TcpStream {\n}\n}\n\nimpl IntoInner<net_imp::TcpStream> for TcpStream {\n    fn into_inner(self) -> net_imp::TcpStream {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for TcpStream {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl TcpListener {\n    /// Creates a new `TcpListener` which will be bound to the specified\n    /// address.\n    ///\n    /// The returned listener is ready for accepting connections.\n    ///\n    /// Binding with a port number of 0 will request that the OS assigns a port\n    /// to this listener. The port allocated can be queried via the\n    /// [`local_addr`] method.\n    ///\n    /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n    /// its documentation for concrete examples.\n    ///\n    /// If `addr` yields multiple addresses, `bind` will be attempted with\n    /// each of the addresses until one succeeds and returns the listener. If\n    /// none of the addresses succeed in creating a listener, the error returned\n    /// from the last attempt (the last address) is returned.\n    ///\n    /// [`local_addr`]: #method.local_addr\n    /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n    ///\n    /// # Examples\n    ///\n    /// Creates a TCP listener bound to `127.0.0.1:80`:\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n    /// ```\n    ///\n    /// Creates a TCP listener bound to `127.0.0.1:80`. If that fails, create a\n    /// TCP listener bound to `127.0.0.1:443`:\n    ///\n    /// ```no_run\n    /// use std::net::{SocketAddr, TcpListener};\n    ///\n    /// let addrs = [\n    ///     SocketAddr::from(([127, 0, 0, 1], 80)),\n    ///     SocketAddr::from(([127, 0, 0, 1], 443)),\n    /// ];\n    /// let listener = TcpListener::bind(&addrs[..]).unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {\n}\n\n    /// Returns the local socket address of this listener.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, TcpListener};\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n    /// assert_eq!(listener.local_addr().unwrap(),\n    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080)));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n}\n\n    /// Creates a new independently owned handle to the underlying socket.\n    ///\n    /// The returned [`TcpListener`] is a reference to the same socket that this\n    /// object references. Both handles can be used to accept incoming\n    /// connections and options set on one listener will affect the other.\n    ///\n    /// [`TcpListener`]: ../../std/net/struct.TcpListener.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n    /// let listener_clone = listener.try_clone().unwrap();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn try_clone(&self) -> io::Result<TcpListener> {\n}\n\n    /// Accept a new incoming connection from this listener.\n    ///\n    /// This function will block the calling thread until a new TCP connection\n    /// is established. When established, the corresponding [`TcpStream`] and the\n    /// remote peer's address will be returned.\n    ///\n    /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n    /// match listener.accept() {\n    ///     Ok((_socket, addr)) => println!(\"new client: {:?}\", addr),\n    ///     Err(e) => println!(\"couldn't get client: {:?}\", e),\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n}\n\n    /// Returns an iterator over the connections being received on this\n    /// listener.\n    ///\n    /// The returned iterator will never return [`None`] and will also not yield\n    /// the peer's [`SocketAddr`] structure. Iterating over it is equivalent to\n    /// calling [`accept`] in a loop.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n    /// [`accept`]: #method.accept\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n    ///\n    /// for stream in listener.incoming() {\n    ///     match stream {\n    ///         Ok(stream) => {\n    ///             println!(\"new client!\");\n    ///         }\n    ///         Err(e) => { /* connection failed */ }\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn incoming(&self) -> Incoming<'_> {\n}\n\n    /// Sets the value for the `IP_TTL` option on this socket.\n    ///\n    /// This value sets the time-to-live field that is used in every packet sent\n    /// from this socket.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n    /// listener.set_ttl(100).expect(\"could not set TTL\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n}\n\n    /// Gets the value of the `IP_TTL` option for this socket.\n    ///\n    /// For more information about this option, see [`set_ttl`][link].\n    ///\n    /// [link]: #method.set_ttl\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n    /// listener.set_ttl(100).expect(\"could not set TTL\");\n    /// assert_eq!(listener.ttl().unwrap_or(0), 100);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn ttl(&self) -> io::Result<u32> {\n}\n\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    #[rustc_deprecated(\n        since = \"1.16.0\",\n        reason = \"this option can only be set before the socket is bound\"\n    )]\n    #[allow(missing_docs)]\n    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n}\n\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    #[rustc_deprecated(\n        since = \"1.16.0\",\n        reason = \"this option can only be set before the socket is bound\"\n    )]\n    #[allow(missing_docs)]\n    pub fn only_v6(&self) -> io::Result<bool> {\n}\n\n    /// Gets the value of the `SO_ERROR` option on this socket.\n    ///\n    /// This will retrieve the stored error in the underlying socket, clearing\n    /// the field in the process. This can be useful for checking errors between\n    /// calls.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n    /// listener.take_error().expect(\"No error was expected\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n}\n\n    /// Moves this TCP stream into or out of nonblocking mode.\n    ///\n    /// This will result in the `accept` operation becoming nonblocking,\n    /// i.e., immediately returning from their calls. If the IO operation is\n    /// successful, `Ok` is returned and no further action is required. If the\n    /// IO operation could not be completed and needs to be retried, an error\n    /// with kind [`io::ErrorKind::WouldBlock`] is returned.\n    ///\n    /// On Unix platforms, calling this method corresponds to calling `fcntl`\n    /// `FIONBIO`. On Windows calling this method corresponds to calling\n    /// `ioctlsocket` `FIONBIO`.\n    ///\n    /// # Examples\n    ///\n    /// Bind a TCP listener to an address, listen for connections, and read\n    /// bytes in nonblocking mode:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::net::TcpListener;\n    ///\n    /// let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    /// listener.set_nonblocking(true).expect(\"Cannot set non-blocking\");\n    ///\n    /// # fn wait_for_fd() { unimplemented!() }\n    /// # fn handle_connection(stream: std::net::TcpStream) { unimplemented!() }\n    /// for stream in listener.incoming() {\n    ///     match stream {\n    ///         Ok(s) => {\n    ///             // do something with the TcpStream\n    ///             handle_connection(s);\n    ///         }\n    ///         Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n    ///             // wait until network socket is ready, typically implemented\n    ///             // via platform-specific APIs such as epoll or IOCP\n    ///             wait_for_fd();\n    ///             continue;\n    ///         }\n    ///         Err(e) => panic!(\"encountered IO error: {}\", e),\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`io::ErrorKind::WouldBlock`]: ../io/enum.ErrorKind.html#variant.WouldBlock\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for Incoming<'a> {\n    type Item = io::Result<TcpStream>;\n    fn next(&mut self) -> Option<io::Result<TcpStream>> {\n}\n}\n\nimpl AsInner<net_imp::TcpListener> for TcpListener {\n    fn as_inner(&self) -> &net_imp::TcpListener {\n}\n}\n\nimpl FromInner<net_imp::TcpListener> for TcpListener {\n    fn from_inner(inner: net_imp::TcpListener) -> TcpListener {\n}\n}\n\nimpl IntoInner<net_imp::TcpListener> for TcpListener {\n    fn into_inner(self) -> net_imp::TcpListener {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for TcpListener {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\nmod tests {\n    use crate::fmt;\n    use crate::io::prelude::*;\n    use crate::io::{ErrorKind, IoSlice, IoSliceMut};\n    use crate::net::test::{next_test_ip4, next_test_ip6};\n    use crate::net::*;\n    use crate::sync::mpsc::channel;\n    use crate::thread;\n    use crate::time::{Duration, Instant};\n\n    fn each_ip(f: &mut dyn FnMut(SocketAddr)) {\n}\n\n    macro_rules! t {\n        ($e:expr) => {\n            match $e {\n                Ok(t) => t,\n                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n            }\n        };\n    }\n\n    #[test]\n    fn bind_error() {\n}\n\n    #[test]\n    fn connect_error() {\n}\n\n    #[test]\n    fn listen_localhost() {\n}\n\n    #[test]\n    fn connect_loopback() {\n}\n\n    #[test]\n    fn smoke_test() {\n}\n\n    #[test]\n    fn read_eof() {\n}\n\n    #[test]\n    fn write_close() {\n}\n\n    #[test]\n    fn multiple_connect_serial() {\n}\n\n    #[test]\n    fn multiple_connect_interleaved_greedy_schedule() {\n}\n\n    #[test]\n    fn multiple_connect_interleaved_lazy_schedule() {\n}\n\n    #[test]\n    fn socket_and_peer_name() {\n}\n\n    #[test]\n    fn partial_read() {\n}\n\n    #[test]\n    fn read_vectored() {\n}\n\n    #[test]\n    fn write_vectored() {\n}\n\n    #[test]\n    fn double_bind() {\n}\n\n    #[test]\n    fn tcp_clone_smoke() {\n}\n\n    #[test]\n    fn tcp_clone_two_read() {\n}\n\n    #[test]\n    fn tcp_clone_two_write() {\n}\n\n    #[test]\n    // FIXME: https://github.com/fortanix/rust-sgx/issues/110\n    #[cfg_attr(target_env = \"sgx\", ignore)]\n    fn shutdown_smoke() {\n}\n\n    #[test]\n    // FIXME: https://github.com/fortanix/rust-sgx/issues/110\n    #[cfg_attr(target_env = \"sgx\", ignore)]\n    fn close_readwrite_smoke() {\n}\n\n    #[test]\n    #[cfg(unix)] // test doesn't work on Windows, see #31657\n    fn close_read_wakes_up() {\n}\n\n    #[test]\n    fn clone_while_reading() {\n}\n\n    #[test]\n    fn clone_accept_smoke() {\n}\n\n    #[test]\n    fn clone_accept_concurrent() {\n}\n\n    #[test]\n    fn debug() {\n}\n\n    // FIXME: re-enabled openbsd tests once their socket timeout code\n    //        no longer has rounding errors.\n    // VxWorks ignores SO_SNDTIMEO.\n    #[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\"), ignore)]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    #[test]\n    fn timeouts() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn test_read_timeout() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn test_read_with_timeout() {\n}\n\n    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n    // when passed zero Durations\n    #[test]\n    fn test_timeout_zero_duration() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)]\n    fn nodelay() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)]\n    fn ttl() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)]\n    fn set_nonblocking() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn peek() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn connect_timeout_valid() {\n}\n}\n}\n#[cfg(test)]\nmod test {\n}\nmod udp {\nuse crate::fmt;\nuse crate::io::{self, Error, ErrorKind};\nuse crate::net::{Ipv4Addr, Ipv6Addr, SocketAddr, ToSocketAddrs};\nuse crate::sys_common::net as net_imp;\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\nuse crate::time::Duration;\n\n/// A UDP socket.\n///\n/// After creating a `UdpSocket` by [`bind`]ing it to a socket address, data can be\n/// [sent to] and [received from] any other socket address.\n///\n/// Although UDP is a connectionless protocol, this implementation provides an interface\n/// to set an address where data should be sent and received from. After setting a remote\n/// address with [`connect`], data can be sent to and received from that address with\n/// [`send`] and [`recv`].\n///\n/// As stated in the User Datagram Protocol's specification in [IETF RFC 768], UDP is\n/// an unordered, unreliable protocol; refer to [`TcpListener`] and [`TcpStream`] for TCP\n/// primitives.\n///\n/// [`bind`]: #method.bind\n/// [`connect`]: #method.connect\n/// [IETF RFC 768]: https://tools.ietf.org/html/rfc768\n/// [`recv`]: #method.recv\n/// [received from]: #method.recv_from\n/// [`send`]: #method.send\n/// [sent to]: #method.send_to\n/// [`TcpListener`]: ../../std/net/struct.TcpListener.html\n/// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::net::UdpSocket;\n///\n/// fn main() -> std::io::Result<()> {\n///     {\n///         let mut socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n///\n///         // Receives a single datagram message on the socket. If `buf` is too small to hold\n///         // the message, it will be cut off.\n///         let mut buf = [0; 10];\n///         let (amt, src) = socket.recv_from(&mut buf)?;\n///\n///         // Redeclare `buf` as slice of the received data and send reverse data back to origin.\n///         let buf = &mut buf[..amt];\n///         buf.reverse();\n///         socket.send_to(buf, &src)?;\n///     } // the socket is closed here\n///     Ok(())\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct UdpSocket(net_imp::UdpSocket);\n\nimpl UdpSocket {\n    /// Creates a UDP socket from the given address.\n    ///\n    /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n    /// its documentation for concrete examples.\n    ///\n    /// If `addr` yields multiple addresses, `bind` will be attempted with\n    /// each of the addresses until one succeeds and returns the socket. If none\n    /// of the addresses succeed in creating a socket, the error returned from\n    /// the last attempt (the last address) is returned.\n    ///\n    /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n    ///\n    /// # Examples\n    ///\n    /// Creates a UDP socket bound to `127.0.0.1:3400`:\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n    /// ```\n    ///\n    /// Creates a UDP socket bound to `127.0.0.1:3400`. If the socket cannot be\n    /// bound to that address, create a UDP socket bound to `127.0.0.1:3401`:\n    ///\n    /// ```no_run\n    /// use std::net::{SocketAddr, UdpSocket};\n    ///\n    /// let addrs = [\n    ///     SocketAddr::from(([127, 0, 0, 1], 3400)),\n    ///     SocketAddr::from(([127, 0, 0, 1], 3401)),\n    /// ];\n    /// let socket = UdpSocket::bind(&addrs[..]).expect(\"couldn't bind to address\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n}\n\n    /// Receives a single datagram message on the socket. On success, returns the number\n    /// of bytes read and the origin.\n    ///\n    /// The function must be called with valid byte array `buf` of sufficient size to\n    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n    /// excess bytes may be discarded.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// let mut buf = [0; 10];\n    /// let (number_of_bytes, src_addr) = socket.recv_from(&mut buf)\n    ///                                         .expect(\"Didn't receive data\");\n    /// let filled_buf = &mut buf[..number_of_bytes];\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n}\n\n    /// Receives a single datagram message on the socket, without removing it from the\n    /// queue. On success, returns the number of bytes read and the origin.\n    ///\n    /// The function must be called with valid byte array `buf` of sufficient size to\n    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n    /// excess bytes may be discarded.\n    ///\n    /// Successive calls return the same data. This is accomplished by passing\n    /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n    ///\n    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n    /// synchronize IO events on one or more sockets.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// let mut buf = [0; 10];\n    /// let (number_of_bytes, src_addr) = socket.peek_from(&mut buf)\n    ///                                         .expect(\"Didn't receive data\");\n    /// let filled_buf = &mut buf[..number_of_bytes];\n    /// ```\n    #[stable(feature = \"peek\", since = \"1.18.0\")]\n    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n}\n\n    /// Sends data on the socket to the given address. On success, returns the\n    /// number of bytes written.\n    ///\n    /// Address type can be any implementor of [`ToSocketAddrs`] trait. See its\n    /// documentation for concrete examples.\n    ///\n    /// It is possible for `addr` to yield multiple addresses, but `send_to`\n    /// will only send data to the first address yielded by `addr`.\n    ///\n    /// This will return an error when the IP version of the local socket\n    /// does not match that returned from [`ToSocketAddrs`].\n    ///\n    /// See issue #34202 for more details.\n    ///\n    /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.send_to(&[0; 10], \"127.0.0.1:4242\").expect(\"couldn't send data\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A) -> io::Result<usize> {\n}\n\n    /// Returns the socket address of the remote peer this socket was connected to.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, UdpSocket};\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.connect(\"192.168.0.1:41203\").expect(\"couldn't connect to address\");\n    /// assert_eq!(socket.peer_addr().unwrap(),\n    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(192, 168, 0, 1), 41203)));\n    /// ```\n    ///\n    /// If the socket isn't connected, it will return a [`NotConnected`] error.\n    ///\n    /// [`NotConnected`]: ../../std/io/enum.ErrorKind.html#variant.NotConnected\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// assert_eq!(socket.peer_addr().unwrap_err().kind(),\n    ///            std::io::ErrorKind::NotConnected);\n    /// ```\n    #[stable(feature = \"udp_peer_addr\", since = \"1.40.0\")]\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n}\n\n    /// Returns the socket address that this socket was created from.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, UdpSocket};\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// assert_eq!(socket.local_addr().unwrap(),\n    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 34254)));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n}\n\n    /// Creates a new independently owned handle to the underlying socket.\n    ///\n    /// The returned `UdpSocket` is a reference to the same socket that this\n    /// object references. Both handles will read and write the same port, and\n    /// options set on one socket will be propagated to the other.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// let socket_clone = socket.try_clone().expect(\"couldn't clone the socket\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn try_clone(&self) -> io::Result<UdpSocket> {\n}\n\n    /// Sets the read timeout to the timeout specified.\n    ///\n    /// If the value specified is [`None`], then [`read`] calls will block\n    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n    /// passed to this method.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Platforms may return a different error code whenever a read times out as\n    /// a result of setting this option. For example Unix typically returns an\n    /// error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`read`]: ../../std/io/trait.Read.html#tymethod.read\n    /// [`Duration`]: ../../std/time/struct.Duration.html\n    /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n    /// [`TimedOut`]: ../../std/io/enum.ErrorKind.html#variant.TimedOut\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n    /// ```\n    ///\n    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n    /// method:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::net::UdpSocket;\n    /// use std::time::Duration;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n    /// let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n}\n\n    /// Sets the write timeout to the timeout specified.\n    ///\n    /// If the value specified is [`None`], then [`write`] calls will block\n    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n    /// passed to this method.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// Platforms may return a different error code whenever a write times out\n    /// as a result of setting this option. For example Unix typically returns\n    /// an error of the kind [`WouldBlock`], but Windows may return [`TimedOut`].\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`write`]: ../../std/io/trait.Write.html#tymethod.write\n    /// [`Duration`]: ../../std/time/struct.Duration.html\n    /// [`WouldBlock`]: ../../std/io/enum.ErrorKind.html#variant.WouldBlock\n    /// [`TimedOut`]: ../../std/io/enum.ErrorKind.html#variant.TimedOut\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n    /// ```\n    ///\n    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n    /// method:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::net::UdpSocket;\n    /// use std::time::Duration;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").unwrap();\n    /// let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n    /// let err = result.unwrap_err();\n    /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n}\n\n    /// Returns the read timeout of this socket.\n    ///\n    /// If the timeout is [`None`], then [`read`] calls will block indefinitely.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`read`]: ../../std/io/trait.Read.html#tymethod.read\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_read_timeout(None).expect(\"set_read_timeout call failed\");\n    /// assert_eq!(socket.read_timeout().unwrap(), None);\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n}\n\n    /// Returns the write timeout of this socket.\n    ///\n    /// If the timeout is [`None`], then [`write`] calls will block indefinitely.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`write`]: ../../std/io/trait.Write.html#tymethod.write\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_write_timeout(None).expect(\"set_write_timeout call failed\");\n    /// assert_eq!(socket.write_timeout().unwrap(), None);\n    /// ```\n    #[stable(feature = \"socket_timeout\", since = \"1.4.0\")]\n    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n}\n\n    /// Sets the value of the `SO_BROADCAST` option for this socket.\n    ///\n    /// When enabled, this socket is allowed to send packets to a broadcast\n    /// address.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_broadcast(false).expect(\"set_broadcast call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> {\n}\n\n    /// Gets the value of the `SO_BROADCAST` option for this socket.\n    ///\n    /// For more information about this option, see\n    /// [`set_broadcast`][link].\n    ///\n    /// [link]: #method.set_broadcast\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_broadcast(false).expect(\"set_broadcast call failed\");\n    /// assert_eq!(socket.broadcast().unwrap(), false);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn broadcast(&self) -> io::Result<bool> {\n}\n\n    /// Sets the value of the `IP_MULTICAST_LOOP` option for this socket.\n    ///\n    /// If enabled, multicast packets will be looped back to the local socket.\n    /// Note that this may not have any effect on IPv6 sockets.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_multicast_loop_v4(false).expect(\"set_multicast_loop_v4 call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n}\n\n    /// Gets the value of the `IP_MULTICAST_LOOP` option for this socket.\n    ///\n    /// For more information about this option, see\n    /// [`set_multicast_loop_v4`][link].\n    ///\n    /// [link]: #method.set_multicast_loop_v4\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_multicast_loop_v4(false).expect(\"set_multicast_loop_v4 call failed\");\n    /// assert_eq!(socket.multicast_loop_v4().unwrap(), false);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n}\n\n    /// Sets the value of the `IP_MULTICAST_TTL` option for this socket.\n    ///\n    /// Indicates the time-to-live value of outgoing multicast packets for\n    /// this socket. The default value is 1 which means that multicast packets\n    /// don't leave the local network unless explicitly requested.\n    ///\n    /// Note that this may not have any effect on IPv6 sockets.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_multicast_ttl_v4(42).expect(\"set_multicast_ttl_v4 call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n}\n\n    /// Gets the value of the `IP_MULTICAST_TTL` option for this socket.\n    ///\n    /// For more information about this option, see\n    /// [`set_multicast_ttl_v4`][link].\n    ///\n    /// [link]: #method.set_multicast_ttl_v4\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_multicast_ttl_v4(42).expect(\"set_multicast_ttl_v4 call failed\");\n    /// assert_eq!(socket.multicast_ttl_v4().unwrap(), 42);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n}\n\n    /// Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.\n    ///\n    /// Controls whether this socket sees the multicast packets it sends itself.\n    /// Note that this may not have any affect on IPv4 sockets.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_multicast_loop_v6(false).expect(\"set_multicast_loop_v6 call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {\n}\n\n    /// Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.\n    ///\n    /// For more information about this option, see\n    /// [`set_multicast_loop_v6`][link].\n    ///\n    /// [link]: #method.set_multicast_loop_v6\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_multicast_loop_v6(false).expect(\"set_multicast_loop_v6 call failed\");\n    /// assert_eq!(socket.multicast_loop_v6().unwrap(), false);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n}\n\n    /// Sets the value for the `IP_TTL` option on this socket.\n    ///\n    /// This value sets the time-to-live field that is used in every packet sent\n    /// from this socket.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_ttl(42).expect(\"set_ttl call failed\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n}\n\n    /// Gets the value of the `IP_TTL` option for this socket.\n    ///\n    /// For more information about this option, see [`set_ttl`][link].\n    ///\n    /// [link]: #method.set_ttl\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.set_ttl(42).expect(\"set_ttl call failed\");\n    /// assert_eq!(socket.ttl().unwrap(), 42);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn ttl(&self) -> io::Result<u32> {\n}\n\n    /// Executes an operation of the `IP_ADD_MEMBERSHIP` type.\n    ///\n    /// This function specifies a new multicast group for this socket to join.\n    /// The address must be a valid multicast address, and `interface` is the\n    /// address of the local interface with which the system should join the\n    /// multicast group. If it's equal to `INADDR_ANY` then an appropriate\n    /// interface is chosen by the system.\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n}\n\n    /// Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.\n    ///\n    /// This function specifies a new multicast group for this socket to join.\n    /// The address must be a valid multicast address, and `interface` is the\n    /// index of the interface to join/leave (or 0 to indicate any interface).\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n}\n\n    /// Executes an operation of the `IP_DROP_MEMBERSHIP` type.\n    ///\n    /// For more information about this option, see\n    /// [`join_multicast_v4`][link].\n    ///\n    /// [link]: #method.join_multicast_v4\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n}\n\n    /// Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.\n    ///\n    /// For more information about this option, see\n    /// [`join_multicast_v6`][link].\n    ///\n    /// [link]: #method.join_multicast_v6\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n}\n\n    /// Gets the value of the `SO_ERROR` option on this socket.\n    ///\n    /// This will retrieve the stored error in the underlying socket, clearing\n    /// the field in the process. This can be useful for checking errors between\n    /// calls.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// match socket.take_error() {\n    ///     Ok(Some(error)) => println!(\"UdpSocket error: {:?}\", error),\n    ///     Ok(None) => println!(\"No error\"),\n    ///     Err(error) => println!(\"UdpSocket.take_error failed: {:?}\", error),\n    /// }\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n}\n\n    /// Connects this UDP socket to a remote address, allowing the `send` and\n    /// `recv` syscalls to be used to send data and also applies filters to only\n    /// receive data from the specified address.\n    ///\n    /// If `addr` yields multiple addresses, `connect` will be attempted with\n    /// each of the addresses until the underlying OS function returns no\n    /// error. Note that usually, a successful `connect` call does not specify\n    /// that there is a remote server listening on the port, rather, such an\n    /// error would only be detected after the first send. If the OS returns an\n    /// error for each of the specified addresses, the error returned from the\n    /// last connection attempt (the last address) is returned.\n    ///\n    /// # Examples\n    ///\n    /// Creates a UDP socket bound to `127.0.0.1:3400` and connect the socket to\n    /// `127.0.0.1:8080`:\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n    /// ```\n    ///\n    /// Unlike in the TCP case, passing an array of addresses to the `connect`\n    /// function of a UDP socket is not a useful thing to do: The OS will be\n    /// unable to determine whether something is listening on the remote\n    /// address without the application sending data.\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {\n}\n\n    /// Sends data on the socket to the remote address to which it is connected.\n    ///\n    /// The [`connect`] method will connect this socket to a remote address. This\n    /// method will fail if the socket is not connected.\n    ///\n    /// [`connect`]: #method.connect\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n    /// socket.send(&[0, 1, 2]).expect(\"couldn't send message\");\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    /// Receives a single datagram message on the socket from the remote address to\n    /// which it is connected. On success, returns the number of bytes read.\n    ///\n    /// The function must be called with valid byte array `buf` of sufficient size to\n    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n    /// excess bytes may be discarded.\n    ///\n    /// The [`connect`] method will connect this socket to a remote address. This\n    /// method will fail if the socket is not connected.\n    ///\n    /// [`connect`]: #method.connect\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n    /// let mut buf = [0; 10];\n    /// match socket.recv(&mut buf) {\n    ///     Ok(received) => println!(\"received {} bytes {:?}\", received, &buf[..received]),\n    ///     Err(e) => println!(\"recv function failed: {:?}\", e),\n    /// }\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    /// Receives single datagram on the socket from the remote address to which it is\n    /// connected, without removing the message from input queue. On success, returns\n    /// the number of bytes peeked.\n    ///\n    /// The function must be called with valid byte array `buf` of sufficient size to\n    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n    /// excess bytes may be discarded.\n    ///\n    /// Successive calls return the same data. This is accomplished by passing\n    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n    ///\n    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n    /// synchronize IO events on one or more sockets.\n    ///\n    /// The [`connect`] method will connect this socket to a remote address. This\n    /// method will fail if the socket is not connected.\n    ///\n    /// [`connect`]: #method.connect\n    ///\n    /// # Errors\n    ///\n    /// This method will fail if the socket is not connected. The `connect` method\n    /// will connect this socket to a remote address.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n    /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n    /// let mut buf = [0; 10];\n    /// match socket.peek(&mut buf) {\n    ///     Ok(received) => println!(\"received {} bytes\", received),\n    ///     Err(e) => println!(\"peek function failed: {:?}\", e),\n    /// }\n    /// ```\n    #[stable(feature = \"peek\", since = \"1.18.0\")]\n    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    /// Moves this UDP socket into or out of nonblocking mode.\n    ///\n    /// This will result in `recv`, `recv_from`, `send`, and `send_to`\n    /// operations becoming nonblocking, i.e., immediately returning from their\n    /// calls. If the IO operation is successful, `Ok` is returned and no\n    /// further action is required. If the IO operation could not be completed\n    /// and needs to be retried, an error with kind\n    /// [`io::ErrorKind::WouldBlock`] is returned.\n    ///\n    /// On Unix platforms, calling this method corresponds to calling `fcntl`\n    /// `FIONBIO`. On Windows calling this method corresponds to calling\n    /// `ioctlsocket` `FIONBIO`.\n    ///\n    /// [`io::ErrorKind::WouldBlock`]: ../io/enum.ErrorKind.html#variant.WouldBlock\n    ///\n    /// # Examples\n    ///\n    /// Creates a UDP socket bound to `127.0.0.1:7878` and read bytes in\n    /// nonblocking mode:\n    ///\n    /// ```no_run\n    /// use std::io;\n    /// use std::net::UdpSocket;\n    ///\n    /// let socket = UdpSocket::bind(\"127.0.0.1:7878\").unwrap();\n    /// socket.set_nonblocking(true).unwrap();\n    ///\n    /// # fn wait_for_fd() { unimplemented!() }\n    /// let mut buf = [0; 10];\n    /// let (num_bytes_read, _) = loop {\n    ///     match socket.recv_from(&mut buf) {\n    ///         Ok(n) => break n,\n    ///         Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n    ///             // wait until network socket is ready, typically implemented\n    ///             // via platform-specific APIs such as epoll or IOCP\n    ///             wait_for_fd();\n    ///         }\n    ///         Err(e) => panic!(\"encountered IO error: {}\", e),\n    ///     }\n    /// };\n    /// println!(\"bytes: {:?}\", &buf[..num_bytes_read]);\n    /// ```\n    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n}\n}\n\nimpl AsInner<net_imp::UdpSocket> for UdpSocket {\n    fn as_inner(&self) -> &net_imp::UdpSocket {\n}\n}\n\nimpl FromInner<net_imp::UdpSocket> for UdpSocket {\n    fn from_inner(inner: net_imp::UdpSocket) -> UdpSocket {\n}\n}\n\nimpl IntoInner<net_imp::UdpSocket> for UdpSocket {\n    fn into_inner(self) -> net_imp::UdpSocket {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for UdpSocket {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\nmod tests {\n    use crate::io::ErrorKind;\n    use crate::net::test::{next_test_ip4, next_test_ip6};\n    use crate::net::*;\n    use crate::sync::mpsc::channel;\n    use crate::sys_common::AsInner;\n    use crate::thread;\n    use crate::time::{Duration, Instant};\n\n    fn each_ip(f: &mut dyn FnMut(SocketAddr, SocketAddr)) {\n}\n\n    macro_rules! t {\n        ($e:expr) => {\n            match $e {\n                Ok(t) => t,\n                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n            }\n        };\n    }\n\n    #[test]\n    fn bind_error() {\n}\n\n    #[test]\n    fn socket_smoke_test_ip4() {\n}\n\n    #[test]\n    fn socket_name() {\n}\n\n    #[test]\n    fn socket_peer() {\n}\n\n    #[test]\n    fn udp_clone_smoke() {\n}\n\n    #[test]\n    fn udp_clone_two_read() {\n}\n\n    #[test]\n    fn udp_clone_two_write() {\n}\n\n    #[test]\n    fn debug() {\n}\n\n    // FIXME: re-enabled openbsd/netbsd tests once their socket timeout code\n    //        no longer has rounding errors.\n    // VxWorks ignores SO_SNDTIMEO.\n    #[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\"), ignore)]\n    #[test]\n    fn timeouts() {\n}\n\n    #[test]\n    fn test_read_timeout() {\n}\n\n    #[test]\n    fn test_read_with_timeout() {\n}\n\n    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n    // when passed zero Durations\n    #[test]\n    fn test_timeout_zero_duration() {\n}\n\n    #[test]\n    fn connect_send_recv() {\n}\n\n    #[test]\n    fn connect_send_peek_recv() {\n}\n\n    #[test]\n    fn peek_from() {\n}\n\n    #[test]\n    fn ttl() {\n}\n\n    #[test]\n    fn set_nonblocking() {\n}\n}\n}\n\n/// Possible values which can be passed to the [`shutdown`] method of\n/// [`TcpStream`].\n///\n/// [`shutdown`]: struct.TcpStream.html#method.shutdown\n/// [`TcpStream`]: struct.TcpStream.html\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Shutdown {\n    /// The reading portion of the [`TcpStream`] should be shut down.\n    ///\n    /// All currently blocked and future [reads] will return [`Ok(0)`].\n    ///\n    /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n    /// [reads]: ../../std/io/trait.Read.html\n    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Read,\n    /// The writing portion of the [`TcpStream`] should be shut down.\n    ///\n    /// All currently blocked and future [writes] will return an error.\n    ///\n    /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n    /// [writes]: ../../std/io/trait.Write.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Write,\n    /// Both the reading and the writing portions of the [`TcpStream`] should be shut down.\n    ///\n    /// See [`Shutdown::Read`] and [`Shutdown::Write`] for more information.\n    ///\n    /// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n    /// [`Shutdown::Read`]: #variant.Read\n    /// [`Shutdown::Write`]: #variant.Write\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Both,\n}\n\n#[inline]\nconst fn htons(i: u16) -> u16 {\n}\n#[inline]\nconst fn ntohs(i: u16) -> u16 {\n}\n\nfn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\nwhere\n    F: FnMut(io::Result<&SocketAddr>) -> io::Result<T>,\n{\n}\n}\npub mod num {\n//! Additional functionality for numerics.\n//!\n//! This module provides some extra types that are useful when doing numerical\n//! work. See the individual documentation for each piece for more information.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![allow(missing_docs)]\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::num::Wrapping;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::num::{FpCategory, ParseFloatError, ParseIntError, TryFromIntError};\n\n#[stable(feature = \"signed_nonzero\", since = \"1.34.0\")]\npub use core::num::{NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize};\n#[stable(feature = \"nonzero\", since = \"1.28.0\")]\npub use core::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\n\n#[unstable(\n    feature = \"int_error_matching\",\n    reason = \"it can be useful to match errors when making error messages \\\n              for integer parsing\",\n    issue = \"22639\"\n)]\npub use core::num::IntErrorKind;\n\n#[cfg(test)]\nuse crate::fmt;\n#[cfg(test)]\nuse crate::ops::{Add, Div, Mul, Rem, Sub};\n\n/// Helper function for testing numeric operations\n#[cfg(test)]\npub fn test_num<T>(ten: T, two: T)\nwhere\n    T: PartialEq\n        + Add<Output = T>\n        + Sub<Output = T>\n        + Mul<Output = T>\n        + Div<Output = T>\n        + Rem<Output = T>\n        + fmt::Debug\n        + Copy,\n{\n}\n\n#[cfg(test)]\nmod tests {\n}\n\n#[cfg(test)]\nmod bench {\n}\n}\npub mod os {\n//! OS-specific functionality.\n\n#![stable(feature = \"os\", since = \"1.0.0\")]\n#![allow(missing_docs, nonstandard_style, missing_debug_implementations)]\n\ncfg_if::cfg_if! {\n    if #[cfg(doc)] {\n\n        // When documenting libstd we want to show unix/windows/linux modules as\n        // these are the \"main modules\" that are used across platforms. This\n        // should help show platform-specific functionality in a hopefully\n        // cross-platform way in the documentation\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub use crate::sys::unix_ext as unix;\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub use crate::sys::windows_ext as windows;\n\n        #[doc(cfg(target_os = \"linux\"))]\n        pub mod linux;\n    } else {\n\n        // If we're not documenting libstd then we just expose the main modules\n        // as we otherwise would.\n\n        #[cfg(any(target_os = \"redox\", unix, target_os = \"vxworks\"))]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub use crate::sys::ext as unix;\n\n        #[cfg(windows)]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub use crate::sys::ext as windows;\n\n        #[cfg(any(target_os = \"linux\", target_os = \"l4re\"))]\n        pub mod linux;\n\n    }\n}\n\n#[cfg(target_os = \"android\")]\npub mod android {\n//! Android-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n#[allow(deprecated)]\nuse crate::os::android::raw;\n\n/// OS-specific extensions to [`fs::Metadata`].\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    /// Gain a reference to the underlying `stat` structure which contains\n    /// the raw information returned by the OS.\n    ///\n    /// The contents of the returned `stat` are **not** consistent across\n    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n    /// cross-Unix abstractions contained within the raw stat.\n    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n    #[rustc_deprecated(\n        since = \"1.8.0\",\n        reason = \"deprecated in favor of the accessor \\\n                  methods of this trait\"\n    )]\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat;\n\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat {\n}\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_atime_nsec(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_mtime_nsec(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_ctime_nsec(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n}\n}\npub mod raw {\n//! Android-specific raw type definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n#![rustc_deprecated(\n    since = \"1.8.0\",\n    reason = \"these type aliases are no longer supported by \\\n              the standard library, the `libc` crate on \\\n              crates.io should be used instead for the correct \\\n              definitions\"\n)]\n#![allow(deprecated)]\n\nuse crate::os::raw::c_long;\n\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = c_long;\n\n#[doc(inline)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub use self::arch::{blkcnt_t, blksize_t, dev_t, ino_t, mode_t, nlink_t, off_t, stat, time_t};\n\n#[cfg(any(target_arch = \"arm\", target_arch = \"x86\"))]\nmod arch {\n    use crate::os::raw::{c_longlong, c_uchar, c_uint, c_ulong, c_ulonglong};\n    use crate::os::unix::raw::{gid_t, uid_t};\n\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type dev_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type mode_t = u32;\n\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blkcnt_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blksize_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type ino_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type nlink_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type off_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type time_t = i64;\n\n    #[repr(C)]\n    #[derive(Clone)]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub struct stat {\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_dev: c_ulonglong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __pad0: [c_uchar; 4],\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __st_ino: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mode: c_uint,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_nlink: c_uint,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_uid: uid_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_gid: gid_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_rdev: c_ulonglong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __pad3: [c_uchar; 4],\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_size: c_longlong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blksize: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blocks: c_ulonglong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime_nsec: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime_nsec: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime_nsec: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ino: c_ulonglong,\n    }\n}\n\n#[cfg(target_arch = \"aarch64\")]\nmod arch {\n    use crate::os::raw::{c_uchar, c_ulong};\n    use crate::os::unix::raw::{gid_t, uid_t};\n\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type dev_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type mode_t = u32;\n\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blkcnt_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blksize_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type ino_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type nlink_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type off_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type time_t = i64;\n\n    #[repr(C)]\n    #[derive(Clone)]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub struct stat {\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_dev: dev_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __pad0: [c_uchar; 4],\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __st_ino: ino_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mode: mode_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_nlink: nlink_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_uid: uid_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_gid: gid_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_rdev: dev_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __pad3: [c_uchar; 4],\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_size: off_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blksize: blksize_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blocks: blkcnt_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime: time_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime_nsec: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime: time_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime_nsec: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime: time_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime_nsec: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ino: ino_t,\n    }\n}\n\n#[cfg(target_arch = \"x86_64\")]\nmod arch {\n    use crate::os::raw::{c_long, c_uint, c_ulong};\n    use crate::os::unix::raw::{gid_t, uid_t};\n\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type dev_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type mode_t = u32;\n\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blkcnt_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blksize_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type ino_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type nlink_t = u32;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type off_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type time_t = i64;\n\n    #[repr(C)]\n    #[derive(Clone)]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub struct stat {\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_dev: dev_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ino: ino_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_nlink: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mode: c_uint,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_uid: uid_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_gid: gid_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_rdev: dev_t,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_size: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blksize: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blocks: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime_nsec: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime_nsec: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime_nsec: c_ulong,\n        __unused: [c_long; 3],\n    }\n}\n}\n}\n#[cfg(target_os = \"dragonfly\")]\npub mod dragonfly {\n//! Dragonfly-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n#[allow(deprecated)]\nuse crate::os::dragonfly::raw;\n\n/// OS-specific extensions to [`fs::Metadata`].\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    /// Gain a reference to the underlying `stat` structure which contains\n    /// the raw information returned by the OS.\n    ///\n    /// The contents of the returned `stat` are **not** consistent across\n    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n    /// cross-Unix abstractions contained within the raw stat.\n    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n    #[rustc_deprecated(\n        since = \"1.8.0\",\n        reason = \"deprecated in favor of the accessor \\\n                  methods of this trait\"\n    )]\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat;\n\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_flags(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gen(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_lspare(&self) -> u32;\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat {\n}\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_atime_nsec(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_mtime_nsec(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_ctime_nsec(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n    fn st_gen(&self) -> u32 {\n}\n    fn st_flags(&self) -> u32 {\n}\n    fn st_lspare(&self) -> u32 {\n}\n}\n}\npub mod raw {\n//! Dragonfly-specific raw type definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n#![rustc_deprecated(\n    since = \"1.8.0\",\n    reason = \"these type aliases are no longer supported by \\\n              the standard library, the `libc` crate on \\\n              crates.io should be used instead for the correct \\\n              definitions\"\n)]\n#![allow(deprecated)]\n\nuse crate::os::raw::c_long;\n\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blkcnt_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blksize_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type dev_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type fflags_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type ino_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type mode_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type nlink_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type off_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type time_t = i64;\n\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = usize;\n\n#[repr(C)]\n#[derive(Clone)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub struct stat {\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_dev: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ino: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mode: u16,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_nlink: u16,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_uid: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gid: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_rdev: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_size: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blocks: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blksize: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_flags: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gen: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_lspare: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_birthtime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_birthtime_nsec: c_long,\n}\n}\n}\n#[cfg(target_os = \"emscripten\")]\npub mod emscripten {\n//! Linux-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n#[allow(deprecated)]\nuse crate::os::emscripten::raw;\n\n/// OS-specific extensions to [`fs::Metadata`].\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    /// Gain a reference to the underlying `stat` structure which contains\n    /// the raw information returned by the OS.\n    ///\n    /// The contents of the returned `stat` are **not** consistent across\n    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n    /// cross-Unix abstractions contained within the raw stat.\n    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n    #[rustc_deprecated(\n        since = \"1.8.0\",\n        reason = \"deprecated in favor of the accessor \\\n                  methods of this trait\"\n    )]\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat;\n\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat {\n}\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_atime_nsec(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_mtime_nsec(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_ctime_nsec(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n}\n}\npub mod raw {\n//! Emscripten-specific raw type definitions\n//! This is basically exactly the same as the linux definitions,\n//! except using the musl-specific stat64 structure in liblibc.\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n#![rustc_deprecated(\n    since = \"1.8.0\",\n    reason = \"these type aliases are no longer supported by \\\n              the standard library, the `libc` crate on \\\n              crates.io should be used instead for the correct \\\n              definitions\"\n)]\n#![allow(deprecated)]\n\nuse crate::os::raw::{c_long, c_short, c_uint, c_ulong};\n\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type dev_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type mode_t = u32;\n\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = c_ulong;\n\n#[doc(inline)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blkcnt_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blksize_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type ino_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type nlink_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type off_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type time_t = c_long;\n\n#[repr(C)]\n#[derive(Clone)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub struct stat {\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_dev: u64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub __pad1: c_short,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub __st_ino: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mode: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_nlink: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_uid: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gid: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_rdev: u64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub __pad2: c_uint,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_size: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blksize: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blocks: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ino: u64,\n}\n}\n}\n#[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))]\npub mod fortanix_sgx {\n//! Functionality specific to the `x86_64-fortanix-unknown-sgx` target.\n//!\n//! This includes functions to deal with memory isolation, usercalls, and the\n//! SGX instruction set.\n\n#![deny(missing_docs, missing_debug_implementations)]\n#![unstable(feature = \"sgx_platform\", issue = \"56975\")]\n\n/// Low-level interfaces to usercalls. See the [ABI documentation] for more\n/// information.\n///\n/// [ABI documentation]: https://docs.rs/fortanix-sgx-abi/\npub mod usercalls {\n    pub use crate::sys::abi::usercalls::*;\n\n    /// Primitives for allocating memory in userspace as well as copying data\n    /// to and from user memory.\n    pub mod alloc {\n        pub use crate::sys::abi::usercalls::alloc::*;\n    }\n\n    /// Lowest-level interfaces to usercalls and usercall ABI type definitions.\n    pub mod raw {\n        pub use crate::sys::abi::usercalls::raw::{\n            accept_stream, alloc, async_queues, bind_stream, close, connect_stream, exit, flush,\n            free, insecure_time, launch_thread, read, read_alloc, send, wait, write,\n        };\n        pub use crate::sys::abi::usercalls::raw::{do_usercall, Usercalls as UsercallNrs};\n\n        // fortanix-sgx-abi re-exports\n        pub use crate::sys::abi::usercalls::raw::Error;\n        pub use crate::sys::abi::usercalls::raw::{ByteBuffer, FifoDescriptor, Return, Usercall};\n        pub use crate::sys::abi::usercalls::raw::{Fd, Result, Tcs};\n        pub use crate::sys::abi::usercalls::raw::{\n            EV_RETURNQ_NOT_EMPTY, EV_UNPARK, EV_USERCALLQ_NOT_FULL, FD_STDERR, FD_STDIN, FD_STDOUT,\n            RESULT_SUCCESS, USERCALL_USER_DEFINED, WAIT_INDEFINITE, WAIT_NO,\n        };\n    }\n}\n\n/// Functions for querying mapping information for pointers.\npub mod mem {\n    pub use crate::sys::abi::mem::*;\n}\n\npub use crate::sys::ext::{arch, ffi, io};\n\n/// Functions for querying thread-related information.\npub mod thread {\n    pub use crate::sys::abi::thread::current;\n}\n}\n#[cfg(target_os = \"freebsd\")]\npub mod freebsd {\n//! FreeBSD-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n#[allow(deprecated)]\nuse crate::os::freebsd::raw;\n\n/// OS-specific extensions to [`fs::Metadata`].\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    /// Gain a reference to the underlying `stat` structure which contains\n    /// the raw information returned by the OS.\n    ///\n    /// The contents of the returned `stat` are **not** consistent across\n    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n    /// cross-Unix abstractions contained within the raw stat.\n    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n    #[rustc_deprecated(\n        since = \"1.8.0\",\n        reason = \"deprecated in favor of the accessor \\\n                  methods of this trait\"\n    )]\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat;\n\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_birthtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_birthtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_flags(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gen(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_lspare(&self) -> u32;\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat {\n}\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_atime_nsec(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_mtime_nsec(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_ctime_nsec(&self) -> i64 {\n}\n    fn st_birthtime(&self) -> i64 {\n}\n    fn st_birthtime_nsec(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n    fn st_gen(&self) -> u32 {\n}\n    fn st_flags(&self) -> u32 {\n}\n    fn st_lspare(&self) -> u32 {\n}\n}\n}\npub mod raw {\n//! FreeBSD-specific raw type definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n#![rustc_deprecated(\n    since = \"1.8.0\",\n    reason = \"these type aliases are no longer supported by \\\n              the standard library, the `libc` crate on \\\n              crates.io should be used instead for the correct \\\n              definitions\"\n)]\n#![allow(deprecated)]\n\nuse crate::os::raw::c_long;\n\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blkcnt_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blksize_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type dev_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type fflags_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type ino_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type mode_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type nlink_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type off_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type time_t = i64;\n\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = usize;\n\n#[repr(C)]\n#[derive(Clone)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub struct stat {\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_dev: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ino: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mode: u16,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_nlink: u16,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_uid: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gid: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_rdev: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_size: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blocks: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blksize: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_flags: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gen: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_lspare: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_birthtime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_birthtime_nsec: c_long,\n    #[cfg(target_arch = \"x86\")]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub __unused: [u8; 8],\n}\n}\n}\n#[cfg(target_os = \"fuchsia\")]\npub mod fuchsia {\n//! Fuchsia-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n/// OS-specific extensions to [`fs::Metadata`].\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_atime_nsec(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_mtime_nsec(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_ctime_nsec(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n}\n}\npub mod raw {\n//! Fuchsia-specific raw type definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n#![rustc_deprecated(\n    since = \"1.8.0\",\n    reason = \"these type aliases are no longer supported by \\\n              the standard library, the `libc` crate on \\\n              crates.io should be used instead for the correct \\\n              definitions\"\n)]\n#![allow(deprecated)]\n\nuse crate::os::raw::c_ulong;\n\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type dev_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type mode_t = u32;\n\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = c_ulong;\n\n#[doc(inline)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub use self::arch::{blkcnt_t, blksize_t, ino_t, nlink_t, off_t, stat, time_t};\n\n#[cfg(any(\n    target_arch = \"x86\",\n    target_arch = \"le32\",\n    target_arch = \"powerpc\",\n    target_arch = \"arm\"\n))]\nmod arch {\n    use crate::os::raw::{c_long, c_short, c_uint};\n\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blkcnt_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blksize_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type ino_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type nlink_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type off_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type time_t = i64;\n\n    #[repr(C)]\n    #[derive(Clone)]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub struct stat {\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_dev: u64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __pad1: c_short,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __st_ino: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mode: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_nlink: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_uid: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_gid: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_rdev: u64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __pad2: c_uint,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_size: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blksize: i32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blocks: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime: i32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime_nsec: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime: i32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime_nsec: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime: i32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime_nsec: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ino: u64,\n    }\n}\n\n#[cfg(target_arch = \"mips\")]\nmod arch {\n    use crate::os::raw::{c_long, c_ulong};\n\n    #[cfg(target_env = \"musl\")]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blkcnt_t = i64;\n    #[cfg(not(target_env = \"musl\"))]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blkcnt_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blksize_t = u64;\n    #[cfg(target_env = \"musl\")]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type ino_t = u64;\n    #[cfg(not(target_env = \"musl\"))]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type ino_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type nlink_t = u64;\n    #[cfg(target_env = \"musl\")]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type off_t = u64;\n    #[cfg(not(target_env = \"musl\"))]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type off_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type time_t = i64;\n\n    #[repr(C)]\n    #[derive(Clone)]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub struct stat {\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_dev: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_pad1: [c_long; 3],\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ino: u64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mode: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_nlink: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_uid: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_gid: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_rdev: c_ulong,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_pad2: [c_long; 2],\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_size: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime: i32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime_nsec: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime: i32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime_nsec: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime: i32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime_nsec: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blksize: i32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blocks: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_pad5: [c_long; 14],\n    }\n}\n\n#[cfg(target_arch = \"mips64\")]\nmod arch {\n    pub use libc::{blkcnt_t, blksize_t, ino_t, nlink_t, off_t, stat, time_t};\n}\n\n#[cfg(target_arch = \"aarch64\")]\nmod arch {\n    use crate::os::raw::{c_int, c_long};\n\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blkcnt_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blksize_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type ino_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type nlink_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type off_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type time_t = i64;\n\n    #[repr(C)]\n    #[derive(Clone)]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub struct stat {\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_dev: u64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ino: u64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mode: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_nlink: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_uid: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_gid: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_rdev: u64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __pad1: u64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_size: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blksize: i32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __pad2: c_int,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blocks: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime_nsec: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime_nsec: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime_nsec: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __unused: [c_int; 2],\n    }\n}\n\n#[cfg(target_arch = \"x86_64\")]\nmod arch {\n    use crate::os::raw::{c_int, c_long};\n\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blkcnt_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type blksize_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type ino_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type nlink_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type off_t = u64;\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub type time_t = i64;\n\n    #[repr(C)]\n    #[derive(Clone)]\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub struct stat {\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_dev: u64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ino: u64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_nlink: u64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mode: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_uid: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_gid: u32,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __pad0: c_int,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_rdev: u64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_size: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blksize: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_blocks: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_atime_nsec: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_mtime_nsec: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime: i64,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub st_ctime_nsec: c_long,\n        #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n        pub __unused: [c_long; 3],\n    }\n}\n}\n}\n#[cfg(target_os = \"haiku\")]\npub mod haiku {\n//! Haiku-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n#[allow(deprecated)]\nuse crate::os::haiku::raw;\n\n/// OS-specific extensions to [`fs::Metadata`].\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    /// Gain a reference to the underlying `stat` structure which contains\n    /// the raw information returned by the OS.\n    ///\n    /// The contents of the returned `stat` are **not** consistent across\n    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n    /// cross-Unix abstractions contained within the raw stat.\n    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n    #[rustc_deprecated(\n        since = \"1.8.0\",\n        reason = \"deprecated in favor of the accessor \\\n                  methods of this trait\"\n    )]\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat;\n\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_crtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_crtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat {\n}\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_atime_nsec(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_mtime_nsec(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_ctime_nsec(&self) -> i64 {\n}\n    fn st_crtime(&self) -> i64 {\n}\n    fn st_crtime_nsec(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n}\n}\npub mod raw {\n//! Haiku-specific raw type definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n#![allow(deprecated)]\n\nuse crate::os::raw::c_long;\nuse crate::os::unix::raw::{gid_t, uid_t};\n\n// Use the direct definition of usize, instead of uintptr_t like in libc\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = usize;\n\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blkcnt_t = i64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blksize_t = i32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type dev_t = i32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type ino_t = i64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type mode_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type nlink_t = i32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type off_t = i64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type time_t = i32;\n\n#[repr(C)]\n#[derive(Clone)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub struct stat {\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_dev: dev_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ino: ino_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mode: mode_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_nlink: nlink_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_uid: uid_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gid: gid_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_size: off_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_rdev: dev_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blksize: blksize_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_crtime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_crtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_type: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blocks: blkcnt_t,\n}\n}\n}\n#[cfg(target_os = \"ios\")]\npub mod ios {\n//! iOS-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n#[allow(deprecated)]\nuse crate::os::ios::raw;\n\n/// OS-specific extensions to [`fs::Metadata`].\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    /// Gain a reference to the underlying `stat` structure which contains\n    /// the raw information returned by the OS.\n    ///\n    /// The contents of the returned `stat` are **not** consistent across\n    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n    /// cross-Unix abstractions contained within the raw stat.\n    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n    #[rustc_deprecated(\n        since = \"1.8.0\",\n        reason = \"deprecated in favor of the accessor \\\n                  methods of this trait\"\n    )]\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat;\n\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_birthtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_birthtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_flags(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gen(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_lspare(&self) -> u32;\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat {\n}\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_atime_nsec(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_mtime_nsec(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_ctime_nsec(&self) -> i64 {\n}\n    fn st_birthtime(&self) -> i64 {\n}\n    fn st_birthtime_nsec(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n    fn st_gen(&self) -> u32 {\n}\n    fn st_flags(&self) -> u32 {\n}\n    fn st_lspare(&self) -> u32 {\n}\n}\n}\npub mod raw {\n//! iOS-specific raw type definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n#![rustc_deprecated(\n    since = \"1.8.0\",\n    reason = \"these type aliases are no longer supported by \\\n              the standard library, the `libc` crate on \\\n              crates.io should be used instead for the correct \\\n              definitions\"\n)]\n#![allow(deprecated)]\n\nuse crate::os::raw::c_long;\n\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blkcnt_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blksize_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type dev_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type ino_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type mode_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type nlink_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type off_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type time_t = i64;\n\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = usize;\n\n#[repr(C)]\n#[derive(Clone)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub struct stat {\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_dev: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mode: u16,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_nlink: u16,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ino: u64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_uid: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gid: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_rdev: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_birthtime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_birthtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_size: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blocks: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blksize: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_flags: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gen: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_lspare: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_qspare: [i64; 2],\n}\n}\n}\n#[cfg(target_os = \"macos\")]\npub mod macos {\n//! macOS-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n#[allow(deprecated)]\nuse crate::os::macos::raw;\n\n/// OS-specific extensions to [`fs::Metadata`].\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    /// Gain a reference to the underlying `stat` structure which contains\n    /// the raw information returned by the OS.\n    ///\n    /// The contents of the returned `stat` are **not** consistent across\n    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n    /// cross-Unix abstractions contained within the raw stat.\n    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n    #[rustc_deprecated(\n        since = \"1.8.0\",\n        reason = \"deprecated in favor of the accessor \\\n                  methods of this trait\"\n    )]\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat;\n\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_birthtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_birthtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_flags(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gen(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_lspare(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_qspare(&self) -> [u64; 2];\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat {\n}\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_atime_nsec(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_mtime_nsec(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_ctime_nsec(&self) -> i64 {\n}\n    fn st_birthtime(&self) -> i64 {\n}\n    fn st_birthtime_nsec(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n    fn st_gen(&self) -> u32 {\n}\n    fn st_flags(&self) -> u32 {\n}\n    fn st_lspare(&self) -> u32 {\n}\n    fn st_qspare(&self) -> [u64; 2] {\n}\n}\n}\npub mod raw {\n//! macOS-specific raw type definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n#![rustc_deprecated(\n    since = \"1.8.0\",\n    reason = \"these type aliases are no longer supported by \\\n              the standard library, the `libc` crate on \\\n              crates.io should be used instead for the correct \\\n              definitions\"\n)]\n#![allow(deprecated)]\n\nuse crate::os::raw::c_long;\n\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blkcnt_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blksize_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type dev_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type ino_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type mode_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type nlink_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type off_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type time_t = i64;\n\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = usize;\n\n#[repr(C)]\n#[derive(Clone)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub struct stat {\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_dev: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mode: u16,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_nlink: u16,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ino: u64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_uid: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gid: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_rdev: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_birthtime: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_birthtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_size: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blocks: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blksize: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_flags: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gen: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_lspare: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_qspare: [i64; 2],\n}\n}\n}\n#[cfg(target_os = \"netbsd\")]\npub mod netbsd {\n//! OpenBSD-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n#[allow(deprecated)]\nuse crate::os::netbsd::raw;\n\n/// OS-specific extensions to [`fs::Metadata`].\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    /// Gain a reference to the underlying `stat` structure which contains\n    /// the raw information returned by the OS.\n    ///\n    /// The contents of the returned `stat` are **not** consistent across\n    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n    /// cross-Unix abstractions contained within the raw stat.\n    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n    #[rustc_deprecated(\n        since = \"1.8.0\",\n        reason = \"deprecated in favor of the accessor \\\n                  methods of this trait\"\n    )]\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat;\n\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_birthtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_birthtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_flags(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gen(&self) -> u32;\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat {\n}\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_atime_nsec(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_mtime_nsec(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_ctime_nsec(&self) -> i64 {\n}\n    fn st_birthtime(&self) -> i64 {\n}\n    fn st_birthtime_nsec(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n    fn st_gen(&self) -> u32 {\n}\n    fn st_flags(&self) -> u32 {\n}\n}\n}\npub mod raw {\n//! NetBSD-specific raw type definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n#![rustc_deprecated(\n    since = \"1.8.0\",\n    reason = \"these type aliases are no longer supported by \\\n              the standard library, the `libc` crate on \\\n              crates.io should be used instead for the correct \\\n              definitions\"\n)]\n#![allow(deprecated)]\n\nuse crate::os::raw::c_long;\nuse crate::os::unix::raw::{gid_t, uid_t};\n\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blkcnt_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blksize_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type dev_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type fflags_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type ino_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type mode_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type nlink_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type off_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type time_t = i64;\n\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = usize;\n\n#[repr(C)]\n#[derive(Clone)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub struct stat {\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_dev: u64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mode: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ino: u64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_nlink: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_uid: uid_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gid: gid_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_rdev: u64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_birthtime: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_birthtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_size: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blocks: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blksize: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_flags: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gen: u32,\n    st_spare: [u32; 2],\n}\n}\n}\n#[cfg(target_os = \"openbsd\")]\npub mod openbsd {\n//! OpenBSD-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n#[allow(deprecated)]\nuse crate::os::openbsd::raw;\n\n/// OS-specific extensions to [`fs::Metadata`].\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    /// Gain a reference to the underlying `stat` structure which contains\n    /// the raw information returned by the OS.\n    ///\n    /// The contents of the returned `stat` are **not** consistent across\n    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n    /// cross-Unix abstractions contained within the raw stat.\n    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n    #[rustc_deprecated(\n        since = \"1.8.0\",\n        reason = \"deprecated in favor of the accessor \\\n                  methods of this trait\"\n    )]\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat;\n\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_birthtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_birthtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_flags(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gen(&self) -> u32;\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat {\n}\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_atime_nsec(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_mtime_nsec(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_ctime_nsec(&self) -> i64 {\n}\n    fn st_birthtime(&self) -> i64 {\n}\n    fn st_birthtime_nsec(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n    fn st_gen(&self) -> u32 {\n}\n    fn st_flags(&self) -> u32 {\n}\n}\n}\npub mod raw {\n//! OpenBSD-specific raw type definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n#![rustc_deprecated(\n    since = \"1.8.0\",\n    reason = \"these type aliases are no longer supported by \\\n              the standard library, the `libc` crate on \\\n              crates.io should be used instead for the correct \\\n              definitions\"\n)]\n#![allow(deprecated)]\n\nuse crate::os::raw::c_long;\n\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blkcnt_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blksize_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type dev_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type fflags_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type ino_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type mode_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type nlink_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type off_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type time_t = i64;\n\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = usize;\n\n#[repr(C)]\n#[derive(Clone)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub struct stat {\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mode: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_dev: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ino: u64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_nlink: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_uid: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gid: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_rdev: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_size: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blocks: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blksize: i32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_flags: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gen: u32,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_birthtime: i64,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_birthtime_nsec: c_long,\n}\n}\n}\n#[cfg(target_os = \"redox\")]\npub mod redox {\n//! Redox-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n#[allow(deprecated)]\nuse crate::os::redox::raw;\n\n/// OS-specific extensions to [`fs::Metadata`].\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    /// Gain a reference to the underlying `stat` structure which contains\n    /// the raw information returned by the OS.\n    ///\n    /// The contents of the returned [`stat`] are **not** consistent across\n    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n    /// cross-Unix abstractions contained within the raw stat.\n    ///\n    /// [`stat`]: ../../../../std/os/redox/raw/struct.stat.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     let stat = meta.as_raw_stat();\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n    #[rustc_deprecated(\n        since = \"1.8.0\",\n        reason = \"deprecated in favor of the accessor \\\n                  methods of this trait\"\n    )]\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat;\n\n    /// Returns the device ID on which this file resides.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_dev());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    /// Returns the inode number.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_ino());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    /// Returns the file type and mode.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_mode());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    /// Returns the number of hard links to file.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_nlink());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    /// Returns the user ID of the file owner.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_uid());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    /// Returns the group ID of the file owner.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_gid());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    /// Returns the device ID that this file represents. Only relevant for special file.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_rdev());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    /// Returns the size of the file (if it is a regular file or a symbolic link) in bytes.\n    ///\n    /// The size of a symbolic link is the length of the pathname it contains,\n    /// without a terminating null byte.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_size());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    /// Returns the last access time of the file, in seconds since Unix Epoch.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_atime());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    /// Returns the last access time of the file, in nanoseconds since [`st_atime`].\n    ///\n    /// [`st_atime`]: #tymethod.st_atime\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_atime_nsec());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime_nsec(&self) -> i64;\n    /// Returns the last modification time of the file, in seconds since Unix Epoch.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_mtime());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    /// Returns the last modification time of the file, in nanoseconds since [`st_mtime`].\n    ///\n    /// [`st_mtime`]: #tymethod.st_mtime\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_mtime_nsec());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime_nsec(&self) -> i64;\n    /// Returns the last status change time of the file, in seconds since Unix Epoch.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_ctime());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    /// Returns the last status change time of the file, in nanoseconds since [`st_ctime`].\n    ///\n    /// [`st_ctime`]: #tymethod.st_ctime\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_ctime_nsec());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime_nsec(&self) -> i64;\n    /// Returns the \"preferred\" blocksize for efficient filesystem I/O.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_blksize());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    /// Returns the number of blocks allocated to the file, 512-byte units.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::fs;\n    /// use std::io;\n    /// use std::os::redox::fs::MetadataExt;\n    ///\n    /// fn main() -> io::Result<()> {\n    ///     let meta = fs::metadata(\"some_file\")?;\n    ///     println!(\"{}\", meta.st_blocks());\n    ///     Ok(())\n    /// }\n    /// ```\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat {\n}\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_atime_nsec(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_mtime_nsec(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_ctime_nsec(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n}\n}\npub mod raw {\n//! Redox-specific raw type definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n#![rustc_deprecated(\n    since = \"1.8.0\",\n    reason = \"these type aliases are no longer supported by \\\n              the standard library, the `libc` crate on \\\n              crates.io should be used instead for the correct \\\n              definitions\"\n)]\n#![allow(deprecated)]\n#![allow(missing_debug_implementations)]\n\nuse crate::os::raw::{c_char, c_int, c_long, c_ulong, c_void};\n\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type dev_t = c_long;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type gid_t = c_int;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type mode_t = c_int;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type uid_t = c_int;\n\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = *mut c_void;\n\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blkcnt_t = c_ulong;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blksize_t = c_ulong;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type ino_t = c_ulong;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type nlink_t = c_ulong;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type off_t = c_long;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type time_t = c_long;\n\n#[repr(C)]\n#[derive(Clone)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub struct stat {\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_dev: dev_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ino: ino_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_nlink: nlink_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mode: mode_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_uid: uid_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gid: gid_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_rdev: dev_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_size: off_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blksize: blksize_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blocks: blkcnt_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub _pad: [c_char; 24],\n}\n}\n}\n#[cfg(target_os = \"solaris\")]\npub mod solaris {\n//! Solaris-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n#[allow(deprecated)]\nuse crate::os::solaris::raw;\n\n/// OS-specific extensions to [`fs::Metadata`].\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    /// Gain a reference to the underlying `stat` structure which contains\n    /// the raw information returned by the OS.\n    ///\n    /// The contents of the returned `stat` are **not** consistent across\n    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n    /// cross-Unix abstractions contained within the raw stat.\n    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n    #[rustc_deprecated(\n        since = \"1.8.0\",\n        reason = \"deprecated in favor of the accessor \\\n                  methods of this trait\"\n    )]\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat;\n\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime_nsec(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    #[allow(deprecated)]\n    fn as_raw_stat(&self) -> &raw::stat {\n}\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_atime_nsec(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_mtime_nsec(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_ctime_nsec(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n}\n}\npub mod raw {\n//! Solaris-specific raw type definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n#![rustc_deprecated(\n    since = \"1.8.0\",\n    reason = \"these type aliases are no longer supported by \\\n              the standard library, the `libc` crate on \\\n              crates.io should be used instead for the correct \\\n              definitions\"\n)]\n#![allow(deprecated)]\n\nuse crate::os::raw::c_long;\nuse crate::os::unix::raw::{gid_t, uid_t};\n\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blkcnt_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type blksize_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type dev_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type fflags_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type ino_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type mode_t = u32;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type nlink_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type off_t = u64;\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub type time_t = i64;\n\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = u32;\n\n#[repr(C)]\n#[derive(Clone)]\n#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\npub struct stat {\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_dev: dev_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ino: ino_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mode: mode_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_nlink: nlink_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_uid: uid_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_gid: gid_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_rdev: dev_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_size: off_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_atime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_mtime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime: time_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_ctime_nsec: c_long,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blksize: blksize_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub st_blocks: blkcnt_t,\n    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n    pub __unused: [u8; 16],\n}\n}\n}\n#[cfg(target_os = \"vxworks\")]\npub mod vxworks {\n//! VxWorks-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\npub mod fs {\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::fs::Metadata;\nuse crate::sys_common::AsInner;\n\n///\n/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\npub trait MetadataExt {\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_dev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ino(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mode(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_nlink(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_uid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_gid(&self) -> u32;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_rdev(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_size(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_atime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_mtime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_ctime(&self) -> i64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blksize(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_blocks(&self) -> u64;\n    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n    fn st_attrib(&self) -> u8;\n}\n\n#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\nimpl MetadataExt for Metadata {\n    fn st_dev(&self) -> u64 {\n}\n    fn st_ino(&self) -> u64 {\n}\n    fn st_mode(&self) -> u32 {\n}\n    fn st_nlink(&self) -> u64 {\n}\n    fn st_uid(&self) -> u32 {\n}\n    fn st_gid(&self) -> u32 {\n}\n    fn st_rdev(&self) -> u64 {\n}\n    fn st_size(&self) -> u64 {\n}\n    fn st_atime(&self) -> i64 {\n}\n    fn st_mtime(&self) -> i64 {\n}\n    fn st_ctime(&self) -> i64 {\n}\n    fn st_blksize(&self) -> u64 {\n}\n    fn st_blocks(&self) -> u64 {\n}\n    fn st_attrib(&self) -> u8 {\n}\n}\n}\npub mod raw {\n//! VxWorks-specific raw type definitions\n#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n\nuse crate::os::raw::c_ulong;\n\n#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\npub type pthread_t = c_ulong;\n}\n}\n#[cfg(target_os = \"wasi\")]\npub mod wasi {\n//! WASI-specific definitions\n\n#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use crate::sys::ext::*;\n}\n\npub mod raw {\n//! Platform-specific types, as defined by C.\n//!\n//! Code that interacts via FFI will almost certainly be using the\n//! base types provided by C, which aren't nearly as nicely defined\n//! as Rust's primitive types. This module provides types which will\n//! match those defined by C, so that code that interacts with C will\n//! refer to the correct types.\n\n#![stable(feature = \"raw_os\", since = \"1.1.0\")]\n\n#[doc(include = \"char.md\")]\n#[cfg(any(\n    all(\n        target_os = \"linux\",\n        any(\n            target_arch = \"aarch64\",\n            target_arch = \"arm\",\n            target_arch = \"hexagon\",\n            target_arch = \"powerpc\",\n            target_arch = \"powerpc64\",\n            target_arch = \"s390x\",\n            target_arch = \"riscv64\"\n        )\n    ),\n    all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n    all(target_os = \"l4re\", target_arch = \"x86_64\"),\n    all(\n        target_os = \"freebsd\",\n        any(\n            target_arch = \"aarch64\",\n            target_arch = \"arm\",\n            target_arch = \"powerpc\",\n            target_arch = \"powerpc64\"\n        )\n    ),\n    all(\n        target_os = \"netbsd\",\n        any(target_arch = \"aarch64\", target_arch = \"arm\", target_arch = \"powerpc\")\n    ),\n    all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n    all(\n        target_os = \"vxworks\",\n        any(\n            target_arch = \"aarch64\",\n            target_arch = \"arm\",\n            target_arch = \"powerpc64\",\n            target_arch = \"powerpc\"\n        )\n    ),\n    all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n))]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_char = u8;\n#[doc(include = \"char.md\")]\n#[cfg(not(any(\n    all(\n        target_os = \"linux\",\n        any(\n            target_arch = \"aarch64\",\n            target_arch = \"arm\",\n            target_arch = \"hexagon\",\n            target_arch = \"powerpc\",\n            target_arch = \"powerpc64\",\n            target_arch = \"s390x\",\n            target_arch = \"riscv64\"\n        )\n    ),\n    all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n    all(target_os = \"l4re\", target_arch = \"x86_64\"),\n    all(\n        target_os = \"freebsd\",\n        any(\n            target_arch = \"aarch64\",\n            target_arch = \"arm\",\n            target_arch = \"powerpc\",\n            target_arch = \"powerpc64\"\n        )\n    ),\n    all(\n        target_os = \"netbsd\",\n        any(target_arch = \"aarch64\", target_arch = \"arm\", target_arch = \"powerpc\")\n    ),\n    all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n    all(\n        target_os = \"vxworks\",\n        any(\n            target_arch = \"aarch64\",\n            target_arch = \"arm\",\n            target_arch = \"powerpc64\",\n            target_arch = \"powerpc\"\n        )\n    ),\n    all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n)))]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_char = i8;\n#[doc(include = \"schar.md\")]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_schar = i8;\n#[doc(include = \"uchar.md\")]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_uchar = u8;\n#[doc(include = \"short.md\")]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_short = i16;\n#[doc(include = \"ushort.md\")]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_ushort = u16;\n#[doc(include = \"int.md\")]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_int = i32;\n#[doc(include = \"uint.md\")]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_uint = u32;\n#[doc(include = \"long.md\")]\n#[cfg(any(target_pointer_width = \"32\", windows))]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_long = i32;\n#[doc(include = \"ulong.md\")]\n#[cfg(any(target_pointer_width = \"32\", windows))]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_ulong = u32;\n#[doc(include = \"long.md\")]\n#[cfg(all(target_pointer_width = \"64\", not(windows)))]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_long = i64;\n#[doc(include = \"ulong.md\")]\n#[cfg(all(target_pointer_width = \"64\", not(windows)))]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_ulong = u64;\n#[doc(include = \"longlong.md\")]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_longlong = i64;\n#[doc(include = \"ulonglong.md\")]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_ulonglong = u64;\n#[doc(include = \"float.md\")]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_float = f32;\n#[doc(include = \"double.md\")]\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\npub type c_double = f64;\n\n#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n#[doc(no_inline)]\npub use core::ffi::c_void;\n\n#[cfg(test)]\n#[allow(unused_imports)]\nmod tests {\n}\n}\n}\npub mod panic {\n//! Panic support in the standard library.\n\n#![stable(feature = \"std_panic\", since = \"1.9.0\")]\n\nuse crate::any::Any;\nuse crate::cell::UnsafeCell;\nuse crate::collections;\nuse crate::fmt;\nuse crate::future::Future;\nuse crate::ops::{Deref, DerefMut};\nuse crate::panicking;\nuse crate::pin::Pin;\nuse crate::ptr::{NonNull, Unique};\nuse crate::rc::Rc;\nuse crate::sync::atomic;\nuse crate::sync::{Arc, Mutex, RwLock};\nuse crate::task::{Context, Poll};\nuse crate::thread::Result;\n\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub use crate::panicking::{set_hook, take_hook};\n\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub use core::panic::{Location, PanicInfo};\n\n/// A marker trait which represents \"panic safe\" types in Rust.\n///\n/// This trait is implemented by default for many types and behaves similarly in\n/// terms of inference of implementation to the [`Send`] and [`Sync`] traits. The\n/// purpose of this trait is to encode what types are safe to cross a [`catch_unwind`]\n/// boundary with no fear of unwind safety.\n///\n/// [`Send`]: ../marker/trait.Send.html\n/// [`Sync`]: ../marker/trait.Sync.html\n/// [`catch_unwind`]: ./fn.catch_unwind.html\n///\n/// ## What is unwind safety?\n///\n/// In Rust a function can \"return\" early if it either panics or calls a\n/// function which transitively panics. This sort of control flow is not always\n/// anticipated, and has the possibility of causing subtle bugs through a\n/// combination of two critical components:\n///\n/// 1. A data structure is in a temporarily invalid state when the thread\n///    panics.\n/// 2. This broken invariant is then later observed.\n///\n/// Typically in Rust, it is difficult to perform step (2) because catching a\n/// panic involves either spawning a thread (which in turns makes it difficult\n/// to later witness broken invariants) or using the `catch_unwind` function in this\n/// module. Additionally, even if an invariant is witnessed, it typically isn't a\n/// problem in Rust because there are no uninitialized values (like in C or C++).\n///\n/// It is possible, however, for **logical** invariants to be broken in Rust,\n/// which can end up causing behavioral bugs. Another key aspect of unwind safety\n/// in Rust is that, in the absence of `unsafe` code, a panic cannot lead to\n/// memory unsafety.\n///\n/// That was a bit of a whirlwind tour of unwind safety, but for more information\n/// about unwind safety and how it applies to Rust, see an [associated RFC][rfc].\n///\n/// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n///\n/// ## What is `UnwindSafe`?\n///\n/// Now that we've got an idea of what unwind safety is in Rust, it's also\n/// important to understand what this trait represents. As mentioned above, one\n/// way to witness broken invariants is through the `catch_unwind` function in this\n/// module as it allows catching a panic and then re-using the environment of\n/// the closure.\n///\n/// Simply put, a type `T` implements `UnwindSafe` if it cannot easily allow\n/// witnessing a broken invariant through the use of `catch_unwind` (catching a\n/// panic). This trait is an auto trait, so it is automatically implemented for\n/// many types, and it is also structurally composed (e.g., a struct is unwind\n/// safe if all of its components are unwind safe).\n///\n/// Note, however, that this is not an unsafe trait, so there is not a succinct\n/// contract that this trait is providing. Instead it is intended as more of a\n/// \"speed bump\" to alert users of `catch_unwind` that broken invariants may be\n/// witnessed and may need to be accounted for.\n///\n/// ## Who implements `UnwindSafe`?\n///\n/// Types such as `&mut T` and `&RefCell<T>` are examples which are **not**\n/// unwind safe. The general idea is that any mutable state which can be shared\n/// across `catch_unwind` is not unwind safe by default. This is because it is very\n/// easy to witness a broken invariant outside of `catch_unwind` as the data is\n/// simply accessed as usual.\n///\n/// Types like `&Mutex<T>`, however, are unwind safe because they implement\n/// poisoning by default. They still allow witnessing a broken invariant, but\n/// they already provide their own \"speed bumps\" to do so.\n///\n/// ## When should `UnwindSafe` be used?\n///\n/// It is not intended that most types or functions need to worry about this trait.\n/// It is only used as a bound on the `catch_unwind` function and as mentioned\n/// above, the lack of `unsafe` means it is mostly an advisory. The\n/// [`AssertUnwindSafe`] wrapper struct can be used to force this trait to be\n/// implemented for any closed over variables passed to `catch_unwind`.\n///\n/// [`AssertUnwindSafe`]: ./struct.AssertUnwindSafe.html\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n#[rustc_on_unimplemented(\n    message = \"the type `{Self}` may not be safely transferred across an unwind boundary\",\n    label = \"`{Self}` may not be safely transferred across an unwind boundary\"\n)]\npub auto trait UnwindSafe {}\n\n/// A marker trait representing types where a shared reference is considered\n/// unwind safe.\n///\n/// This trait is namely not implemented by [`UnsafeCell`], the root of all\n/// interior mutability.\n///\n/// This is a \"helper marker trait\" used to provide impl blocks for the\n/// [`UnwindSafe`] trait, for more information see that documentation.\n///\n/// [`UnsafeCell`]: ../cell/struct.UnsafeCell.html\n/// [`UnwindSafe`]: ./trait.UnwindSafe.html\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n#[rustc_on_unimplemented(\n    message = \"the type `{Self}` may contain interior mutability and a reference may not be safely \\\n               transferrable across a catch_unwind boundary\",\n    label = \"`{Self}` may contain interior mutability and a reference may not be safely \\\n             transferrable across a catch_unwind boundary\"\n)]\npub auto trait RefUnwindSafe {}\n\n/// A simple wrapper around a type to assert that it is unwind safe.\n///\n/// When using [`catch_unwind`] it may be the case that some of the closed over\n/// variables are not unwind safe. For example if `&mut T` is captured the\n/// compiler will generate a warning indicating that it is not unwind safe. It\n/// may not be the case, however, that this is actually a problem due to the\n/// specific usage of [`catch_unwind`] if unwind safety is specifically taken into\n/// account. This wrapper struct is useful for a quick and lightweight\n/// annotation that a variable is indeed unwind safe.\n///\n/// [`catch_unwind`]: ./fn.catch_unwind.html\n/// # Examples\n///\n/// One way to use `AssertUnwindSafe` is to assert that the entire closure\n/// itself is unwind safe, bypassing all checks for all variables:\n///\n/// ```\n/// use std::panic::{self, AssertUnwindSafe};\n///\n/// let mut variable = 4;\n///\n/// // This code will not compile because the closure captures `&mut variable`\n/// // which is not considered unwind safe by default.\n///\n/// // panic::catch_unwind(|| {\n/// //     variable += 3;\n/// // });\n///\n/// // This, however, will compile due to the `AssertUnwindSafe` wrapper\n/// let result = panic::catch_unwind(AssertUnwindSafe(|| {\n///     variable += 3;\n/// }));\n/// // ...\n/// ```\n///\n/// Wrapping the entire closure amounts to a blanket assertion that all captured\n/// variables are unwind safe. This has the downside that if new captures are\n/// added in the future, they will also be considered unwind safe. Therefore,\n/// you may prefer to just wrap individual captures, as shown below. This is\n/// more annotation, but it ensures that if a new capture is added which is not\n/// unwind safe, you will get a compilation error at that time, which will\n/// allow you to consider whether that new capture in fact represent a bug or\n/// not.\n///\n/// ```\n/// use std::panic::{self, AssertUnwindSafe};\n///\n/// let mut variable = 4;\n/// let other_capture = 3;\n///\n/// let result = {\n///     let mut wrapper = AssertUnwindSafe(&mut variable);\n///     panic::catch_unwind(move || {\n///         **wrapper += other_capture;\n///     })\n/// };\n/// // ...\n/// ```\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\npub struct AssertUnwindSafe<T>(#[stable(feature = \"catch_unwind\", since = \"1.9.0\")] pub T);\n\n// Implementations of the `UnwindSafe` trait:\n//\n// * By default everything is unwind safe\n// * pointers T contains mutability of some form are not unwind safe\n// * Unique, an owning pointer, lifts an implementation\n// * Types like Mutex/RwLock which are explicitly poisoned are unwind safe\n// * Our custom AssertUnwindSafe wrapper is indeed unwind safe\n\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: ?Sized> !UnwindSafe for &mut T {}\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: RefUnwindSafe + ?Sized> UnwindSafe for &T {}\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: RefUnwindSafe + ?Sized> UnwindSafe for *const T {}\n#[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\nimpl<T: RefUnwindSafe + ?Sized> UnwindSafe for *mut T {}\n#[unstable(feature = \"ptr_internals\", issue = \"none\")]\nimpl<T: UnwindSafe + ?Sized> UnwindSafe for Unique<T> {}}\npub mod path {\n// ignore-tidy-filelength\n\n//! Cross-platform path manipulation.\n//!\n//! This module provides two types, [`PathBuf`] and [`Path`] (akin to [`String`]\n//! and [`str`]), for working with paths abstractly. These types are thin wrappers\n//! around [`OsString`] and [`OsStr`] respectively, meaning that they work directly\n//! on strings according to the local platform's path syntax.\n//!\n//! Paths can be parsed into [`Component`]s by iterating over the structure\n//! returned by the [`components`] method on [`Path`]. [`Component`]s roughly\n//! correspond to the substrings between path separators (`/` or `\\`). You can\n//! reconstruct an equivalent path from components with the [`push`] method on\n//! [`PathBuf`]; note that the paths may differ syntactically by the\n//! normalization described in the documentation for the [`components`] method.\n//!\n//! ## Simple usage\n//!\n//! Path manipulation includes both parsing components from slices and building\n//! new owned paths.\n//!\n//! To parse a path, you can create a [`Path`] slice from a [`str`]\n//! slice and start asking questions:\n//!\n//! ```\n//! use std::path::Path;\n//! use std::ffi::OsStr;\n//!\n//! let path = Path::new(\"/tmp/foo/bar.txt\");\n//!\n//! let parent = path.parent();\n//! assert_eq!(parent, Some(Path::new(\"/tmp/foo\")));\n//!\n//! let file_stem = path.file_stem();\n//! assert_eq!(file_stem, Some(OsStr::new(\"bar\")));\n//!\n//! let extension = path.extension();\n//! assert_eq!(extension, Some(OsStr::new(\"txt\")));\n//! ```\n//!\n//! To build or modify paths, use [`PathBuf`]:\n//!\n//! ```\n//! use std::path::PathBuf;\n//!\n//! // This way works...\n//! let mut path = PathBuf::from(\"c:\\\\\");\n//!\n//! path.push(\"windows\");\n//! path.push(\"system32\");\n//!\n//! path.set_extension(\"dll\");\n//!\n//! // ... but push is best used if you don't know everything up\n//! // front. If you do, this way is better:\n//! let path: PathBuf = [\"c:\\\\\", \"windows\", \"system32.dll\"].iter().collect();\n//! ```\n//!\n//! [`Component`]: ../../std/path/enum.Component.html\n//! [`components`]: ../../std/path/struct.Path.html#method.components\n//! [`PathBuf`]: ../../std/path/struct.PathBuf.html\n//! [`Path`]: ../../std/path/struct.Path.html\n//! [`push`]: ../../std/path/struct.PathBuf.html#method.push\n//! [`String`]: ../../std/string/struct.String.html\n//!\n//! [`str`]: ../../std/primitive.str.html\n//! [`OsString`]: ../../std/ffi/struct.OsString.html\n//! [`OsStr`]: ../../std/ffi/struct.OsStr.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::borrow::{Borrow, Cow};\nuse crate::cmp;\nuse crate::error::Error;\nuse crate::fmt;\nuse crate::fs;\nuse crate::hash::{Hash, Hasher};\nuse crate::io;\nuse crate::iter::{self, FusedIterator};\nuse crate::ops::{self, Deref};\nuse crate::rc::Rc;\nuse crate::str::FromStr;\nuse crate::sync::Arc;\n\nuse crate::ffi::{OsStr, OsString};\n\nuse crate::sys::path::{is_sep_byte, is_verbatim_sep, parse_prefix, MAIN_SEP_STR};\n\n////////////////////////////////////////////////////////////////////////////////\n// GENERAL NOTES\n////////////////////////////////////////////////////////////////////////////////\n//\n// Parsing in this module is done by directly transmuting OsStr to [u8] slices,\n// taking advantage of the fact that OsStr always encodes ASCII characters\n// as-is.  Eventually, this transmutation should be replaced by direct uses of\n// OsStr APIs for parsing, but it will take a while for those to become\n// available.\n\n////////////////////////////////////////////////////////////////////////////////\n// Windows Prefixes\n////////////////////////////////////////////////////////////////////////////////\n\n/// Windows path prefixes, e.g., `C:` or `\\\\server\\share`.\n///\n/// Windows uses a variety of path prefix styles, including references to drive\n/// volumes (like `C:`), network shared folders (like `\\\\server\\share`), and\n/// others. In addition, some path prefixes are \"verbatim\" (i.e., prefixed with\n/// `\\\\?\\`), in which case `/` is *not* treated as a separator and essentially\n/// no normalization is performed.\n///\n/// # Examples\n///\n/// ```\n/// use std::path::{Component, Path, Prefix};\n/// use std::path::Prefix::*;\n/// use std::ffi::OsStr;\n///\n/// fn get_path_prefix(s: &str) -> Prefix {\n///     let path = Path::new(s);\n///     match path.components().next().unwrap() {\n///         Component::Prefix(prefix_component) => prefix_component.kind(),\n///         _ => panic!(),\n///     }\n/// }\n///\n/// # if cfg!(windows) {\n/// assert_eq!(Verbatim(OsStr::new(\"pictures\")),\n///            get_path_prefix(r\"\\\\?\\pictures\\kittens\"));\n/// assert_eq!(VerbatimUNC(OsStr::new(\"server\"), OsStr::new(\"share\")),\n///            get_path_prefix(r\"\\\\?\\UNC\\server\\share\"));\n/// assert_eq!(VerbatimDisk(b'C'), get_path_prefix(r\"\\\\?\\c:\\\"));\n/// assert_eq!(DeviceNS(OsStr::new(\"BrainInterface\")),\n///            get_path_prefix(r\"\\\\.\\BrainInterface\"));\n/// assert_eq!(UNC(OsStr::new(\"server\"), OsStr::new(\"share\")),\n///            get_path_prefix(r\"\\\\server\\share\"));\n/// assert_eq!(Disk(b'C'), get_path_prefix(r\"C:\\Users\\Rust\\Pictures\\Ferris\"));\n/// # }\n/// ```\n#[derive(Copy, Clone, Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Prefix<'a> {\n    /// Verbatim prefix, e.g., `\\\\?\\cat_pics`.\n    ///\n    /// Verbatim prefixes consist of `\\\\?\\` immediately followed by the given\n    /// component.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Verbatim(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr),\n\n    /// Verbatim prefix using Windows' _**U**niform **N**aming **C**onvention_,\n    /// e.g., `\\\\?\\UNC\\server\\share`.\n    ///\n    /// Verbatim UNC prefixes consist of `\\\\?\\UNC\\` immediately followed by the\n    /// server's hostname and a share name.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    VerbatimUNC(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n        #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n    ),\n\n    /// Verbatim disk prefix, e.g., `\\\\?\\C:\\`.\n    ///\n    /// Verbatim disk prefixes consist of `\\\\?\\` immediately followed by the\n    /// drive letter and `:\\`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    VerbatimDisk(#[stable(feature = \"rust1\", since = \"1.0.0\")] u8),\n\n    /// Device namespace prefix, e.g., `\\\\.\\COM42`.\n    ///\n    /// Device namespace prefixes consist of `\\\\.\\` immediately followed by the\n    /// device name.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    DeviceNS(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr),\n\n    /// Prefix using Windows' _**U**niform **N**aming **C**onvention_, e.g.\n    /// `\\\\server\\share`.\n    ///\n    /// UNC prefixes consist of the server's hostname and a share name.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    UNC(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n        #[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr,\n    ),\n\n    /// Prefix `C:` for the given disk drive.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Disk(#[stable(feature = \"rust1\", since = \"1.0.0\")] u8),\n}\n\nimpl<'a> Prefix<'a> {\n    #[inline]\n    fn len(&self) -> usize {\n}\n\n    /// Determines if the prefix is verbatim, i.e., begins with `\\\\?\\`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Prefix::*;\n    /// use std::ffi::OsStr;\n    ///\n    /// assert!(Verbatim(OsStr::new(\"pictures\")).is_verbatim());\n    /// assert!(VerbatimUNC(OsStr::new(\"server\"), OsStr::new(\"share\")).is_verbatim());\n    /// assert!(VerbatimDisk(b'C').is_verbatim());\n    /// assert!(!DeviceNS(OsStr::new(\"BrainInterface\")).is_verbatim());\n    /// assert!(!UNC(OsStr::new(\"server\"), OsStr::new(\"share\")).is_verbatim());\n    /// assert!(!Disk(b'C').is_verbatim());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_verbatim(&self) -> bool {\n}\n\n    #[inline]\n    fn is_drive(&self) -> bool {\n}\n\n    #[inline]\n    fn has_implicit_root(&self) -> bool {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Exposed parsing helpers\n////////////////////////////////////////////////////////////////////////////////\n\n/// Determines whether the character is one of the permitted path\n/// separators for the current platform.\n///\n/// # Examples\n///\n/// ```\n/// use std::path;\n///\n/// assert!(path::is_separator('/')); // '/' works for both Unix and Windows\n/// assert!(!path::is_separator('❤'));\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn is_separator(c: char) -> bool {\n}\n\n/// The primary separator of path components for the current platform.\n///\n/// For example, `/` on Unix and `\\` on Windows.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MAIN_SEPARATOR: char = crate::sys::path::MAIN_SEP;\n\n////////////////////////////////////////////////////////////////////////////////\n// Misc helpers\n////////////////////////////////////////////////////////////////////////////////\n\n// Iterate through `iter` while it matches `prefix`; return `None` if `prefix`\n// is not a prefix of `iter`, otherwise return `Some(iter_after_prefix)` giving\n// `iter` after having exhausted `prefix`.\nfn iter_after<'a, 'b, I, J>(mut iter: I, mut prefix: J) -> Option<I>\nwhere\n    I: Iterator<Item = Component<'a>> + Clone,\n    J: Iterator<Item = Component<'b>>,\n{\n}\n\n// See note at the top of this module to understand why these are used:\n//\n// These casts are safe as OsStr is internally a wrapper around [u8] on all\n// platforms.\n//\n// Note that currently this relies on the special knowledge that libstd has;\n// these types are single-element structs but are not marked repr(transparent)\n// or repr(C) which would make these casts allowable outside std.\nfn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n}\nunsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n}\n\n// Detect scheme on Redox\nfn has_redox_scheme(s: &[u8]) -> bool {\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Cross-platform, iterator-independent parsing\n////////////////////////////////////////////////////////////////////////////////\n\n/// Says whether the first byte after the prefix is a separator.\nfn has_physical_root(s: &[u8], prefix: Option<Prefix<'_>>) -> bool {\n}\n\n// basic workhorse for splitting stem and extension\nfn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// The core iterators\n////////////////////////////////////////////////////////////////////////////////\n\n/// Component parsing works by a double-ended state machine; the cursors at the\n/// front and back of the path each keep track of what parts of the path have\n/// been consumed so far.\n///\n/// Going front to back, a path is made up of a prefix, a starting\n/// directory component, and a body (of normal components)\n#[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]\nenum State {\n    Prefix = 0,   // c:\n    StartDir = 1, // / or . or nothing\n    Body = 2,     // foo/bar/baz\n    Done = 3,\n}\n\n/// A structure wrapping a Windows path prefix as well as its unparsed string\n/// representation.\n///\n/// In addition to the parsed [`Prefix`] information returned by [`kind`],\n/// `PrefixComponent` also holds the raw and unparsed [`OsStr`] slice,\n/// returned by [`as_os_str`].\n///\n/// Instances of this `struct` can be obtained by matching against the\n/// [`Prefix` variant] on [`Component`].\n///\n/// Does not occur on Unix.\n///\n/// # Examples\n///\n/// ```\n/// # if cfg!(windows) {\n/// use std::path::{Component, Path, Prefix};\n/// use std::ffi::OsStr;\n///\n/// let path = Path::new(r\"c:\\you\\later\\\");\n/// match path.components().next().unwrap() {\n///     Component::Prefix(prefix_component) => {\n///         assert_eq!(Prefix::Disk(b'C'), prefix_component.kind());\n///         assert_eq!(OsStr::new(\"c:\"), prefix_component.as_os_str());\n///     }\n///     _ => unreachable!(),\n/// }\n/// # }\n/// ```\n///\n/// [`as_os_str`]: #method.as_os_str\n/// [`Component`]: enum.Component.html\n/// [`kind`]: #method.kind\n/// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n/// [`Prefix` variant]: enum.Component.html#variant.Prefix\n/// [`Prefix`]: enum.Prefix.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone, Eq, Debug)]\npub struct PrefixComponent<'a> {\n    /// The prefix as an unparsed `OsStr` slice.\n    raw: &'a OsStr,\n\n    /// The parsed prefix data.\n    parsed: Prefix<'a>,\n}\n\nimpl<'a> PrefixComponent<'a> {\n    /// Returns the parsed prefix data.\n    ///\n    /// See [`Prefix`]'s documentation for more information on the different\n    /// kinds of prefixes.\n    ///\n    /// [`Prefix`]: enum.Prefix.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn kind(&self) -> Prefix<'a> {\n}\n\n    /// Returns the raw [`OsStr`] slice for this prefix.\n    ///\n    /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_os_str(&self) -> &'a OsStr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> cmp::PartialEq for PrefixComponent<'a> {\n    fn eq(&self, other: &PrefixComponent<'a>) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> cmp::PartialOrd for PrefixComponent<'a> {\n    fn partial_cmp(&self, other: &PrefixComponent<'a>) -> Option<cmp::Ordering> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Ord for PrefixComponent<'_> {\n    fn cmp(&self, other: &Self) -> cmp::Ordering {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Hash for PrefixComponent<'_> {\n    fn hash<H: Hasher>(&self, h: &mut H) {\n}\n}\n\n/// A single component of a path.\n///\n/// A `Component` roughly corresponds to a substring between path separators\n/// (`/` or `\\`).\n///\n/// This `enum` is created by iterating over [`Components`], which in turn is\n/// created by the [`components`][`Path::components`] method on [`Path`].\n///\n/// # Examples\n///\n/// ```rust\n/// use std::path::{Component, Path};\n///\n/// let path = Path::new(\"/tmp/foo/bar.txt\");\n/// let components = path.components().collect::<Vec<_>>();\n/// assert_eq!(&components, &[\n///     Component::RootDir,\n///     Component::Normal(\"tmp\".as_ref()),\n///     Component::Normal(\"foo\".as_ref()),\n///     Component::Normal(\"bar.txt\".as_ref()),\n/// ]);\n/// ```\n///\n/// [`Components`]: struct.Components.html\n/// [`Path`]: struct.Path.html\n/// [`Path::components`]: struct.Path.html#method.components\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Component<'a> {\n    /// A Windows path prefix, e.g., `C:` or `\\\\server\\share`.\n    ///\n    /// There is a large variety of prefix types, see [`Prefix`]'s documentation\n    /// for more.\n    ///\n    /// Does not occur on Unix.\n    ///\n    /// [`Prefix`]: enum.Prefix.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Prefix(#[stable(feature = \"rust1\", since = \"1.0.0\")] PrefixComponent<'a>),\n\n    /// The root directory component, appears after any prefix and before anything else.\n    ///\n    /// It represents a separator that designates that a path starts from root.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    RootDir,\n\n    /// A reference to the current directory, i.e., `.`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    CurDir,\n\n    /// A reference to the parent directory, i.e., `..`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    ParentDir,\n\n    /// A normal component, e.g., `a` and `b` in `a/b`.\n    ///\n    /// This variant is the most common one, it represents references to files\n    /// or directories.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Normal(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a OsStr),\n}\n\nimpl<'a> Component<'a> {\n    /// Extracts the underlying [`OsStr`] slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"./tmp/foo/bar.txt\");\n    /// let components: Vec<_> = path.components().map(|comp| comp.as_os_str()).collect();\n    /// assert_eq!(&components, &[\".\", \"tmp\", \"foo\", \"bar.txt\"]);\n    /// ```\n    ///\n    /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_os_str(self) -> &'a OsStr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for Component<'_> {\n    fn as_ref(&self) -> &OsStr {\n}\n}\n\n#[stable(feature = \"path_component_asref\", since = \"1.25.0\")]\nimpl AsRef<Path> for Component<'_> {\n    fn as_ref(&self) -> &Path {\n}\n}\n\n/// An iterator over the [`Component`]s of a [`Path`].\n///\n/// This `struct` is created by the [`components`] method on [`Path`].\n/// See its documentation for more.\n///\n/// # Examples\n///\n/// ```\n/// use std::path::Path;\n///\n/// let path = Path::new(\"/tmp/foo/bar.txt\");\n///\n/// for component in path.components() {\n///     println!(\"{:?}\", component);\n/// }\n/// ```\n///\n/// [`Component`]: enum.Component.html\n/// [`components`]: struct.Path.html#method.components\n/// [`Path`]: struct.Path.html\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Components<'a> {\n    // The path left to parse components from\n    path: &'a [u8],\n\n    // The prefix as it was originally parsed, if any\n    prefix: Option<Prefix<'a>>,\n\n    // true if path *physically* has a root separator; for most Windows\n    // prefixes, it may have a \"logical\" rootseparator for the purposes of\n    // normalization, e.g.,  \\\\server\\share == \\\\server\\share\\.\n    has_physical_root: bool,\n\n    // The iterator is double-ended, and these two states keep track of what has\n    // been produced from either end\n    front: State,\n    back: State,\n}\n\n/// An iterator over the [`Component`]s of a [`Path`], as [`OsStr`] slices.\n///\n/// This `struct` is created by the [`iter`] method on [`Path`].\n/// See its documentation for more.\n///\n/// [`Component`]: enum.Component.html\n/// [`iter`]: struct.Path.html#method.iter\n/// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n/// [`Path`]: struct.Path.html\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a> {\n    inner: Components<'a>,\n}\n\n#[stable(feature = \"path_components_debug\", since = \"1.13.0\")]\nimpl fmt::Debug for Components<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<'a> Components<'a> {\n    // how long is the prefix, if any?\n    #[inline]\n    fn prefix_len(&self) -> usize {\n}\n\n    #[inline]\n    fn prefix_verbatim(&self) -> bool {\n}\n\n    /// how much of the prefix is left from the point of view of iteration?\n    #[inline]\n    fn prefix_remaining(&self) -> usize {\n}\n\n    // Given the iteration so far, how much of the pre-State::Body path is left?\n    #[inline]\n    fn len_before_body(&self) -> usize {\n}\n\n    // is the iteration complete?\n    #[inline]\n    fn finished(&self) -> bool {\n}\n\n    #[inline]\n    fn is_sep_byte(&self, b: u8) -> bool {\n}\n\n    /// Extracts a slice corresponding to the portion of the path remaining for iteration.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let mut components = Path::new(\"/tmp/foo/bar.txt\").components();\n    /// components.next();\n    /// components.next();\n    ///\n    /// assert_eq!(Path::new(\"foo/bar.txt\"), components.as_path());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_path(&self) -> &'a Path {\n}\n\n    /// Is the *original* path rooted?\n    fn has_root(&self) -> bool {\n}\n\n    /// Should the normalized path include a leading . ?\n    fn include_cur_dir(&self) -> bool {\n}\n\n    // parse a given byte sequence into the corresponding path component\n    fn parse_single_component<'b>(&self, comp: &'b [u8]) -> Option<Component<'b>> {\n}\n\n    // parse a component from the left, saying how many bytes to consume to\n    // remove the component\n    fn parse_next_component(&self) -> (usize, Option<Component<'a>>) {\n}\n\n    // parse a component from the right, saying how many bytes to consume to\n    // remove the component\n    fn parse_next_component_back(&self) -> (usize, Option<Component<'a>>) {\n}\n\n    // trim away repeated separators (i.e., empty components) on the left\n    fn trim_left(&mut self) {\n}\n\n    // trim away repeated separators (i.e., empty components) on the right\n    fn trim_right(&mut self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for Components<'_> {\n    fn as_ref(&self) -> &Path {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for Components<'_> {\n    fn as_ref(&self) -> &OsStr {\n}\n}\n\n#[stable(feature = \"path_iter_debug\", since = \"1.13.0\")]\nimpl fmt::Debug for Iter<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<'a> Iter<'a> {\n    /// Extracts a slice corresponding to the portion of the path remaining for iteration.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let mut iter = Path::new(\"/tmp/foo/bar.txt\").iter();\n    /// iter.next();\n    /// iter.next();\n    ///\n    /// assert_eq!(Path::new(\"foo/bar.txt\"), iter.as_path());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_path(&self) -> &'a Path {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for Iter<'_> {\n    fn as_ref(&self) -> &Path {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for Iter<'_> {\n    fn as_ref(&self) -> &OsStr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for Iter<'a> {\n    type Item = &'a OsStr;\n\n    fn next(&mut self) -> Option<&'a OsStr> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> DoubleEndedIterator for Iter<'a> {\n    fn next_back(&mut self) -> Option<&'a OsStr> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for Iter<'_> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for Components<'a> {\n    type Item = Component<'a>;\n\n    fn next(&mut self) -> Option<Component<'a>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> DoubleEndedIterator for Components<'a> {\n    fn next_back(&mut self) -> Option<Component<'a>> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for Components<'_> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> cmp::PartialEq for Components<'a> {\n    fn eq(&self, other: &Components<'a>) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Eq for Components<'_> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> cmp::PartialOrd for Components<'a> {\n    fn partial_cmp(&self, other: &Components<'a>) -> Option<cmp::Ordering> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Ord for Components<'_> {\n    fn cmp(&self, other: &Self) -> cmp::Ordering {\n}\n}\n\n/// An iterator over [`Path`] and its ancestors.\n///\n/// This `struct` is created by the [`ancestors`] method on [`Path`].\n/// See its documentation for more.\n///\n/// # Examples\n///\n/// ```\n/// use std::path::Path;\n///\n/// let path = Path::new(\"/foo/bar\");\n///\n/// for ancestor in path.ancestors() {\n///     println!(\"{}\", ancestor.display());\n/// }\n/// ```\n///\n/// [`ancestors`]: struct.Path.html#method.ancestors\n/// [`Path`]: struct.Path.html\n#[derive(Copy, Clone, Debug)]\n#[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\npub struct Ancestors<'a> {\n    next: Option<&'a Path>,\n}\n\n#[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\nimpl<'a> Iterator for Ancestors<'a> {\n    type Item = &'a Path;\n\n    fn next(&mut self) -> Option<Self::Item> {\n}\n}\n\n#[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\nimpl FusedIterator for Ancestors<'_> {}\n\n////////////////////////////////////////////////////////////////////////////////\n// Basic types and traits\n////////////////////////////////////////////////////////////////////////////////\n\n/// An owned, mutable path (akin to [`String`]).\n///\n/// This type provides methods like [`push`] and [`set_extension`] that mutate\n/// the path in place. It also implements [`Deref`] to [`Path`], meaning that\n/// all methods on [`Path`] slices are available on `PathBuf` values as well.\n///\n/// [`String`]: ../string/struct.String.html\n/// [`Path`]: struct.Path.html\n/// [`push`]: struct.PathBuf.html#method.push\n/// [`set_extension`]: struct.PathBuf.html#method.set_extension\n/// [`Deref`]: ../ops/trait.Deref.html\n///\n/// More details about the overall approach can be found in\n/// the [module documentation](index.html).\n///\n/// # Examples\n///\n/// You can use [`push`] to build up a `PathBuf` from\n/// components:\n///\n/// ```\n/// use std::path::PathBuf;\n///\n/// let mut path = PathBuf::new();\n///\n/// path.push(r\"C:\\\");\n/// path.push(\"windows\");\n/// path.push(\"system32\");\n///\n/// path.set_extension(\"dll\");\n/// ```\n///\n/// However, [`push`] is best used for dynamic situations. This is a better way\n/// to do this when you know all of the components ahead of time:\n///\n/// ```\n/// use std::path::PathBuf;\n///\n/// let path: PathBuf = [r\"C:\\\", \"windows\", \"system32.dll\"].iter().collect();\n/// ```\n///\n/// We can still do better than this! Since these are all strings, we can use\n/// `From::from`:\n///\n/// ```\n/// use std::path::PathBuf;\n///\n/// let path = PathBuf::from(r\"C:\\windows\\system32.dll\");\n/// ```\n///\n/// Which method works best depends on what kind of situation you're in.\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n// FIXME:\n// `PathBuf::as_mut_vec` current implementation relies\n// on `PathBuf` being layout-compatible with `Vec<u8>`.\n// When attribute privacy is implemented, `PathBuf` should be annotated as `#[repr(transparent)]`.\n// Anyway, `PathBuf` representation and layout are considered implementation detail, are\n// not documented and must not be relied upon.\npub struct PathBuf {\n    inner: OsString,\n}\n\nimpl PathBuf {\n    fn as_mut_vec(&mut self) -> &mut Vec<u8> {\n}\n\n    /// Allocates an empty `PathBuf`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::PathBuf;\n    ///\n    /// let path = PathBuf::new();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> PathBuf {\n}\n\n    /// Creates a new `PathBuf` with a given capacity used to create the\n    /// internal [`OsString`]. See [`with_capacity`] defined on [`OsString`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(path_buf_capacity)]\n    /// use std::path::PathBuf;\n    ///\n    /// let mut path = PathBuf::with_capacity(10);\n    /// let capacity = path.capacity();\n    ///\n    /// // This push is done without reallocating\n    /// path.push(r\"C:\\\");\n    ///\n    /// assert_eq!(capacity, path.capacity());\n    /// ```\n    ///\n    /// [`with_capacity`]: ../ffi/struct.OsString.html#method.with_capacity\n    /// [`OsString`]: ../ffi/struct.OsString.html\n    #[unstable(feature = \"path_buf_capacity\", issue = \"58234\")]\n    pub fn with_capacity(capacity: usize) -> PathBuf {\n}\n\n    /// Coerces to a [`Path`] slice.\n    ///\n    /// [`Path`]: struct.Path.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let p = PathBuf::from(\"/test\");\n    /// assert_eq!(Path::new(\"/test\"), p.as_path());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_path(&self) -> &Path {\n}\n\n    /// Extends `self` with `path`.\n    ///\n    /// If `path` is absolute, it replaces the current path.\n    ///\n    /// On Windows:\n    ///\n    /// * if `path` has a root but no prefix (e.g., `\\windows`), it\n    ///   replaces everything except for the prefix (if any) of `self`.\n    /// * if `path` has a prefix but no root, it replaces `self`.\n    ///\n    /// # Examples\n    ///\n    /// Pushing a relative path extends the existing path:\n    ///\n    /// ```\n    /// use std::path::PathBuf;\n    ///\n    /// let mut path = PathBuf::from(\"/tmp\");\n    /// path.push(\"file.bk\");\n    /// assert_eq!(path, PathBuf::from(\"/tmp/file.bk\"));\n    /// ```\n    ///\n    /// Pushing an absolute path replaces the existing path:\n    ///\n    /// ```\n    /// use std::path::PathBuf;\n    ///\n    /// let mut path = PathBuf::from(\"/tmp\");\n    /// path.push(\"/etc\");\n    /// assert_eq!(path, PathBuf::from(\"/etc\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push<P: AsRef<Path>>(&mut self, path: P) {\n}\n\n    fn _push(&mut self, path: &Path) {\n}\n\n    /// Truncates `self` to [`self.parent`].\n    ///\n    /// Returns `false` and does nothing if [`self.parent`] is [`None`].\n    /// Otherwise, returns `true`.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`self.parent`]: struct.PathBuf.html#method.parent\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let mut p = PathBuf::from(\"/test/test.rs\");\n    ///\n    /// p.pop();\n    /// assert_eq!(Path::new(\"/test\"), p);\n    /// p.pop();\n    /// assert_eq!(Path::new(\"/\"), p);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop(&mut self) -> bool {\n}\n\n    /// Updates [`self.file_name`] to `file_name`.\n    ///\n    /// If [`self.file_name`] was [`None`], this is equivalent to pushing\n    /// `file_name`.\n    ///\n    /// Otherwise it is equivalent to calling [`pop`] and then pushing\n    /// `file_name`. The new path will be a sibling of the original path.\n    /// (That is, it will have the same parent.)\n    ///\n    /// [`self.file_name`]: struct.PathBuf.html#method.file_name\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`pop`]: struct.PathBuf.html#method.pop\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::PathBuf;\n    ///\n    /// let mut buf = PathBuf::from(\"/\");\n    /// assert!(buf.file_name() == None);\n    /// buf.set_file_name(\"bar\");\n    /// assert!(buf == PathBuf::from(\"/bar\"));\n    /// assert!(buf.file_name().is_some());\n    /// buf.set_file_name(\"baz.txt\");\n    /// assert!(buf == PathBuf::from(\"/baz.txt\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set_file_name<S: AsRef<OsStr>>(&mut self, file_name: S) {\n}\n\n    fn _set_file_name(&mut self, file_name: &OsStr) {\n}\n\n    /// Updates [`self.extension`] to `extension`.\n    ///\n    /// Returns `false` and does nothing if [`self.file_name`] is [`None`],\n    /// returns `true` and updates the extension otherwise.\n    ///\n    /// If [`self.extension`] is [`None`], the extension is added; otherwise\n    /// it is replaced.\n    ///\n    /// [`self.file_name`]: struct.PathBuf.html#method.file_name\n    /// [`self.extension`]: struct.PathBuf.html#method.extension\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let mut p = PathBuf::from(\"/feel/the\");\n    ///\n    /// p.set_extension(\"force\");\n    /// assert_eq!(Path::new(\"/feel/the.force\"), p.as_path());\n    ///\n    /// p.set_extension(\"dark_side\");\n    /// assert_eq!(Path::new(\"/feel/the.dark_side\"), p.as_path());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set_extension<S: AsRef<OsStr>>(&mut self, extension: S) -> bool {\n}\n\n    fn _set_extension(&mut self, extension: &OsStr) -> bool {\n}\n\n    /// Consumes the `PathBuf`, yielding its internal [`OsString`] storage.\n    ///\n    /// [`OsString`]: ../ffi/struct.OsString.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::PathBuf;\n    ///\n    /// let p = PathBuf::from(\"/the/head\");\n    /// let os_str = p.into_os_string();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_os_string(self) -> OsString {\n}\n\n    /// Converts this `PathBuf` into a [boxed][`Box`] [`Path`].\n    ///\n    /// [`Box`]: ../../std/boxed/struct.Box.html\n    /// [`Path`]: struct.Path.html\n    #[stable(feature = \"into_boxed_path\", since = \"1.20.0\")]\n    pub fn into_boxed_path(self) -> Box<Path> {\n}\n\n    /// Invokes [`capacity`] on the underlying instance of [`OsString`].\n    ///\n    /// [`capacity`]: ../ffi/struct.OsString.html#method.capacity\n    /// [`OsString`]: ../ffi/struct.OsString.html\n    #[unstable(feature = \"path_buf_capacity\", issue = \"58234\")]\n    pub fn capacity(&self) -> usize {\n}\n\n    /// Invokes [`clear`] on the underlying instance of [`OsString`].\n    ///\n    /// [`clear`]: ../ffi/struct.OsString.html#method.clear\n    /// [`OsString`]: ../ffi/struct.OsString.html\n    #[unstable(feature = \"path_buf_capacity\", issue = \"58234\")]\n    pub fn clear(&mut self) {\n}\n\n    /// Invokes [`reserve`] on the underlying instance of [`OsString`].\n    ///\n    /// [`reserve`]: ../ffi/struct.OsString.html#method.reserve\n    /// [`OsString`]: ../ffi/struct.OsString.html\n    #[unstable(feature = \"path_buf_capacity\", issue = \"58234\")]\n    pub fn reserve(&mut self, additional: usize) {\n}\n\n    /// Invokes [`reserve_exact`] on the underlying instance of [`OsString`].\n    ///\n    /// [`reserve_exact`]: ../ffi/struct.OsString.html#method.reserve_exact\n    /// [`OsString`]: ../ffi/struct.OsString.html\n    #[unstable(feature = \"path_buf_capacity\", issue = \"58234\")]\n    pub fn reserve_exact(&mut self, additional: usize) {\n}\n\n    /// Invokes [`shrink_to_fit`] on the underlying instance of [`OsString`].\n    ///\n    /// [`shrink_to_fit`]: ../ffi/struct.OsString.html#method.shrink_to_fit\n    /// [`OsString`]: ../ffi/struct.OsString.html\n    #[unstable(feature = \"path_buf_capacity\", issue = \"58234\")]\n    pub fn shrink_to_fit(&mut self) {\n}\n\n    /// Invokes [`shrink_to`] on the underlying instance of [`OsString`].\n    ///\n    /// [`shrink_to`]: ../ffi/struct.OsString.html#method.shrink_to\n    /// [`OsString`]: ../ffi/struct.OsString.html\n    #[unstable(feature = \"path_buf_capacity\", issue = \"58234\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n}\n}\n\n#[stable(feature = \"box_from_path\", since = \"1.17.0\")]\nimpl From<&Path> for Box<Path> {\n    fn from(path: &Path) -> Box<Path> {\n}\n}\n\n#[stable(feature = \"path_buf_from_box\", since = \"1.18.0\")]\nimpl From<Box<Path>> for PathBuf {\n    /// Converts a `Box<Path>` into a `PathBuf`\n    ///\n    /// This conversion does not allocate or copy memory.\n    fn from(boxed: Box<Path>) -> PathBuf {\n}\n}\n\n#[stable(feature = \"box_from_path_buf\", since = \"1.20.0\")]\nimpl From<PathBuf> for Box<Path> {\n    /// Converts a `PathBuf` into a `Box<Path>`\n    ///\n    /// This conversion currently should not allocate memory,\n    /// but this behavior is not guaranteed on all platforms or in all future versions.\n    fn from(p: PathBuf) -> Box<Path> {\n}\n}\n\n#[stable(feature = \"more_box_slice_clone\", since = \"1.29.0\")]\nimpl Clone for Box<Path> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + AsRef<OsStr>> From<&T> for PathBuf {\n    fn from(s: &T) -> PathBuf {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<OsString> for PathBuf {\n    /// Converts a `OsString` into a `PathBuf`\n    ///\n    /// This conversion does not allocate or copy memory.\n    #[inline]\n    fn from(s: OsString) -> PathBuf {\n}\n}\n\n#[stable(feature = \"from_path_buf_for_os_string\", since = \"1.14.0\")]\nimpl From<PathBuf> for OsString {\n    /// Converts a `PathBuf` into a `OsString`\n    ///\n    /// This conversion does not allocate or copy memory.\n    fn from(path_buf: PathBuf) -> OsString {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<String> for PathBuf {\n    /// Converts a `String` into a `PathBuf`\n    ///\n    /// This conversion does not allocate or copy memory.\n    fn from(s: String) -> PathBuf {\n}\n}\n\n#[stable(feature = \"path_from_str\", since = \"1.32.0\")]\nimpl FromStr for PathBuf {\n    type Err = core::convert::Infallible;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<P: AsRef<Path>> iter::FromIterator<P> for PathBuf {\n    fn from_iter<I: IntoIterator<Item = P>>(iter: I) -> PathBuf {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<P: AsRef<Path>> iter::Extend<P> for PathBuf {\n    fn extend<I: IntoIterator<Item = P>>(&mut self, iter: I) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for PathBuf {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Deref for PathBuf {\n    type Target = Path;\n    #[inline]\n    fn deref(&self) -> &Path {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Borrow<Path> for PathBuf {\n    fn borrow(&self) -> &Path {\n}\n}\n\n#[stable(feature = \"default_for_pathbuf\", since = \"1.17.0\")]\nimpl Default for PathBuf {\n    fn default() -> Self {\n}\n}\n\n#[stable(feature = \"cow_from_path\", since = \"1.6.0\")]\nimpl<'a> From<&'a Path> for Cow<'a, Path> {\n    #[inline]\n    fn from(s: &'a Path) -> Cow<'a, Path> {\n}\n}\n\n#[stable(feature = \"cow_from_path\", since = \"1.6.0\")]\nimpl<'a> From<PathBuf> for Cow<'a, Path> {\n    #[inline]\n    fn from(s: PathBuf) -> Cow<'a, Path> {\n}\n}\n\n#[stable(feature = \"cow_from_pathbuf_ref\", since = \"1.28.0\")]\nimpl<'a> From<&'a PathBuf> for Cow<'a, Path> {\n    #[inline]\n    fn from(p: &'a PathBuf) -> Cow<'a, Path> {\n}\n}\n\n#[stable(feature = \"pathbuf_from_cow_path\", since = \"1.28.0\")]\nimpl<'a> From<Cow<'a, Path>> for PathBuf {\n    #[inline]\n    fn from(p: Cow<'a, Path>) -> Self {\n}\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<PathBuf> for Arc<Path> {\n    /// Converts a `PathBuf` into an `Arc` by moving the `PathBuf` data into a new `Arc` buffer.\n    #[inline]\n    fn from(s: PathBuf) -> Arc<Path> {\n}\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<&Path> for Arc<Path> {\n    /// Converts a `Path` into an `Arc` by copying the `Path` data into a new `Arc` buffer.\n    #[inline]\n    fn from(s: &Path) -> Arc<Path> {\n}\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<PathBuf> for Rc<Path> {\n    /// Converts a `PathBuf` into an `Rc` by moving the `PathBuf` data into a new `Rc` buffer.\n    #[inline]\n    fn from(s: PathBuf) -> Rc<Path> {\n}\n}\n\n#[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\nimpl From<&Path> for Rc<Path> {\n    /// Converts a `Path` into an `Rc` by copying the `Path` data into a new `Rc` buffer.\n    #[inline]\n    fn from(s: &Path) -> Rc<Path> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToOwned for Path {\n    type Owned = PathBuf;\n    fn to_owned(&self) -> PathBuf {\n}\n    fn clone_into(&self, target: &mut PathBuf) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::PartialEq for PathBuf {\n    fn eq(&self, other: &PathBuf) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Hash for PathBuf {\n    fn hash<H: Hasher>(&self, h: &mut H) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Eq for PathBuf {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::PartialOrd for PathBuf {\n    fn partial_cmp(&self, other: &PathBuf) -> Option<cmp::Ordering> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Ord for PathBuf {\n    fn cmp(&self, other: &PathBuf) -> cmp::Ordering {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for PathBuf {\n    fn as_ref(&self) -> &OsStr {\n}\n}\n\n/// A slice of a path (akin to [`str`]).\n///\n/// This type supports a number of operations for inspecting a path, including\n/// breaking the path into its components (separated by `/` on Unix and by either\n/// `/` or `\\` on Windows), extracting the file name, determining whether the path\n/// is absolute, and so on.\n///\n/// This is an *unsized* type, meaning that it must always be used behind a\n/// pointer like `&` or [`Box`]. For an owned version of this type,\n/// see [`PathBuf`].\n///\n/// [`str`]: ../primitive.str.html\n/// [`Box`]: ../boxed/struct.Box.html\n/// [`PathBuf`]: struct.PathBuf.html\n///\n/// More details about the overall approach can be found in\n/// the [module documentation](index.html).\n///\n/// # Examples\n///\n/// ```\n/// use std::path::Path;\n/// use std::ffi::OsStr;\n///\n/// // Note: this example does work on Windows\n/// let path = Path::new(\"./foo/bar.txt\");\n///\n/// let parent = path.parent();\n/// assert_eq!(parent, Some(Path::new(\"./foo\")));\n///\n/// let file_stem = path.file_stem();\n/// assert_eq!(file_stem, Some(OsStr::new(\"bar\")));\n///\n/// let extension = path.extension();\n/// assert_eq!(extension, Some(OsStr::new(\"txt\")));\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n// FIXME:\n// `Path::new` current implementation relies\n// on `Path` being layout-compatible with `OsStr`.\n// When attribute privacy is implemented, `Path` should be annotated as `#[repr(transparent)]`.\n// Anyway, `Path` representation and layout are considered implementation detail, are\n// not documented and must not be relied upon.\npub struct Path {\n    inner: OsStr,\n}\n\n/// An error returned from [`Path::strip_prefix`][`strip_prefix`] if the prefix\n/// was not found.\n///\n/// This `struct` is created by the [`strip_prefix`] method on [`Path`].\n/// See its documentation for more.\n///\n/// [`strip_prefix`]: struct.Path.html#method.strip_prefix\n/// [`Path`]: struct.Path.html\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\npub struct StripPrefixError(());\n\nimpl Path {\n    // The following (private!) function allows construction of a path from a u8\n    // slice, which is only safe when it is known to follow the OsStr encoding.\n    unsafe fn from_u8_slice(s: &[u8]) -> &Path {\n}\n    // The following (private!) function reveals the byte encoding used for OsStr.\n    fn as_u8_slice(&self) -> &[u8] {\n}\n\n    /// Directly wraps a string slice as a `Path` slice.\n    ///\n    /// This is a cost-free conversion.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// Path::new(\"foo.txt\");\n    /// ```\n    ///\n    /// You can create `Path`s from `String`s, or even other `Path`s:\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let string = String::from(\"foo.txt\");\n    /// let from_string = Path::new(&string);\n    /// let from_path = Path::new(&from_string);\n    /// assert_eq!(from_string, from_path);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &Path {\n}\n\n    /// Yields the underlying [`OsStr`] slice.\n    ///\n    /// [`OsStr`]: ../ffi/struct.OsStr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let os_str = Path::new(\"foo.txt\").as_os_str();\n    /// assert_eq!(os_str, std::ffi::OsStr::new(\"foo.txt\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_os_str(&self) -> &OsStr {\n}\n\n    /// Yields a [`&str`] slice if the `Path` is valid unicode.\n    ///\n    /// This conversion may entail doing a check for UTF-8 validity.\n    /// Note that validation is performed because non-UTF-8 strings are\n    /// perfectly valid for some OS.\n    ///\n    /// [`&str`]: ../primitive.str.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"foo.txt\");\n    /// assert_eq!(path.to_str(), Some(\"foo.txt\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_str(&self) -> Option<&str> {\n}\n\n    /// Converts a `Path` to a [`Cow<str>`].\n    ///\n    /// Any non-Unicode sequences are replaced with\n    /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n    ///\n    /// [`Cow<str>`]: ../borrow/enum.Cow.html\n    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n    ///\n    /// # Examples\n    ///\n    /// Calling `to_string_lossy` on a `Path` with valid unicode:\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"foo.txt\");\n    /// assert_eq!(path.to_string_lossy(), \"foo.txt\");\n    /// ```\n    ///\n    /// Had `path` contained invalid unicode, the `to_string_lossy` call might\n    /// have returned `\"fo�.txt\"`.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n}\n\n    /// Converts a `Path` to an owned [`PathBuf`].\n    ///\n    /// [`PathBuf`]: struct.PathBuf.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path_buf = Path::new(\"foo.txt\").to_path_buf();\n    /// assert_eq!(path_buf, std::path::PathBuf::from(\"foo.txt\"));\n    /// ```\n    #[rustc_conversion_suggestion]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_path_buf(&self) -> PathBuf {\n}\n\n    /// Returns `true` if the `Path` is absolute, i.e., if it is independent of\n    /// the current directory.\n    ///\n    /// * On Unix, a path is absolute if it starts with the root, so\n    /// `is_absolute` and [`has_root`] are equivalent.\n    ///\n    /// * On Windows, a path is absolute if it has a prefix and starts with the\n    /// root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// assert!(!Path::new(\"foo.txt\").is_absolute());\n    /// ```\n    ///\n    /// [`has_root`]: #method.has_root\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow(deprecated)]\n    pub fn is_absolute(&self) -> bool {\n}\n\n    /// Returns `true` if the `Path` is relative, i.e., not absolute.\n    ///\n    /// See [`is_absolute`]'s documentation for more details.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// assert!(Path::new(\"foo.txt\").is_relative());\n    /// ```\n    ///\n    /// [`is_absolute`]: #method.is_absolute\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_relative(&self) -> bool {\n}\n\n    fn prefix(&self) -> Option<Prefix<'_>> {\n}\n\n    /// Returns `true` if the `Path` has a root.\n    ///\n    /// * On Unix, a path has a root if it begins with `/`.\n    ///\n    /// * On Windows, a path has a root if it:\n    ///     * has no prefix and begins with a separator, e.g., `\\windows`\n    ///     * has a prefix followed by a separator, e.g., `c:\\windows` but not `c:windows`\n    ///     * has any non-disk prefix, e.g., `\\\\server\\share`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// assert!(Path::new(\"/etc/passwd\").has_root());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn has_root(&self) -> bool {\n}\n\n    /// Returns the `Path` without its final component, if there is one.\n    ///\n    /// Returns [`None`] if the path terminates in a root or prefix.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/foo/bar\");\n    /// let parent = path.parent().unwrap();\n    /// assert_eq!(parent, Path::new(\"/foo\"));\n    ///\n    /// let grand_parent = parent.parent().unwrap();\n    /// assert_eq!(grand_parent, Path::new(\"/\"));\n    /// assert_eq!(grand_parent.parent(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn parent(&self) -> Option<&Path> {\n}\n\n    /// Produces an iterator over `Path` and its ancestors.\n    ///\n    /// The iterator will yield the `Path` that is returned if the [`parent`] method is used zero\n    /// or more times. That means, the iterator will yield `&self`, `&self.parent().unwrap()`,\n    /// `&self.parent().unwrap().parent().unwrap()` and so on. If the [`parent`] method returns\n    /// [`None`], the iterator will do likewise. The iterator will always yield at least one value,\n    /// namely `&self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let mut ancestors = Path::new(\"/foo/bar\").ancestors();\n    /// assert_eq!(ancestors.next(), Some(Path::new(\"/foo/bar\")));\n    /// assert_eq!(ancestors.next(), Some(Path::new(\"/foo\")));\n    /// assert_eq!(ancestors.next(), Some(Path::new(\"/\")));\n    /// assert_eq!(ancestors.next(), None);\n    /// ```\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`parent`]: struct.Path.html#method.parent\n    #[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\n    pub fn ancestors(&self) -> Ancestors<'_> {\n}\n\n    /// Returns the final component of the `Path`, if there is one.\n    ///\n    /// If the path is a normal file, this is the file name. If it's the path of a directory, this\n    /// is the directory name.\n    ///\n    /// Returns [`None`] if the path terminates in `..`.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    /// use std::ffi::OsStr;\n    ///\n    /// assert_eq!(Some(OsStr::new(\"bin\")), Path::new(\"/usr/bin/\").file_name());\n    /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"tmp/foo.txt\").file_name());\n    /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.\").file_name());\n    /// assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.//\").file_name());\n    /// assert_eq!(None, Path::new(\"foo.txt/..\").file_name());\n    /// assert_eq!(None, Path::new(\"/\").file_name());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn file_name(&self) -> Option<&OsStr> {\n}\n\n    /// Returns a path that, when joined onto `base`, yields `self`.\n    ///\n    /// # Errors\n    ///\n    /// If `base` is not a prefix of `self` (i.e., [`starts_with`]\n    /// returns `false`), returns [`Err`].\n    ///\n    /// [`starts_with`]: #method.starts_with\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let path = Path::new(\"/test/haha/foo.txt\");\n    ///\n    /// assert_eq!(path.strip_prefix(\"/\"), Ok(Path::new(\"test/haha/foo.txt\")));\n    /// assert_eq!(path.strip_prefix(\"/test\"), Ok(Path::new(\"haha/foo.txt\")));\n    /// assert_eq!(path.strip_prefix(\"/test/\"), Ok(Path::new(\"haha/foo.txt\")));\n    /// assert_eq!(path.strip_prefix(\"/test/haha/foo.txt\"), Ok(Path::new(\"\")));\n    /// assert_eq!(path.strip_prefix(\"/test/haha/foo.txt/\"), Ok(Path::new(\"\")));\n    /// assert_eq!(path.strip_prefix(\"test\").is_ok(), false);\n    /// assert_eq!(path.strip_prefix(\"/haha\").is_ok(), false);\n    ///\n    /// let prefix = PathBuf::from(\"/test/\");\n    /// assert_eq!(path.strip_prefix(prefix), Ok(Path::new(\"haha/foo.txt\")));\n    /// ```\n    #[stable(since = \"1.7.0\", feature = \"path_strip_prefix\")]\n    pub fn strip_prefix<P>(&self, base: P) -> Result<&Path, StripPrefixError>\n    where\n        P: AsRef<Path>,\n    {\n}\n\n    fn _strip_prefix(&self, base: &Path) -> Result<&Path, StripPrefixError> {\n}\n\n    /// Determines whether `base` is a prefix of `self`.\n    ///\n    /// Only considers whole path components to match.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/etc/passwd\");\n    ///\n    /// assert!(path.starts_with(\"/etc\"));\n    /// assert!(path.starts_with(\"/etc/\"));\n    /// assert!(path.starts_with(\"/etc/passwd\"));\n    /// assert!(path.starts_with(\"/etc/passwd/\"));\n    ///\n    /// assert!(!path.starts_with(\"/e\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool {\n}\n\n    fn _starts_with(&self, base: &Path) -> bool {\n}\n\n    /// Determines whether `child` is a suffix of `self`.\n    ///\n    /// Only considers whole path components to match.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/etc/passwd\");\n    ///\n    /// assert!(path.ends_with(\"passwd\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ends_with<P: AsRef<Path>>(&self, child: P) -> bool {\n}\n\n    fn _ends_with(&self, child: &Path) -> bool {\n}\n\n    /// Extracts the stem (non-extension) portion of [`self.file_name`].\n    ///\n    /// [`self.file_name`]: struct.Path.html#method.file_name\n    ///\n    /// The stem is:\n    ///\n    /// * [`None`], if there is no file name;\n    /// * The entire file name if there is no embedded `.`;\n    /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n    /// * Otherwise, the portion of the file name before the final `.`\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"foo.rs\");\n    ///\n    /// assert_eq!(\"foo\", path.file_stem().unwrap());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn file_stem(&self) -> Option<&OsStr> {\n}\n\n    /// Extracts the extension of [`self.file_name`], if possible.\n    ///\n    /// The extension is:\n    ///\n    /// * [`None`], if there is no file name;\n    /// * [`None`], if there is no embedded `.`;\n    /// * [`None`], if the file name begins with `.` and has no other `.`s within;\n    /// * Otherwise, the portion of the file name after the final `.`\n    ///\n    /// [`self.file_name`]: struct.Path.html#method.file_name\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"foo.rs\");\n    ///\n    /// assert_eq!(\"rs\", path.extension().unwrap());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn extension(&self) -> Option<&OsStr> {\n}\n\n    /// Creates an owned [`PathBuf`] with `path` adjoined to `self`.\n    ///\n    /// See [`PathBuf::push`] for more details on what it means to adjoin a path.\n    ///\n    /// [`PathBuf`]: struct.PathBuf.html\n    /// [`PathBuf::push`]: struct.PathBuf.html#method.push\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// assert_eq!(Path::new(\"/etc\").join(\"passwd\"), PathBuf::from(\"/etc/passwd\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[must_use]\n    pub fn join<P: AsRef<Path>>(&self, path: P) -> PathBuf {\n}\n\n    fn _join(&self, path: &Path) -> PathBuf {\n}\n\n    /// Creates an owned [`PathBuf`] like `self` but with the given file name.\n    ///\n    /// See [`PathBuf::set_file_name`] for more details.\n    ///\n    /// [`PathBuf`]: struct.PathBuf.html\n    /// [`PathBuf::set_file_name`]: struct.PathBuf.html#method.set_file_name\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let path = Path::new(\"/tmp/foo.txt\");\n    /// assert_eq!(path.with_file_name(\"bar.txt\"), PathBuf::from(\"/tmp/bar.txt\"));\n    ///\n    /// let path = Path::new(\"/tmp\");\n    /// assert_eq!(path.with_file_name(\"var\"), PathBuf::from(\"/var\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_file_name<S: AsRef<OsStr>>(&self, file_name: S) -> PathBuf {\n}\n\n    fn _with_file_name(&self, file_name: &OsStr) -> PathBuf {\n}\n\n    /// Creates an owned [`PathBuf`] like `self` but with the given extension.\n    ///\n    /// See [`PathBuf::set_extension`] for more details.\n    ///\n    /// [`PathBuf`]: struct.PathBuf.html\n    /// [`PathBuf::set_extension`]: struct.PathBuf.html#method.set_extension\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let path = Path::new(\"foo.rs\");\n    /// assert_eq!(path.with_extension(\"txt\"), PathBuf::from(\"foo.txt\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {\n}\n\n    fn _with_extension(&self, extension: &OsStr) -> PathBuf {\n}\n\n    /// Produces an iterator over the [`Component`]s of the path.\n    ///\n    /// When parsing the path, there is a small amount of normalization:\n    ///\n    /// * Repeated separators are ignored, so `a/b` and `a//b` both have\n    ///   `a` and `b` as components.\n    ///\n    /// * Occurrences of `.` are normalized away, except if they are at the\n    ///   beginning of the path. For example, `a/./b`, `a/b/`, `a/b/.` and\n    ///   `a/b` all have `a` and `b` as components, but `./a/b` starts with\n    ///   an additional [`CurDir`] component.\n    ///\n    /// * A trailing slash is normalized away, `/a/b` and `/a/b/` are equivalent.\n    ///\n    /// Note that no other normalization takes place; in particular, `a/c`\n    /// and `a/b/../c` are distinct, to account for the possibility that `b`\n    /// is a symbolic link (so its parent isn't `a`).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{Path, Component};\n    /// use std::ffi::OsStr;\n    ///\n    /// let mut components = Path::new(\"/tmp/foo.txt\").components();\n    ///\n    /// assert_eq!(components.next(), Some(Component::RootDir));\n    /// assert_eq!(components.next(), Some(Component::Normal(OsStr::new(\"tmp\"))));\n    /// assert_eq!(components.next(), Some(Component::Normal(OsStr::new(\"foo.txt\"))));\n    /// assert_eq!(components.next(), None)\n    /// ```\n    ///\n    /// [`Component`]: enum.Component.html\n    /// [`CurDir`]: enum.Component.html#variant.CurDir\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn components(&self) -> Components<'_> {\n}\n\n    /// Produces an iterator over the path's components viewed as [`OsStr`]\n    /// slices.\n    ///\n    /// For more information about the particulars of how the path is separated\n    /// into components, see [`components`].\n    ///\n    /// [`components`]: #method.components\n    /// [`OsStr`]: ../ffi/struct.OsStr.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::{self, Path};\n    /// use std::ffi::OsStr;\n    ///\n    /// let mut it = Path::new(\"/tmp/foo.txt\").iter();\n    /// assert_eq!(it.next(), Some(OsStr::new(&path::MAIN_SEPARATOR.to_string())));\n    /// assert_eq!(it.next(), Some(OsStr::new(\"tmp\")));\n    /// assert_eq!(it.next(), Some(OsStr::new(\"foo.txt\")));\n    /// assert_eq!(it.next(), None)\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_> {\n}\n\n    /// Returns an object that implements [`Display`] for safely printing paths\n    /// that may contain non-Unicode data.\n    ///\n    /// [`Display`]: ../fmt/trait.Display.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/tmp/foo.rs\");\n    ///\n    /// println!(\"{}\", path.display());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn display(&self) -> Display<'_> {\n}\n\n    /// Queries the file system to get information about a file, directory, etc.\n    ///\n    /// This function will traverse symbolic links to query information about the\n    /// destination file.\n    ///\n    /// This is an alias to [`fs::metadata`].\n    ///\n    /// [`fs::metadata`]: ../fs/fn.metadata.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/Minas/tirith\");\n    /// let metadata = path.metadata().expect(\"metadata call failed\");\n    /// println!(\"{:?}\", metadata.file_type());\n    /// ```\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    pub fn metadata(&self) -> io::Result<fs::Metadata> {\n}\n\n    /// Queries the metadata about a file without following symlinks.\n    ///\n    /// This is an alias to [`fs::symlink_metadata`].\n    ///\n    /// [`fs::symlink_metadata`]: ../fs/fn.symlink_metadata.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/Minas/tirith\");\n    /// let metadata = path.symlink_metadata().expect(\"symlink_metadata call failed\");\n    /// println!(\"{:?}\", metadata.file_type());\n    /// ```\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    pub fn symlink_metadata(&self) -> io::Result<fs::Metadata> {\n}\n\n    /// Returns the canonical, absolute form of the path with all intermediate\n    /// components normalized and symbolic links resolved.\n    ///\n    /// This is an alias to [`fs::canonicalize`].\n    ///\n    /// [`fs::canonicalize`]: ../fs/fn.canonicalize.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::{Path, PathBuf};\n    ///\n    /// let path = Path::new(\"/foo/test/../test/bar.rs\");\n    /// assert_eq!(path.canonicalize().unwrap(), PathBuf::from(\"/foo/test/bar.rs\"));\n    /// ```\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    pub fn canonicalize(&self) -> io::Result<PathBuf> {\n}\n\n    /// Reads a symbolic link, returning the file that the link points to.\n    ///\n    /// This is an alias to [`fs::read_link`].\n    ///\n    /// [`fs::read_link`]: ../fs/fn.read_link.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/laputa/sky_castle.rs\");\n    /// let path_link = path.read_link().expect(\"read_link call failed\");\n    /// ```\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    pub fn read_link(&self) -> io::Result<PathBuf> {\n}\n\n    /// Returns an iterator over the entries within a directory.\n    ///\n    /// The iterator will yield instances of [`io::Result`]`<`[`DirEntry`]`>`. New\n    /// errors may be encountered after an iterator is initially constructed.\n    ///\n    /// This is an alias to [`fs::read_dir`].\n    ///\n    /// [`io::Result`]: ../io/type.Result.html\n    /// [`DirEntry`]: ../fs/struct.DirEntry.html\n    /// [`fs::read_dir`]: ../fs/fn.read_dir.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    ///\n    /// let path = Path::new(\"/laputa\");\n    /// for entry in path.read_dir().expect(\"read_dir call failed\") {\n    ///     if let Ok(entry) = entry {\n    ///         println!(\"{:?}\", entry.path());\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    pub fn read_dir(&self) -> io::Result<fs::ReadDir> {\n}\n\n    /// Returns `true` if the path points at an existing entity.\n    ///\n    /// This function will traverse symbolic links to query information about the\n    /// destination file. In case of broken symbolic links this will return `false`.\n    ///\n    /// If you cannot access the directory containing the file, e.g., because of a\n    /// permission error, this will return `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    /// assert_eq!(Path::new(\"does_not_exist.txt\").exists(), false);\n    /// ```\n    ///\n    /// # See Also\n    ///\n    /// This is a convenience function that coerces errors to false. If you want to\n    /// check errors, call [fs::metadata].\n    ///\n    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    pub fn exists(&self) -> bool {\n}\n\n    /// Returns `true` if the path exists on disk and is pointing at a regular file.\n    ///\n    /// This function will traverse symbolic links to query information about the\n    /// destination file. In case of broken symbolic links this will return `false`.\n    ///\n    /// If you cannot access the directory containing the file, e.g., because of a\n    /// permission error, this will return `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    /// assert_eq!(Path::new(\"./is_a_directory/\").is_file(), false);\n    /// assert_eq!(Path::new(\"a_file.txt\").is_file(), true);\n    /// ```\n    ///\n    /// # See Also\n    ///\n    /// This is a convenience function that coerces errors to false. If you want to\n    /// check errors, call [fs::metadata] and handle its Result. Then call\n    /// [fs::Metadata::is_file] if it was Ok.\n    ///\n    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n    /// [fs::Metadata::is_file]: ../../std/fs/struct.Metadata.html#method.is_file\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    pub fn is_file(&self) -> bool {\n}\n\n    /// Returns `true` if the path exists on disk and is pointing at a directory.\n    ///\n    /// This function will traverse symbolic links to query information about the\n    /// destination file. In case of broken symbolic links this will return `false`.\n    ///\n    /// If you cannot access the directory containing the file, e.g., because of a\n    /// permission error, this will return `false`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::path::Path;\n    /// assert_eq!(Path::new(\"./is_a_directory/\").is_dir(), true);\n    /// assert_eq!(Path::new(\"a_file.txt\").is_dir(), false);\n    /// ```\n    ///\n    /// # See Also\n    ///\n    /// This is a convenience function that coerces errors to false. If you want to\n    /// check errors, call [fs::metadata] and handle its Result. Then call\n    /// [fs::Metadata::is_dir] if it was Ok.\n    ///\n    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n    /// [fs::Metadata::is_dir]: ../../std/fs/struct.Metadata.html#method.is_dir\n    #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n    pub fn is_dir(&self) -> bool {\n}\n\n    /// Converts a [`Box<Path>`][`Box`] into a [`PathBuf`] without copying or\n    /// allocating.\n    ///\n    /// [`Box`]: ../../std/boxed/struct.Box.html\n    /// [`PathBuf`]: struct.PathBuf.html\n    #[stable(feature = \"into_boxed_path\", since = \"1.20.0\")]\n    pub fn into_path_buf(self: Box<Path>) -> PathBuf {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<OsStr> for Path {\n    fn as_ref(&self) -> &OsStr {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Path {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// Helper struct for safely printing paths with [`format!`] and `{}`.\n///\n/// A [`Path`] might contain non-Unicode data. This `struct` implements the\n/// [`Display`] trait in a way that mitigates that. It is created by the\n/// [`display`][`Path::display`] method on [`Path`].\n///\n/// # Examples\n///\n/// ```\n/// use std::path::Path;\n///\n/// let path = Path::new(\"/tmp/foo.rs\");\n///\n/// println!(\"{}\", path.display());\n/// ```\n///\n/// [`Display`]: ../../std/fmt/trait.Display.html\n/// [`format!`]: ../../std/macro.format.html\n/// [`Path`]: struct.Path.html\n/// [`Path::display`]: struct.Path.html#method.display\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Display<'a> {\n    path: &'a Path,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Display<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Display<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::PartialEq for Path {\n    fn eq(&self, other: &Path) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Hash for Path {\n    fn hash<H: Hasher>(&self, h: &mut H) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Eq for Path {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::PartialOrd for Path {\n    fn partial_cmp(&self, other: &Path) -> Option<cmp::Ordering> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl cmp::Ord for Path {\n    fn cmp(&self, other: &Path) -> cmp::Ordering {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for Path {\n    fn as_ref(&self) -> &Path {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for OsStr {\n    fn as_ref(&self) -> &Path {\n}\n}\n\n#[stable(feature = \"cow_os_str_as_ref_path\", since = \"1.8.0\")]\nimpl AsRef<Path> for Cow<'_, OsStr> {\n    fn as_ref(&self) -> &Path {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for OsString {\n    fn as_ref(&self) -> &Path {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for str {\n    #[inline]\n    fn as_ref(&self) -> &Path {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for String {\n    fn as_ref(&self) -> &Path {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<Path> for PathBuf {\n    #[inline]\n    fn as_ref(&self) -> &Path {\n}\n}\n\n#[stable(feature = \"path_into_iter\", since = \"1.6.0\")]\nimpl<'a> IntoIterator for &'a PathBuf {\n    type Item = &'a OsStr;\n    type IntoIter = Iter<'a>;\n    fn into_iter(self) -> Iter<'a> {\n}\n}\n\n#[stable(feature = \"path_into_iter\", since = \"1.6.0\")]\nimpl<'a> IntoIterator for &'a Path {\n    type Item = &'a OsStr;\n    type IntoIter = Iter<'a>;\n    fn into_iter(self) -> Iter<'a> {\n}\n}\n\nmacro_rules! impl_cmp {\n    ($lhs:ty, $rhs: ty) => {\n        #[stable(feature = \"partialeq_path\", since = \"1.6.0\")]\n        impl<'a, 'b> PartialEq<$rhs> for $lhs {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool {\n}\n        }\n\n        #[stable(feature = \"partialeq_path\", since = \"1.6.0\")]\n        impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool {\n}\n        }\n\n        #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$rhs> for $lhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$rhs) -> Option<cmp::Ordering> {\n}\n        }\n\n        #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$lhs> for $rhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$lhs) -> Option<cmp::Ordering> {\n}\n        }\n    };\n}\n\nimpl_cmp!(PathBuf, Path);\nimpl_cmp!(PathBuf, &'a Path);\nimpl_cmp!(Cow<'a, Path>, Path);\nimpl_cmp!(Cow<'a, Path>, &'b Path);\nimpl_cmp!(Cow<'a, Path>, PathBuf);\n\nmacro_rules! impl_cmp_os_str {\n    ($lhs:ty, $rhs: ty) => {\n        #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialEq<$rhs> for $lhs {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool {\n}\n        }\n\n        #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool {\n}\n        }\n\n        #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$rhs> for $lhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$rhs) -> Option<cmp::Ordering> {\n}\n        }\n\n        #[stable(feature = \"cmp_path\", since = \"1.8.0\")]\n        impl<'a, 'b> PartialOrd<$lhs> for $rhs {\n            #[inline]\n            fn partial_cmp(&self, other: &$lhs) -> Option<cmp::Ordering> {\n}\n        }\n    };\n}\n\nimpl_cmp_os_str!(PathBuf, OsStr);\nimpl_cmp_os_str!(PathBuf, &'a OsStr);\nimpl_cmp_os_str!(PathBuf, Cow<'a, OsStr>);\nimpl_cmp_os_str!(PathBuf, OsString);\nimpl_cmp_os_str!(Path, OsStr);\nimpl_cmp_os_str!(Path, &'a OsStr);\nimpl_cmp_os_str!(Path, Cow<'a, OsStr>);\nimpl_cmp_os_str!(Path, OsString);\nimpl_cmp_os_str!(&'a Path, OsStr);\nimpl_cmp_os_str!(&'a Path, Cow<'b, OsStr>);\nimpl_cmp_os_str!(&'a Path, OsString);\nimpl_cmp_os_str!(Cow<'a, Path>, OsStr);\nimpl_cmp_os_str!(Cow<'a, Path>, &'b OsStr);\nimpl_cmp_os_str!(Cow<'a, Path>, OsString);\n\n#[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\nimpl fmt::Display for StripPrefixError {\n    #[allow(deprecated, deprecated_in_future)]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\nimpl Error for StripPrefixError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\npub mod process {\n//! A module for working with processes.\n//!\n//! This module is mostly concerned with spawning and interacting with child\n//! processes, but it also provides [`abort`] and [`exit`] for terminating the\n//! current process.\n//!\n//! # Spawning a process\n//!\n//! The [`Command`] struct is used to configure and spawn processes:\n//!\n//! ```no_run\n//! use std::process::Command;\n//!\n//! let output = Command::new(\"echo\")\n//!                      .arg(\"Hello world\")\n//!                      .output()\n//!                      .expect(\"Failed to execute command\");\n//!\n//! assert_eq!(b\"Hello world\\n\", output.stdout.as_slice());\n//! ```\n//!\n//! Several methods on [`Command`], such as [`spawn`] or [`output`], can be used\n//! to spawn a process. In particular, [`output`] spawns the child process and\n//! waits until the process terminates, while [`spawn`] will return a [`Child`]\n//! that represents the spawned child process.\n//!\n//! # Handling I/O\n//!\n//! The [`stdout`], [`stdin`], and [`stderr`] of a child process can be\n//! configured by passing an [`Stdio`] to the corresponding method on\n//! [`Command`]. Once spawned, they can be accessed from the [`Child`]. For\n//! example, piping output from one command into another command can be done\n//! like so:\n//!\n//! ```no_run\n//! use std::process::{Command, Stdio};\n//!\n//! // stdout must be configured with `Stdio::piped` in order to use\n//! // `echo_child.stdout`\n//! let echo_child = Command::new(\"echo\")\n//!     .arg(\"Oh no, a tpyo!\")\n//!     .stdout(Stdio::piped())\n//!     .spawn()\n//!     .expect(\"Failed to start echo process\");\n//!\n//! // Note that `echo_child` is moved here, but we won't be needing\n//! // `echo_child` anymore\n//! let echo_out = echo_child.stdout.expect(\"Failed to open echo stdout\");\n//!\n//! let mut sed_child = Command::new(\"sed\")\n//!     .arg(\"s/tpyo/typo/\")\n//!     .stdin(Stdio::from(echo_out))\n//!     .stdout(Stdio::piped())\n//!     .spawn()\n//!     .expect(\"Failed to start sed process\");\n//!\n//! let output = sed_child.wait_with_output().expect(\"Failed to wait on sed\");\n//! assert_eq!(b\"Oh no, a typo!\\n\", output.stdout.as_slice());\n//! ```\n//!\n//! Note that [`ChildStderr`] and [`ChildStdout`] implement [`Read`] and\n//! [`ChildStdin`] implements [`Write`]:\n//!\n//! ```no_run\n//! use std::process::{Command, Stdio};\n//! use std::io::Write;\n//!\n//! let mut child = Command::new(\"/bin/cat\")\n//!     .stdin(Stdio::piped())\n//!     .stdout(Stdio::piped())\n//!     .spawn()\n//!     .expect(\"failed to execute child\");\n//!\n//! {\n//!     // limited borrow of stdin\n//!     let stdin = child.stdin.as_mut().expect(\"failed to get stdin\");\n//!     stdin.write_all(b\"test\").expect(\"failed to write to stdin\");\n//! }\n//!\n//! let output = child\n//!     .wait_with_output()\n//!     .expect(\"failed to wait on child\");\n//!\n//! assert_eq!(b\"test\", output.stdout.as_slice());\n//! ```\n//!\n//! [`abort`]: fn.abort.html\n//! [`exit`]: fn.exit.html\n//!\n//! [`Command`]: struct.Command.html\n//! [`spawn`]: struct.Command.html#method.spawn\n//! [`output`]: struct.Command.html#method.output\n//!\n//! [`Child`]: struct.Child.html\n//! [`ChildStdin`]: struct.ChildStdin.html\n//! [`ChildStdout`]: struct.ChildStdout.html\n//! [`ChildStderr`]: struct.ChildStderr.html\n//! [`Stdio`]: struct.Stdio.html\n//!\n//! [`stdout`]: struct.Command.html#method.stdout\n//! [`stdin`]: struct.Command.html#method.stdin\n//! [`stderr`]: struct.Command.html#method.stderr\n//!\n//! [`Write`]: ../io/trait.Write.html\n//! [`Read`]: ../io/trait.Read.html\n\n#![stable(feature = \"process\", since = \"1.0.0\")]\n\nuse crate::io::prelude::*;\n\nuse crate::ffi::OsStr;\nuse crate::fmt;\nuse crate::fs;\nuse crate::io::{self, Initializer, IoSlice, IoSliceMut};\nuse crate::path::Path;\nuse crate::str;\nuse crate::sys::pipe::{read2, AnonPipe};\nuse crate::sys::process as imp;\nuse crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n\n/// Representation of a running or exited child process.\n///\n/// This structure is used to represent and manage child processes. A child\n/// process is created via the [`Command`] struct, which configures the\n/// spawning process and can itself be constructed using a builder-style\n/// interface.\n///\n/// There is no implementation of [`Drop`] for child processes,\n/// so if you do not ensure the `Child` has exited then it will continue to\n/// run, even after the `Child` handle to the child process has gone out of\n/// scope.\n///\n/// Calling [`wait`](#method.wait) (or other functions that wrap around it) will make\n/// the parent process wait until the child has actually exited before\n/// continuing.\n///\n/// # Warning\n///\n/// On some system, calling [`wait`] or similar is necessary for the OS to\n/// release resources. A process that terminated but has not been waited on is\n/// still around as a \"zombie\". Leaving too many zombies around may exhaust\n/// global resources (for example process IDs).\n///\n/// The standard library does *not* automatically wait on child processes (not\n/// even if the `Child` is dropped), it is up to the application developer to do\n/// so. As a consequence, dropping `Child` handles without waiting on them first\n/// is not recommended in long-running applications.\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::process::Command;\n///\n/// let mut child = Command::new(\"/bin/cat\")\n///                         .arg(\"file.txt\")\n///                         .spawn()\n///                         .expect(\"failed to execute child\");\n///\n/// let ecode = child.wait()\n///                  .expect(\"failed to wait on child\");\n///\n/// assert!(ecode.success());\n/// ```\n///\n/// [`Command`]: struct.Command.html\n/// [`Drop`]: ../../core/ops/trait.Drop.html\n/// [`wait`]: #method.wait\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Child {\n    handle: imp::Process,\n\n    /// The handle for writing to the child's standard input (stdin), if it has\n    /// been captured.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stdin: Option<ChildStdin>,\n\n    /// The handle for reading from the child's standard output (stdout), if it\n    /// has been captured.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stdout: Option<ChildStdout>,\n\n    /// The handle for reading from the child's standard error (stderr), if it\n    /// has been captured.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stderr: Option<ChildStderr>,\n}\n\nimpl AsInner<imp::Process> for Child {\n    fn as_inner(&self) -> &imp::Process {\n}\n}\n\nimpl FromInner<(imp::Process, imp::StdioPipes)> for Child {\n    fn from_inner((handle, io): (imp::Process, imp::StdioPipes)) -> Child {\n}\n}\n\nimpl IntoInner<imp::Process> for Child {\n    fn into_inner(self) -> imp::Process {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Child {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A handle to a child process's standard input (stdin).\n///\n/// This struct is used in the [`stdin`] field on [`Child`].\n///\n/// When an instance of `ChildStdin` is [dropped], the `ChildStdin`'s underlying\n/// file handle will be closed. If the child process was blocked on input prior\n/// to being dropped, it will become unblocked after dropping.\n///\n/// [`Child`]: struct.Child.html\n/// [`stdin`]: struct.Child.html#structfield.stdin\n/// [dropped]: ../ops/trait.Drop.html\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ChildStdin {\n    inner: AnonPipe,\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl Write for ChildStdin {\n    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n}\n\n    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n}\n\n    fn flush(&mut self) -> io::Result<()> {\n}\n}\n\nimpl AsInner<AnonPipe> for ChildStdin {\n    fn as_inner(&self) -> &AnonPipe {\n}\n}\n\nimpl IntoInner<AnonPipe> for ChildStdin {\n    fn into_inner(self) -> AnonPipe {\n}\n}\n\nimpl FromInner<AnonPipe> for ChildStdin {\n    fn from_inner(pipe: AnonPipe) -> ChildStdin {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ChildStdin {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A handle to a child process's standard output (stdout).\n///\n/// This struct is used in the [`stdout`] field on [`Child`].\n///\n/// When an instance of `ChildStdout` is [dropped], the `ChildStdout`'s\n/// underlying file handle will be closed.\n///\n/// [`Child`]: struct.Child.html\n/// [`stdout`]: struct.Child.html#structfield.stdout\n/// [dropped]: ../ops/trait.Drop.html\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ChildStdout {\n    inner: AnonPipe,\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl Read for ChildStdout {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\n\nimpl AsInner<AnonPipe> for ChildStdout {\n    fn as_inner(&self) -> &AnonPipe {\n}\n}\n\nimpl IntoInner<AnonPipe> for ChildStdout {\n    fn into_inner(self) -> AnonPipe {\n}\n}\n\nimpl FromInner<AnonPipe> for ChildStdout {\n    fn from_inner(pipe: AnonPipe) -> ChildStdout {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ChildStdout {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A handle to a child process's stderr.\n///\n/// This struct is used in the [`stderr`] field on [`Child`].\n///\n/// When an instance of `ChildStderr` is [dropped], the `ChildStderr`'s\n/// underlying file handle will be closed.\n///\n/// [`Child`]: struct.Child.html\n/// [`stderr`]: struct.Child.html#structfield.stderr\n/// [dropped]: ../ops/trait.Drop.html\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ChildStderr {\n    inner: AnonPipe,\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl Read for ChildStderr {\n    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n}\n\n    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n}\n\n    #[inline]\n    unsafe fn initializer(&self) -> Initializer {\n}\n}\n\nimpl AsInner<AnonPipe> for ChildStderr {\n    fn as_inner(&self) -> &AnonPipe {\n}\n}\n\nimpl IntoInner<AnonPipe> for ChildStderr {\n    fn into_inner(self) -> AnonPipe {\n}\n}\n\nimpl FromInner<AnonPipe> for ChildStderr {\n    fn from_inner(pipe: AnonPipe) -> ChildStderr {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for ChildStderr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A process builder, providing fine-grained control\n/// over how a new process should be spawned.\n///\n/// A default configuration can be\n/// generated using `Command::new(program)`, where `program` gives a path to the\n/// program to be executed. Additional builder methods allow the configuration\n/// to be changed (for example, by adding arguments) prior to spawning:\n///\n/// ```\n/// use std::process::Command;\n///\n/// let output = if cfg!(target_os = \"windows\") {\n///     Command::new(\"cmd\")\n///             .args(&[\"/C\", \"echo hello\"])\n///             .output()\n///             .expect(\"failed to execute process\")\n/// } else {\n///     Command::new(\"sh\")\n///             .arg(\"-c\")\n///             .arg(\"echo hello\")\n///             .output()\n///             .expect(\"failed to execute process\")\n/// };\n///\n/// let hello = output.stdout;\n/// ```\n///\n/// `Command` can be reused to spawn multiple processes. The builder methods\n/// change the command without needing to immediately spawn the process.\n///\n/// ```no_run\n/// use std::process::Command;\n///\n/// let mut echo_hello = Command::new(\"sh\");\n/// echo_hello.arg(\"-c\")\n///           .arg(\"echo hello\");\n/// let hello_1 = echo_hello.output().expect(\"failed to execute process\");\n/// let hello_2 = echo_hello.output().expect(\"failed to execute process\");\n/// ```\n///\n/// Similarly, you can call builder methods after spawning a process and then\n/// spawn a new process with the modified settings.\n///\n/// ```no_run\n/// use std::process::Command;\n///\n/// let mut list_dir = Command::new(\"ls\");\n///\n/// // Execute `ls` in the current directory of the program.\n/// list_dir.status().expect(\"process failed to execute\");\n///\n/// println!();\n///\n/// // Change `ls` to execute in the root directory.\n/// list_dir.current_dir(\"/\");\n///\n/// // And then execute `ls` again but in the root directory.\n/// list_dir.status().expect(\"process failed to execute\");\n/// ```\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Command {\n    inner: imp::Command,\n}\n\nimpl Command {\n    /// Constructs a new `Command` for launching the program at\n    /// path `program`, with the following default configuration:\n    ///\n    /// * No arguments to the program\n    /// * Inherit the current process's environment\n    /// * Inherit the current process's working directory\n    /// * Inherit stdin/stdout/stderr for `spawn` or `status`, but create pipes for `output`\n    ///\n    /// Builder methods are provided to change these defaults and\n    /// otherwise configure the process.\n    ///\n    /// If `program` is not an absolute path, the `PATH` will be searched in\n    /// an OS-defined way.\n    ///\n    /// The search path to be used may be controlled by setting the\n    /// `PATH` environment variable on the Command,\n    /// but this has some implementation limitations on Windows\n    /// (see issue #37519).\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"sh\")\n    ///         .spawn()\n    ///         .expect(\"sh command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn new<S: AsRef<OsStr>>(program: S) -> Command {\n}\n\n    /// Adds an argument to pass to the program.\n    ///\n    /// Only one argument can be passed per use. So instead of:\n    ///\n    /// ```no_run\n    /// # std::process::Command::new(\"sh\")\n    /// .arg(\"-C /path/to/repo\")\n    /// # ;\n    /// ```\n    ///\n    /// usage would be:\n    ///\n    /// ```no_run\n    /// # std::process::Command::new(\"sh\")\n    /// .arg(\"-C\")\n    /// .arg(\"/path/to/repo\")\n    /// # ;\n    /// ```\n    ///\n    /// To pass multiple arguments see [`args`].\n    ///\n    /// [`args`]: #method.args\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .arg(\"-l\")\n    ///         .arg(\"-a\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {\n}\n\n    /// Adds multiple arguments to pass to the program.\n    ///\n    /// To pass a single argument see [`arg`].\n    ///\n    /// [`arg`]: #method.arg\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .args(&[\"-l\", \"-a\"])\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn args<I, S>(&mut self, args: I) -> &mut Command\n    where\n        I: IntoIterator<Item = S>,\n        S: AsRef<OsStr>,\n    {\n}\n\n    /// Inserts or updates an environment variable mapping.\n    ///\n    /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n    /// and case-sensitive on all other platforms.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .env(\"PATH\", \"/bin\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command\n    where\n        K: AsRef<OsStr>,\n        V: AsRef<OsStr>,\n    {\n}\n\n    /// Adds or updates multiple environment variable mappings.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    /// use std::env;\n    /// use std::collections::HashMap;\n    ///\n    /// let filtered_env : HashMap<String, String> =\n    ///     env::vars().filter(|&(ref k, _)|\n    ///         k == \"TERM\" || k == \"TZ\" || k == \"LANG\" || k == \"PATH\"\n    ///     ).collect();\n    ///\n    /// Command::new(\"printenv\")\n    ///         .stdin(Stdio::null())\n    ///         .stdout(Stdio::inherit())\n    ///         .env_clear()\n    ///         .envs(&filtered_env)\n    ///         .spawn()\n    ///         .expect(\"printenv failed to start\");\n    /// ```\n    #[stable(feature = \"command_envs\", since = \"1.19.0\")]\n    pub fn envs<I, K, V>(&mut self, vars: I) -> &mut Command\n    where\n        I: IntoIterator<Item = (K, V)>,\n        K: AsRef<OsStr>,\n        V: AsRef<OsStr>,\n    {\n}\n\n    /// Removes an environment variable mapping.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .env_remove(\"PATH\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Command {\n}\n\n    /// Clears the entire environment map for the child process.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .env_clear()\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn env_clear(&mut self) -> &mut Command {\n}\n\n    /// Sets the working directory for the child process.\n    ///\n    /// # Platform-specific behavior\n    ///\n    /// If the program path is relative (e.g., `\"./script.sh\"`), it's ambiguous\n    /// whether it should be interpreted relative to the parent's working\n    /// directory or relative to `current_dir`. The behavior in this case is\n    /// platform specific and unstable, and it's recommended to use\n    /// [`canonicalize`] to get an absolute program path instead.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .current_dir(\"/bin\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    ///\n    /// [`canonicalize`]: ../fs/fn.canonicalize.html\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn current_dir<P: AsRef<Path>>(&mut self, dir: P) -> &mut Command {\n}\n\n    /// Configuration for the child process's standard input (stdin) handle.\n    ///\n    /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n    /// defaults to [`piped`] when used with `output`.\n    ///\n    /// [`inherit`]: struct.Stdio.html#method.inherit\n    /// [`piped`]: struct.Stdio.html#method.piped\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// Command::new(\"ls\")\n    ///         .stdin(Stdio::null())\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn stdin<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command {\n}\n\n    /// Configuration for the child process's standard output (stdout) handle.\n    ///\n    /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n    /// defaults to [`piped`] when used with `output`.\n    ///\n    /// [`inherit`]: struct.Stdio.html#method.inherit\n    /// [`piped`]: struct.Stdio.html#method.piped\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// Command::new(\"ls\")\n    ///         .stdout(Stdio::null())\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn stdout<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command {\n}\n\n    /// Configuration for the child process's standard error (stderr) handle.\n    ///\n    /// Defaults to [`inherit`] when used with `spawn` or `status`, and\n    /// defaults to [`piped`] when used with `output`.\n    ///\n    /// [`inherit`]: struct.Stdio.html#method.inherit\n    /// [`piped`]: struct.Stdio.html#method.piped\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// Command::new(\"ls\")\n    ///         .stderr(Stdio::null())\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn stderr<T: Into<Stdio>>(&mut self, cfg: T) -> &mut Command {\n}\n\n    /// Executes the command as a child process, returning a handle to it.\n    ///\n    /// By default, stdin, stdout and stderr are inherited from the parent.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// Command::new(\"ls\")\n    ///         .spawn()\n    ///         .expect(\"ls command failed to start\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn spawn(&mut self) -> io::Result<Child> {\n}\n\n    /// Executes the command as a child process, waiting for it to finish and\n    /// collecting all of its output.\n    ///\n    /// By default, stdout and stderr are captured (and used to provide the\n    /// resulting output). Stdin is not inherited from the parent and any\n    /// attempt by the child process to read from the stdin stream will result\n    /// in the stream immediately closing.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::process::Command;\n    /// use std::io::{self, Write};\n    /// let output = Command::new(\"/bin/cat\")\n    ///                      .arg(\"file.txt\")\n    ///                      .output()\n    ///                      .expect(\"failed to execute process\");\n    ///\n    /// println!(\"status: {}\", output.status);\n    /// io::stdout().write_all(&output.stdout).unwrap();\n    /// io::stderr().write_all(&output.stderr).unwrap();\n    ///\n    /// assert!(output.status.success());\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn output(&mut self) -> io::Result<Output> {\n}\n\n    /// Executes a command as a child process, waiting for it to finish and\n    /// collecting its exit status.\n    ///\n    /// By default, stdin, stdout and stderr are inherited from the parent.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"/bin/cat\")\n    ///                      .arg(\"file.txt\")\n    ///                      .status()\n    ///                      .expect(\"failed to execute process\");\n    ///\n    /// println!(\"process exited with: {}\", status);\n    ///\n    /// assert!(status.success());\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn status(&mut self) -> io::Result<ExitStatus> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for Command {\n    /// Format the program and arguments of a Command for display. Any\n    /// non-utf8 data is lossily converted using the utf8 replacement\n    /// character.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl AsInner<imp::Command> for Command {\n    fn as_inner(&self) -> &imp::Command {\n}\n}\n\nimpl AsInnerMut<imp::Command> for Command {\n    fn as_inner_mut(&mut self) -> &mut imp::Command {\n}\n}\n\n/// The output of a finished process.\n///\n/// This is returned in a Result by either the [`output`] method of a\n/// [`Command`], or the [`wait_with_output`] method of a [`Child`]\n/// process.\n///\n/// [`Command`]: struct.Command.html\n/// [`Child`]: struct.Child.html\n/// [`output`]: struct.Command.html#method.output\n/// [`wait_with_output`]: struct.Child.html#method.wait_with_output\n#[derive(PartialEq, Eq, Clone)]\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Output {\n    /// The status (exit code) of the process.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub status: ExitStatus,\n    /// The data that the process wrote to stdout.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stdout: Vec<u8>,\n    /// The data that the process wrote to stderr.\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub stderr: Vec<u8>,\n}\n\n// If either stderr or stdout are valid utf8 strings it prints the valid\n// strings, otherwise it prints the byte sequence instead\n#[stable(feature = \"process_output_debug\", since = \"1.7.0\")]\nimpl fmt::Debug for Output {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// Describes what to do with a standard I/O stream for a child process when\n/// passed to the [`stdin`], [`stdout`], and [`stderr`] methods of [`Command`].\n///\n/// [`stdin`]: struct.Command.html#method.stdin\n/// [`stdout`]: struct.Command.html#method.stdout\n/// [`stderr`]: struct.Command.html#method.stderr\n/// [`Command`]: struct.Command.html\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct Stdio(imp::Stdio);\n\nimpl Stdio {\n    /// A new pipe should be arranged to connect the parent and child processes.\n    ///\n    /// # Examples\n    ///\n    /// With stdout:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::piped())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"Hello, world!\\n\");\n    /// // Nothing echoed to console\n    /// ```\n    ///\n    /// With stdin:\n    ///\n    /// ```no_run\n    /// use std::io::Write;\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let mut child = Command::new(\"rev\")\n    ///     .stdin(Stdio::piped())\n    ///     .stdout(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"Failed to spawn child process\");\n    ///\n    /// {\n    ///     let stdin = child.stdin.as_mut().expect(\"Failed to open stdin\");\n    ///     stdin.write_all(\"Hello, world!\".as_bytes()).expect(\"Failed to write to stdin\");\n    /// }\n    ///\n    /// let output = child.wait_with_output().expect(\"Failed to read stdout\");\n    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"!dlrow ,olleH\");\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn piped() -> Stdio {\n}\n\n    /// The child inherits from the corresponding parent descriptor.\n    ///\n    /// # Examples\n    ///\n    /// With stdout:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::inherit())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n    /// // \"Hello, world!\" echoed to console\n    /// ```\n    ///\n    /// With stdin:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    /// use std::io::{self, Write};\n    ///\n    /// let output = Command::new(\"rev\")\n    ///     .stdin(Stdio::inherit())\n    ///     .stdout(Stdio::piped())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// print!(\"You piped in the reverse of: \");\n    /// io::stdout().write_all(&output.stdout).unwrap();\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn inherit() -> Stdio {\n}\n\n    /// This stream will be ignored. This is the equivalent of attaching the\n    /// stream to `/dev/null`\n    ///\n    /// # Examples\n    ///\n    /// With stdout:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::null())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n    /// // Nothing echoed to console\n    /// ```\n    ///\n    /// With stdin:\n    ///\n    /// ```no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let output = Command::new(\"rev\")\n    ///     .stdin(Stdio::null())\n    ///     .stdout(Stdio::piped())\n    ///     .output()\n    ///     .expect(\"Failed to execute command\");\n    ///\n    /// assert_eq!(String::from_utf8_lossy(&output.stdout), \"\");\n    /// // Ignores any piped-in input\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn null() -> Stdio {\n}\n}\n\nimpl FromInner<imp::Stdio> for Stdio {\n    fn from_inner(inner: imp::Stdio) -> Stdio {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Stdio {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From<ChildStdin> for Stdio {\n    /// Converts a `ChildStdin` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// `ChildStdin` will be converted to `Stdio` using `Stdio::from` under the hood.\n    ///\n    /// ```rust,no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .stdin(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// let _echo = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(reverse.stdin.unwrap()) // Converted into a Stdio here\n    ///     .output()\n    ///     .expect(\"failed echo command\");\n    ///\n    /// // \"!dlrow ,olleH\" echoed to console\n    /// ```\n    fn from(child: ChildStdin) -> Stdio {\n}\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From<ChildStdout> for Stdio {\n    /// Converts a `ChildStdout` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// `ChildStdout` will be converted to `Stdio` using `Stdio::from` under the hood.\n    ///\n    /// ```rust,no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let hello = Command::new(\"echo\")\n    ///     .arg(\"Hello, world!\")\n    ///     .stdout(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed echo command\");\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .stdin(hello.stdout.unwrap())  // Converted into a Stdio here\n    ///     .output()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// assert_eq!(reverse.stdout, b\"!dlrow ,olleH\\n\");\n    /// ```\n    fn from(child: ChildStdout) -> Stdio {\n}\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From<ChildStderr> for Stdio {\n    /// Converts a `ChildStderr` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .arg(\"non_existing_file.txt\")\n    ///     .stderr(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// let cat = Command::new(\"cat\")\n    ///     .arg(\"-\")\n    ///     .stdin(reverse.stderr.unwrap()) // Converted into a Stdio here\n    ///     .output()\n    ///     .expect(\"failed echo command\");\n    ///\n    /// assert_eq!(\n    ///     String::from_utf8_lossy(&cat.stdout),\n    ///     \"rev: cannot open non_existing_file.txt: No such file or directory\\n\"\n    /// );\n    /// ```\n    fn from(child: ChildStderr) -> Stdio {\n}\n}\n\n#[stable(feature = \"stdio_from\", since = \"1.20.0\")]\nimpl From<fs::File> for Stdio {\n    /// Converts a `File` into a `Stdio`\n    ///\n    /// # Examples\n    ///\n    /// `File` will be converted to `Stdio` using `Stdio::from` under the hood.\n    ///\n    /// ```rust,no_run\n    /// use std::fs::File;\n    /// use std::process::Command;\n    ///\n    /// // With the `foo.txt` file containing `Hello, world!\"\n    /// let file = File::open(\"foo.txt\").unwrap();\n    ///\n    /// let reverse = Command::new(\"rev\")\n    ///     .stdin(file)  // Implicit File conversion into a Stdio\n    ///     .output()\n    ///     .expect(\"failed reverse command\");\n    ///\n    /// assert_eq!(reverse.stdout, b\"!dlrow ,olleH\");\n    /// ```\n    fn from(file: fs::File) -> Stdio {\n}\n}\n\n/// Describes the result of a process after it has terminated.\n///\n/// This `struct` is used to represent the exit status of a child process.\n/// Child processes are created via the [`Command`] struct and their exit\n/// status is exposed through the [`status`] method, or the [`wait`] method\n/// of a [`Child`] process.\n///\n/// [`Command`]: struct.Command.html\n/// [`Child`]: struct.Child.html\n/// [`status`]: struct.Command.html#method.status\n/// [`wait`]: struct.Child.html#method.wait\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n#[stable(feature = \"process\", since = \"1.0.0\")]\npub struct ExitStatus(imp::ExitStatus);\n\nimpl ExitStatus {\n    /// Was termination successful? Signal termination is not considered a\n    /// success, and success is defined as a zero exit status.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"mkdir\")\n    ///                      .arg(\"projects\")\n    ///                      .status()\n    ///                      .expect(\"failed to execute mkdir\");\n    ///\n    /// if status.success() {\n    ///     println!(\"'projects/' directory created\");\n    /// } else {\n    ///     println!(\"failed to create 'projects/' directory\");\n    /// }\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn success(&self) -> bool {\n}\n\n    /// Returns the exit code of the process, if any.\n    ///\n    /// On Unix, this will return `None` if the process was terminated\n    /// by a signal; `std::os::unix` provides an extension trait for\n    /// extracting the signal and other details from the `ExitStatus`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let status = Command::new(\"mkdir\")\n    ///                      .arg(\"projects\")\n    ///                      .status()\n    ///                      .expect(\"failed to execute mkdir\");\n    ///\n    /// match status.code() {\n    ///     Some(code) => println!(\"Exited with status code: {}\", code),\n    ///     None       => println!(\"Process terminated by signal\")\n    /// }\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn code(&self) -> Option<i32> {\n}\n}\n\nimpl AsInner<imp::ExitStatus> for ExitStatus {\n    fn as_inner(&self) -> &imp::ExitStatus {\n}\n}\n\nimpl FromInner<imp::ExitStatus> for ExitStatus {\n    fn from_inner(s: imp::ExitStatus) -> ExitStatus {\n}\n}\n\n#[stable(feature = \"process\", since = \"1.0.0\")]\nimpl fmt::Display for ExitStatus {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// This type represents the status code a process can return to its\n/// parent under normal termination.\n///\n/// Numeric values used in this type don't have portable meanings, and\n/// different platforms may mask different amounts of them.\n///\n/// For the platform's canonical successful and unsuccessful codes, see\n/// the [`SUCCESS`] and [`FAILURE`] associated items.\n///\n/// [`SUCCESS`]: #associatedconstant.SUCCESS\n/// [`FAILURE`]: #associatedconstant.FAILURE\n///\n/// **Warning**: While various forms of this were discussed in [RFC #1937],\n/// it was ultimately cut from that RFC, and thus this type is more subject\n/// to change even than the usual unstable item churn.\n///\n/// [RFC #1937]: https://github.com/rust-lang/rfcs/pull/1937\n#[derive(Clone, Copy, Debug)]\n#[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\npub struct ExitCode(imp::ExitCode);\n\n#[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\nimpl ExitCode {\n    /// The canonical ExitCode for successful termination on this platform.\n    ///\n    /// Note that a `()`-returning `main` implicitly results in a successful\n    /// termination, so there's no need to return this from `main` unless\n    /// you're also returning other possible codes.\n    #[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\n    pub const SUCCESS: ExitCode = ExitCode(imp::ExitCode::SUCCESS);\n\n    /// The canonical ExitCode for unsuccessful termination on this platform.\n    ///\n    /// If you're only returning this and `SUCCESS` from `main`, consider\n    /// instead returning `Err(_)` and `Ok(())` respectively, which will\n    /// return the same codes (but will also `eprintln!` the error).\n    #[unstable(feature = \"process_exitcode_placeholder\", issue = \"48711\")]\n    pub const FAILURE: ExitCode = ExitCode(imp::ExitCode::FAILURE);\n}\n\nimpl Child {\n    /// Forces the child process to exit. If the child has already exited, an [`InvalidInput`]\n    /// error is returned.\n    ///\n    /// The mapping to [`ErrorKind`]s is not part of the compatibility contract of the function,\n    /// especially the [`Other`] kind might change to more specific kinds in the future.\n    ///\n    /// This is equivalent to sending a SIGKILL on Unix platforms.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut command = Command::new(\"yes\");\n    /// if let Ok(mut child) = command.spawn() {\n    ///     child.kill().expect(\"command wasn't running\");\n    /// } else {\n    ///     println!(\"yes command didn't start\");\n    /// }\n    /// ```\n    ///\n    /// [`ErrorKind`]: ../io/enum.ErrorKind.html\n    /// [`InvalidInput`]: ../io/enum.ErrorKind.html#variant.InvalidInput\n    /// [`Other`]: ../io/enum.ErrorKind.html#variant.Other\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn kill(&mut self) -> io::Result<()> {\n}\n\n    /// Returns the OS-assigned process identifier associated with this child.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut command = Command::new(\"ls\");\n    /// if let Ok(child) = command.spawn() {\n    ///     println!(\"Child's ID is {}\", child.id());\n    /// } else {\n    ///     println!(\"ls command didn't start\");\n    /// }\n    /// ```\n    #[stable(feature = \"process_id\", since = \"1.3.0\")]\n    pub fn id(&self) -> u32 {\n}\n\n    /// Waits for the child to exit completely, returning the status that it\n    /// exited with. This function will continue to have the same return value\n    /// after it has been called at least once.\n    ///\n    /// The stdin handle to the child process, if any, will be closed\n    /// before waiting. This helps avoid deadlock: it ensures that the\n    /// child does not block waiting for input from the parent, while\n    /// the parent waits for the child to exit.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut command = Command::new(\"ls\");\n    /// if let Ok(mut child) = command.spawn() {\n    ///     child.wait().expect(\"command wasn't running\");\n    ///     println!(\"Child has finished its execution!\");\n    /// } else {\n    ///     println!(\"ls command didn't start\");\n    /// }\n    /// ```\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n}\n\n    /// Attempts to collect the exit status of the child if it has already\n    /// exited.\n    ///\n    /// This function will not block the calling thread and will only\n    /// check to see if the child process has exited or not. If the child has\n    /// exited then on Unix the process ID is reaped. This function is\n    /// guaranteed to repeatedly return a successful exit status so long as the\n    /// child has already exited.\n    ///\n    /// If the child has exited, then `Ok(Some(status))` is returned. If the\n    /// exit status is not available at this time then `Ok(None)` is returned.\n    /// If an error occurs, then that error is returned.\n    ///\n    /// Note that unlike `wait`, this function will not attempt to drop stdin.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```no_run\n    /// use std::process::Command;\n    ///\n    /// let mut child = Command::new(\"ls\").spawn().unwrap();\n    ///\n    /// match child.try_wait() {\n    ///     Ok(Some(status)) => println!(\"exited with: {}\", status),\n    ///     Ok(None) => {\n    ///         println!(\"status not ready yet, let's really wait\");\n    ///         let res = child.wait();\n    ///         println!(\"result: {:?}\", res);\n    ///     }\n    ///     Err(e) => println!(\"error attempting to wait: {}\", e),\n    /// }\n    /// ```\n    #[stable(feature = \"process_try_wait\", since = \"1.18.0\")]\n    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n}\n\n    /// Simultaneously waits for the child to exit and collect all remaining\n    /// output on the stdout/stderr handles, returning an `Output`\n    /// instance.\n    ///\n    /// The stdin handle to the child process, if any, will be closed\n    /// before waiting. This helps avoid deadlock: it ensures that the\n    /// child does not block waiting for input from the parent, while\n    /// the parent waits for the child to exit.\n    ///\n    /// By default, stdin, stdout and stderr are inherited from the parent.\n    /// In order to capture the output into this `Result<Output>` it is\n    /// necessary to create new pipes between parent and child. Use\n    /// `stdout(Stdio::piped())` or `stderr(Stdio::piped())`, respectively.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::process::{Command, Stdio};\n    ///\n    /// let child = Command::new(\"/bin/cat\")\n    ///     .arg(\"file.txt\")\n    ///     .stdout(Stdio::piped())\n    ///     .spawn()\n    ///     .expect(\"failed to execute child\");\n    ///\n    /// let output = child\n    ///     .wait_with_output()\n    ///     .expect(\"failed to wait on child\");\n    ///\n    /// assert!(output.status.success());\n    /// ```\n    ///\n    #[stable(feature = \"process\", since = \"1.0.0\")]\n    pub fn wait_with_output(mut self) -> io::Result<Output> {\n}\n}\n\n/// Terminates the current process with the specified exit code.\n///\n/// This function will never return and will immediately terminate the current\n/// process. The exit code is passed through to the underlying OS and will be\n/// available for consumption by another process.\n///\n/// Note that because this function never returns, and that it terminates the\n/// process, no destructors on the current stack or any other thread's stack\n/// will be run. If a clean shutdown is needed it is recommended to only call\n/// this function at a known point where there are no more destructors left\n/// to run.\n///\n/// ## Platform-specific behavior\n///\n/// **Unix**: On Unix-like platforms, it is unlikely that all 32 bits of `exit`\n/// will be visible to a parent process inspecting the exit code. On most\n/// Unix-like platforms, only the eight least-significant bits are considered.\n///\n/// # Examples\n///\n/// Due to this function’s behavior regarding destructors, a conventional way\n/// to use the function is to extract the actual computation to another\n/// function and compute the exit code from its return value:\n///\n/// ```\n/// fn run_app() -> Result<(), ()> {\n///     // Application logic here\n///     Ok(())\n/// }\n///\n/// fn main() {\n///     std::process::exit(match run_app() {\n///         Ok(_) => 0,\n///         Err(err) => {\n///             eprintln!(\"error: {:?}\", err);\n///             1\n///         }\n///     });\n/// }\n/// ```\n///\n/// Due to [platform-specific behavior], the exit code for this example will be\n/// `0` on Linux, but `256` on Windows:\n///\n/// ```no_run\n/// use std::process;\n///\n/// process::exit(0x0100);\n/// ```\n///\n/// [platform-specific behavior]: #platform-specific-behavior\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn exit(code: i32) -> ! {\n}\n\n/// Terminates the process in an abnormal fashion.\n///\n/// The function will never return and will immediately terminate the current\n/// process in a platform specific \"abnormal\" manner.\n///\n/// Note that because this function never returns, and that it terminates the\n/// process, no destructors on the current stack or any other thread's stack\n/// will be run.\n///\n/// This is in contrast to the default behaviour of [`panic!`] which unwinds\n/// the current thread's stack and calls all destructors.\n/// When `panic=\"abort\"` is set, either as an argument to `rustc` or in a\n/// crate's Cargo.toml, [`panic!`] and `abort` are similar. However,\n/// [`panic!`] will still call the [panic hook] while `abort` will not.\n///\n/// If a clean shutdown is needed it is recommended to only call\n/// this function at a known point where there are no more destructors left\n/// to run.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::process;\n///\n/// fn main() {\n///     println!(\"aborting\");\n///\n///     process::abort();\n///\n///     // execution never gets here\n/// }\n/// ```\n///\n/// The `abort` function terminates the process, so the destructor will not\n/// get run on the example below:\n///\n/// ```no_run\n/// use std::process;\n///\n/// struct HasDrop;\n///\n/// impl Drop for HasDrop {\n///     fn drop(&mut self) {\n///         println!(\"This will never be printed!\");\n///     }\n/// }\n///\n/// fn main() {\n///     let _x = HasDrop;\n///     process::abort();\n///     // the destructor implemented for HasDrop will never get run\n/// }\n/// ```\n///\n/// [`panic!`]: ../../std/macro.panic.html\n/// [panic hook]: ../../std/panic/fn.set_hook.html\n#[stable(feature = \"process_abort\", since = \"1.17.0\")]\npub fn abort() -> ! {\n}\n\n/// Returns the OS-assigned process identifier associated with this process.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```no_run\n/// use std::process;\n///\n/// println!(\"My pid is {}\", process::id());\n/// ```\n///\n///\n#[stable(feature = \"getpid\", since = \"1.26.0\")]\npub fn id() -> u32 {\n}\n\n/// A trait for implementing arbitrary return types in the `main` function.\n///\n/// The C-main function only supports to return integers as return type.\n/// So, every type implementing the `Termination` trait has to be converted\n/// to an integer.\n///\n/// The default implementations are returning `libc::EXIT_SUCCESS` to indicate\n/// a successful execution. In case of a failure, `libc::EXIT_FAILURE` is returned.\n#[cfg_attr(not(test), lang = \"termination\")]\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n#[rustc_on_unimplemented(\n    message = \"`main` has invalid return type `{S}`\",\n    label = \"`main` can only return types that implement `{Termination}`\"\n)]\npub trait Termination {\n    /// Is called to get the representation of the value as status code.\n    /// This status code is returned to the operating system.\n    fn report(self) -> i32;\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl Termination for () {\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl<E: fmt::Debug> Termination for Result<(), E> {\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl Termination for ! {\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl<E: fmt::Debug> Termination for Result<!, E> {\n}\n\n#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\nimpl Termination for ExitCode {\n}\n\n#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\nmod tests {\n    use crate::io::prelude::*;\n\n    use super::{Command, Output, Stdio};\n    use crate::io::ErrorKind;\n    use crate::str;\n\n    // FIXME(#10380) these tests should not all be ignored on android.\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn smoke() {\n}\n\n    #[test]\n    #[cfg_attr(target_os = \"android\", ignore)]\n    fn smoke_failure() {\n}\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn exit_reported_right() {\n}\n\n    #[test]\n    #[cfg(unix)]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn signal_reported_right() {\n}\n\n    pub fn run_output(mut cmd: Command) -> String {\n}\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn stdout_works() {\n}\n\n    #[test]\n    #[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\n    fn set_current_dir_works() {\n}\n\n    #[test]\n    #[cfg_attr(any(windows, target_os = \"android\", target_os = \"vxworks\"), ignore)]\n    fn stdin_works() {\n}\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_process_status() {\n}\n\n    #[test]\n    fn test_process_output_fail_to_start() {\n}\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_process_output_output() {\n}\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_process_output_error() {\n}\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_finish_once() {\n}\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_finish_twice() {\n}\n\n    #[test]\n    #[cfg_attr(any(target_os = \"vxworks\", target_os = \"android\"), ignore)]\n    fn test_wait_with_output_once() {\n}\n\n    #[cfg(all(unix, not(target_os = \"android\")))]\n    pub fn env_cmd() -> Command {\n}\n    #[cfg(target_os = \"android\")]\n    pub fn env_cmd() -> Command {\n}\n\n    #[cfg(windows)]\n    pub fn env_cmd() -> Command {\n}\n\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_override_env() {\n}\n\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_add_to_env() {\n}\n\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_capture_env_at_spawn() {\n}\n\n    // Regression tests for #30858.\n    #[test]\n    fn test_interior_nul_in_progname_is_error() {\n}\n\n    #[test]\n    fn test_interior_nul_in_arg_is_error() {\n}\n\n    #[test]\n    fn test_interior_nul_in_args_is_error() {\n}\n\n    #[test]\n    fn test_interior_nul_in_current_dir_is_error() {\n}\n\n    // Regression tests for #30862.\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_interior_nul_in_env_key_is_error() {\n}\n\n    #[test]\n    #[cfg_attr(target_os = \"vxworks\", ignore)]\n    fn test_interior_nul_in_env_value_is_error() {\n}\n\n    /// Tests that process creation flags work by debugging a process.\n    /// Other creation flags make it hard or impossible to detect\n    /// behavioral changes in the process.\n    #[test]\n    #[cfg(windows)]\n    fn test_creation_flags() {\n}\n\n    #[test]\n    fn test_command_implements_send() {\n}\n}\n}\npub mod sync {\n//! Useful synchronization primitives.\n//!\n//! ## The need for synchronization\n//!\n//! Conceptually, a Rust program is a series of operations which will\n//! be executed on a computer. The timeline of events happening in the\n//! program is consistent with the order of the operations in the code.\n//!\n//! Consider the following code, operating on some global static variables:\n//!\n//! ```rust\n//! static mut A: u32 = 0;\n//! static mut B: u32 = 0;\n//! static mut C: u32 = 0;\n//!\n//! fn main() {\n//!     unsafe {\n//!         A = 3;\n//!         B = 4;\n//!         A = A + B;\n//!         C = B;\n//!         println!(\"{} {} {}\", A, B, C);\n//!         C = A;\n//!     }\n//! }\n//! ```\n//!\n//! It appears as if some variables stored in memory are changed, an addition\n//! is performed, result is stored in `A` and the variable `C` is\n//! modified twice.\n//!\n//! When only a single thread is involved, the results are as expected:\n//! the line `7 4 4` gets printed.\n//!\n//! As for what happens behind the scenes, when optimizations are enabled the\n//! final generated machine code might look very different from the code:\n//!\n//! - The first store to `C` might be moved before the store to `A` or `B`,\n//!   _as if_ we had written `C = 4; A = 3; B = 4`.\n//!\n//! - Assignment of `A + B` to `A` might be removed, since the sum can be stored\n//!   in a temporary location until it gets printed, with the global variable\n//!   never getting updated.\n//!\n//! - The final result could be determined just by looking at the code\n//!   at compile time, so [constant folding] might turn the whole\n//!   block into a simple `println!(\"7 4 4\")`.\n//!\n//! The compiler is allowed to perform any combination of these\n//! optimizations, as long as the final optimized code, when executed,\n//! produces the same results as the one without optimizations.\n//!\n//! Due to the [concurrency] involved in modern computers, assumptions\n//! about the program's execution order are often wrong. Access to\n//! global variables can lead to nondeterministic results, **even if**\n//! compiler optimizations are disabled, and it is **still possible**\n//! to introduce synchronization bugs.\n//!\n//! Note that thanks to Rust's safety guarantees, accessing global (static)\n//! variables requires `unsafe` code, assuming we don't use any of the\n//! synchronization primitives in this module.\n//!\n//! [constant folding]: https://en.wikipedia.org/wiki/Constant_folding\n//! [concurrency]: https://en.wikipedia.org/wiki/Concurrency_(computer_science)\n//!\n//! ## Out-of-order execution\n//!\n//! Instructions can execute in a different order from the one we define, due to\n//! various reasons:\n//!\n//! - The **compiler** reordering instructions: If the compiler can issue an\n//!   instruction at an earlier point, it will try to do so. For example, it\n//!   might hoist memory loads at the top of a code block, so that the CPU can\n//!   start [prefetching] the values from memory.\n//!\n//!   In single-threaded scenarios, this can cause issues when writing\n//!   signal handlers or certain kinds of low-level code.\n//!   Use [compiler fences] to prevent this reordering.\n//!\n//! - A **single processor** executing instructions [out-of-order]:\n//!   Modern CPUs are capable of [superscalar] execution,\n//!   i.e., multiple instructions might be executing at the same time,\n//!   even though the machine code describes a sequential process.\n//!\n//!   This kind of reordering is handled transparently by the CPU.\n//!\n//! - A **multiprocessor** system executing multiple hardware threads\n//!   at the same time: In multi-threaded scenarios, you can use two\n//!   kinds of primitives to deal with synchronization:\n//!   - [memory fences] to ensure memory accesses are made visible to\n//!   other CPUs in the right order.\n//!   - [atomic operations] to ensure simultaneous access to the same\n//!   memory location doesn't lead to undefined behavior.\n//!\n//! [prefetching]: https://en.wikipedia.org/wiki/Cache_prefetching\n//! [compiler fences]: crate::sync::atomic::compiler_fence\n//! [out-of-order]: https://en.wikipedia.org/wiki/Out-of-order_execution\n//! [superscalar]: https://en.wikipedia.org/wiki/Superscalar_processor\n//! [memory fences]: crate::sync::atomic::fence\n//! [atomic operations]: crate::sync::atomic\n//!\n//! ## Higher-level synchronization objects\n//!\n//! Most of the low-level synchronization primitives are quite error-prone and\n//! inconvenient to use, which is why the standard library also exposes some\n//! higher-level synchronization objects.\n//!\n//! These abstractions can be built out of lower-level primitives.\n//! For efficiency, the sync objects in the standard library are usually\n//! implemented with help from the operating system's kernel, which is\n//! able to reschedule the threads while they are blocked on acquiring\n//! a lock.\n//!\n//! The following is an overview of the available synchronization\n//! objects:\n//!\n//! - [`Arc`]: Atomically Reference-Counted pointer, which can be used\n//!   in multithreaded environments to prolong the lifetime of some\n//!   data until all the threads have finished using it.\n//!\n//! - [`Barrier`]: Ensures multiple threads will wait for each other\n//!   to reach a point in the program, before continuing execution all\n//!   together.\n//!\n//! - [`Condvar`]: Condition Variable, providing the ability to block\n//!   a thread while waiting for an event to occur.\n//!\n//! - [`mpsc`]: Multi-producer, single-consumer queues, used for\n//!   message-based communication. Can provide a lightweight\n//!   inter-thread synchronisation mechanism, at the cost of some\n//!   extra memory.\n//!\n//! - [`Mutex`]: Mutual Exclusion mechanism, which ensures that at\n//!   most one thread at a time is able to access some data.\n//!\n//! - [`Once`]: Used for thread-safe, one-time initialization of a\n//!   global variable.\n//!\n//! - [`RwLock`]: Provides a mutual exclusion mechanism which allows\n//!   multiple readers at the same time, while allowing only one\n//!   writer at a time. In some cases, this can be more efficient than\n//!   a mutex.\n//!\n//! [`Arc`]: crate::sync::Arc\n//! [`Barrier`]: crate::sync::Barrier\n//! [`Condvar`]: crate::sync::Condvar\n//! [`mpsc`]: crate::sync::mpsc\n//! [`Mutex`]: crate::sync::Mutex\n//! [`Once`]: crate::sync::Once\n//! [`RwLock`]: crate::sync::RwLock\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use alloc_crate::sync::{Arc, Weak};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::sync::atomic;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::barrier::{Barrier, BarrierWaitResult};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::condvar::{Condvar, WaitTimeoutResult};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::mutex::{Mutex, MutexGuard};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\npub use self::once::{Once, OnceState, ONCE_INIT};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::rwlock::{RwLock, RwLockReadGuard, RwLockWriteGuard};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use crate::sys_common::poison::{LockResult, PoisonError, TryLockError, TryLockResult};\n\npub mod mpsc {\n// ignore-tidy-filelength\n\n//! Multi-producer, single-consumer FIFO queue communication primitives.\n//!\n//! This module provides message-based communication over channels, concretely\n//! defined among three types:\n//!\n//! * [`Sender`]\n//! * [`SyncSender`]\n//! * [`Receiver`]\n//!\n//! A [`Sender`] or [`SyncSender`] is used to send data to a [`Receiver`]. Both\n//! senders are clone-able (multi-producer) such that many threads can send\n//! simultaneously to one receiver (single-consumer).\n//!\n//! These channels come in two flavors:\n//!\n//! 1. An asynchronous, infinitely buffered channel. The [`channel`] function\n//!    will return a `(Sender, Receiver)` tuple where all sends will be\n//!    **asynchronous** (they never block). The channel conceptually has an\n//!    infinite buffer.\n//!\n//! 2. A synchronous, bounded channel. The [`sync_channel`] function will\n//!    return a `(SyncSender, Receiver)` tuple where the storage for pending\n//!    messages is a pre-allocated buffer of a fixed size. All sends will be\n//!    **synchronous** by blocking until there is buffer space available. Note\n//!    that a bound of 0 is allowed, causing the channel to become a \"rendezvous\"\n//!    channel where each sender atomically hands off a message to a receiver.\n//!\n//! [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n//! [`SyncSender`]: ../../../std/sync/mpsc/struct.SyncSender.html\n//! [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n//! [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n//! [`channel`]: ../../../std/sync/mpsc/fn.channel.html\n//! [`sync_channel`]: ../../../std/sync/mpsc/fn.sync_channel.html\n//!\n//! ## Disconnection\n//!\n//! The send and receive operations on channels will all return a [`Result`]\n//! indicating whether the operation succeeded or not. An unsuccessful operation\n//! is normally indicative of the other half of a channel having \"hung up\" by\n//! being dropped in its corresponding thread.\n//!\n//! Once half of a channel has been deallocated, most operations can no longer\n//! continue to make progress, so [`Err`] will be returned. Many applications\n//! will continue to [`unwrap`] the results returned from this module,\n//! instigating a propagation of failure among threads if one unexpectedly dies.\n//!\n//! [`Result`]: ../../../std/result/enum.Result.html\n//! [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n//! [`unwrap`]: ../../../std/result/enum.Result.html#method.unwrap\n//!\n//! # Examples\n//!\n//! Simple usage:\n//!\n//! ```\n//! use std::thread;\n//! use std::sync::mpsc::channel;\n//!\n//! // Create a simple streaming channel\n//! let (tx, rx) = channel();\n//! thread::spawn(move|| {\n//!     tx.send(10).unwrap();\n//! });\n//! assert_eq!(rx.recv().unwrap(), 10);\n//! ```\n//!\n//! Shared usage:\n//!\n//! ```\n//! use std::thread;\n//! use std::sync::mpsc::channel;\n//!\n//! // Create a shared channel that can be sent along from many threads\n//! // where tx is the sending half (tx for transmission), and rx is the receiving\n//! // half (rx for receiving).\n//! let (tx, rx) = channel();\n//! for i in 0..10 {\n//!     let tx = tx.clone();\n//!     thread::spawn(move|| {\n//!         tx.send(i).unwrap();\n//!     });\n//! }\n//!\n//! for _ in 0..10 {\n//!     let j = rx.recv().unwrap();\n//!     assert!(0 <= j && j < 10);\n//! }\n//! ```\n//!\n//! Propagating panics:\n//!\n//! ```\n//! use std::sync::mpsc::channel;\n//!\n//! // The call to recv() will return an error because the channel has already\n//! // hung up (or been deallocated)\n//! let (tx, rx) = channel::<i32>();\n//! drop(tx);\n//! assert!(rx.recv().is_err());\n//! ```\n//!\n//! Synchronous channels:\n//!\n//! ```\n//! use std::thread;\n//! use std::sync::mpsc::sync_channel;\n//!\n//! let (tx, rx) = sync_channel::<i32>(0);\n//! thread::spawn(move|| {\n//!     // This will wait for the parent thread to start receiving\n//!     tx.send(53).unwrap();\n//! });\n//! rx.recv().unwrap();\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n// A description of how Rust's channel implementation works\n//\n// Channels are supposed to be the basic building block for all other\n// concurrent primitives that are used in Rust. As a result, the channel type\n// needs to be highly optimized, flexible, and broad enough for use everywhere.\n//\n// The choice of implementation of all channels is to be built on lock-free data\n// structures. The channels themselves are then consequently also lock-free data\n// structures. As always with lock-free code, this is a very \"here be dragons\"\n// territory, especially because I'm unaware of any academic papers that have\n// gone into great length about channels of these flavors.\n//\n// ## Flavors of channels\n//\n// From the perspective of a consumer of this library, there is only one flavor\n// of channel. This channel can be used as a stream and cloned to allow multiple\n// senders. Under the hood, however, there are actually three flavors of\n// channels in play.\n//\n// * Flavor::Oneshots - these channels are highly optimized for the one-send use\n//                      case. They contain as few atomics as possible and\n//                      involve one and exactly one allocation.\n// * Streams - these channels are optimized for the non-shared use case. They\n//             use a different concurrent queue that is more tailored for this\n//             use case. The initial allocation of this flavor of channel is not\n//             optimized.\n// * Shared - this is the most general form of channel that this module offers,\n//            a channel with multiple senders. This type is as optimized as it\n//            can be, but the previous two types mentioned are much faster for\n//            their use-cases.\n//\n// ## Concurrent queues\n//\n// The basic idea of Rust's Sender/Receiver types is that send() never blocks,\n// but recv() obviously blocks. This means that under the hood there must be\n// some shared and concurrent queue holding all of the actual data.\n//\n// With two flavors of channels, two flavors of queues are also used. We have\n// chosen to use queues from a well-known author that are abbreviated as SPSC\n// and MPSC (single producer, single consumer and multiple producer, single\n// consumer). SPSC queues are used for streams while MPSC queues are used for\n// shared channels.\n//\n// ### SPSC optimizations\n//\n// The SPSC queue found online is essentially a linked list of nodes where one\n// half of the nodes are the \"queue of data\" and the other half of nodes are a\n// cache of unused nodes. The unused nodes are used such that an allocation is\n// not required on every push() and a free doesn't need to happen on every\n// pop().\n//\n// As found online, however, the cache of nodes is of an infinite size. This\n// means that if a channel at one point in its life had 50k items in the queue,\n// then the queue will always have the capacity for 50k items. I believed that\n// this was an unnecessary limitation of the implementation, so I have altered\n// the queue to optionally have a bound on the cache size.\n//\n// By default, streams will have an unbounded SPSC queue with a small-ish cache\n// size. The hope is that the cache is still large enough to have very fast\n// send() operations while not too large such that millions of channels can\n// coexist at once.\n//\n// ### MPSC optimizations\n//\n// Right now the MPSC queue has not been optimized. Like the SPSC queue, it uses\n// a linked list under the hood to earn its unboundedness, but I have not put\n// forth much effort into having a cache of nodes similar to the SPSC queue.\n//\n// For now, I believe that this is \"ok\" because shared channels are not the most\n// common type, but soon we may wish to revisit this queue choice and determine\n// another candidate for backend storage of shared channels.\n//\n// ## Overview of the Implementation\n//\n// Now that there's a little background on the concurrent queues used, it's\n// worth going into much more detail about the channels themselves. The basic\n// pseudocode for a send/recv are:\n//\n//\n//      send(t)                             recv()\n//        queue.push(t)                       return if queue.pop()\n//        if increment() == -1                deschedule {\n//          wakeup()                            if decrement() > 0\n//                                                cancel_deschedule()\n//                                            }\n//                                            queue.pop()\n//\n// As mentioned before, there are no locks in this implementation, only atomic\n// instructions are used.\n//\n// ### The internal atomic counter\n//\n// Every channel has a shared counter with each half to keep track of the size\n// of the queue. This counter is used to abort descheduling by the receiver and\n// to know when to wake up on the sending side.\n//\n// As seen in the pseudocode, senders will increment this count and receivers\n// will decrement the count. The theory behind this is that if a sender sees a\n// -1 count, it will wake up the receiver, and if the receiver sees a 1+ count,\n// then it doesn't need to block.\n//\n// The recv() method has a beginning call to pop(), and if successful, it needs\n// to decrement the count. It is a crucial implementation detail that this\n// decrement does *not* happen to the shared counter. If this were the case,\n// then it would be possible for the counter to be very negative when there were\n// no receivers waiting, in which case the senders would have to determine when\n// it was actually appropriate to wake up a receiver.\n//\n// Instead, the \"steal count\" is kept track of separately (not atomically\n// because it's only used by receivers), and then the decrement() call when\n// descheduling will lump in all of the recent steals into one large decrement.\n//\n// The implication of this is that if a sender sees a -1 count, then there's\n// guaranteed to be a waiter waiting!\n//\n// ## Native Implementation\n//\n// A major goal of these channels is to work seamlessly on and off the runtime.\n// All of the previous race conditions have been worded in terms of\n// scheduler-isms (which is obviously not available without the runtime).\n//\n// For now, native usage of channels (off the runtime) will fall back onto\n// mutexes/cond vars for descheduling/atomic decisions. The no-contention path\n// is still entirely lock-free, the \"deschedule\" blocks above are surrounded by\n// a mutex and the \"wakeup\" blocks involve grabbing a mutex and signaling on a\n// condition variable.\n//\n// ## Select\n//\n// Being able to support selection over channels has greatly influenced this\n// design, and not only does selection need to work inside the runtime, but also\n// outside the runtime.\n//\n// The implementation is fairly straightforward. The goal of select() is not to\n// return some data, but only to return which channel can receive data without\n// blocking. The implementation is essentially the entire blocking procedure\n// followed by an increment as soon as its woken up. The cancellation procedure\n// involves an increment and swapping out of to_wake to acquire ownership of the\n// thread to unblock.\n//\n// Sadly this current implementation requires multiple allocations, so I have\n// seen the throughput of select() be much worse than it should be. I do not\n// believe that there is anything fundamental that needs to change about these\n// channels, however, in order to support a more efficient select().\n//\n// FIXME: Select is now removed, so these factors are ready to be cleaned up!\n//\n// # Conclusion\n//\n// And now that you've seen all the races that I found and attempted to fix,\n// here's the code for you to find some more!\n\nuse crate::cell::UnsafeCell;\nuse crate::error;\nuse crate::fmt;\nuse crate::mem;\nuse crate::sync::Arc;\nuse crate::time::{Duration, Instant};\n\nmod blocking {\n//! Generic support for building blocking abstractions.\n\nuse crate::mem;\nuse crate::sync::atomic::{AtomicBool, Ordering};\nuse crate::sync::Arc;\nuse crate::thread::{self, Thread};\nuse crate::time::Instant;\n\nstruct Inner {\n    thread: Thread,\n    woken: AtomicBool,\n}\n\nunsafe impl Send for Inner {}\nunsafe impl Sync for Inner {}\n\n#[derive(Clone)]\npub struct SignalToken {\n    inner: Arc<Inner>,\n}\n\npub struct WaitToken {\n    inner: Arc<Inner>,\n}\n\nimpl !Send for WaitToken {}\n\nimpl !Sync for WaitToken {}\n\npub fn tokens() -> (WaitToken, SignalToken) {\n}\n\nimpl SignalToken {\n    pub fn signal(&self) -> bool {\n}\n\n    /// Converts to an unsafe usize value. Useful for storing in a pipe's state\n    /// flag.\n    #[inline]\n    pub unsafe fn cast_to_usize(self) -> usize {\n}\n\n    /// Converts from an unsafe usize value. Useful for retrieving a pipe's state\n    /// flag.\n    #[inline]\n    pub unsafe fn cast_from_usize(signal_ptr: usize) -> SignalToken {\n}\n}\n\nimpl WaitToken {\n    pub fn wait(self) {\n}\n\n    /// Returns `true` if we wake up normally.\n    pub fn wait_max_until(self, end: Instant) -> bool {\n}\n}\n}\nmod mpsc_queue {\n//! A mostly lock-free multi-producer, single consumer queue.\n//!\n//! This module contains an implementation of a concurrent MPSC queue. This\n//! queue can be used to share data between threads, and is also used as the\n//! building block of channels in rust.\n//!\n//! Note that the current implementation of this queue has a caveat of the `pop`\n//! method, and see the method for more information about it. Due to this\n//! caveat, this queue may not be appropriate for all use-cases.\n\n// http://www.1024cores.net/home/lock-free-algorithms\n//                         /queues/non-intrusive-mpsc-node-based-queue\n\npub use self::PopResult::*;\n\nuse core::cell::UnsafeCell;\nuse core::ptr;\n\nuse crate::boxed::Box;\nuse crate::sync::atomic::{AtomicPtr, Ordering};\n\n/// A result of the `pop` function.\npub enum PopResult<T> {\n    /// Some data has been popped\n    Data(T),\n    /// The queue is empty\n    Empty,\n    /// The queue is in an inconsistent state. Popping data should succeed, but\n    /// some pushers have yet to make enough progress in order allow a pop to\n    /// succeed. It is recommended that a pop() occur \"in the near future\" in\n    /// order to see if the sender has made progress or not\n    Inconsistent,\n}\n\nstruct Node<T> {\n    next: AtomicPtr<Node<T>>,\n    value: Option<T>,\n}\n\n/// The multi-producer single-consumer structure. This is not cloneable, but it\n/// may be safely shared so long as it is guaranteed that there is only one\n/// popper at a time (many pushers are allowed).\npub struct Queue<T> {\n    head: AtomicPtr<Node<T>>,\n    tail: UnsafeCell<*mut Node<T>>,\n}\n\nunsafe impl<T: Send> Send for Queue<T> {}\nunsafe impl<T: Send> Sync for Queue<T> {}\n\nimpl<T> Node<T> {\n    unsafe fn new(v: Option<T>) -> *mut Node<T> {\n}\n}\n\nimpl<T> Queue<T> {\n    /// Creates a new queue that is safe to share among multiple producers and\n    /// one consumer.\n    pub fn new() -> Queue<T> {\n}\n\n    /// Pushes a new value onto this queue.\n    pub fn push(&self, t: T) {\n}\n\n    /// Pops some data from this queue.\n    ///\n    /// Note that the current implementation means that this function cannot\n    /// return `Option<T>`. It is possible for this queue to be in an\n    /// inconsistent state where many pushes have succeeded and completely\n    /// finished, but pops cannot return `Some(t)`. This inconsistent state\n    /// happens when a pusher is pre-empted at an inopportune moment.\n    ///\n    /// This inconsistent state means that this queue does indeed have data, but\n    /// it does not currently have access to it at this time.\n    pub fn pop(&self) -> PopResult<T> {\n}\n}\n\nimpl<T> Drop for Queue<T> {\n    fn drop(&mut self) {\n}\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use super::{Data, Empty, Inconsistent, Queue};\n    use crate::sync::mpsc::channel;\n    use crate::sync::Arc;\n    use crate::thread;\n\n    #[test]\n    fn test_full() {\n}\n\n    #[test]\n    fn test() {\n}\n}\n}\nmod oneshot {\n/// Oneshot channels/ports\n///\n/// This is the initial flavor of channels/ports used for comm module. This is\n/// an optimization for the one-use case of a channel. The major optimization of\n/// this type is to have one and exactly one allocation when the chan/port pair\n/// is created.\n///\n/// Another possible optimization would be to not use an Arc box because\n/// in theory we know when the shared packet can be deallocated (no real need\n/// for the atomic reference counting), but I was having trouble how to destroy\n/// the data early in a drop of a Port.\n///\n/// # Implementation\n///\n/// Oneshots are implemented around one atomic usize variable. This variable\n/// indicates both the state of the port/chan but also contains any threads\n/// blocked on the port. All atomic operations happen on this one word.\n///\n/// In order to upgrade a oneshot channel, an upgrade is considered a disconnect\n/// on behalf of the channel side of things (it can be mentally thought of as\n/// consuming the port). This upgrade is then also stored in the shared packet.\n/// The one caveat to consider is that when a port sees a disconnected channel\n/// it must check for data because there is no \"data plus upgrade\" state.\npub use self::Failure::*;\nuse self::MyUpgrade::*;\npub use self::UpgradeResult::*;\n\nuse crate::cell::UnsafeCell;\nuse crate::ptr;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\nuse crate::sync::mpsc::blocking::{self, SignalToken};\nuse crate::sync::mpsc::Receiver;\nuse crate::time::Instant;\n\n// Various states you can find a port in.\nconst EMPTY: usize = 0; // initial state: no data, no blocked receiver\nconst DATA: usize = 1; // data ready for receiver to take\nconst DISCONNECTED: usize = 2; // channel is disconnected OR upgraded\n// Any other value represents a pointer to a SignalToken value. The\n// protocol ensures that when the state moves *to* a pointer,\n// ownership of the token is given to the packet, and when the state\n// moves *from* a pointer, ownership of the token is transferred to\n// whoever changed the state.\n\npub struct Packet<T> {\n    // Internal state of the chan/port pair (stores the blocked thread as well)\n    state: AtomicUsize,\n    // One-shot data slot location\n    data: UnsafeCell<Option<T>>,\n    // when used for the second time, a oneshot channel must be upgraded, and\n    // this contains the slot for the upgrade\n    upgrade: UnsafeCell<MyUpgrade<T>>,\n}\n\npub enum Failure<T> {\n    Empty,\n    Disconnected,\n    Upgraded(Receiver<T>),\n}\n\npub enum UpgradeResult {\n    UpSuccess,\n    UpDisconnected,\n    UpWoke(SignalToken),\n}\n\nenum MyUpgrade<T> {\n    NothingSent,\n    SendUsed,\n    GoUp(Receiver<T>),\n}\n\nimpl<T> Packet<T> {\n    pub fn new() -> Packet<T> {\n}\n\n    pub fn send(&self, t: T) -> Result<(), T> {\n}\n\n    // Just tests whether this channel has been sent on or not, this is only\n    // safe to use from the sender.\n    pub fn sent(&self) -> bool {\n}\n\n    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n}\n\n    pub fn try_recv(&self) -> Result<T, Failure<T>> {\n}\n\n    // Returns whether the upgrade was completed. If the upgrade wasn't\n    // completed, then the port couldn't get sent to the other half (it will\n    // never receive it).\n    pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult {\n}\n\n    pub fn drop_chan(&self) {\n}\n\n    pub fn drop_port(&self) {\n}\n\n    ////////////////////////////////////////////////////////////////////////////\n    // select implementation\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Remove a previous selecting thread from this port. This ensures that the\n    // blocked thread will no longer be visible to any other threads.\n    //\n    // The return value indicates whether there's data on this port.\n    pub fn abort_selection(&self) -> Result<bool, Receiver<T>> {\n}\n}\n\nimpl<T> Drop for Packet<T> {\n    fn drop(&mut self) {\n}\n}\n}\nmod shared {\n/// Shared channels.\n///\n/// This is the flavor of channels which are not necessarily optimized for any\n/// particular use case, but are the most general in how they are used. Shared\n/// channels are cloneable allowing for multiple senders.\n///\n/// High level implementation details can be found in the comment of the parent\n/// module. You'll also note that the implementation of the shared and stream\n/// channels are quite similar, and this is no coincidence!\npub use self::Failure::*;\nuse self::StartResult::*;\n\nuse core::cmp;\nuse core::intrinsics::abort;\nuse core::isize;\n\nuse crate::cell::UnsafeCell;\nuse crate::ptr;\nuse crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicUsize, Ordering};\nuse crate::sync::mpsc::blocking::{self, SignalToken};\nuse crate::sync::mpsc::mpsc_queue as mpsc;\nuse crate::sync::{Mutex, MutexGuard};\nuse crate::thread;\nuse crate::time::Instant;\n\nconst DISCONNECTED: isize = isize::MIN;\nconst FUDGE: isize = 1024;\nconst MAX_REFCOUNT: usize = (isize::MAX) as usize;\n#[cfg(test)]\nconst MAX_STEALS: isize = 5;\n#[cfg(not(test))]\nconst MAX_STEALS: isize = 1 << 20;\n\npub struct Packet<T> {\n    queue: mpsc::Queue<T>,\n    cnt: AtomicIsize,          // How many items are on this channel\n    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n    to_wake: AtomicUsize,      // SignalToken for wake up\n\n    // The number of channels which are currently using this packet.\n    channels: AtomicUsize,\n\n    // See the discussion in Port::drop and the channel send methods for what\n    // these are used for\n    port_dropped: AtomicBool,\n    sender_drain: AtomicIsize,\n\n    // this lock protects various portions of this implementation during\n    // select()\n    select_lock: Mutex<()>,\n}\n\npub enum Failure {\n    Empty,\n    Disconnected,\n}\n\n#[derive(PartialEq, Eq)]\nenum StartResult {\n    Installed,\n    Abort,\n}\n\nimpl<T> Packet<T> {\n    // Creation of a packet *must* be followed by a call to postinit_lock\n    // and later by inherit_blocker\n    pub fn new() -> Packet<T> {\n}\n\n    // This function should be used after newly created Packet\n    // was wrapped with an Arc\n    // In other case mutex data will be duplicated while cloning\n    // and that could cause problems on platforms where it is\n    // represented by opaque data structure\n    pub fn postinit_lock(&self) -> MutexGuard<'_, ()> {\n}\n\n    // This function is used at the creation of a shared packet to inherit a\n    // previously blocked thread. This is done to prevent spurious wakeups of\n    // threads in select().\n    //\n    // This can only be called at channel-creation time\n    pub fn inherit_blocker(&self, token: Option<SignalToken>, guard: MutexGuard<'_, ()>) {\n}\n\n    pub fn send(&self, t: T) -> Result<(), T> {\n}\n\n    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure> {\n}\n\n    // Essentially the exact same thing as the stream decrement function.\n    // Returns true if blocking should proceed.\n    fn decrement(&self, token: SignalToken) -> StartResult {\n}\n\n    pub fn try_recv(&self) -> Result<T, Failure> {\n}\n\n    // Prepares this shared packet for a channel clone, essentially just bumping\n    // a refcount.\n    pub fn clone_chan(&self) {\n}\n\n    // Decrement the reference count on a channel. This is called whenever a\n    // Chan is dropped and may end up waking up a receiver. It's the receiver's\n    // responsibility on the other end to figure out that we've disconnected.\n    pub fn drop_chan(&self) {\n}\n\n    // See the long discussion inside of stream.rs for why the queue is drained,\n    // and why it is done in this fashion.\n    pub fn drop_port(&self) {\n}\n\n    // Consumes ownership of the 'to_wake' field.\n    fn take_to_wake(&self) -> SignalToken {\n}\n\n    ////////////////////////////////////////////////////////////////////////////\n    // select implementation\n    ////////////////////////////////////////////////////////////////////////////\n\n    // increment the count on the channel (used for selection)\n    fn bump(&self, amt: isize) -> isize {\n}\n\n    // Cancels a previous thread waiting on this port, returning whether there's\n    // data on the port.\n    //\n    // This is similar to the stream implementation (hence fewer comments), but\n    // uses a different value for the \"steals\" variable.\n    pub fn abort_selection(&self, _was_upgrade: bool) -> bool {\n}\n}\n\nimpl<T> Drop for Packet<T> {\n    fn drop(&mut self) {\n}\n}\n}\nmod spsc_queue {\n//! A single-producer single-consumer concurrent queue\n//!\n//! This module contains the implementation of an SPSC queue which can be used\n//! concurrently between two threads. This data structure is safe to use and\n//! enforces the semantics that there is one pusher and one popper.\n\n// http://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n\nuse core::cell::UnsafeCell;\nuse core::ptr;\n\nuse crate::boxed::Box;\nuse crate::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\n\nuse super::cache_aligned::CacheAligned;\n\n// Node within the linked list queue of messages to send\nstruct Node<T> {\n    // FIXME: this could be an uninitialized T if we're careful enough, and\n    //      that would reduce memory usage (and be a bit faster).\n    //      is it worth it?\n    value: Option<T>,         // nullable for re-use of nodes\n    cached: bool,             // This node goes into the node cache\n    next: AtomicPtr<Node<T>>, // next node in the queue\n}\n\n/// The single-producer single-consumer queue. This structure is not cloneable,\n/// but it can be safely shared in an Arc if it is guaranteed that there\n/// is only one popper and one pusher touching the queue at any one point in\n/// time.\npub struct Queue<T, ProducerAddition = (), ConsumerAddition = ()> {\n    // consumer fields\n    consumer: CacheAligned<Consumer<T, ConsumerAddition>>,\n\n    // producer fields\n    producer: CacheAligned<Producer<T, ProducerAddition>>,\n}\n\nstruct Consumer<T, Addition> {\n    tail: UnsafeCell<*mut Node<T>>, // where to pop from\n    tail_prev: AtomicPtr<Node<T>>,  // where to pop from\n    cache_bound: usize,             // maximum cache size\n    cached_nodes: AtomicUsize,      // number of nodes marked as cachable\n    addition: Addition,\n}\n\nstruct Producer<T, Addition> {\n    head: UnsafeCell<*mut Node<T>>,      // where to push to\n    first: UnsafeCell<*mut Node<T>>,     // where to get new nodes from\n    tail_copy: UnsafeCell<*mut Node<T>>, // between first/tail\n    addition: Addition,\n}\n\nunsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Send for Queue<T, P, C> {}\n\nunsafe impl<T: Send, P: Send + Sync, C: Send + Sync> Sync for Queue<T, P, C> {}\n\nimpl<T> Node<T> {\n    fn new() -> *mut Node<T> {\n}\n}\n\nimpl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerAddition> {\n    /// Creates a new queue. With given additional elements in the producer and\n    /// consumer portions of the queue.\n    ///\n    /// Due to the performance implications of cache-contention,\n    /// we wish to keep fields used mainly by the producer on a separate cache\n    /// line than those used by the consumer.\n    /// Since cache lines are usually 64 bytes, it is unreasonably expensive to\n    /// allocate one for small fields, so we allow users to insert additional\n    /// fields into the cache lines already allocated by this for the producer\n    /// and consumer.\n    ///\n    /// This is unsafe as the type system doesn't enforce a single\n    /// consumer-producer relationship. It also allows the consumer to `pop`\n    /// items while there is a `peek` active due to all methods having a\n    /// non-mutable receiver.\n    ///\n    /// # Arguments\n    ///\n    ///   * `bound` - This queue implementation is implemented with a linked\n    ///               list, and this means that a push is always a malloc. In\n    ///               order to amortize this cost, an internal cache of nodes is\n    ///               maintained to prevent a malloc from always being\n    ///               necessary. This bound is the limit on the size of the\n    ///               cache (if desired). If the value is 0, then the cache has\n    ///               no bound. Otherwise, the cache will never grow larger than\n    ///               `bound` (although the queue itself could be much larger.\n    pub unsafe fn with_additions(\n        bound: usize,\n        producer_addition: ProducerAddition,\n        consumer_addition: ConsumerAddition,\n    ) -> Self {\n}\n\n    /// Pushes a new value onto this queue. Note that to use this function\n    /// safely, it must be externally guaranteed that there is only one pusher.\n    pub fn push(&self, t: T) {\n}\n\n    unsafe fn alloc(&self) -> *mut Node<T> {\n}\n\n    /// Attempts to pop a value from this queue. Remember that to use this type\n    /// safely you must ensure that there is only one popper at a time.\n    pub fn pop(&self) -> Option<T> {\n}\n\n    /// Attempts to peek at the head of the queue, returning `None` if the queue\n    /// has no data currently\n    ///\n    /// # Warning\n    /// The reference returned is invalid if it is not used before the consumer\n    /// pops the value off the queue. If the producer then pushes another value\n    /// onto the queue, it will overwrite the value pointed to by the reference.\n    pub fn peek(&self) -> Option<&mut T> {\n}\n\n    pub fn producer_addition(&self) -> &ProducerAddition {\n}\n\n    pub fn consumer_addition(&self) -> &ConsumerAddition {\n}\n}\n\nimpl<T, ProducerAddition, ConsumerAddition> Drop for Queue<T, ProducerAddition, ConsumerAddition> {\n    fn drop(&mut self) {\n}\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use super::Queue;\n    use crate::sync::mpsc::channel;\n    use crate::sync::Arc;\n    use crate::thread;\n\n    #[test]\n    fn smoke() {\n}\n\n    #[test]\n    fn peek() {\n}\n\n    #[test]\n    fn drop_full() {\n}\n\n    #[test]\n    fn smoke_bound() {\n}\n\n    #[test]\n    fn stress() {\n}\n}\n}\nmod stream {\n/// Stream channels\n///\n/// This is the flavor of channels which are optimized for one sender and one\n/// receiver. The sender will be upgraded to a shared channel if the channel is\n/// cloned.\n///\n/// High level implementation details can be found in the comment of the parent\n/// module.\npub use self::Failure::*;\nuse self::Message::*;\npub use self::UpgradeResult::*;\n\nuse core::cmp;\nuse core::isize;\n\nuse crate::cell::UnsafeCell;\nuse crate::ptr;\nuse crate::thread;\nuse crate::time::Instant;\n\nuse crate::sync::atomic::{AtomicBool, AtomicIsize, AtomicUsize, Ordering};\nuse crate::sync::mpsc::blocking::{self, SignalToken};\nuse crate::sync::mpsc::spsc_queue as spsc;\nuse crate::sync::mpsc::Receiver;\n\nconst DISCONNECTED: isize = isize::MIN;\n#[cfg(test)]\nconst MAX_STEALS: isize = 5;\n#[cfg(not(test))]\nconst MAX_STEALS: isize = 1 << 20;\n\npub struct Packet<T> {\n    // internal queue for all messages\n    queue: spsc::Queue<Message<T>, ProducerAddition, ConsumerAddition>,\n}\n\nstruct ProducerAddition {\n    cnt: AtomicIsize,     // How many items are on this channel\n    to_wake: AtomicUsize, // SignalToken for the blocked thread to wake up\n\n    port_dropped: AtomicBool, // flag if the channel has been destroyed.\n}\n\nstruct ConsumerAddition {\n    steals: UnsafeCell<isize>, // How many times has a port received without blocking?\n}\n\npub enum Failure<T> {\n    Empty,\n    Disconnected,\n    Upgraded(Receiver<T>),\n}\n\npub enum UpgradeResult {\n    UpSuccess,\n    UpDisconnected,\n    UpWoke(SignalToken),\n}\n\n// Any message could contain an \"upgrade request\" to a new shared port, so the\n// internal queue it's a queue of T, but rather Message<T>\nenum Message<T> {\n    Data(T),\n    GoUp(Receiver<T>),\n}\n\nimpl<T> Packet<T> {\n    pub fn new() -> Packet<T> {\n}\n\n    pub fn send(&self, t: T) -> Result<(), T> {\n}\n\n    pub fn upgrade(&self, up: Receiver<T>) -> UpgradeResult {\n}\n\n    fn do_send(&self, t: Message<T>) -> UpgradeResult {\n}\n\n    // Consumes ownership of the 'to_wake' field.\n    fn take_to_wake(&self) -> SignalToken {\n}\n\n    // Decrements the count on the channel for a sleeper, returning the sleeper\n    // back if it shouldn't sleep. Note that this is the location where we take\n    // steals into account.\n    fn decrement(&self, token: SignalToken) -> Result<(), SignalToken> {\n}\n\n    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure<T>> {\n}\n\n    pub fn try_recv(&self) -> Result<T, Failure<T>> {\n}\n\n    pub fn drop_chan(&self) {\n}\n\n    pub fn drop_port(&self) {\n}\n\n    ////////////////////////////////////////////////////////////////////////////\n    // select implementation\n    ////////////////////////////////////////////////////////////////////////////\n\n    // increment the count on the channel (used for selection)\n    fn bump(&self, amt: isize) -> isize {\n}\n\n    // Removes a previous thread from being blocked in this port\n    pub fn abort_selection(&self, was_upgrade: bool) -> Result<bool, Receiver<T>> {\n}\n}\n\nimpl<T> Drop for Packet<T> {\n    fn drop(&mut self) {\n}\n}\n}\nmod sync {\nuse self::Blocker::*;\n/// Synchronous channels/ports\n///\n/// This channel implementation differs significantly from the asynchronous\n/// implementations found next to it (oneshot/stream/share). This is an\n/// implementation of a synchronous, bounded buffer channel.\n///\n/// Each channel is created with some amount of backing buffer, and sends will\n/// *block* until buffer space becomes available. A buffer size of 0 is valid,\n/// which means that every successful send is paired with a successful recv.\n///\n/// This flavor of channels defines a new `send_opt` method for channels which\n/// is the method by which a message is sent but the thread does not panic if it\n/// cannot be delivered.\n///\n/// Another major difference is that send() will *always* return back the data\n/// if it couldn't be sent. This is because it is deterministically known when\n/// the data is received and when it is not received.\n///\n/// Implementation-wise, it can all be summed up with \"use a mutex plus some\n/// logic\". The mutex used here is an OS native mutex, meaning that no user code\n/// is run inside of the mutex (to prevent context switching). This\n/// implementation shares almost all code for the buffered and unbuffered cases\n/// of a synchronous channel. There are a few branches for the unbuffered case,\n/// but they're mostly just relevant to blocking senders.\npub use self::Failure::*;\n\nuse core::intrinsics::abort;\nuse core::isize;\nuse core::mem;\nuse core::ptr;\n\nuse crate::sync::atomic::{AtomicUsize, Ordering};\nuse crate::sync::mpsc::blocking::{self, SignalToken, WaitToken};\nuse crate::sync::{Mutex, MutexGuard};\nuse crate::time::Instant;\n\nconst MAX_REFCOUNT: usize = (isize::MAX) as usize;\n\npub struct Packet<T> {\n    /// Only field outside of the mutex. Just done for kicks, but mainly because\n    /// the other shared channel already had the code implemented\n    channels: AtomicUsize,\n\n    lock: Mutex<State<T>>,\n}\n\nunsafe impl<T: Send> Send for Packet<T> {}\n\nunsafe impl<T: Send> Sync for Packet<T> {}\n\nstruct State<T> {\n    disconnected: bool, // Is the channel disconnected yet?\n    queue: Queue,       // queue of senders waiting to send data\n    blocker: Blocker,   // currently blocked thread on this channel\n    buf: Buffer<T>,     // storage for buffered messages\n    cap: usize,         // capacity of this channel\n\n    /// A curious flag used to indicate whether a sender failed or succeeded in\n    /// blocking. This is used to transmit information back to the thread that it\n    /// must dequeue its message from the buffer because it was not received.\n    /// This is only relevant in the 0-buffer case. This obviously cannot be\n    /// safely constructed, but it's guaranteed to always have a valid pointer\n    /// value.\n    canceled: Option<&'static mut bool>,\n}\n\nunsafe impl<T: Send> Send for State<T> {}\n\n/// Possible flavors of threads who can be blocked on this channel.\nenum Blocker {\n    BlockedSender(SignalToken),\n    BlockedReceiver(SignalToken),\n    NoneBlocked,\n}\n\n/// Simple queue for threading threads together. Nodes are stack-allocated, so\n/// this structure is not safe at all\nstruct Queue {\n    head: *mut Node,\n    tail: *mut Node,\n}\n\nstruct Node {\n    token: Option<SignalToken>,\n    next: *mut Node,\n}\n\nunsafe impl Send for Node {}\n\n/// A simple ring-buffer\nstruct Buffer<T> {\n    buf: Vec<Option<T>>,\n    start: usize,\n    size: usize,\n}\n\n#[derive(Debug)]\npub enum Failure {\n    Empty,\n    Disconnected,\n}\n\n/// Atomically blocks the current thread, placing it into `slot`, unlocking `lock`\n/// in the meantime. This re-locks the mutex upon returning.\nfn wait<'a, 'b, T>(\n    lock: &'a Mutex<State<T>>,\n    mut guard: MutexGuard<'b, State<T>>,\n    f: fn(SignalToken) -> Blocker,\n) -> MutexGuard<'a, State<T>> {\n}\n\n/// Same as wait, but waiting at most until `deadline`.\nfn wait_timeout_receiver<'a, 'b, T>(\n    lock: &'a Mutex<State<T>>,\n    deadline: Instant,\n    mut guard: MutexGuard<'b, State<T>>,\n    success: &mut bool,\n) -> MutexGuard<'a, State<T>> {\n}\n\nfn abort_selection<T>(guard: &mut MutexGuard<'_, State<T>>) -> bool {\n}\n\n/// Wakes up a thread, dropping the lock at the correct time\nfn wakeup<T>(token: SignalToken, guard: MutexGuard<'_, State<T>>) {\n}\n\nimpl<T> Packet<T> {\n    pub fn new(capacity: usize) -> Packet<T> {\n}\n\n    // wait until a send slot is available, returning locked access to\n    // the channel state.\n    fn acquire_send_slot(&self) -> MutexGuard<'_, State<T>> {\n}\n\n    pub fn send(&self, t: T) -> Result<(), T> {\n}\n\n    pub fn try_send(&self, t: T) -> Result<(), super::TrySendError<T>> {\n}\n\n    // Receives a message from this channel\n    //\n    // When reading this, remember that there can only ever be one receiver at\n    // time.\n    pub fn recv(&self, deadline: Option<Instant>) -> Result<T, Failure> {\n}\n\n    pub fn try_recv(&self) -> Result<T, Failure> {\n}\n\n    // Wake up pending senders after some data has been received\n    //\n    // * `waited` - flag if the receiver blocked to receive some data, or if it\n    //              just picked up some data on the way out\n    // * `guard` - the lock guard that is held over this channel's lock\n    fn wakeup_senders(&self, waited: bool, mut guard: MutexGuard<'_, State<T>>) {\n}\n\n    // Prepares this shared packet for a channel clone, essentially just bumping\n    // a refcount.\n    pub fn clone_chan(&self) {\n}\n\n    pub fn drop_chan(&self) {\n}\n\n    pub fn drop_port(&self) {\n}\n}\n\nimpl<T> Drop for Packet<T> {\n    fn drop(&mut self) {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Buffer, a simple ring buffer backed by Vec<T>\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Buffer<T> {\n    fn enqueue(&mut self, t: T) {\n}\n\n    fn dequeue(&mut self) -> T {\n}\n\n    fn size(&self) -> usize {\n}\n    fn capacity(&self) -> usize {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Queue, a simple queue to enqueue threads with (stack-allocated nodes)\n////////////////////////////////////////////////////////////////////////////////\n\nimpl Queue {\n    fn enqueue(&mut self, node: &mut Node) -> WaitToken {\n}\n\n    fn dequeue(&mut self) -> Option<SignalToken> {\n}\n}\n}\n\nmod cache_aligned {\nuse crate::ops::{Deref, DerefMut};\n\n#[derive(Copy, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[repr(align(64))]\npub(super) struct Aligner;\n\n#[derive(Copy, Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub(super) struct CacheAligned<T>(pub T, pub Aligner);\n\nimpl<T> Deref for CacheAligned<T> {\n    type Target = T;\n    fn deref(&self) -> &Self::Target {\n}\n}\n\nimpl<T> DerefMut for CacheAligned<T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n}\n}\n\nimpl<T> CacheAligned<T> {\n    pub(super) fn new(t: T) -> Self {\n}\n}\n}\n\n/// The receiving half of Rust's [`channel`] (or [`sync_channel`]) type.\n/// This half can only be owned by one thread.\n///\n/// Messages sent to the channel can be retrieved using [`recv`].\n///\n/// [`channel`]: fn.channel.html\n/// [`sync_channel`]: fn.sync_channel.html\n/// [`recv`]: struct.Receiver.html#method.recv\n///\n/// # Examples\n///\n/// ```rust\n/// use std::sync::mpsc::channel;\n/// use std::thread;\n/// use std::time::Duration;\n///\n/// let (send, recv) = channel();\n///\n/// thread::spawn(move || {\n///     send.send(\"Hello world!\").unwrap();\n///     thread::sleep(Duration::from_secs(2)); // block for two seconds\n///     send.send(\"Delayed for 2 seconds\").unwrap();\n/// });\n///\n/// println!(\"{}\", recv.recv().unwrap()); // Received immediately\n/// println!(\"Waiting...\");\n/// println!(\"{}\", recv.recv().unwrap()); // Received after 2 seconds\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Receiver<T> {\n    inner: UnsafeCell<Flavor<T>>,\n}\n\n// The receiver port can be sent from place to place, so long as it\n// is not used to receive non-sendable things.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Send> Send for Receiver<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> !Sync for Receiver<T> {}\n\n/// An iterator over messages on a [`Receiver`], created by [`iter`].\n///\n/// This iterator will block whenever [`next`] is called,\n/// waiting for a new message, and [`None`] will be returned\n/// when the corresponding channel has hung up.\n///\n/// [`iter`]: struct.Receiver.html#method.iter\n/// [`Receiver`]: struct.Receiver.html\n/// [`next`]: ../../../std/iter/trait.Iterator.html#tymethod.next\n/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n///\n/// # Examples\n///\n/// ```rust\n/// use std::sync::mpsc::channel;\n/// use std::thread;\n///\n/// let (send, recv) = channel();\n///\n/// thread::spawn(move || {\n///     send.send(1u8).unwrap();\n///     send.send(2u8).unwrap();\n///     send.send(3u8).unwrap();\n/// });\n///\n/// for x in recv.iter() {\n///     println!(\"Got: {}\", x);\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Iter<'a, T: 'a> {\n    rx: &'a Receiver<T>,\n}\n\n/// An iterator that attempts to yield all pending values for a [`Receiver`],\n/// created by [`try_iter`].\n///\n/// [`None`] will be returned when there are no pending values remaining or\n/// if the corresponding channel has hung up.\n///\n/// This iterator will never block the caller in order to wait for data to\n/// become available. Instead, it will return [`None`].\n///\n/// [`Receiver`]: struct.Receiver.html\n/// [`try_iter`]: struct.Receiver.html#method.try_iter\n/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n///\n/// # Examples\n///\n/// ```rust\n/// use std::sync::mpsc::channel;\n/// use std::thread;\n/// use std::time::Duration;\n///\n/// let (sender, receiver) = channel();\n///\n/// // Nothing is in the buffer yet\n/// assert!(receiver.try_iter().next().is_none());\n/// println!(\"Nothing in the buffer...\");\n///\n/// thread::spawn(move || {\n///     sender.send(1).unwrap();\n///     sender.send(2).unwrap();\n///     sender.send(3).unwrap();\n/// });\n///\n/// println!(\"Going to sleep...\");\n/// thread::sleep(Duration::from_secs(2)); // block for two seconds\n///\n/// for x in receiver.try_iter() {\n///     println!(\"Got: {}\", x);\n/// }\n/// ```\n#[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n#[derive(Debug)]\npub struct TryIter<'a, T: 'a> {\n    rx: &'a Receiver<T>,\n}\n\n/// An owning iterator over messages on a [`Receiver`],\n/// created by **Receiver::into_iter**.\n///\n/// This iterator will block whenever [`next`]\n/// is called, waiting for a new message, and [`None`] will be\n/// returned if the corresponding channel has hung up.\n///\n/// [`Receiver`]: struct.Receiver.html\n/// [`next`]: ../../../std/iter/trait.Iterator.html#tymethod.next\n/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n///\n/// # Examples\n///\n/// ```rust\n/// use std::sync::mpsc::channel;\n/// use std::thread;\n///\n/// let (send, recv) = channel();\n///\n/// thread::spawn(move || {\n///     send.send(1u8).unwrap();\n///     send.send(2u8).unwrap();\n///     send.send(3u8).unwrap();\n/// });\n///\n/// for x in recv.into_iter() {\n///     println!(\"Got: {}\", x);\n/// }\n/// ```\n#[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n#[derive(Debug)]\npub struct IntoIter<T> {\n    rx: Receiver<T>,\n}\n\n/// The sending-half of Rust's asynchronous [`channel`] type. This half can only be\n/// owned by one thread, but it can be cloned to send to other threads.\n///\n/// Messages can be sent through this channel with [`send`].\n///\n/// [`channel`]: fn.channel.html\n/// [`send`]: struct.Sender.html#method.send\n///\n/// # Examples\n///\n/// ```rust\n/// use std::sync::mpsc::channel;\n/// use std::thread;\n///\n/// let (sender, receiver) = channel();\n/// let sender2 = sender.clone();\n///\n/// // First thread owns sender\n/// thread::spawn(move || {\n///     sender.send(1).unwrap();\n/// });\n///\n/// // Second thread owns sender2\n/// thread::spawn(move || {\n///     sender2.send(2).unwrap();\n/// });\n///\n/// let msg = receiver.recv().unwrap();\n/// let msg2 = receiver.recv().unwrap();\n///\n/// assert_eq!(3, msg + msg2);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Sender<T> {\n    inner: UnsafeCell<Flavor<T>>,\n}\n\n// The send port can be sent from place to place, so long as it\n// is not used to send non-sendable things.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Send> Send for Sender<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> !Sync for Sender<T> {}\n\n/// The sending-half of Rust's synchronous [`sync_channel`] type.\n///\n/// Messages can be sent through this channel with [`send`] or [`try_send`].\n///\n/// [`send`] will block if there is no space in the internal buffer.\n///\n/// [`sync_channel`]: fn.sync_channel.html\n/// [`send`]: struct.SyncSender.html#method.send\n/// [`try_send`]: struct.SyncSender.html#method.try_send\n///\n/// # Examples\n///\n/// ```rust\n/// use std::sync::mpsc::sync_channel;\n/// use std::thread;\n///\n/// // Create a sync_channel with buffer size 2\n/// let (sync_sender, receiver) = sync_channel(2);\n/// let sync_sender2 = sync_sender.clone();\n///\n/// // First thread owns sync_sender\n/// thread::spawn(move || {\n///     sync_sender.send(1).unwrap();\n///     sync_sender.send(2).unwrap();\n/// });\n///\n/// // Second thread owns sync_sender2\n/// thread::spawn(move || {\n///     sync_sender2.send(3).unwrap();\n///     // thread will now block since the buffer is full\n///     println!(\"Thread unblocked!\");\n/// });\n///\n/// let mut msg;\n///\n/// msg = receiver.recv().unwrap();\n/// println!(\"message {} received\", msg);\n///\n/// // \"Thread unblocked!\" will be printed now\n///\n/// msg = receiver.recv().unwrap();\n/// println!(\"message {} received\", msg);\n///\n/// msg = receiver.recv().unwrap();\n///\n/// println!(\"message {} received\", msg);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SyncSender<T> {\n    inner: Arc<sync::Packet<T>>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Send> Send for SyncSender<T> {}\n\n/// An error returned from the [`Sender::send`] or [`SyncSender::send`]\n/// function on **channel**s.\n///\n/// A **send** operation can only fail if the receiving end of a channel is\n/// disconnected, implying that the data could never be received. The error\n/// contains the data being sent as a payload so it can be recovered.\n///\n/// [`Sender::send`]: struct.Sender.html#method.send\n/// [`SyncSender::send`]: struct.SyncSender.html#method.send\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(PartialEq, Eq, Clone, Copy)]\npub struct SendError<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n\n/// An error returned from the [`recv`] function on a [`Receiver`].\n///\n/// The [`recv`] operation can only fail if the sending half of a\n/// [`channel`] (or [`sync_channel`]) is disconnected, implying that no further\n/// messages will ever be received.\n///\n/// [`recv`]: struct.Receiver.html#method.recv\n/// [`Receiver`]: struct.Receiver.html\n/// [`channel`]: fn.channel.html\n/// [`sync_channel`]: fn.sync_channel.html\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RecvError;\n\n/// This enumeration is the list of the possible reasons that [`try_recv`] could\n/// not return data when called. This can occur with both a [`channel`] and\n/// a [`sync_channel`].\n///\n/// [`try_recv`]: struct.Receiver.html#method.try_recv\n/// [`channel`]: fn.channel.html\n/// [`sync_channel`]: fn.sync_channel.html\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum TryRecvError {\n    /// This **channel** is currently empty, but the **Sender**(s) have not yet\n    /// disconnected, so data may yet become available.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Empty,\n\n    /// The **channel**'s sending half has become disconnected, and there will\n    /// never be any more data received on it.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Disconnected,\n}\n\n/// This enumeration is the list of possible errors that made [`recv_timeout`]\n/// unable to return data when called. This can occur with both a [`channel`] and\n/// a [`sync_channel`].\n///\n/// [`recv_timeout`]: struct.Receiver.html#method.recv_timeout\n/// [`channel`]: fn.channel.html\n/// [`sync_channel`]: fn.sync_channel.html\n#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n#[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\npub enum RecvTimeoutError {\n    /// This **channel** is currently empty, but the **Sender**(s) have not yet\n    /// disconnected, so data may yet become available.\n    #[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\n    Timeout,\n    /// The **channel**'s sending half has become disconnected, and there will\n    /// never be any more data received on it.\n    #[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\n    Disconnected,\n}\n\n/// This enumeration is the list of the possible error outcomes for the\n/// [`try_send`] method.\n///\n/// [`try_send`]: struct.SyncSender.html#method.try_send\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(PartialEq, Eq, Clone, Copy)]\npub enum TrySendError<T> {\n    /// The data could not be sent on the [`sync_channel`] because it would require that\n    /// the callee block to send the data.\n    ///\n    /// If this is a buffered channel, then the buffer is full at this time. If\n    /// this is not a buffered channel, then there is no [`Receiver`] available to\n    /// acquire the data.\n    ///\n    /// [`sync_channel`]: fn.sync_channel.html\n    /// [`Receiver`]: struct.Receiver.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Full(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n\n    /// This [`sync_channel`]'s receiving half has disconnected, so the data could not be\n    /// sent. The data is returned back to the callee in this case.\n    ///\n    /// [`sync_channel`]: fn.sync_channel.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Disconnected(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n}\n\nenum Flavor<T> {\n    Oneshot(Arc<oneshot::Packet<T>>),\n    Stream(Arc<stream::Packet<T>>),\n    Shared(Arc<shared::Packet<T>>),\n    Sync(Arc<sync::Packet<T>>),\n}\n\n#[doc(hidden)]\ntrait UnsafeFlavor<T> {\n    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>>;\n    unsafe fn inner_mut(&self) -> &mut Flavor<T> {\n        &mut *self.inner_unsafe().get()\n    }\n    unsafe fn inner(&self) -> &Flavor<T> {\n}\n}\nimpl<T> UnsafeFlavor<T> for Sender<T> {\n    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>> {\n}\n}\nimpl<T> UnsafeFlavor<T> for Receiver<T> {\n    fn inner_unsafe(&self) -> &UnsafeCell<Flavor<T>> {\n}\n}\n\n/// Creates a new asynchronous channel, returning the sender/receiver halves.\n/// All data sent on the [`Sender`] will become available on the [`Receiver`] in\n/// the same order as it was sent, and no [`send`] will block the calling thread\n/// (this channel has an \"infinite buffer\", unlike [`sync_channel`], which will\n/// block after its buffer limit is reached). [`recv`] will block until a message\n/// is available.\n///\n/// The [`Sender`] can be cloned to [`send`] to the same channel multiple times, but\n/// only one [`Receiver`] is supported.\n///\n/// If the [`Receiver`] is disconnected while trying to [`send`] with the\n/// [`Sender`], the [`send`] method will return a [`SendError`]. Similarly, if the\n/// [`Sender`] is disconnected while trying to [`recv`], the [`recv`] method will\n/// return a [`RecvError`].\n///\n/// [`send`]: struct.Sender.html#method.send\n/// [`recv`]: struct.Receiver.html#method.recv\n/// [`Sender`]: struct.Sender.html\n/// [`Receiver`]: struct.Receiver.html\n/// [`sync_channel`]: fn.sync_channel.html\n/// [`SendError`]: struct.SendError.html\n/// [`RecvError`]: struct.RecvError.html\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::mpsc::channel;\n/// use std::thread;\n///\n/// let (sender, receiver) = channel();\n///\n/// // Spawn off an expensive computation\n/// thread::spawn(move|| {\n/// #   fn expensive_computation() {}\n///     sender.send(expensive_computation()).unwrap();\n/// });\n///\n/// // Do some useful work for awhile\n///\n/// // Let's see what that answer was\n/// println!(\"{:?}\", receiver.recv().unwrap());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n}\n\n/// Creates a new synchronous, bounded channel.\n/// All data sent on the [`SyncSender`] will become available on the [`Receiver`]\n/// in the same order as it was sent. Like asynchronous [`channel`]s, the\n/// [`Receiver`] will block until a message becomes available. `sync_channel`\n/// differs greatly in the semantics of the sender, however.\n///\n/// This channel has an internal buffer on which messages will be queued.\n/// `bound` specifies the buffer size. When the internal buffer becomes full,\n/// future sends will *block* waiting for the buffer to open up. Note that a\n/// buffer size of 0 is valid, in which case this becomes \"rendezvous channel\"\n/// where each [`send`] will not return until a [`recv`] is paired with it.\n///\n/// The [`SyncSender`] can be cloned to [`send`] to the same channel multiple\n/// times, but only one [`Receiver`] is supported.\n///\n/// Like asynchronous channels, if the [`Receiver`] is disconnected while trying\n/// to [`send`] with the [`SyncSender`], the [`send`] method will return a\n/// [`SendError`]. Similarly, If the [`SyncSender`] is disconnected while trying\n/// to [`recv`], the [`recv`] method will return a [`RecvError`].\n///\n/// [`channel`]: fn.channel.html\n/// [`send`]: struct.SyncSender.html#method.send\n/// [`recv`]: struct.Receiver.html#method.recv\n/// [`SyncSender`]: struct.SyncSender.html\n/// [`Receiver`]: struct.Receiver.html\n/// [`SendError`]: struct.SendError.html\n/// [`RecvError`]: struct.RecvError.html\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::mpsc::sync_channel;\n/// use std::thread;\n///\n/// let (sender, receiver) = sync_channel(1);\n///\n/// // this returns immediately\n/// sender.send(1).unwrap();\n///\n/// thread::spawn(move|| {\n///     // this will block until the previous message has been received\n///     sender.send(2).unwrap();\n/// });\n///\n/// assert_eq!(receiver.recv().unwrap(), 1);\n/// assert_eq!(receiver.recv().unwrap(), 2);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>) {\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Sender\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Sender<T> {\n    fn new(inner: Flavor<T>) -> Sender<T> {\n}\n\n    /// Attempts to send a value on this channel, returning it back if it could\n    /// not be sent.\n    ///\n    /// A successful send occurs when it is determined that the other end of\n    /// the channel has not hung up already. An unsuccessful send would be one\n    /// where the corresponding receiver has already been deallocated. Note\n    /// that a return value of [`Err`] means that the data will never be\n    /// received, but a return value of [`Ok`] does *not* mean that the data\n    /// will be received. It is possible for the corresponding receiver to\n    /// hang up immediately after this function returns [`Ok`].\n    ///\n    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n    /// [`Ok`]: ../../../std/result/enum.Result.html#variant.Ok\n    ///\n    /// This method will never block the current thread.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::mpsc::channel;\n    ///\n    /// let (tx, rx) = channel();\n    ///\n    /// // This send is always successful\n    /// tx.send(1).unwrap();\n    ///\n    /// // This send will fail because the receiver is gone\n    /// drop(rx);\n    /// assert_eq!(tx.send(1).unwrap_err().0, 1);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Sender<T> {\n    fn clone(&self) -> Sender<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Drop for Sender<T> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"mpsc_debug\", since = \"1.8.0\")]\nimpl<T> fmt::Debug for Sender<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// SyncSender\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<T> SyncSender<T> {\n    fn new(inner: Arc<sync::Packet<T>>) -> SyncSender<T> {\n}\n\n    /// Sends a value on this synchronous channel.\n    ///\n    /// This function will *block* until space in the internal buffer becomes\n    /// available or a receiver is available to hand off the message to.\n    ///\n    /// Note that a successful send does *not* guarantee that the receiver will\n    /// ever see the data if there is a buffer on this channel. Items may be\n    /// enqueued in the internal buffer for the receiver to receive at a later\n    /// time. If the buffer size is 0, however, the channel becomes a rendezvous\n    /// channel and it guarantees that the receiver has indeed received\n    /// the data if this function returns success.\n    ///\n    /// This function will never panic, but it may return [`Err`] if the\n    /// [`Receiver`] has disconnected and is no longer able to receive\n    /// information.\n    ///\n    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n    /// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::sync::mpsc::sync_channel;\n    /// use std::thread;\n    ///\n    /// // Create a rendezvous sync_channel with buffer size 0\n    /// let (sync_sender, receiver) = sync_channel(0);\n    ///\n    /// thread::spawn(move || {\n    ///    println!(\"sending message...\");\n    ///    sync_sender.send(1).unwrap();\n    ///    // Thread is now blocked until the message is received\n    ///\n    ///    println!(\"...message received!\");\n    /// });\n    ///\n    /// let msg = receiver.recv().unwrap();\n    /// assert_eq!(1, msg);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n}\n\n    /// Attempts to send a value on this channel without blocking.\n    ///\n    /// This method differs from [`send`] by returning immediately if the\n    /// channel's buffer is full or no receiver is waiting to acquire some\n    /// data. Compared with [`send`], this function has two failure cases\n    /// instead of one (one for disconnection, one for a full buffer).\n    ///\n    /// See [`send`] for notes about guarantees of whether the\n    /// receiver has received the data or not if this function is successful.\n    ///\n    /// [`send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::sync::mpsc::sync_channel;\n    /// use std::thread;\n    ///\n    /// // Create a sync_channel with buffer size 1\n    /// let (sync_sender, receiver) = sync_channel(1);\n    /// let sync_sender2 = sync_sender.clone();\n    ///\n    /// // First thread owns sync_sender\n    /// thread::spawn(move || {\n    ///     sync_sender.send(1).unwrap();\n    ///     sync_sender.send(2).unwrap();\n    ///     // Thread blocked\n    /// });\n    ///\n    /// // Second thread owns sync_sender2\n    /// thread::spawn(move || {\n    ///     // This will return an error and send\n    ///     // no message if the buffer is full\n    ///     let _ = sync_sender2.try_send(3);\n    /// });\n    ///\n    /// let mut msg;\n    /// msg = receiver.recv().unwrap();\n    /// println!(\"message {} received\", msg);\n    ///\n    /// msg = receiver.recv().unwrap();\n    /// println!(\"message {} received\", msg);\n    ///\n    /// // Third message may have never been sent\n    /// match receiver.try_recv() {\n    ///     Ok(msg) => println!(\"message {} received\", msg),\n    ///     Err(_) => println!(\"the third message was never sent\"),\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for SyncSender<T> {\n    fn clone(&self) -> SyncSender<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Drop for SyncSender<T> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"mpsc_debug\", since = \"1.8.0\")]\nimpl<T> fmt::Debug for SyncSender<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Receiver\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Receiver<T> {\n    fn new(inner: Flavor<T>) -> Receiver<T> {\n}\n\n    /// Attempts to return a pending value on this receiver without blocking.\n    ///\n    /// This method will never block the caller in order to wait for data to\n    /// become available. Instead, this will always return immediately with a\n    /// possible option of pending data on the channel.\n    ///\n    /// This is useful for a flavor of \"optimistic check\" before deciding to\n    /// block on a receiver.\n    ///\n    /// Compared with [`recv`], this function has two failure cases instead of one\n    /// (one for disconnection, one for an empty buffer).\n    ///\n    /// [`recv`]: struct.Receiver.html#method.recv\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::sync::mpsc::{Receiver, channel};\n    ///\n    /// let (_, receiver): (_, Receiver<i32>) = channel();\n    ///\n    /// assert!(receiver.try_recv().is_err());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn try_recv(&self) -> Result<T, TryRecvError> {\n}\n\n    /// Attempts to wait for a value on this receiver, returning an error if the\n    /// corresponding channel has hung up.\n    ///\n    /// This function will always block the current thread if there is no data\n    /// available and it's possible for more data to be sent. Once a message is\n    /// sent to the corresponding [`Sender`] (or [`SyncSender`]), then this\n    /// receiver will wake up and return that message.\n    ///\n    /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n    /// this call is blocking, this call will wake up and return [`Err`] to\n    /// indicate that no more messages can ever be received on this channel.\n    /// However, since channels are buffered, messages sent before the disconnect\n    /// will still be properly received.\n    ///\n    /// [`Sender`]: struct.Sender.html\n    /// [`SyncSender`]: struct.SyncSender.html\n    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::mpsc;\n    /// use std::thread;\n    ///\n    /// let (send, recv) = mpsc::channel();\n    /// let handle = thread::spawn(move || {\n    ///     send.send(1u8).unwrap();\n    /// });\n    ///\n    /// handle.join().unwrap();\n    ///\n    /// assert_eq!(Ok(1), recv.recv());\n    /// ```\n    ///\n    /// Buffering behavior:\n    ///\n    /// ```\n    /// use std::sync::mpsc;\n    /// use std::thread;\n    /// use std::sync::mpsc::RecvError;\n    ///\n    /// let (send, recv) = mpsc::channel();\n    /// let handle = thread::spawn(move || {\n    ///     send.send(1u8).unwrap();\n    ///     send.send(2).unwrap();\n    ///     send.send(3).unwrap();\n    ///     drop(send);\n    /// });\n    ///\n    /// // wait for the thread to join so we ensure the sender is dropped\n    /// handle.join().unwrap();\n    ///\n    /// assert_eq!(Ok(1), recv.recv());\n    /// assert_eq!(Ok(2), recv.recv());\n    /// assert_eq!(Ok(3), recv.recv());\n    /// assert_eq!(Err(RecvError), recv.recv());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn recv(&self) -> Result<T, RecvError> {\n}\n\n    /// Attempts to wait for a value on this receiver, returning an error if the\n    /// corresponding channel has hung up, or if it waits more than `timeout`.\n    ///\n    /// This function will always block the current thread if there is no data\n    /// available and it's possible for more data to be sent. Once a message is\n    /// sent to the corresponding [`Sender`] (or [`SyncSender`]), then this\n    /// receiver will wake up and return that message.\n    ///\n    /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n    /// this call is blocking, this call will wake up and return [`Err`] to\n    /// indicate that no more messages can ever be received on this channel.\n    /// However, since channels are buffered, messages sent before the disconnect\n    /// will still be properly received.\n    ///\n    /// [`Sender`]: struct.Sender.html\n    /// [`SyncSender`]: struct.SyncSender.html\n    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n    ///\n    /// # Known Issues\n    ///\n    /// There is currently a known issue (see [`#39364`]) that causes `recv_timeout`\n    /// to panic unexpectedly with the following example:\n    ///\n    /// ```no_run\n    /// use std::sync::mpsc::channel;\n    /// use std::thread;\n    /// use std::time::Duration;\n    ///\n    /// let (tx, rx) = channel::<String>();\n    ///\n    /// thread::spawn(move || {\n    ///     let d = Duration::from_millis(10);\n    ///     loop {\n    ///         println!(\"recv\");\n    ///         let _r = rx.recv_timeout(d);\n    ///     }\n    /// });\n    ///\n    /// thread::sleep(Duration::from_millis(100));\n    /// let _c1 = tx.clone();\n    ///\n    /// thread::sleep(Duration::from_secs(1));\n    /// ```\n    ///\n    /// [`#39364`]: https://github.com/rust-lang/rust/issues/39364\n    ///\n    /// # Examples\n    ///\n    /// Successfully receiving value before encountering timeout:\n    ///\n    /// ```no_run\n    /// use std::thread;\n    /// use std::time::Duration;\n    /// use std::sync::mpsc;\n    ///\n    /// let (send, recv) = mpsc::channel();\n    ///\n    /// thread::spawn(move || {\n    ///     send.send('a').unwrap();\n    /// });\n    ///\n    /// assert_eq!(\n    ///     recv.recv_timeout(Duration::from_millis(400)),\n    ///     Ok('a')\n    /// );\n    /// ```\n    ///\n    /// Receiving an error upon reaching timeout:\n    ///\n    /// ```no_run\n    /// use std::thread;\n    /// use std::time::Duration;\n    /// use std::sync::mpsc;\n    ///\n    /// let (send, recv) = mpsc::channel();\n    ///\n    /// thread::spawn(move || {\n    ///     thread::sleep(Duration::from_millis(800));\n    ///     send.send('a').unwrap();\n    /// });\n    ///\n    /// assert_eq!(\n    ///     recv.recv_timeout(Duration::from_millis(400)),\n    ///     Err(mpsc::RecvTimeoutError::Timeout)\n    /// );\n    /// ```\n    #[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\n    pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError> {\n}\n\n    /// Attempts to wait for a value on this receiver, returning an error if the\n    /// corresponding channel has hung up, or if `deadline` is reached.\n    ///\n    /// This function will always block the current thread if there is no data\n    /// available and it's possible for more data to be sent. Once a message is\n    /// sent to the corresponding [`Sender`] (or [`SyncSender`]), then this\n    /// receiver will wake up and return that message.\n    ///\n    /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n    /// this call is blocking, this call will wake up and return [`Err`] to\n    /// indicate that no more messages can ever be received on this channel.\n    /// However, since channels are buffered, messages sent before the disconnect\n    /// will still be properly received.\n    ///\n    /// [`Sender`]: struct.Sender.html\n    /// [`SyncSender`]: struct.SyncSender.html\n    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Successfully receiving value before reaching deadline:\n    ///\n    /// ```no_run\n    /// #![feature(deadline_api)]\n    /// use std::thread;\n    /// use std::time::{Duration, Instant};\n    /// use std::sync::mpsc;\n    ///\n    /// let (send, recv) = mpsc::channel();\n    ///\n    /// thread::spawn(move || {\n    ///     send.send('a').unwrap();\n    /// });\n    ///\n    /// assert_eq!(\n    ///     recv.recv_deadline(Instant::now() + Duration::from_millis(400)),\n    ///     Ok('a')\n    /// );\n    /// ```\n    ///\n    /// Receiving an error upon reaching deadline:\n    ///\n    /// ```no_run\n    /// #![feature(deadline_api)]\n    /// use std::thread;\n    /// use std::time::{Duration, Instant};\n    /// use std::sync::mpsc;\n    ///\n    /// let (send, recv) = mpsc::channel();\n    ///\n    /// thread::spawn(move || {\n    ///     thread::sleep(Duration::from_millis(800));\n    ///     send.send('a').unwrap();\n    /// });\n    ///\n    /// assert_eq!(\n    ///     recv.recv_deadline(Instant::now() + Duration::from_millis(400)),\n    ///     Err(mpsc::RecvTimeoutError::Timeout)\n    /// );\n    /// ```\n    #[unstable(feature = \"deadline_api\", issue = \"46316\")]\n    pub fn recv_deadline(&self, deadline: Instant) -> Result<T, RecvTimeoutError> {\n}\n\n    /// Returns an iterator that will block waiting for messages, but never\n    /// [`panic!`]. It will return [`None`] when the channel has hung up.\n    ///\n    /// [`panic!`]: ../../../std/macro.panic.html\n    /// [`None`]: ../../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::sync::mpsc::channel;\n    /// use std::thread;\n    ///\n    /// let (send, recv) = channel();\n    ///\n    /// thread::spawn(move || {\n    ///     send.send(1).unwrap();\n    ///     send.send(2).unwrap();\n    ///     send.send(3).unwrap();\n    /// });\n    ///\n    /// let mut iter = recv.iter();\n    /// assert_eq!(iter.next(), Some(1));\n    /// assert_eq!(iter.next(), Some(2));\n    /// assert_eq!(iter.next(), Some(3));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, T> {\n}\n\n    /// Returns an iterator that will attempt to yield all pending values.\n    /// It will return `None` if there are no more pending values or if the\n    /// channel has hung up. The iterator will never [`panic!`] or block the\n    /// user by waiting for values.\n    ///\n    /// [`panic!`]: ../../../std/macro.panic.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::sync::mpsc::channel;\n    /// use std::thread;\n    /// use std::time::Duration;\n    ///\n    /// let (sender, receiver) = channel();\n    ///\n    /// // nothing is in the buffer yet\n    /// assert!(receiver.try_iter().next().is_none());\n    ///\n    /// thread::spawn(move || {\n    ///     thread::sleep(Duration::from_secs(1));\n    ///     sender.send(1).unwrap();\n    ///     sender.send(2).unwrap();\n    ///     sender.send(3).unwrap();\n    /// });\n    ///\n    /// // nothing is in the buffer yet\n    /// assert!(receiver.try_iter().next().is_none());\n    ///\n    /// // block for two seconds\n    /// thread::sleep(Duration::from_secs(2));\n    ///\n    /// let mut iter = receiver.try_iter();\n    /// assert_eq!(iter.next(), Some(1));\n    /// assert_eq!(iter.next(), Some(2));\n    /// assert_eq!(iter.next(), Some(3));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n    pub fn try_iter(&self) -> TryIter<'_, T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n}\n}\n\n#[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\nimpl<'a, T> Iterator for TryIter<'a, T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n}\n}\n\n#[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\nimpl<'a, T> IntoIterator for &'a Receiver<T> {\n    type Item = T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n}\n}\n\n#[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n}\n}\n\n#[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\nimpl<T> IntoIterator for Receiver<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    fn into_iter(self) -> IntoIter<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Drop for Receiver<T> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"mpsc_debug\", since = \"1.8.0\")]\nimpl<T> fmt::Debug for Receiver<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> fmt::Debug for SendError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> fmt::Display for SendError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Send> error::Error for SendError<T> {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> fmt::Debug for TrySendError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> fmt::Display for TrySendError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Send> error::Error for TrySendError<T> {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"mpsc_error_conversions\", since = \"1.24.0\")]\nimpl<T> From<SendError<T>> for TrySendError<T> {\n    fn from(err: SendError<T>) -> TrySendError<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for RecvError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl error::Error for RecvError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for TryRecvError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl error::Error for TryRecvError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"mpsc_error_conversions\", since = \"1.24.0\")]\nimpl From<RecvError> for TryRecvError {\n    fn from(err: RecvError) -> TryRecvError {\n}\n}\n\n#[stable(feature = \"mpsc_recv_timeout_error\", since = \"1.15.0\")]\nimpl fmt::Display for RecvTimeoutError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"mpsc_recv_timeout_error\", since = \"1.15.0\")]\nimpl error::Error for RecvTimeoutError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"mpsc_error_conversions\", since = \"1.24.0\")]\nimpl From<RecvError> for RecvTimeoutError {\n    fn from(err: RecvError) -> RecvTimeoutError {\n}\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use super::*;\n    use crate::env;\n    use crate::thread;\n    use crate::time::{Duration, Instant};\n\n    pub fn stress_factor() -> usize {\n}\n\n    #[test]\n    fn smoke() {\n}\n\n    #[test]\n    fn drop_full() {\n}\n\n    #[test]\n    fn drop_full_shared() {\n}\n\n    #[test]\n    fn smoke_shared() {\n}\n\n    #[test]\n    fn smoke_threads() {\n}\n\n    #[test]\n    fn smoke_port_gone() {\n}\n\n    #[test]\n    fn smoke_shared_port_gone() {\n}\n\n    #[test]\n    fn smoke_shared_port_gone2() {\n}\n\n    #[test]\n    fn port_gone_concurrent() {\n}\n\n    #[test]\n    fn port_gone_concurrent_shared() {\n}\n\n    #[test]\n    fn smoke_chan_gone() {\n}\n\n    #[test]\n    fn smoke_chan_gone_shared() {\n}\n\n    #[test]\n    fn chan_gone_concurrent() {\n}\n\n    #[test]\n    fn stress() {\n}\n\n    #[test]\n    fn stress_shared() {\n}\n\n    #[test]\n    fn send_from_outside_runtime() {\n}\n\n    #[test]\n    fn recv_from_outside_runtime() {\n}\n\n    #[test]\n    fn no_runtime() {\n}\n\n    #[test]\n    fn oneshot_single_thread_close_port_first() {\n}\n\n    #[test]\n    fn oneshot_single_thread_close_chan_first() {\n}\n\n    #[test]\n    fn oneshot_single_thread_send_port_close() {\n}\n\n    #[test]\n    fn oneshot_single_thread_recv_chan_close() {\n}\n\n    #[test]\n    fn oneshot_single_thread_send_then_recv() {\n}\n\n    #[test]\n    fn oneshot_single_thread_try_send_open() {\n}\n\n    #[test]\n    fn oneshot_single_thread_try_send_closed() {\n}\n\n    #[test]\n    fn oneshot_single_thread_try_recv_open() {\n}\n\n    #[test]\n    fn oneshot_single_thread_try_recv_closed() {\n}\n\n    #[test]\n    fn oneshot_single_thread_peek_data() {\n}\n\n    #[test]\n    fn oneshot_single_thread_peek_close() {\n}\n\n    #[test]\n    fn oneshot_single_thread_peek_open() {\n}\n\n    #[test]\n    fn oneshot_multi_task_recv_then_send() {\n}\n\n    #[test]\n    fn oneshot_multi_task_recv_then_close() {\n}\n\n    #[test]\n    fn oneshot_multi_thread_close_stress() {\n}\n\n    #[test]\n    fn oneshot_multi_thread_send_close_stress() {\n}\n\n    #[test]\n    fn oneshot_multi_thread_recv_close_stress() {\n}\n\n    #[test]\n    fn oneshot_multi_thread_send_recv_stress() {\n}\n\n    #[test]\n    fn stream_send_recv_stress() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn oneshot_single_thread_recv_timeout() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn stress_recv_timeout_two_threads() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn recv_timeout_upgrade() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn stress_recv_timeout_shared() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn very_long_recv_timeout_wont_panic() {\n}\n\n    #[test]\n    fn recv_a_lot() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn shared_recv_timeout() {\n}\n\n    #[test]\n    fn shared_chan_stress() {\n}\n\n    #[test]\n    fn test_nested_recv_iter() {\n}\n\n    #[test]\n    fn test_recv_iter_break() {\n}\n\n    #[test]\n    fn test_recv_try_iter() {\n}\n\n    #[test]\n    fn test_recv_into_iter_owned() {\n}\n\n    #[test]\n    fn test_recv_into_iter_borrowed() {\n}\n\n    #[test]\n    fn try_recv_states() {\n}\n\n    // This bug used to end up in a livelock inside of the Receiver destructor\n    // because the internal state of the Shared packet was corrupted\n    #[test]\n    fn destroy_upgraded_shared_port_when_sender_still_active() {\n}\n\n    #[test]\n    fn issue_32114() {\n}\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod sync_tests {\n    use super::*;\n    use crate::env;\n    use crate::thread;\n    use crate::time::Duration;\n\n    pub fn stress_factor() -> usize {\n}\n\n    #[test]\n    fn smoke() {\n}\n\n    #[test]\n    fn drop_full() {\n}\n\n    #[test]\n    fn smoke_shared() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn recv_timeout() {\n}\n\n    #[test]\n    fn smoke_threads() {\n}\n\n    #[test]\n    fn smoke_port_gone() {\n}\n\n    #[test]\n    fn smoke_shared_port_gone2() {\n}\n\n    #[test]\n    fn port_gone_concurrent() {\n}\n\n    #[test]\n    fn port_gone_concurrent_shared() {\n}\n\n    #[test]\n    fn smoke_chan_gone() {\n}\n\n    #[test]\n    fn smoke_chan_gone_shared() {\n}\n\n    #[test]\n    fn chan_gone_concurrent() {\n}\n\n    #[test]\n    fn stress() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn stress_recv_timeout_two_threads() {\n}\n\n    #[test]\n    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n    fn stress_recv_timeout_shared() {\n}\n\n    #[test]\n    fn stress_shared() {\n}\n\n    #[test]\n    fn oneshot_single_thread_close_port_first() {\n}\n\n    #[test]\n    fn oneshot_single_thread_close_chan_first() {\n}\n\n    #[test]\n    fn oneshot_single_thread_send_port_close() {\n}\n\n    #[test]\n    fn oneshot_single_thread_recv_chan_close() {\n}\n\n    #[test]\n    fn oneshot_single_thread_send_then_recv() {\n}\n\n    #[test]\n    fn oneshot_single_thread_try_send_open() {\n}\n\n    #[test]\n    fn oneshot_single_thread_try_send_closed() {\n}\n\n    #[test]\n    fn oneshot_single_thread_try_send_closed2() {\n}\n\n    #[test]\n    fn oneshot_single_thread_try_recv_open() {\n}\n\n    #[test]\n    fn oneshot_single_thread_try_recv_closed() {\n}\n\n    #[test]\n    fn oneshot_single_thread_try_recv_closed_with_data() {\n}\n\n    #[test]\n    fn oneshot_single_thread_peek_data() {\n}\n\n    #[test]\n    fn oneshot_single_thread_peek_close() {\n}\n\n    #[test]\n    fn oneshot_single_thread_peek_open() {\n}\n\n    #[test]\n    fn oneshot_multi_task_recv_then_send() {\n}\n\n    #[test]\n    fn oneshot_multi_task_recv_then_close() {\n}\n\n    #[test]\n    fn oneshot_multi_thread_close_stress() {\n}\n\n    #[test]\n    fn oneshot_multi_thread_send_close_stress() {\n}\n\n    #[test]\n    fn oneshot_multi_thread_recv_close_stress() {\n}\n\n    #[test]\n    fn oneshot_multi_thread_send_recv_stress() {\n}\n\n    #[test]\n    fn stream_send_recv_stress() {\n}\n\n    #[test]\n    fn recv_a_lot() {\n}\n\n    #[test]\n    fn shared_chan_stress() {\n}\n\n    #[test]\n    fn test_nested_recv_iter() {\n}\n\n    #[test]\n    fn test_recv_iter_break() {\n}\n\n    #[test]\n    fn try_recv_states() {\n}\n\n    // This bug used to end up in a livelock inside of the Receiver destructor\n    // because the internal state of the Shared packet was corrupted\n    #[test]\n    fn destroy_upgraded_shared_port_when_sender_still_active() {\n}\n\n    #[test]\n    fn send1() {\n}\n\n    #[test]\n    fn send2() {\n}\n\n    #[test]\n    fn send3() {\n}\n\n    #[test]\n    fn send4() {\n}\n\n    #[test]\n    fn try_send1() {\n}\n\n    #[test]\n    fn try_send2() {\n}\n\n    #[test]\n    fn try_send3() {\n}\n\n    #[test]\n    fn issue_15761() {\n}\n}\n}\n\nmod barrier {\nuse crate::fmt;\nuse crate::sync::{Condvar, Mutex};\n\n/// A barrier enables multiple threads to synchronize the beginning\n/// of some computation.\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::{Arc, Barrier};\n/// use std::thread;\n///\n/// let mut handles = Vec::with_capacity(10);\n/// let barrier = Arc::new(Barrier::new(10));\n/// for _ in 0..10 {\n///     let c = barrier.clone();\n///     // The same messages will be printed together.\n///     // You will NOT see any interleaving.\n///     handles.push(thread::spawn(move|| {\n///         println!(\"before wait\");\n///         c.wait();\n///         println!(\"after wait\");\n///     }));\n/// }\n/// // Wait for other threads to finish.\n/// for handle in handles {\n///     handle.join().unwrap();\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Barrier {\n    lock: Mutex<BarrierState>,\n    cvar: Condvar,\n    num_threads: usize,\n}\n\n// The inner state of a double barrier\nstruct BarrierState {\n    count: usize,\n    generation_id: usize,\n}\n\n/// A `BarrierWaitResult` is returned by [`wait`] when all threads in the [`Barrier`]\n/// have rendezvoused.\n///\n/// [`wait`]: struct.Barrier.html#method.wait\n/// [`Barrier`]: struct.Barrier.html\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::Barrier;\n///\n/// let barrier = Barrier::new(1);\n/// let barrier_wait_result = barrier.wait();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct BarrierWaitResult(bool);\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Barrier {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl Barrier {\n    /// Creates a new barrier that can block a given number of threads.\n    ///\n    /// A barrier will block `n`-1 threads which call [`wait`] and then wake up\n    /// all threads at once when the `n`th thread calls [`wait`].\n    ///\n    /// [`wait`]: #method.wait\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Barrier;\n    ///\n    /// let barrier = Barrier::new(10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(n: usize) -> Barrier {\n}\n\n    /// Blocks the current thread until all threads have rendezvoused here.\n    ///\n    /// Barriers are re-usable after all threads have rendezvoused once, and can\n    /// be used continuously.\n    ///\n    /// A single (arbitrary) thread will receive a [`BarrierWaitResult`] that\n    /// returns `true` from [`is_leader`] when returning from this function, and\n    /// all other threads will receive a result that will return `false` from\n    /// [`is_leader`].\n    ///\n    /// [`BarrierWaitResult`]: struct.BarrierWaitResult.html\n    /// [`is_leader`]: struct.BarrierWaitResult.html#method.is_leader\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Barrier};\n    /// use std::thread;\n    ///\n    /// let mut handles = Vec::with_capacity(10);\n    /// let barrier = Arc::new(Barrier::new(10));\n    /// for _ in 0..10 {\n    ///     let c = barrier.clone();\n    ///     // The same messages will be printed together.\n    ///     // You will NOT see any interleaving.\n    ///     handles.push(thread::spawn(move|| {\n    ///         println!(\"before wait\");\n    ///         c.wait();\n    ///         println!(\"after wait\");\n    ///     }));\n    /// }\n    /// // Wait for other threads to finish.\n    /// for handle in handles {\n    ///     handle.join().unwrap();\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn wait(&self) -> BarrierWaitResult {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for BarrierWaitResult {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl BarrierWaitResult {\n    /// Returns `true` if this thread from [`wait`] is the \"leader thread\".\n    ///\n    /// Only one thread will have `true` returned from their result, all other\n    /// threads will have `false` returned.\n    ///\n    /// [`wait`]: struct.Barrier.html#method.wait\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Barrier;\n    ///\n    /// let barrier = Barrier::new(1);\n    /// let barrier_wait_result = barrier.wait();\n    /// println!(\"{:?}\", barrier_wait_result.is_leader());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_leader(&self) -> bool {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod condvar {\nuse crate::fmt;\nuse crate::sync::atomic::{AtomicUsize, Ordering};\nuse crate::sync::{mutex, MutexGuard, PoisonError};\nuse crate::sys_common::condvar as sys;\nuse crate::sys_common::mutex as sys_mutex;\nuse crate::sys_common::poison::{self, LockResult};\nuse crate::time::{Duration, Instant};\n\n/// A type indicating whether a timed wait on a condition variable returned\n/// due to a time out or not.\n///\n/// It is returned by the [`wait_timeout`] method.\n///\n/// [`wait_timeout`]: struct.Condvar.html#method.wait_timeout\n#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n#[stable(feature = \"wait_timeout\", since = \"1.5.0\")]\npub struct WaitTimeoutResult(bool);\n\nimpl WaitTimeoutResult {\n    /// Returns `true` if the wait was known to have timed out.\n    ///\n    /// # Examples\n    ///\n    /// This example spawns a thread which will update the boolean value and\n    /// then wait 100 milliseconds before notifying the condvar.\n    ///\n    /// The main thread will wait with a timeout on the condvar and then leave\n    /// once the boolean has been updated and notified.\n    ///\n    /// ```\n    /// use std::sync::{Arc, Condvar, Mutex};\n    /// use std::thread;\n    /// use std::time::Duration;\n    ///\n    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move || {\n    ///     let (lock, cvar) = &*pair2;\n    ///\n    ///     // Let's wait 20 milliseconds before notifying the condvar.\n    ///     thread::sleep(Duration::from_millis(20));\n    ///\n    ///     let mut started = lock.lock().unwrap();\n    ///     // We update the boolean value.\n    ///     *started = true;\n    ///     cvar.notify_one();\n    /// });\n    ///\n    /// // Wait for the thread to start up.\n    /// let (lock, cvar) = &*pair;\n    /// let mut started = lock.lock().unwrap();\n    /// loop {\n    ///     // Let's put a timeout on the condvar's wait.\n    ///     let result = cvar.wait_timeout(started, Duration::from_millis(10)).unwrap();\n    ///     // 10 milliseconds have passed, or maybe the value changed!\n    ///     started = result.0;\n    ///     if *started == true {\n    ///         // We received the notification and the value has been updated, we can leave.\n    ///         break\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"wait_timeout\", since = \"1.5.0\")]\n    pub fn timed_out(&self) -> bool {\n}\n}\n\n/// A Condition Variable\n///\n/// Condition variables represent the ability to block a thread such that it\n/// consumes no CPU time while waiting for an event to occur. Condition\n/// variables are typically associated with a boolean predicate (a condition)\n/// and a mutex. The predicate is always verified inside of the mutex before\n/// determining that a thread must block.\n///\n/// Functions in this module will block the current **thread** of execution and\n/// are bindings to system-provided condition variables where possible. Note\n/// that this module places one additional restriction over the system condition\n/// variables: each condvar can be used with precisely one mutex at runtime. Any\n/// attempt to use multiple mutexes on the same condition variable will result\n/// in a runtime panic. If this is not desired, then the unsafe primitives in\n/// `sys` do not have this restriction but may result in undefined behavior.\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::{Arc, Mutex, Condvar};\n/// use std::thread;\n///\n/// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n/// let pair2 = pair.clone();\n///\n/// // Inside of our lock, spawn a new thread, and then wait for it to start.\n/// thread::spawn(move|| {\n///     let (lock, cvar) = &*pair2;\n///     let mut started = lock.lock().unwrap();\n///     *started = true;\n///     // We notify the condvar that the value has changed.\n///     cvar.notify_one();\n/// });\n///\n/// // Wait for the thread to start up.\n/// let (lock, cvar) = &*pair;\n/// let mut started = lock.lock().unwrap();\n/// while !*started {\n///     started = cvar.wait(started).unwrap();\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Condvar {\n    inner: Box<sys::Condvar>,\n    mutex: AtomicUsize,\n}\n\nimpl Condvar {\n    /// Creates a new condition variable which is ready to be waited on and\n    /// notified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Condvar;\n    ///\n    /// let condvar = Condvar::new();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> Condvar {\n}\n\n    /// Blocks the current thread until this condition variable receives a\n    /// notification.\n    ///\n    /// This function will atomically unlock the mutex specified (represented by\n    /// `guard`) and block the current thread. This means that any calls\n    /// to [`notify_one`] or [`notify_all`] which happen logically after the\n    /// mutex is unlocked are candidates to wake this thread up. When this\n    /// function call returns, the lock specified will have been re-acquired.\n    ///\n    /// Note that this function is susceptible to spurious wakeups. Condition\n    /// variables normally have a boolean predicate associated with them, and\n    /// the predicate must always be checked each time this function returns to\n    /// protect against spurious wakeups.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the mutex being waited on is\n    /// poisoned when this thread re-acquires the lock. For more information,\n    /// see information about [poisoning] on the [`Mutex`] type.\n    ///\n    /// # Panics\n    ///\n    /// This function will [`panic!`] if it is used with more than one mutex\n    /// over time. Each condition variable is dynamically bound to exactly one\n    /// mutex to ensure defined behavior across platforms. If this functionality\n    /// is not desired, then unsafe primitives in `sys` are provided.\n    ///\n    /// [`notify_one`]: #method.notify_one\n    /// [`notify_all`]: #method.notify_all\n    /// [poisoning]: ../sync/struct.Mutex.html#poisoning\n    /// [`Mutex`]: ../sync/struct.Mutex.html\n    /// [`panic!`]: ../../std/macro.panic.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    ///\n    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let (lock, cvar) = &*pair2;\n    ///     let mut started = lock.lock().unwrap();\n    ///     *started = true;\n    ///     // We notify the condvar that the value has changed.\n    ///     cvar.notify_one();\n    /// });\n    ///\n    /// // Wait for the thread to start up.\n    /// let (lock, cvar) = &*pair;\n    /// let mut started = lock.lock().unwrap();\n    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n    /// while !*started {\n    ///     started = cvar.wait(started).unwrap();\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>) -> LockResult<MutexGuard<'a, T>> {\n}\n\n    /// Blocks the current thread until this condition variable receives a\n    /// notification and the provided condition is false.\n    ///\n    /// This function will atomically unlock the mutex specified (represented by\n    /// `guard`) and block the current thread. This means that any calls\n    /// to [`notify_one`] or [`notify_all`] which happen logically after the\n    /// mutex is unlocked are candidates to wake this thread up. When this\n    /// function call returns, the lock specified will have been re-acquired.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the mutex being waited on is\n    /// poisoned when this thread re-acquires the lock. For more information,\n    /// see information about [poisoning] on the [`Mutex`] type.\n    ///\n    /// [`notify_one`]: #method.notify_one\n    /// [`notify_all`]: #method.notify_all\n    /// [poisoning]: ../sync/struct.Mutex.html#poisoning\n    /// [`Mutex`]: ../sync/struct.Mutex.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    ///\n    /// let pair = Arc::new((Mutex::new(true), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let (lock, cvar) = &*pair2;\n    ///     let mut pending = lock.lock().unwrap();\n    ///     *pending = false;\n    ///     // We notify the condvar that the value has changed.\n    ///     cvar.notify_one();\n    /// });\n    ///\n    /// // Wait for the thread to start up.\n    /// let (lock, cvar) = &*pair;\n    /// // As long as the value inside the `Mutex<bool>` is `true`, we wait.\n    /// let _guard = cvar.wait_while(lock.lock().unwrap(), |pending| { *pending }).unwrap();\n    /// ```\n    #[stable(feature = \"wait_until\", since = \"1.42.0\")]\n    pub fn wait_while<'a, T, F>(\n        &self,\n        mut guard: MutexGuard<'a, T>,\n        mut condition: F,\n    ) -> LockResult<MutexGuard<'a, T>>\n    where\n        F: FnMut(&mut T) -> bool,\n    {\n}\n\n    /// Waits on this condition variable for a notification, timing out after a\n    /// specified duration.\n    ///\n    /// The semantics of this function are equivalent to [`wait`]\n    /// except that the thread will be blocked for roughly no longer\n    /// than `ms` milliseconds. This method should not be used for\n    /// precise timing due to anomalies such as preemption or platform\n    /// differences that may not cause the maximum amount of time\n    /// waited to be precisely `ms`.\n    ///\n    /// Note that the best effort is made to ensure that the time waited is\n    /// measured with a monotonic clock, and not affected by the changes made to\n    /// the system time.\n    ///\n    /// The returned boolean is `false` only if the timeout is known\n    /// to have elapsed.\n    ///\n    /// Like [`wait`], the lock specified will be re-acquired when this function\n    /// returns, regardless of whether the timeout elapsed or not.\n    ///\n    /// [`wait`]: #method.wait\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    ///\n    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let (lock, cvar) = &*pair2;\n    ///     let mut started = lock.lock().unwrap();\n    ///     *started = true;\n    ///     // We notify the condvar that the value has changed.\n    ///     cvar.notify_one();\n    /// });\n    ///\n    /// // Wait for the thread to start up.\n    /// let (lock, cvar) = &*pair;\n    /// let mut started = lock.lock().unwrap();\n    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n    /// loop {\n    ///     let result = cvar.wait_timeout_ms(started, 10).unwrap();\n    ///     // 10 milliseconds have passed, or maybe the value changed!\n    ///     started = result.0;\n    ///     if *started == true {\n    ///         // We received the notification and the value has been updated, we can leave.\n    ///         break\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::sync::Condvar::wait_timeout`\")]\n    pub fn wait_timeout_ms<'a, T>(\n        &self,\n        guard: MutexGuard<'a, T>,\n        ms: u32,\n    ) -> LockResult<(MutexGuard<'a, T>, bool)> {\n}\n\n    /// Waits on this condition variable for a notification, timing out after a\n    /// specified duration.\n    ///\n    /// The semantics of this function are equivalent to [`wait`] except that\n    /// the thread will be blocked for roughly no longer than `dur`. This\n    /// method should not be used for precise timing due to anomalies such as\n    /// preemption or platform differences that may not cause the maximum\n    /// amount of time waited to be precisely `dur`.\n    ///\n    /// Note that the best effort is made to ensure that the time waited is\n    /// measured with a monotonic clock, and not affected by the changes made to\n    /// the system time. This function is susceptible to spurious wakeups.\n    /// Condition variables normally have a boolean predicate associated with\n    /// them, and the predicate must always be checked each time this function\n    /// returns to protect against spurious wakeups. Additionally, it is\n    /// typically desirable for the timeout to not exceed some duration in\n    /// spite of spurious wakes, thus the sleep-duration is decremented by the\n    /// amount slept. Alternatively, use the `wait_timeout_while` method\n    /// to wait with a timeout while a predicate is true.\n    ///\n    /// The returned [`WaitTimeoutResult`] value indicates if the timeout is\n    /// known to have elapsed.\n    ///\n    /// Like [`wait`], the lock specified will be re-acquired when this function\n    /// returns, regardless of whether the timeout elapsed or not.\n    ///\n    /// [`wait`]: #method.wait\n    /// [`wait_timeout_while`]: #method.wait_timeout_while\n    /// [`WaitTimeoutResult`]: struct.WaitTimeoutResult.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    /// use std::time::Duration;\n    ///\n    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let (lock, cvar) = &*pair2;\n    ///     let mut started = lock.lock().unwrap();\n    ///     *started = true;\n    ///     // We notify the condvar that the value has changed.\n    ///     cvar.notify_one();\n    /// });\n    ///\n    /// // wait for the thread to start up\n    /// let (lock, cvar) = &*pair;\n    /// let mut started = lock.lock().unwrap();\n    /// // as long as the value inside the `Mutex<bool>` is `false`, we wait\n    /// loop {\n    ///     let result = cvar.wait_timeout(started, Duration::from_millis(10)).unwrap();\n    ///     // 10 milliseconds have passed, or maybe the value changed!\n    ///     started = result.0;\n    ///     if *started == true {\n    ///         // We received the notification and the value has been updated, we can leave.\n    ///         break\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"wait_timeout\", since = \"1.5.0\")]\n    pub fn wait_timeout<'a, T>(\n        &self,\n        guard: MutexGuard<'a, T>,\n        dur: Duration,\n    ) -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n}\n\n    /// Waits on this condition variable for a notification, timing out after a\n    /// specified duration.\n    ///\n    /// The semantics of this function are equivalent to [`wait_while`] except\n    /// that the thread will be blocked for roughly no longer than `dur`. This\n    /// method should not be used for precise timing due to anomalies such as\n    /// preemption or platform differences that may not cause the maximum\n    /// amount of time waited to be precisely `dur`.\n    ///\n    /// Note that the best effort is made to ensure that the time waited is\n    /// measured with a monotonic clock, and not affected by the changes made to\n    /// the system time.\n    ///\n    /// The returned [`WaitTimeoutResult`] value indicates if the timeout is\n    /// known to have elapsed without the condition being met.\n    ///\n    /// Like [`wait_while`], the lock specified will be re-acquired when this\n    /// function returns, regardless of whether the timeout elapsed or not.\n    ///\n    /// [`wait_while`]: #method.wait_while\n    /// [`wait_timeout`]: #method.wait_timeout\n    /// [`WaitTimeoutResult`]: struct.WaitTimeoutResult.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    /// use std::time::Duration;\n    ///\n    /// let pair = Arc::new((Mutex::new(true), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let (lock, cvar) = &*pair2;\n    ///     let mut pending = lock.lock().unwrap();\n    ///     *pending = false;\n    ///     // We notify the condvar that the value has changed.\n    ///     cvar.notify_one();\n    /// });\n    ///\n    /// // wait for the thread to start up\n    /// let (lock, cvar) = &*pair;\n    /// let result = cvar.wait_timeout_while(\n    ///     lock.lock().unwrap(),\n    ///     Duration::from_millis(100),\n    ///     |&mut pending| pending,\n    /// ).unwrap();\n    /// if result.1.timed_out() {\n    ///     // timed-out without the condition ever evaluating to false.\n    /// }\n    /// // access the locked mutex via result.0\n    /// ```\n    #[stable(feature = \"wait_timeout_until\", since = \"1.42.0\")]\n    pub fn wait_timeout_while<'a, T, F>(\n        &self,\n        mut guard: MutexGuard<'a, T>,\n        dur: Duration,\n        mut condition: F,\n    ) -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)>\n    where\n        F: FnMut(&mut T) -> bool,\n    {\n}\n\n    /// Wakes up one blocked thread on this condvar.\n    ///\n    /// If there is a blocked thread on this condition variable, then it will\n    /// be woken up from its call to [`wait`] or [`wait_timeout`]. Calls to\n    /// `notify_one` are not buffered in any way.\n    ///\n    /// To wake up all threads, see [`notify_all`].\n    ///\n    /// [`wait`]: #method.wait\n    /// [`wait_timeout`]: #method.wait_timeout\n    /// [`notify_all`]: #method.notify_all\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    ///\n    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let (lock, cvar) = &*pair2;\n    ///     let mut started = lock.lock().unwrap();\n    ///     *started = true;\n    ///     // We notify the condvar that the value has changed.\n    ///     cvar.notify_one();\n    /// });\n    ///\n    /// // Wait for the thread to start up.\n    /// let (lock, cvar) = &*pair;\n    /// let mut started = lock.lock().unwrap();\n    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n    /// while !*started {\n    ///     started = cvar.wait(started).unwrap();\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn notify_one(&self) {\n}\n\n    /// Wakes up all blocked threads on this condvar.\n    ///\n    /// This method will ensure that any current waiters on the condition\n    /// variable are awoken. Calls to `notify_all()` are not buffered in any\n    /// way.\n    ///\n    /// To wake up only one thread, see [`notify_one`].\n    ///\n    /// [`notify_one`]: #method.notify_one\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex, Condvar};\n    /// use std::thread;\n    ///\n    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    /// let pair2 = pair.clone();\n    ///\n    /// thread::spawn(move|| {\n    ///     let (lock, cvar) = &*pair2;\n    ///     let mut started = lock.lock().unwrap();\n    ///     *started = true;\n    ///     // We notify the condvar that the value has changed.\n    ///     cvar.notify_all();\n    /// });\n    ///\n    /// // Wait for the thread to start up.\n    /// let (lock, cvar) = &*pair;\n    /// let mut started = lock.lock().unwrap();\n    /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n    /// while !*started {\n    ///     started = cvar.wait(started).unwrap();\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn notify_all(&self) {\n}\n\n    fn verify(&self, mutex: &sys_mutex::Mutex) {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Condvar {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"condvar_default\", since = \"1.10.0\")]\nimpl Default for Condvar {\n    /// Creates a `Condvar` which is ready to be waited on and notified.\n    fn default() -> Condvar {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Drop for Condvar {\n    fn drop(&mut self) {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod mutex {\nuse crate::cell::UnsafeCell;\nuse crate::fmt;\nuse crate::mem;\nuse crate::ops::{Deref, DerefMut};\nuse crate::ptr;\nuse crate::sys_common::mutex as sys;\nuse crate::sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n\n/// A mutual exclusion primitive useful for protecting shared data\n///\n/// This mutex will block threads waiting for the lock to become available. The\n/// mutex can also be statically initialized or created via a [`new`]\n/// constructor. Each mutex has a type parameter which represents the data that\n/// it is protecting. The data can only be accessed through the RAII guards\n/// returned from [`lock`] and [`try_lock`], which guarantees that the data is only\n/// ever accessed when the mutex is locked.\n///\n/// # Poisoning\n///\n/// The mutexes in this module implement a strategy called \"poisoning\" where a\n/// mutex is considered poisoned whenever a thread panics while holding the\n/// mutex. Once a mutex is poisoned, all other threads are unable to access the\n/// data by default as it is likely tainted (some invariant is not being\n/// upheld).\n///\n/// For a mutex, this means that the [`lock`] and [`try_lock`] methods return a\n/// [`Result`] which indicates whether a mutex has been poisoned or not. Most\n/// usage of a mutex will simply [`unwrap()`] these results, propagating panics\n/// among threads to ensure that a possibly invalid invariant is not witnessed.\n///\n/// A poisoned mutex, however, does not prevent all access to the underlying\n/// data. The [`PoisonError`] type has an [`into_inner`] method which will return\n/// the guard that would have otherwise been returned on a successful lock. This\n/// allows access to the data, despite the lock being poisoned.\n///\n/// [`new`]: #method.new\n/// [`lock`]: #method.lock\n/// [`try_lock`]: #method.try_lock\n/// [`Result`]: ../../std/result/enum.Result.html\n/// [`unwrap()`]: ../../std/result/enum.Result.html#method.unwrap\n/// [`PoisonError`]: ../../std/sync/struct.PoisonError.html\n/// [`into_inner`]: ../../std/sync/struct.PoisonError.html#method.into_inner\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::{Arc, Mutex};\n/// use std::thread;\n/// use std::sync::mpsc::channel;\n///\n/// const N: usize = 10;\n///\n/// // Spawn a few threads to increment a shared variable (non-atomically), and\n/// // let the main thread know once all increments are done.\n/// //\n/// // Here we're using an Arc to share memory among threads, and the data inside\n/// // the Arc is protected with a mutex.\n/// let data = Arc::new(Mutex::new(0));\n///\n/// let (tx, rx) = channel();\n/// for _ in 0..N {\n///     let (data, tx) = (Arc::clone(&data), tx.clone());\n///     thread::spawn(move || {\n///         // The shared state can only be accessed once the lock is held.\n///         // Our non-atomic increment is safe because we're the only thread\n///         // which can access the shared state when the lock is held.\n///         //\n///         // We unwrap() the return value to assert that we are not expecting\n///         // threads to ever fail while holding the lock.\n///         let mut data = data.lock().unwrap();\n///         *data += 1;\n///         if *data == N {\n///             tx.send(()).unwrap();\n///         }\n///         // the lock is unlocked here when `data` goes out of scope.\n///     });\n/// }\n///\n/// rx.recv().unwrap();\n/// ```\n///\n/// To recover from a poisoned mutex:\n///\n/// ```\n/// use std::sync::{Arc, Mutex};\n/// use std::thread;\n///\n/// let lock = Arc::new(Mutex::new(0_u32));\n/// let lock2 = lock.clone();\n///\n/// let _ = thread::spawn(move || -> () {\n///     // This thread will acquire the mutex first, unwrapping the result of\n///     // `lock` because the lock has not been poisoned.\n///     let _guard = lock2.lock().unwrap();\n///\n///     // This panic while holding the lock (`_guard` is in scope) will poison\n///     // the mutex.\n///     panic!();\n/// }).join();\n///\n/// // The lock is poisoned by this point, but the returned result can be\n/// // pattern matched on to return the underlying guard on both branches.\n/// let mut guard = match lock.lock() {\n///     Ok(guard) => guard,\n///     Err(poisoned) => poisoned.into_inner(),\n/// };\n///\n/// *guard += 1;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Mutex<T: ?Sized> {\n    // Note that this mutex is in a *box*, not inlined into the struct itself.\n    // Once a native mutex has been used once, its address can never change (it\n    // can't be moved). This mutex type can be safely moved at any time, so to\n    // ensure that the native mutex is used correctly we box the inner mutex to\n    // give it a constant address.\n    inner: Box<sys::Mutex>,\n    poison: poison::Flag,\n    data: UnsafeCell<T>,\n}\n\n// these are the only places where `T: Send` matters; all other\n// functionality works fine on a single thread.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: ?Sized + Send> Send for Mutex<T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: ?Sized + Send> Sync for Mutex<T> {}\n\n/// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n/// dropped (falls out of scope), the lock will be unlocked.\n///\n/// The data protected by the mutex can be accessed through this guard via its\n/// [`Deref`] and [`DerefMut`] implementations.\n///\n/// This structure is created by the [`lock`] and [`try_lock`] methods on\n/// [`Mutex`].\n///\n/// [`Deref`]: ../../std/ops/trait.Deref.html\n/// [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n/// [`lock`]: struct.Mutex.html#method.lock\n/// [`try_lock`]: struct.Mutex.html#method.try_lock\n/// [`Mutex`]: struct.Mutex.html\n#[must_use = \"if unused the Mutex will immediately unlock\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct MutexGuard<'a, T: ?Sized + 'a> {\n    lock: &'a Mutex<T>,\n    poison: poison::Guard,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !Send for MutexGuard<'_, T> {}\n#[stable(feature = \"mutexguard\", since = \"1.19.0\")]\nunsafe impl<T: ?Sized + Sync> Sync for MutexGuard<'_, T> {}\n\nimpl<T> Mutex<T> {\n    /// Creates a new mutex in an unlocked state ready for use.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Mutex;\n    ///\n    /// let mutex = Mutex::new(0);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(t: T) -> Mutex<T> {\n}\n}\n\nimpl<T: ?Sized> Mutex<T> {\n    /// Acquires a mutex, blocking the current thread until it is able to do so.\n    ///\n    /// This function will block the local thread until it is available to acquire\n    /// the mutex. Upon returning, the thread is the only thread with the lock\n    /// held. An RAII guard is returned to allow scoped unlock of the lock. When\n    /// the guard goes out of scope, the mutex will be unlocked.\n    ///\n    /// The exact behavior on locking a mutex in the thread which already holds\n    /// the lock is left unspecified. However, this function will not return on\n    /// the second call (it might panic or deadlock, for example).\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return an error once the mutex is acquired.\n    ///\n    /// # Panics\n    ///\n    /// This function might panic when called if the lock is already held by\n    /// the current thread.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex};\n    /// use std::thread;\n    ///\n    /// let mutex = Arc::new(Mutex::new(0));\n    /// let c_mutex = mutex.clone();\n    ///\n    /// thread::spawn(move || {\n    ///     *c_mutex.lock().unwrap() = 10;\n    /// }).join().expect(\"thread::spawn failed\");\n    /// assert_eq!(*mutex.lock().unwrap(), 10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn lock(&self) -> LockResult<MutexGuard<'_, T>> {\n}\n\n    /// Attempts to acquire this lock.\n    ///\n    /// If the lock could not be acquired at this time, then [`Err`] is returned.\n    /// Otherwise, an RAII guard is returned. The lock will be unlocked when the\n    /// guard is dropped.\n    ///\n    /// This function does not block.\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return failure if the mutex would otherwise be\n    /// acquired.\n    ///\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex};\n    /// use std::thread;\n    ///\n    /// let mutex = Arc::new(Mutex::new(0));\n    /// let c_mutex = mutex.clone();\n    ///\n    /// thread::spawn(move || {\n    ///     let mut lock = c_mutex.try_lock();\n    ///     if let Ok(ref mut mutex) = lock {\n    ///         **mutex = 10;\n    ///     } else {\n    ///         println!(\"try_lock failed\");\n    ///     }\n    /// }).join().expect(\"thread::spawn failed\");\n    /// assert_eq!(*mutex.lock().unwrap(), 10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn try_lock(&self) -> TryLockResult<MutexGuard<'_, T>> {\n}\n\n    /// Determines whether the mutex is poisoned.\n    ///\n    /// If another thread is active, the mutex can still become poisoned at any\n    /// time. You should not trust a `false` value for program correctness\n    /// without additional synchronization.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, Mutex};\n    /// use std::thread;\n    ///\n    /// let mutex = Arc::new(Mutex::new(0));\n    /// let c_mutex = mutex.clone();\n    ///\n    /// let _ = thread::spawn(move || {\n    ///     let _lock = c_mutex.lock().unwrap();\n    ///     panic!(); // the mutex gets poisoned\n    /// }).join();\n    /// assert_eq!(mutex.is_poisoned(), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n    pub fn is_poisoned(&self) -> bool {\n}\n\n    /// Consumes this mutex, returning the underlying data.\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return an error instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Mutex;\n    ///\n    /// let mutex = Mutex::new(0);\n    /// assert_eq!(mutex.into_inner().unwrap(), 0);\n    /// ```\n    #[stable(feature = \"mutex_into_inner\", since = \"1.6.0\")]\n    pub fn into_inner(self) -> LockResult<T>\n    where\n        T: Sized,\n    {\n}\n\n    /// Returns a mutable reference to the underlying data.\n    ///\n    /// Since this call borrows the `Mutex` mutably, no actual locking needs to\n    /// take place -- the mutable borrow statically guarantees no locks exist.\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return an error instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Mutex;\n    ///\n    /// let mut mutex = Mutex::new(0);\n    /// *mutex.get_mut().unwrap() = 10;\n    /// assert_eq!(*mutex.lock().unwrap(), 10);\n    /// ```\n    #[stable(feature = \"mutex_get_mut\", since = \"1.6.0\")]\n    pub fn get_mut(&mut self) -> LockResult<&mut T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T: ?Sized> Drop for Mutex<T> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"mutex_from\", since = \"1.24.0\")]\nimpl<T> From<T> for Mutex<T> {\n    /// Creates a new mutex in an unlocked state ready for use.\n    /// This is equivalent to [`Mutex::new`].\n    ///\n    /// [`Mutex::new`]: ../../std/sync/struct.Mutex.html#method.new\n    fn from(t: T) -> Self {\n}\n}\n\n#[stable(feature = \"mutex_default\", since = \"1.10.0\")]\nimpl<T: ?Sized + Default> Default for Mutex<T> {\n    /// Creates a `Mutex<T>`, with the `Default` value for T.\n    fn default() -> Mutex<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + fmt::Debug> fmt::Debug for Mutex<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n    unsafe fn new(lock: &'mutex Mutex<T>) -> LockResult<MutexGuard<'mutex, T>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Deref for MutexGuard<'_, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> DerefMut for MutexGuard<'_, T> {\n    fn deref_mut(&mut self) -> &mut T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Drop for MutexGuard<'_, T> {\n    #[inline]\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T: ?Sized + fmt::Debug> fmt::Debug for MutexGuard<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"std_guard_impls\", since = \"1.20.0\")]\nimpl<T: ?Sized + fmt::Display> fmt::Display for MutexGuard<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\npub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n}\n\npub fn guard_poison<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use crate::sync::atomic::{AtomicUsize, Ordering};\n    use crate::sync::mpsc::channel;\n    use crate::sync::{Arc, Condvar, Mutex};\n    use crate::thread;\n\n    struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n\n    #[derive(Eq, PartialEq, Debug)]\n    struct NonCopy(i32);\n\n    #[test]\n    fn smoke() {\n}\n\n    #[test]\n    fn lots_and_lots() {\n}\n\n    #[test]\n    fn try_lock() {\n}\n\n    #[test]\n    fn test_into_inner() {\n}\n\n    #[test]\n    fn test_into_inner_drop() {\n}\n\n    #[test]\n    fn test_into_inner_poison() {\n}\n\n    #[test]\n    fn test_get_mut() {\n}\n\n    #[test]\n    fn test_get_mut_poison() {\n}\n\n    #[test]\n    fn test_mutex_arc_condvar() {\n}\n\n    #[test]\n    fn test_arc_condvar_poison() {\n}\n\n    #[test]\n    fn test_mutex_arc_poison() {\n}\n\n    #[test]\n    fn test_mutex_arc_nested() {\n}\n\n    #[test]\n    fn test_mutex_arc_access_in_unwind() {\n}\n\n    #[test]\n    fn test_mutex_unsized() {\n}\n}\n}\nmod once {\n//! A \"once initialization\" primitive\n//!\n//! This primitive is meant to be used to run one-time initialization. An\n//! example use case would be for initializing an FFI library.\n\n// A \"once\" is a relatively simple primitive, and it's also typically provided\n// by the OS as well (see `pthread_once` or `InitOnceExecuteOnce`). The OS\n// primitives, however, tend to have surprising restrictions, such as the Unix\n// one doesn't allow an argument to be passed to the function.\n//\n// As a result, we end up implementing it ourselves in the standard library.\n// This also gives us the opportunity to optimize the implementation a bit which\n// should help the fast path on call sites. Consequently, let's explain how this\n// primitive works now!\n//\n// So to recap, the guarantees of a Once are that it will call the\n// initialization closure at most once, and it will never return until the one\n// that's running has finished running. This means that we need some form of\n// blocking here while the custom callback is running at the very least.\n// Additionally, we add on the restriction of **poisoning**. Whenever an\n// initialization closure panics, the Once enters a \"poisoned\" state which means\n// that all future calls will immediately panic as well.\n//\n// So to implement this, one might first reach for a `Mutex`, but those cannot\n// be put into a `static`. It also gets a lot harder with poisoning to figure\n// out when the mutex needs to be deallocated because it's not after the closure\n// finishes, but after the first successful closure finishes.\n//\n// All in all, this is instead implemented with atomics and lock-free\n// operations! Whee! Each `Once` has one word of atomic state, and this state is\n// CAS'd on to determine what to do. There are four possible state of a `Once`:\n//\n// * Incomplete - no initialization has run yet, and no thread is currently\n//                using the Once.\n// * Poisoned - some thread has previously attempted to initialize the Once, but\n//              it panicked, so the Once is now poisoned. There are no other\n//              threads currently accessing this Once.\n// * Running - some thread is currently attempting to run initialization. It may\n//             succeed, so all future threads need to wait for it to finish.\n//             Note that this state is accompanied with a payload, described\n//             below.\n// * Complete - initialization has completed and all future calls should finish\n//              immediately.\n//\n// With 4 states we need 2 bits to encode this, and we use the remaining bits\n// in the word we have allocated as a queue of threads waiting for the thread\n// responsible for entering the RUNNING state. This queue is just a linked list\n// of Waiter nodes which is monotonically increasing in size. Each node is\n// allocated on the stack, and whenever the running closure finishes it will\n// consume the entire queue and notify all waiters they should try again.\n//\n// You'll find a few more details in the implementation, but that's the gist of\n// it!\n//\n// Atomic orderings:\n// When running `Once` we deal with multiple atomics:\n// `Once.state_and_queue` and an unknown number of `Waiter.signaled`.\n// * `state_and_queue` is used (1) as a state flag, (2) for synchronizing the\n//   result of the `Once`, and (3) for synchronizing `Waiter` nodes.\n//     - At the end of the `call_inner` function we have to make sure the result\n//       of the `Once` is acquired. So every load which can be the only one to\n//       load COMPLETED must have at least Acquire ordering, which means all\n//       three of them.\n//     - `WaiterQueue::Drop` is the only place that may store COMPLETED, and\n//       must do so with Release ordering to make the result available.\n//     - `wait` inserts `Waiter` nodes as a pointer in `state_and_queue`, and\n//       needs to make the nodes available with Release ordering. The load in\n//       its `compare_and_swap` can be Relaxed because it only has to compare\n//       the atomic, not to read other data.\n//     - `WaiterQueue::Drop` must see the `Waiter` nodes, so it must load\n//       `state_and_queue` with Acquire ordering.\n//     - There is just one store where `state_and_queue` is used only as a\n//       state flag, without having to synchronize data: switching the state\n//       from INCOMPLETE to RUNNING in `call_inner`. This store can be Relaxed,\n//       but the read has to be Acquire because of the requirements mentioned\n//       above.\n// * `Waiter.signaled` is both used as a flag, and to protect a field with\n//   interior mutability in `Waiter`. `Waiter.thread` is changed in\n//   `WaiterQueue::Drop` which then sets `signaled` with Release ordering.\n//   After `wait` loads `signaled` with Acquire and sees it is true, it needs to\n//   see the changes to drop the `Waiter` struct correctly.\n// * There is one place where the two atomics `Once.state_and_queue` and\n//   `Waiter.signaled` come together, and might be reordered by the compiler or\n//   processor. Because both use Aquire ordering such a reordering is not\n//   allowed, so no need for SeqCst.\n\nuse crate::cell::Cell;\nuse crate::fmt;\nuse crate::marker;\nuse crate::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\nuse crate::thread::{self, Thread};\n\n/// A synchronization primitive which can be used to run a one-time global\n/// initialization. Useful for one-time initialization for FFI or related\n/// functionality. This type can only be constructed with the [`Once::new`]\n/// constructor.\n///\n/// [`Once::new`]: struct.Once.html#method.new\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::Once;\n///\n/// static START: Once = Once::new();\n///\n/// START.call_once(|| {\n///     // run initialization here\n/// });\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Once {\n    // `state_and_queue` is actually an a pointer to a `Waiter` with extra state\n    // bits, so we add the `PhantomData` appropriately.\n    state_and_queue: AtomicUsize,\n    _marker: marker::PhantomData<*const Waiter>,\n}\n\n// The `PhantomData` of a raw pointer removes these two auto traits, but we\n// enforce both below in the implementation so this should be safe to add.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl Sync for Once {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl Send for Once {}\n\n/// State yielded to [`call_once_force`]’s closure parameter. The state can be\n/// used to query the poison status of the [`Once`].\n///\n/// [`call_once_force`]: struct.Once.html#method.call_once_force\n/// [`Once`]: struct.Once.html\n#[unstable(feature = \"once_poison\", issue = \"33577\")]\n#[derive(Debug)]\npub struct OnceState {\n}\n\n/// Initialization value for static [`Once`] values.\n///\n/// [`Once`]: struct.Once.html\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::{Once, ONCE_INIT};\n///\n/// static START: Once = ONCE_INIT;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"1.38.0\",\n    reason = \"the `new` function is now preferred\",\n    suggestion = \"Once::new()\"\n)]\npub const ONCE_INIT: Once = Once::new();\n\n// Four states that a Once can be in, encoded into the lower bits of\n// `state_and_queue` in the Once structure.\nconst INCOMPLETE: usize = 0x0;\nconst POISONED: usize = 0x1;\nconst RUNNING: usize = 0x2;\nconst COMPLETE: usize = 0x3;\n\n// Mask to learn about the state. All other bits are the queue of waiters if\n// this is in the RUNNING state.\nconst STATE_MASK: usize = 0x3;\n\n// Representation of a node in the linked list of waiters, used while in the\n// RUNNING state.\n// Note: `Waiter` can't hold a mutable pointer to the next thread, because then\n// `wait` would both hand out a mutable reference to its `Waiter` node, and keep\n// a shared reference to check `signaled`. Instead we hold shared references and\n// use interior mutability.\n#[repr(align(4))] // Ensure the two lower bits are free to use as state bits.\nstruct Waiter {\n    thread: Cell<Option<Thread>>,\n    signaled: AtomicBool,\n    next: *const Waiter,\n}\n\n// Head of a linked list of waiters.\n// Every node is a struct on the stack of a waiting thread.\n// Will wake up the waiters when it gets dropped, i.e. also on panic.\nstruct WaiterQueue<'a> {\n    state_and_queue: &'a AtomicUsize,\n    set_state_on_drop_to: usize,\n}\n\nimpl Once {\n    /// Creates a new `Once` value.\n    #[stable(feature = \"once_new\", since = \"1.2.0\")]\n    #[rustc_const_stable(feature = \"const_once_new\", since = \"1.32.0\")]\n    pub const fn new() -> Once {\n}\n\n    /// Performs an initialization routine once and only once. The given closure\n    /// will be executed if this is the first time `call_once` has been called,\n    /// and otherwise the routine will *not* be invoked.\n    ///\n    /// This method will block the calling thread if another initialization\n    /// routine is currently running.\n    ///\n    /// When this function returns, it is guaranteed that some initialization\n    /// has run and completed (it may not be the closure specified). It is also\n    /// guaranteed that any memory writes performed by the executed closure can\n    /// be reliably observed by other threads at this point (there is a\n    /// happens-before relation between the closure and code executing after the\n    /// return).\n    ///\n    /// If the given closure recursively invokes `call_once` on the same `Once`\n    /// instance the exact behavior is not specified, allowed outcomes are\n    /// a panic or a deadlock.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::Once;\n    ///\n    /// static mut VAL: usize = 0;\n    /// static INIT: Once = Once::new();\n    ///\n    /// // Accessing a `static mut` is unsafe much of the time, but if we do so\n    /// // in a synchronized fashion (e.g., write once or read all) then we're\n    /// // good to go!\n    /// //\n    /// // This function will only call `expensive_computation` once, and will\n    /// // otherwise always return the value returned from the first invocation.\n    /// fn get_cached_val() -> usize {\n    ///     unsafe {\n    ///         INIT.call_once(|| {\n    ///             VAL = expensive_computation();\n    ///         });\n    ///         VAL\n    ///     }\n    /// }\n    ///\n    /// fn expensive_computation() -> usize {\n    ///     // ...\n    /// # 2\n    /// }\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// The closure `f` will only be executed once if this is called\n    /// concurrently amongst many threads. If that closure panics, however, then\n    /// it will *poison* this `Once` instance, causing all future invocations of\n    /// `call_once` to also panic.\n    ///\n    /// This is similar to [poisoning with mutexes][poison].\n    ///\n    /// [poison]: struct.Mutex.html#poisoning\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn call_once<F>(&self, f: F)\n    where\n        F: FnOnce(),\n    {\n}\n\n    /// Performs the same function as [`call_once`] except ignores poisoning.\n    ///\n    /// Unlike [`call_once`], if this `Once` has been poisoned (i.e., a previous\n    /// call to `call_once` or `call_once_force` caused a panic), calling\n    /// `call_once_force` will still invoke the closure `f` and will _not_\n    /// result in an immediate panic. If `f` panics, the `Once` will remain\n    /// in a poison state. If `f` does _not_ panic, the `Once` will no\n    /// longer be in a poison state and all future calls to `call_once` or\n    /// `call_one_force` will be no-ops.\n    ///\n    /// The closure `f` is yielded a [`OnceState`] structure which can be used\n    /// to query the poison status of the `Once`.\n    ///\n    /// [`call_once`]: struct.Once.html#method.call_once\n    /// [`OnceState`]: struct.OnceState.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_poison)]\n    ///\n    /// use std::sync::Once;\n    /// use std::thread;\n    ///\n    /// static INIT: Once = Once::new();\n    ///\n    /// // poison the once\n    /// let handle = thread::spawn(|| {\n    ///     INIT.call_once(|| panic!());\n    /// });\n    /// assert!(handle.join().is_err());\n    ///\n    /// // poisoning propagates\n    /// let handle = thread::spawn(|| {\n    ///     INIT.call_once(|| {});\n    /// });\n    /// assert!(handle.join().is_err());\n    ///\n    /// // call_once_force will still run and reset the poisoned state\n    /// INIT.call_once_force(|state| {\n    ///     assert!(state.poisoned());\n    /// });\n    ///\n    /// // once any success happens, we stop propagating the poison\n    /// INIT.call_once(|| {});\n    /// ```\n    #[unstable(feature = \"once_poison\", issue = \"33577\")]\n    pub fn call_once_force<F>(&self, f: F)\n    where\n        F: FnOnce(&OnceState),\n    {\n}\n\n    /// Returns `true` if some `call_once` call has completed\n    /// successfully. Specifically, `is_completed` will return false in\n    /// the following situations:\n    ///   * `call_once` was not called at all,\n    ///   * `call_once` was called, but has not yet completed,\n    ///   * the `Once` instance is poisoned\n    ///\n    /// It is also possible that immediately after `is_completed`\n    /// returns false, some other thread finishes executing\n    /// `call_once`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(once_is_completed)]\n    /// use std::sync::Once;\n    ///\n    /// static INIT: Once = Once::new();\n    ///\n    /// assert_eq!(INIT.is_completed(), false);\n    /// INIT.call_once(|| {\n    ///     assert_eq!(INIT.is_completed(), false);\n    /// });\n    /// assert_eq!(INIT.is_completed(), true);\n    /// ```\n    ///\n    /// ```\n    /// #![feature(once_is_completed)]\n    /// use std::sync::Once;\n    /// use std::thread;\n    ///\n    /// static INIT: Once = Once::new();\n    ///\n    /// assert_eq!(INIT.is_completed(), false);\n    /// let handle = thread::spawn(|| {\n    ///     INIT.call_once(|| panic!());\n    /// });\n    /// assert!(handle.join().is_err());\n    /// assert_eq!(INIT.is_completed(), false);\n    /// ```\n    #[unstable(feature = \"once_is_completed\", issue = \"54890\")]\n    #[inline]\n    pub fn is_completed(&self) -> bool {\n}\n\n    // This is a non-generic function to reduce the monomorphization cost of\n    // using `call_once` (this isn't exactly a trivial or small implementation).\n    //\n    // Additionally, this is tagged with `#[cold]` as it should indeed be cold\n    // and it helps let LLVM know that calls to this function should be off the\n    // fast path. Essentially, this should help generate more straight line code\n    // in LLVM.\n    //\n    // Finally, this takes an `FnMut` instead of a `FnOnce` because there's\n    // currently no way to take an `FnOnce` and call it via virtual dispatch\n    // without some allocation overhead.\n    #[cold]\n    fn call_inner(&self, ignore_poisoning: bool, init: &mut dyn FnMut(bool)) {\n}\n}\n\nfn wait(state_and_queue: &AtomicUsize, mut current_state: usize) {\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for Once {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl Drop for WaiterQueue<'_> {\n    fn drop(&mut self) {\n}\n}\n\nimpl OnceState {\n    /// Returns `true` if the associated [`Once`] was poisoned prior to the\n    /// invocation of the closure passed to [`call_once_force`].\n    ///\n    /// [`call_once_force`]: struct.Once.html#method.call_once_force\n    /// [`Once`]: struct.Once.html\n    ///\n    /// # Examples\n    ///\n    /// A poisoned `Once`:\n    ///\n    /// ```\n    /// #![feature(once_poison)]\n    ///\n    /// use std::sync::Once;\n    /// use std::thread;\n    ///\n    /// static INIT: Once = Once::new();\n    ///\n    /// // poison the once\n    /// let handle = thread::spawn(|| {\n    ///     INIT.call_once(|| panic!());\n    /// });\n    /// assert!(handle.join().is_err());\n    ///\n    /// INIT.call_once_force(|state| {\n    ///     assert!(state.poisoned());\n    /// });\n    /// ```\n    ///\n    /// An unpoisoned `Once`:\n    ///\n    /// ```\n    /// #![feature(once_poison)]\n    ///\n    /// use std::sync::Once;\n    ///\n    /// static INIT: Once = Once::new();\n    ///\n    /// INIT.call_once_force(|state| {\n    ///     assert!(!state.poisoned());\n    /// });\n    #[unstable(feature = \"once_poison\", issue = \"33577\")]\n    pub fn poisoned(&self) -> bool {\n}\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use super::Once;\n    use crate::panic;\n    use crate::sync::mpsc::channel;\n    use crate::thread;\n\n    #[test]\n    fn smoke_once() {\n}\n\n    #[test]\n    fn stampede_once() {\n}\n\n    #[test]\n    fn poison_bad() {\n}\n\n    #[test]\n    fn wait_for_force_to_finish() {\n}\n}\n}\nmod rwlock {\nuse crate::cell::UnsafeCell;\nuse crate::fmt;\nuse crate::mem;\nuse crate::ops::{Deref, DerefMut};\nuse crate::ptr;\nuse crate::sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\nuse crate::sys_common::rwlock as sys;\n\n/// A reader-writer lock\n///\n/// This type of lock allows a number of readers or at most one writer at any\n/// point in time. The write portion of this lock typically allows modification\n/// of the underlying data (exclusive access) and the read portion of this lock\n/// typically allows for read-only access (shared access).\n///\n/// In comparison, a [`Mutex`] does not distinguish between readers or writers\n/// that acquire the lock, therefore blocking any threads waiting for the lock to\n/// become available. An `RwLock` will allow any number of readers to acquire the\n/// lock as long as a writer is not holding the lock.\n///\n/// The priority policy of the lock is dependent on the underlying operating\n/// system's implementation, and this type does not guarantee that any\n/// particular policy will be used.\n///\n/// The type parameter `T` represents the data that this lock protects. It is\n/// required that `T` satisfies [`Send`] to be shared across threads and\n/// [`Sync`] to allow concurrent access through readers. The RAII guards\n/// returned from the locking methods implement [`Deref`] (and [`DerefMut`]\n/// for the `write` methods) to allow access to the content of the lock.\n///\n/// # Poisoning\n///\n/// An `RwLock`, like [`Mutex`], will become poisoned on a panic. Note, however,\n/// that an `RwLock` may only be poisoned if a panic occurs while it is locked\n/// exclusively (write mode). If a panic occurs in any reader, then the lock\n/// will not be poisoned.\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::RwLock;\n///\n/// let lock = RwLock::new(5);\n///\n/// // many reader locks can be held at once\n/// {\n///     let r1 = lock.read().unwrap();\n///     let r2 = lock.read().unwrap();\n///     assert_eq!(*r1, 5);\n///     assert_eq!(*r2, 5);\n/// } // read locks are dropped at this point\n///\n/// // only one write lock may be held, however\n/// {\n///     let mut w = lock.write().unwrap();\n///     *w += 1;\n///     assert_eq!(*w, 6);\n/// } // write lock is dropped here\n/// ```\n///\n/// [`Deref`]: ../../std/ops/trait.Deref.html\n/// [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n/// [`Send`]: ../../std/marker/trait.Send.html\n/// [`Sync`]: ../../std/marker/trait.Sync.html\n/// [`Mutex`]: struct.Mutex.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RwLock<T: ?Sized> {\n    inner: Box<sys::RWLock>,\n    poison: poison::Flag,\n    data: UnsafeCell<T>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: ?Sized + Send> Send for RwLock<T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n\n/// RAII structure used to release the shared read access of a lock when\n/// dropped.\n///\n/// This structure is created by the [`read`] and [`try_read`] methods on\n/// [`RwLock`].\n///\n/// [`read`]: struct.RwLock.html#method.read\n/// [`try_read`]: struct.RwLock.html#method.try_read\n/// [`RwLock`]: struct.RwLock.html\n#[must_use = \"if unused the RwLock will immediately unlock\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n    lock: &'a RwLock<T>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !Send for RwLockReadGuard<'_, T> {}\n\n#[stable(feature = \"rwlock_guard_sync\", since = \"1.23.0\")]\nunsafe impl<T: ?Sized + Sync> Sync for RwLockReadGuard<'_, T> {}\n\n/// RAII structure used to release the exclusive write access of a lock when\n/// dropped.\n///\n/// This structure is created by the [`write`] and [`try_write`] methods\n/// on [`RwLock`].\n///\n/// [`write`]: struct.RwLock.html#method.write\n/// [`try_write`]: struct.RwLock.html#method.try_write\n/// [`RwLock`]: struct.RwLock.html\n#[must_use = \"if unused the RwLock will immediately unlock\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RwLockWriteGuard<'a, T: ?Sized + 'a> {\n    lock: &'a RwLock<T>,\n    poison: poison::Guard,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !Send for RwLockWriteGuard<'_, T> {}\n\n#[stable(feature = \"rwlock_guard_sync\", since = \"1.23.0\")]\nunsafe impl<T: ?Sized + Sync> Sync for RwLockWriteGuard<'_, T> {}\n\nimpl<T> RwLock<T> {\n    /// Creates a new instance of an `RwLock<T>` which is unlocked.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::RwLock;\n    ///\n    /// let lock = RwLock::new(5);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new(t: T) -> RwLock<T> {\n}\n}\n\nimpl<T: ?Sized> RwLock<T> {\n    /// Locks this rwlock with shared read access, blocking the current thread\n    /// until it can be acquired.\n    ///\n    /// The calling thread will be blocked until there are no more writers which\n    /// hold the lock. There may be other readers currently inside the lock when\n    /// this method returns. This method does not provide any guarantees with\n    /// respect to the ordering of whether contentious readers or writers will\n    /// acquire the lock first.\n    ///\n    /// Returns an RAII guard which will release this thread's shared access\n    /// once it is dropped.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the RwLock is poisoned. An RwLock\n    /// is poisoned whenever a writer panics while holding an exclusive lock.\n    /// The failure will occur immediately after the lock has been acquired.\n    ///\n    /// # Panics\n    ///\n    /// This function might panic when called if the lock is already held by the current thread.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, RwLock};\n    /// use std::thread;\n    ///\n    /// let lock = Arc::new(RwLock::new(1));\n    /// let c_lock = lock.clone();\n    ///\n    /// let n = lock.read().unwrap();\n    /// assert_eq!(*n, 1);\n    ///\n    /// thread::spawn(move || {\n    ///     let r = c_lock.read();\n    ///     assert!(r.is_ok());\n    /// }).join().unwrap();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn read(&self) -> LockResult<RwLockReadGuard<'_, T>> {\n}\n\n    /// Attempts to acquire this rwlock with shared read access.\n    ///\n    /// If the access could not be granted at this time, then `Err` is returned.\n    /// Otherwise, an RAII guard is returned which will release the shared access\n    /// when it is dropped.\n    ///\n    /// This function does not block.\n    ///\n    /// This function does not provide any guarantees with respect to the ordering\n    /// of whether contentious readers or writers will acquire the lock first.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the RwLock is poisoned. An RwLock\n    /// is poisoned whenever a writer panics while holding an exclusive lock. An\n    /// error will only be returned if the lock would have otherwise been\n    /// acquired.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::RwLock;\n    ///\n    /// let lock = RwLock::new(1);\n    ///\n    /// match lock.try_read() {\n    ///     Ok(n) => assert_eq!(*n, 1),\n    ///     Err(_) => unreachable!(),\n    /// };\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<'_, T>> {\n}\n\n    /// Locks this rwlock with exclusive write access, blocking the current\n    /// thread until it can be acquired.\n    ///\n    /// This function will not return while other writers or other readers\n    /// currently have access to the lock.\n    ///\n    /// Returns an RAII guard which will drop the write access of this rwlock\n    /// when dropped.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the RwLock is poisoned. An RwLock\n    /// is poisoned whenever a writer panics while holding an exclusive lock.\n    /// An error will be returned when the lock is acquired.\n    ///\n    /// # Panics\n    ///\n    /// This function might panic when called if the lock is already held by the current thread.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::RwLock;\n    ///\n    /// let lock = RwLock::new(1);\n    ///\n    /// let mut n = lock.write().unwrap();\n    /// *n = 2;\n    ///\n    /// assert!(lock.try_read().is_err());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write(&self) -> LockResult<RwLockWriteGuard<'_, T>> {\n}\n\n    /// Attempts to lock this rwlock with exclusive write access.\n    ///\n    /// If the lock could not be acquired at this time, then `Err` is returned.\n    /// Otherwise, an RAII guard is returned which will release the lock when\n    /// it is dropped.\n    ///\n    /// This function does not block.\n    ///\n    /// This function does not provide any guarantees with respect to the ordering\n    /// of whether contentious readers or writers will acquire the lock first.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the RwLock is poisoned. An RwLock\n    /// is poisoned whenever a writer panics while holding an exclusive lock. An\n    /// error will only be returned if the lock would have otherwise been\n    /// acquired.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::RwLock;\n    ///\n    /// let lock = RwLock::new(1);\n    ///\n    /// let n = lock.read().unwrap();\n    /// assert_eq!(*n, 1);\n    ///\n    /// assert!(lock.try_write().is_err());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<'_, T>> {\n}\n\n    /// Determines whether the lock is poisoned.\n    ///\n    /// If another thread is active, the lock can still become poisoned at any\n    /// time. You should not trust a `false` value for program correctness\n    /// without additional synchronization.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::{Arc, RwLock};\n    /// use std::thread;\n    ///\n    /// let lock = Arc::new(RwLock::new(0));\n    /// let c_lock = lock.clone();\n    ///\n    /// let _ = thread::spawn(move || {\n    ///     let _lock = c_lock.write().unwrap();\n    ///     panic!(); // the lock gets poisoned\n    /// }).join();\n    /// assert_eq!(lock.is_poisoned(), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n    pub fn is_poisoned(&self) -> bool {\n}\n\n    /// Consumes this `RwLock`, returning the underlying data.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the RwLock is poisoned. An RwLock\n    /// is poisoned whenever a writer panics while holding an exclusive lock. An\n    /// error will only be returned if the lock would have otherwise been\n    /// acquired.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::RwLock;\n    ///\n    /// let lock = RwLock::new(String::new());\n    /// {\n    ///     let mut s = lock.write().unwrap();\n    ///     *s = \"modified\".to_owned();\n    /// }\n    /// assert_eq!(lock.into_inner().unwrap(), \"modified\");\n    /// ```\n    #[stable(feature = \"rwlock_into_inner\", since = \"1.6.0\")]\n    pub fn into_inner(self) -> LockResult<T>\n    where\n        T: Sized,\n    {\n}\n\n    /// Returns a mutable reference to the underlying data.\n    ///\n    /// Since this call borrows the `RwLock` mutably, no actual locking needs to\n    /// take place -- the mutable borrow statically guarantees no locks exist.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an error if the RwLock is poisoned. An RwLock\n    /// is poisoned whenever a writer panics while holding an exclusive lock. An\n    /// error will only be returned if the lock would have otherwise been\n    /// acquired.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::RwLock;\n    ///\n    /// let mut lock = RwLock::new(0);\n    /// *lock.get_mut().unwrap() = 10;\n    /// assert_eq!(*lock.read().unwrap(), 10);\n    /// ```\n    #[stable(feature = \"rwlock_get_mut\", since = \"1.6.0\")]\n    pub fn get_mut(&mut self) -> LockResult<&mut T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T: ?Sized> Drop for RwLock<T> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rw_lock_default\", since = \"1.10.0\")]\nimpl<T: Default> Default for RwLock<T> {\n    /// Creates a new `RwLock<T>`, with the `Default` value for T.\n    fn default() -> RwLock<T> {\n}\n}\n\n#[stable(feature = \"rw_lock_from\", since = \"1.24.0\")]\nimpl<T> From<T> for RwLock<T> {\n    /// Creates a new instance of an `RwLock<T>` which is unlocked.\n    /// This is equivalent to [`RwLock::new`].\n    ///\n    /// [`RwLock::new`]: ../../std/sync/struct.RwLock.html#method.new\n    fn from(t: T) -> Self {\n}\n}\n\nimpl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n    unsafe fn new(lock: &'rwlock RwLock<T>) -> LockResult<RwLockReadGuard<'rwlock, T>> {\n}\n}\n\nimpl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n    unsafe fn new(lock: &'rwlock RwLock<T>) -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T: fmt::Debug> fmt::Debug for RwLockReadGuard<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"std_guard_impls\", since = \"1.20.0\")]\nimpl<T: ?Sized + fmt::Display> fmt::Display for RwLockReadGuard<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl<T: fmt::Debug> fmt::Debug for RwLockWriteGuard<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"std_guard_impls\", since = \"1.20.0\")]\nimpl<T: ?Sized + fmt::Display> fmt::Display for RwLockWriteGuard<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Deref for RwLockReadGuard<'_, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Deref for RwLockWriteGuard<'_, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> DerefMut for RwLockWriteGuard<'_, T> {\n    fn deref_mut(&mut self) -> &mut T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Drop for RwLockReadGuard<'_, T> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Drop for RwLockWriteGuard<'_, T> {\n    fn drop(&mut self) {\n}\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use crate::sync::atomic::{AtomicUsize, Ordering};\n    use crate::sync::mpsc::channel;\n    use crate::sync::{Arc, RwLock, TryLockError};\n    use crate::thread;\n    use rand::{self, Rng};\n\n    #[derive(Eq, PartialEq, Debug)]\n    struct NonCopy(i32);\n\n    #[test]\n    fn smoke() {\n}\n\n    #[test]\n    fn frob() {\n}\n\n    #[test]\n    fn test_rw_arc_poison_wr() {\n}\n\n    #[test]\n    fn test_rw_arc_poison_ww() {\n}\n\n    #[test]\n    fn test_rw_arc_no_poison_rr() {\n}\n    #[test]\n    fn test_rw_arc_no_poison_rw() {\n}\n\n    #[test]\n    fn test_rw_arc() {\n}\n\n    #[test]\n    fn test_rw_arc_access_in_unwind() {\n}\n\n    #[test]\n    fn test_rwlock_unsized() {\n}\n\n    #[test]\n    fn test_rwlock_try_write() {\n}\n\n    #[test]\n    fn test_into_inner() {\n}\n\n    #[test]\n    fn test_into_inner_drop() {\n}\n\n    #[test]\n    fn test_into_inner_poison() {\n}\n\n    #[test]\n    fn test_get_mut() {\n}\n\n    #[test]\n    fn test_get_mut_poison() {\n}\n}\n}\n}\npub mod time {\n//! Temporal quantification.\n//!\n//! Example:\n//!\n//! ```\n//! use std::time::Duration;\n//!\n//! let five_seconds = Duration::new(5, 0);\n//! // both declarations are equivalent\n//! assert_eq!(Duration::new(5, 0), Duration::from_secs(5));\n//! ```\n\n#![stable(feature = \"time\", since = \"1.3.0\")]\n\nuse crate::cmp;\nuse crate::error::Error;\nuse crate::fmt;\nuse crate::ops::{Add, AddAssign, Sub, SubAssign};\nuse crate::sys::time;\nuse crate::sys_common::mutex::Mutex;\nuse crate::sys_common::FromInner;\n\n#[stable(feature = \"time\", since = \"1.3.0\")]\npub use core::time::Duration;\n\n/// A measurement of a monotonically nondecreasing clock.\n/// Opaque and useful only with `Duration`.\n///\n/// Instants are always guaranteed to be no less than any previously measured\n/// instant when created, and are often useful for tasks such as measuring\n/// benchmarks or timing how long an operation takes.\n///\n/// Note, however, that instants are not guaranteed to be **steady**. In other\n/// words, each tick of the underlying clock may not be the same length (e.g.\n/// some seconds may be longer than others). An instant may jump forwards or\n/// experience time dilation (slow down or speed up), but it will never go\n/// backwards.\n///\n/// Instants are opaque types that can only be compared to one another. There is\n/// no method to get \"the number of seconds\" from an instant. Instead, it only\n/// allows measuring the duration between two instants (or comparing two\n/// instants).\n///\n/// The size of an `Instant` struct may vary depending on the target operating\n/// system.\n///\n/// Example:\n///\n/// ```no_run\n/// use std::time::{Duration, Instant};\n/// use std::thread::sleep;\n///\n/// fn main() {\n///    let now = Instant::now();\n///\n///    // we sleep for 2 seconds\n///    sleep(Duration::new(2, 0));\n///    // it prints '2'\n///    println!(\"{}\", now.elapsed().as_secs());\n/// }\n/// ```\n///\n/// # Underlying System calls\n/// Currently, the following system calls are being used to get the current time using `now()`:\n///\n/// |  Platform |               System call                                            |\n/// |:---------:|:--------------------------------------------------------------------:|\n/// | CloudABI  | [clock_time_get (Monotonic Clock)]                                   |\n/// | SGX       | [`insecure_time` usercall]. More information on [timekeeping in SGX] |\n/// | UNIX      | [clock_gettime (Monotonic Clock)]                                    |\n/// | Darwin    | [mach_absolute_time]                                                 |\n/// | VXWorks   | [clock_gettime (Monotonic Clock)]                                    |\n/// | WASI      | [__wasi_clock_time_get (Monotonic Clock)]                            |\n/// | Windows   | [QueryPerformanceCounter]                                            |\n///\n/// [QueryPerformanceCounter]: https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter\n/// [`insecure_time` usercall]: https://edp.fortanix.com/docs/api/fortanix_sgx_abi/struct.Usercalls.html#method.insecure_time\n/// [timekeeping in SGX]: https://edp.fortanix.com/docs/concepts/rust-std/#codestdtimecode\n/// [__wasi_clock_time_get (Monotonic Clock)]: https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-api.md#clock_time_get\n/// [clock_gettime (Monotonic Clock)]: https://linux.die.net/man/3/clock_gettime\n/// [mach_absolute_time]: https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/services/services.html\n/// [clock_time_get (Monotonic Clock)]: https://nuxi.nl/cloudabi/#clock_time_get\n///\n/// **Disclaimer:** These system calls might change over time.\n///\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[stable(feature = \"time2\", since = \"1.8.0\")]\npub struct Instant(time::Instant);\n\n/// A measurement of the system clock, useful for talking to\n/// external entities like the file system or other processes.\n///\n/// Distinct from the [`Instant`] type, this time measurement **is not\n/// monotonic**. This means that you can save a file to the file system, then\n/// save another file to the file system, **and the second file has a\n/// `SystemTime` measurement earlier than the first**. In other words, an\n/// operation that happens after another operation in real time may have an\n/// earlier `SystemTime`!\n///\n/// Consequently, comparing two `SystemTime` instances to learn about the\n/// duration between them returns a [`Result`] instead of an infallible [`Duration`]\n/// to indicate that this sort of time drift may happen and needs to be handled.\n///\n/// Although a `SystemTime` cannot be directly inspected, the [`UNIX_EPOCH`]\n/// constant is provided in this module as an anchor in time to learn\n/// information about a `SystemTime`. By calculating the duration from this\n/// fixed point in time, a `SystemTime` can be converted to a human-readable time,\n/// or perhaps some other string representation.\n///\n/// The size of a `SystemTime` struct may vary depending on the target operating\n/// system.\n///\n/// [`Instant`]: ../../std/time/struct.Instant.html\n/// [`Result`]: ../../std/result/enum.Result.html\n/// [`Duration`]: ../../std/time/struct.Duration.html\n/// [`UNIX_EPOCH`]: ../../std/time/constant.UNIX_EPOCH.html\n///\n/// Example:\n///\n/// ```no_run\n/// use std::time::{Duration, SystemTime};\n/// use std::thread::sleep;\n///\n/// fn main() {\n///    let now = SystemTime::now();\n///\n///    // we sleep for 2 seconds\n///    sleep(Duration::new(2, 0));\n///    match now.elapsed() {\n///        Ok(elapsed) => {\n///            // it prints '2'\n///            println!(\"{}\", elapsed.as_secs());\n///        }\n///        Err(e) => {\n///            // an error occurred!\n///            println!(\"Error: {:?}\", e);\n///        }\n///    }\n/// }\n/// ```\n///\n/// # Underlying System calls\n/// Currently, the following system calls are being used to get the current time using `now()`:\n///\n/// |  Platform |               System call                                            |\n/// |:---------:|:--------------------------------------------------------------------:|\n/// | CloudABI  | [clock_time_get (Realtime Clock)]                                    |\n/// | SGX       | [`insecure_time` usercall]. More information on [timekeeping in SGX] |\n/// | UNIX      | [clock_gettime (Realtime Clock)]                                     |\n/// | DARWIN    | [gettimeofday]                                                       |\n/// | VXWorks   | [clock_gettime (Realtime Clock)]                                     |\n/// | WASI      | [__wasi_clock_time_get (Realtime Clock)]                             |\n/// | Windows   | [GetSystemTimeAsFileTime]                                            |\n///\n/// [clock_time_get (Realtime Clock)]: https://nuxi.nl/cloudabi/#clock_time_get\n/// [`insecure_time` usercall]: https://edp.fortanix.com/docs/api/fortanix_sgx_abi/struct.Usercalls.html#method.insecure_time\n/// [timekeeping in SGX]: https://edp.fortanix.com/docs/concepts/rust-std/#codestdtimecode\n/// [gettimeofday]: http://man7.org/linux/man-pages/man2/gettimeofday.2.html\n/// [clock_gettime (Realtime Clock)]: https://linux.die.net/man/3/clock_gettime\n/// [__wasi_clock_time_get (Realtime Clock)]: https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-api.md#clock_time_get\n/// [GetSystemTimeAsFileTime]: https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimeasfiletime\n///\n/// **Disclaimer:** These system calls might change over time.\n///\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[stable(feature = \"time2\", since = \"1.8.0\")]\npub struct SystemTime(time::SystemTime);\n\n/// An error returned from the `duration_since` and `elapsed` methods on\n/// `SystemTime`, used to learn how far in the opposite direction a system time\n/// lies.\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::thread::sleep;\n/// use std::time::{Duration, SystemTime};\n///\n/// let sys_time = SystemTime::now();\n/// sleep(Duration::from_secs(1));\n/// let new_sys_time = SystemTime::now();\n/// match sys_time.duration_since(new_sys_time) {\n///     Ok(_) => {}\n///     Err(e) => println!(\"SystemTimeError difference: {:?}\", e.duration()),\n/// }\n/// ```\n#[derive(Clone, Debug)]\n#[stable(feature = \"time2\", since = \"1.8.0\")]\npub struct SystemTimeError(Duration);\n\nimpl Instant {\n    /// Returns an instant corresponding to \"now\".\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Instant;\n    ///\n    /// let now = Instant::now();\n    /// ```\n    #[stable(feature = \"time2\", since = \"1.8.0\")]\n    pub fn now() -> Instant {\n}\n\n    /// Returns the amount of time elapsed from another instant to this one.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if `earlier` is later than `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::time::{Duration, Instant};\n    /// use std::thread::sleep;\n    ///\n    /// let now = Instant::now();\n    /// sleep(Duration::new(1, 0));\n    /// let new_now = Instant::now();\n    /// println!(\"{:?}\", new_now.duration_since(now));\n    /// ```\n    #[stable(feature = \"time2\", since = \"1.8.0\")]\n    pub fn duration_since(&self, earlier: Instant) -> Duration {\n}\n\n    /// Returns the amount of time elapsed from another instant to this one,\n    /// or None if that instant is later than this one.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::time::{Duration, Instant};\n    /// use std::thread::sleep;\n    ///\n    /// let now = Instant::now();\n    /// sleep(Duration::new(1, 0));\n    /// let new_now = Instant::now();\n    /// println!(\"{:?}\", new_now.checked_duration_since(now));\n    /// println!(\"{:?}\", now.checked_duration_since(new_now)); // None\n    /// ```\n    #[stable(feature = \"checked_duration_since\", since = \"1.39.0\")]\n    pub fn checked_duration_since(&self, earlier: Instant) -> Option<Duration> {\n}\n\n    /// Returns the amount of time elapsed from another instant to this one,\n    /// or zero duration if that instant is earlier than this one.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::time::{Duration, Instant};\n    /// use std::thread::sleep;\n    ///\n    /// let now = Instant::now();\n    /// sleep(Duration::new(1, 0));\n    /// let new_now = Instant::now();\n    /// println!(\"{:?}\", new_now.saturating_duration_since(now));\n    /// println!(\"{:?}\", now.saturating_duration_since(new_now)); // 0ns\n    /// ```\n    #[stable(feature = \"checked_duration_since\", since = \"1.39.0\")]\n    pub fn saturating_duration_since(&self, earlier: Instant) -> Duration {\n}\n\n    /// Returns the amount of time elapsed since this instant was created.\n    ///\n    /// # Panics\n    ///\n    /// This function may panic if the current time is earlier than this\n    /// instant, which is something that can happen if an `Instant` is\n    /// produced synthetically.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::thread::sleep;\n    /// use std::time::{Duration, Instant};\n    ///\n    /// let instant = Instant::now();\n    /// let three_secs = Duration::from_secs(3);\n    /// sleep(three_secs);\n    /// assert!(instant.elapsed() >= three_secs);\n    /// ```\n    #[stable(feature = \"time2\", since = \"1.8.0\")]\n    pub fn elapsed(&self) -> Duration {\n}\n\n    /// Returns `Some(t)` where `t` is the time `self + duration` if `t` can be represented as\n    /// `Instant` (which means it's inside the bounds of the underlying data structure), `None`\n    /// otherwise.\n    #[stable(feature = \"time_checked_add\", since = \"1.34.0\")]\n    pub fn checked_add(&self, duration: Duration) -> Option<Instant> {\n}\n\n    /// Returns `Some(t)` where `t` is the time `self - duration` if `t` can be represented as\n    /// `Instant` (which means it's inside the bounds of the underlying data structure), `None`\n    /// otherwise.\n    #[stable(feature = \"time_checked_add\", since = \"1.34.0\")]\n    pub fn checked_sub(&self, duration: Duration) -> Option<Instant> {\n}\n}\n\n#[stable(feature = \"time2\", since = \"1.8.0\")]\nimpl Add<Duration> for Instant {\n    type Output = Instant;\n\n    /// # Panics\n    ///\n    /// This function may panic if the resulting point in time cannot be represented by the\n    /// underlying data structure. See [`checked_add`] for a version without panic.\n    ///\n    /// [`checked_add`]: ../../std/time/struct.Instant.html#method.checked_add\n    fn add(self, other: Duration) -> Instant {\n}\n}\n\n#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\nimpl AddAssign<Duration> for Instant {\n    fn add_assign(&mut self, other: Duration) {\n}\n}\n\n#[stable(feature = \"time2\", since = \"1.8.0\")]\nimpl Sub<Duration> for Instant {\n    type Output = Instant;\n\n    fn sub(self, other: Duration) -> Instant {\n}\n}\n\n#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\nimpl SubAssign<Duration> for Instant {\n    fn sub_assign(&mut self, other: Duration) {\n}\n}\n\n#[stable(feature = \"time2\", since = \"1.8.0\")]\nimpl Sub<Instant> for Instant {\n    type Output = Duration;\n\n    fn sub(self, other: Instant) -> Duration {\n}\n}\n\n#[stable(feature = \"time2\", since = \"1.8.0\")]\nimpl fmt::Debug for Instant {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl SystemTime {\n    /// An anchor in time which can be used to create new `SystemTime` instances or\n    /// learn about where in time a `SystemTime` lies.\n    ///\n    /// This constant is defined to be \"1970-01-01 00:00:00 UTC\" on all systems with\n    /// respect to the system clock. Using `duration_since` on an existing\n    /// `SystemTime` instance can tell how far away from this point in time a\n    /// measurement lies, and using `UNIX_EPOCH + duration` can be used to create a\n    /// `SystemTime` instance to represent another fixed point in time.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::time::SystemTime;\n    ///\n    /// match SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) {\n    ///     Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n    ///     Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n    /// }\n    /// ```\n    #[stable(feature = \"assoc_unix_epoch\", since = \"1.28.0\")]\n    pub const UNIX_EPOCH: SystemTime = UNIX_EPOCH;\n\n    /// Returns the system time corresponding to \"now\".\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::SystemTime;\n    ///\n    /// let sys_time = SystemTime::now();\n    /// ```\n    #[stable(feature = \"time2\", since = \"1.8.0\")]\n    pub fn now() -> SystemTime {\n}\n\n    /// Returns the amount of time elapsed from an earlier point in time.\n    ///\n    /// This function may fail because measurements taken earlier are not\n    /// guaranteed to always be before later measurements (due to anomalies such\n    /// as the system clock being adjusted either forwards or backwards).\n    /// [`Instant`] can be used to measure elapsed time without this risk of failure.\n    ///\n    /// If successful, [`Ok`]`(`[`Duration`]`)` is returned where the duration represents\n    /// the amount of time elapsed from the specified measurement to this one.\n    ///\n    /// Returns an [`Err`] if `earlier` is later than `self`, and the error\n    /// contains how far from `self` the time is.\n    ///\n    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`Duration`]: ../../std/time/struct.Duration.html\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`Instant`]: ../../std/time/struct.Instant.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::SystemTime;\n    ///\n    /// let sys_time = SystemTime::now();\n    /// let difference = sys_time.duration_since(sys_time)\n    ///                          .expect(\"Clock may have gone backwards\");\n    /// println!(\"{:?}\", difference);\n    /// ```\n    #[stable(feature = \"time2\", since = \"1.8.0\")]\n    pub fn duration_since(&self, earlier: SystemTime) -> Result<Duration, SystemTimeError> {\n}\n\n    /// Returns the difference between the clock time when this\n    /// system time was created, and the current clock time.\n    ///\n    /// This function may fail as the underlying system clock is susceptible to\n    /// drift and updates (e.g., the system clock could go backwards), so this\n    /// function may not always succeed. If successful, [`Ok`]`(`[`Duration`]`)` is\n    /// returned where the duration represents the amount of time elapsed from\n    /// this time measurement to the current time.\n    ///\n    /// To measure elapsed time reliably, use [`Instant`] instead.\n    ///\n    /// Returns an [`Err`] if `self` is later than the current system time, and\n    /// the error contains how far from the current system time `self` is.\n    ///\n    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`Duration`]: ../../std/time/struct.Duration.html\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`Instant`]: ../../std/time/struct.Instant.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::thread::sleep;\n    /// use std::time::{Duration, SystemTime};\n    ///\n    /// let sys_time = SystemTime::now();\n    /// let one_sec = Duration::from_secs(1);\n    /// sleep(one_sec);\n    /// assert!(sys_time.elapsed().unwrap() >= one_sec);\n    /// ```\n    #[stable(feature = \"time2\", since = \"1.8.0\")]\n    pub fn elapsed(&self) -> Result<Duration, SystemTimeError> {\n}\n\n    /// Returns `Some(t)` where `t` is the time `self + duration` if `t` can be represented as\n    /// `SystemTime` (which means it's inside the bounds of the underlying data structure), `None`\n    /// otherwise.\n    #[stable(feature = \"time_checked_add\", since = \"1.34.0\")]\n    pub fn checked_add(&self, duration: Duration) -> Option<SystemTime> {\n}\n\n    /// Returns `Some(t)` where `t` is the time `self - duration` if `t` can be represented as\n    /// `SystemTime` (which means it's inside the bounds of the underlying data structure), `None`\n    /// otherwise.\n    #[stable(feature = \"time_checked_add\", since = \"1.34.0\")]\n    pub fn checked_sub(&self, duration: Duration) -> Option<SystemTime> {\n}\n}\n\n#[stable(feature = \"time2\", since = \"1.8.0\")]\nimpl Add<Duration> for SystemTime {\n    type Output = SystemTime;\n\n    /// # Panics\n    ///\n    /// This function may panic if the resulting point in time cannot be represented by the\n    /// underlying data structure. See [`checked_add`] for a version without panic.\n    ///\n    /// [`checked_add`]: ../../std/time/struct.SystemTime.html#method.checked_add\n    fn add(self, dur: Duration) -> SystemTime {\n}\n}\n\n#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\nimpl AddAssign<Duration> for SystemTime {\n    fn add_assign(&mut self, other: Duration) {\n}\n}\n\n#[stable(feature = \"time2\", since = \"1.8.0\")]\nimpl Sub<Duration> for SystemTime {\n    type Output = SystemTime;\n\n    fn sub(self, dur: Duration) -> SystemTime {\n}\n}\n\n#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\nimpl SubAssign<Duration> for SystemTime {\n    fn sub_assign(&mut self, other: Duration) {\n}\n}\n\n#[stable(feature = \"time2\", since = \"1.8.0\")]\nimpl fmt::Debug for SystemTime {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// An anchor in time which can be used to create new `SystemTime` instances or\n/// learn about where in time a `SystemTime` lies.\n///\n/// This constant is defined to be \"1970-01-01 00:00:00 UTC\" on all systems with\n/// respect to the system clock. Using `duration_since` on an existing\n/// [`SystemTime`] instance can tell how far away from this point in time a\n/// measurement lies, and using `UNIX_EPOCH + duration` can be used to create a\n/// [`SystemTime`] instance to represent another fixed point in time.\n///\n/// [`SystemTime`]: ../../std/time/struct.SystemTime.html\n///\n/// # Examples\n///\n/// ```no_run\n/// use std::time::{SystemTime, UNIX_EPOCH};\n///\n/// match SystemTime::now().duration_since(UNIX_EPOCH) {\n///     Ok(n) => println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n///     Err(_) => panic!(\"SystemTime before UNIX EPOCH!\"),\n/// }\n/// ```\n#[stable(feature = \"time2\", since = \"1.8.0\")]\npub const UNIX_EPOCH: SystemTime = SystemTime(time::UNIX_EPOCH);\n\nimpl SystemTimeError {\n    /// Returns the positive duration which represents how far forward the\n    /// second system time was from the first.\n    ///\n    /// A `SystemTimeError` is returned from the [`duration_since`] and [`elapsed`]\n    /// methods of [`SystemTime`] whenever the second system time represents a point later\n    /// in time than the `self` of the method call.\n    ///\n    /// [`duration_since`]: ../../std/time/struct.SystemTime.html#method.duration_since\n    /// [`elapsed`]: ../../std/time/struct.SystemTime.html#method.elapsed\n    /// [`SystemTime`]: ../../std/time/struct.SystemTime.html\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use std::thread::sleep;\n    /// use std::time::{Duration, SystemTime};\n    ///\n    /// let sys_time = SystemTime::now();\n    /// sleep(Duration::from_secs(1));\n    /// let new_sys_time = SystemTime::now();\n    /// match sys_time.duration_since(new_sys_time) {\n    ///     Ok(_) => {}\n    ///     Err(e) => println!(\"SystemTimeError difference: {:?}\", e.duration()),\n    /// }\n    /// ```\n    #[stable(feature = \"time2\", since = \"1.8.0\")]\n    pub fn duration(&self) -> Duration {\n}\n}\n\n#[stable(feature = \"time2\", since = \"1.8.0\")]\nimpl Error for SystemTimeError {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"time2\", since = \"1.8.0\")]\nimpl fmt::Display for SystemTimeError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl FromInner<time::SystemTime> for SystemTime {\n    fn from_inner(time: time::SystemTime) -> SystemTime {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub mod task {\n    //! Types and Traits for working with asynchronous tasks.\n    #[doc(inline)]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub use core::task::*;\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub mod future {\n//! Asynchronous values.\n\nuse core::cell::Cell;\nuse core::marker::Unpin;\nuse core::ops::{Drop, Generator, GeneratorState};\nuse core::option::Option;\nuse core::pin::Pin;\nuse core::ptr::NonNull;\nuse core::task::{Context, Poll};\n\n#[doc(inline)]\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub use core::future::*;\n\n/// Wrap a generator in a future.\n///\n/// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n/// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n#[doc(hidden)]\n#[unstable(feature = \"gen_future\", issue = \"50547\")]\npub fn from_generator<T: Generator<Yield = ()>>(x: T) -> impl Future<Output = T::Return> {\n}\n\n/// A wrapper around generators used to implement `Future` for `async`/`await` code.\n#[doc(hidden)]\n#[unstable(feature = \"gen_future\", issue = \"50547\")]\n#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\nstruct GenFuture<T: Generator<Yield = ()>>(T);\n\n// We rely on the fact that async/await futures are immovable in order to create\n// self-referential borrows in the underlying generator.\nimpl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n\n#[doc(hidden)]\n#[unstable(feature = \"gen_future\", issue = \"50547\")]\nimpl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n}\n\nthread_local! {\n    static TLS_CX: Cell<Option<NonNull<Context<'static>>>> = Cell::new(None);\n}\n\nstruct SetOnDrop(Option<NonNull<Context<'static>>>);\n\nimpl Drop for SetOnDrop {\n    fn drop(&mut self) {\n}\n}\n\n// Safety: the returned guard must drop before `cx` is dropped and before\n// any previous guard is dropped.\nunsafe fn set_task_context(cx: &mut Context<'_>) -> SetOnDrop {\n}\n\n#[doc(hidden)]\n#[unstable(feature = \"gen_future\", issue = \"50547\")]\n/// Polls a future in the current thread-local task waker.\npub fn poll_with_tls_context<F>(f: Pin<&mut F>) -> Poll<F::Output>\nwhere\n    F: Future,\n{\n}\n}\n\n// Platform-abstraction modules\n#[macro_use]\nmod sys_common {\n//! Platform-independent platform abstraction\n//!\n//! This is the platform-independent portion of the standard library's\n//! platform abstraction layer, whereas `std::sys` is the\n//! platform-specific portion.\n//!\n//! The relationship between `std::sys_common`, `std::sys` and the\n//! rest of `std` is complex, with dependencies going in all\n//! directions: `std` depending on `sys_common`, `sys_common`\n//! depending on `sys`, and `sys` depending on `sys_common` and `std`.\n//! Ideally `sys_common` would be split into two and the dependencies\n//! between them all would form a dag, facilitating the extraction of\n//! `std::sys` from the standard library.\n\n#![allow(missing_docs)]\n#![allow(missing_debug_implementations)]\n\nuse crate::sync::Once;\nuse crate::sys;\n\nmacro_rules! rtabort {\n    ($($t:tt)*) => (crate::sys_common::util::abort(format_args!($($t)*)))\n}\n\nmacro_rules! rtassert {\n    ($e:expr) => {\n        if !$e {\n            rtabort!(concat!(\"assertion failed: \", stringify!($e)));\n        }\n    };\n}\n\n#[allow(unused_macros)] // not used on all platforms\nmacro_rules! rtunwrap {\n    ($ok:ident, $e:expr) => {\n        match $e {\n            $ok(v) => v,\n            ref err => {\n                let err = err.as_ref().map(drop); // map Ok/Some which might not be Debug\n                rtabort!(concat!(\"unwrap failed: \", stringify!($e), \" = {:?}\"), err)\n            }\n        }\n    };\n}\n\npub mod alloc {\n#![allow(dead_code)]\n\nuse crate::alloc::{GlobalAlloc, Layout, System};\nuse crate::cmp;\nuse crate::ptr;\n\n// The minimum alignment guaranteed by the architecture. This value is used to\n// add fast paths for low alignment values.\n#[cfg(all(any(\n    target_arch = \"x86\",\n    target_arch = \"arm\",\n    target_arch = \"mips\",\n    target_arch = \"powerpc\",\n    target_arch = \"powerpc64\",\n    target_arch = \"asmjs\",\n    target_arch = \"wasm32\",\n    target_arch = \"hexagon\"\n)))]\npub const MIN_ALIGN: usize = 8;\n#[cfg(all(any(\n    target_arch = \"x86_64\",\n    target_arch = \"aarch64\",\n    target_arch = \"mips64\",\n    target_arch = \"s390x\",\n    target_arch = \"sparc64\",\n    target_arch = \"riscv64\"\n)))]\npub const MIN_ALIGN: usize = 16;\n\npub unsafe fn realloc_fallback(\n    alloc: &System,\n    ptr: *mut u8,\n    old_layout: Layout,\n    new_size: usize,\n) -> *mut u8 {\n}\n}\npub mod at_exit_imp {\n//! Implementation of running at_exit routines\n//!\n//! Documentation can be found on the `rt::at_exit` function.\n\nuse crate::mem;\nuse crate::ptr;\nuse crate::sys_common::mutex::Mutex;\n\ntype Queue = Vec<Box<dyn FnOnce()>>;\n\n// NB these are specifically not types from `std::sync` as they currently rely\n// on poisoning and this module needs to operate at a lower level than requiring\n// the thread infrastructure to be in place (useful on the borders of\n// initialization/destruction).\n// We never call `LOCK.init()`, so it is UB to attempt to\n// acquire this mutex reentrantly!\nstatic LOCK: Mutex = Mutex::new();\nstatic mut QUEUE: *mut Queue = ptr::null_mut();\n\nconst DONE: *mut Queue = 1_usize as *mut _;\n\n// The maximum number of times the cleanup routines will be run. While running\n// the at_exit closures new ones may be registered, and this count is the number\n// of times the new closures will be allowed to register successfully. After\n// this number of iterations all new registrations will return `false`.\nconst ITERS: usize = 10;\n\nunsafe fn init() -> bool {\n}\n\npub fn cleanup() {\n}\n\npub fn push(f: Box<dyn FnOnce()>) -> bool {\n}\n}\npub mod backtrace {\nuse crate::borrow::Cow;\n/// Common code for printing the backtrace in the same way across the different\n/// supported platforms.\nuse crate::env;\nuse crate::fmt;\nuse crate::io;\nuse crate::io::prelude::*;\nuse crate::path::{self, Path, PathBuf};\nuse crate::sync::atomic::{self, Ordering};\nuse crate::sys::mutex::Mutex;\n\nuse backtrace_rs::{BacktraceFmt, BytesOrWideString, PrintFmt};\n\n/// Max number of frames to print.\nconst MAX_NB_FRAMES: usize = 100;\n\npub fn lock() -> impl Drop {\n}\n\n/// Prints the current backtrace.\npub fn print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n}\n\nunsafe fn _print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n}\n\nunsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::Result {\n}\n\n/// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`. Note that\n/// this is only inline(never) when backtraces in libstd are enabled, otherwise\n/// it's fine to optimize away.\n#[cfg_attr(feature = \"backtrace\", inline(never))]\npub fn __rust_begin_short_backtrace<F, T>(f: F) -> T\nwhere\n    F: FnOnce() -> T,\n    F: Send,\n    T: Send,\n{\n}\n\npub enum RustBacktrace {\n    Print(PrintFmt),\n    Disabled,\n    RuntimeDisabled,\n}\n\n// For now logging is turned off by default, and this function checks to see\n// whether the magical environment variable is present to see if it's turned on.\npub fn rust_backtrace_env() -> RustBacktrace {\n}\n\n/// Prints the filename of the backtrace frame.\n///\n/// See also `output`.\npub fn output_filename(\n    fmt: &mut fmt::Formatter<'_>,\n    bows: BytesOrWideString<'_>,\n    print_fmt: PrintFmt,\n    cwd: Option<&PathBuf>,\n) -> fmt::Result {\n}\n}\npub mod bytestring {\n#![allow(dead_code)]\n\nuse crate::fmt::{Formatter, Result, Write};\nuse core::str::lossy::{Utf8Lossy, Utf8LossyChunk};\n\npub fn debug_fmt_bytestring(slice: &[u8], f: &mut Formatter<'_>) -> Result {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\npub mod condvar {\nuse crate::sys::condvar as imp;\nuse crate::sys_common::mutex::{self, Mutex};\nuse crate::time::Duration;\n\n/// An OS-based condition variable.\n///\n/// This structure is the lowest layer possible on top of the OS-provided\n/// condition variables. It is consequently entirely unsafe to use. It is\n/// recommended to use the safer types at the top level of this crate instead of\n/// this type.\npub struct Condvar(imp::Condvar);\n\nimpl Condvar {\n    /// Creates a new condition variable for use.\n    ///\n    /// Behavior is undefined if the condition variable is moved after it is\n    /// first used with any of the functions below.\n    pub const fn new() -> Condvar {\n}\n\n    /// Prepares the condition variable for use.\n    ///\n    /// This should be called once the condition variable is at a stable memory\n    /// address.\n    #[inline]\n    pub unsafe fn init(&mut self) {\n}\n\n    /// Signals one waiter on this condition variable to wake up.\n    #[inline]\n    pub unsafe fn notify_one(&self) {\n}\n\n    /// Awakens all current waiters on this condition variable.\n    #[inline]\n    pub unsafe fn notify_all(&self) {\n}\n\n    /// Waits for a signal on the specified mutex.\n    ///\n    /// Behavior is undefined if the mutex is not locked by the current thread.\n    /// Behavior is also undefined if more than one mutex is used concurrently\n    /// on this condition variable.\n    #[inline]\n    pub unsafe fn wait(&self, mutex: &Mutex) {\n}\n\n    /// Waits for a signal on the specified mutex with a timeout duration\n    /// specified by `dur` (a relative time into the future).\n    ///\n    /// Behavior is undefined if the mutex is not locked by the current thread.\n    /// Behavior is also undefined if more than one mutex is used concurrently\n    /// on this condition variable.\n    #[inline]\n    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n}\n\n    /// Deallocates all resources associated with this condition variable.\n    ///\n    /// Behavior is undefined if there are current or will be future users of\n    /// this condition variable.\n    #[inline]\n    pub unsafe fn destroy(&self) {\n}\n}\n}\npub mod fs {\n#![allow(dead_code)] // not used on all platforms\n\nuse crate::fs;\nuse crate::io::{self, Error, ErrorKind};\nuse crate::path::Path;\n\npub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n}\n\npub fn remove_dir_all(path: &Path) -> io::Result<()> {\n}\n\nfn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n}\n}\npub mod io {\npub const DEFAULT_BUF_SIZE: usize = 8 * 1024;\n\n#[cfg(test)]\n#[allow(dead_code)] // not used on emscripten\npub mod test {\n}\n}\npub mod mutex {\nuse crate::sys::mutex as imp;\n\n/// An OS-based mutual exclusion lock.\n///\n/// This is the thinnest cross-platform wrapper around OS mutexes. All usage of\n/// this mutex is unsafe and it is recommended to instead use the safe wrapper\n/// at the top level of the crate instead of this type.\npub struct Mutex(imp::Mutex);\n\nunsafe impl Sync for Mutex {}\n\nimpl Mutex {\n    /// Creates a new mutex for use.\n    ///\n    /// Behavior is undefined if the mutex is moved after it is\n    /// first used with any of the functions below.\n    /// Also, until `init` is called, behavior is undefined if this\n    /// mutex is ever used reentrantly, i.e., `raw_lock` or `try_lock`\n    /// are called by the thread currently holding the lock.\n    pub const fn new() -> Mutex {\n}\n\n    /// Prepare the mutex for use.\n    ///\n    /// This should be called once the mutex is at a stable memory address.\n    /// If called, this must be the very first thing that happens to the mutex.\n    /// Calling it in parallel with or after any operation (including another\n    /// `init()`) is undefined behavior.\n    #[inline]\n    pub unsafe fn init(&mut self) {\n}\n\n    /// Locks the mutex blocking the current thread until it is available.\n    ///\n    /// Behavior is undefined if the mutex has been moved between this and any\n    /// previous function call.\n    #[inline]\n    pub unsafe fn raw_lock(&self) {\n}\n\n    /// Calls raw_lock() and then returns an RAII guard to guarantee the mutex\n    /// will be unlocked.\n    #[inline]\n    pub unsafe fn lock(&self) -> MutexGuard<'_> {\n}\n\n    /// Attempts to lock the mutex without blocking, returning whether it was\n    /// successfully acquired or not.\n    ///\n    /// Behavior is undefined if the mutex has been moved between this and any\n    /// previous function call.\n    #[inline]\n    pub unsafe fn try_lock(&self) -> bool {\n}\n\n    /// Unlocks the mutex.\n    ///\n    /// Behavior is undefined if the current thread does not actually hold the\n    /// mutex.\n    ///\n    /// Consider switching from the pair of raw_lock() and raw_unlock() to\n    /// lock() whenever possible.\n    #[inline]\n    pub unsafe fn raw_unlock(&self) {\n}\n\n    /// Deallocates all resources associated with this mutex.\n    ///\n    /// Behavior is undefined if there are current or will be future users of\n    /// this mutex.\n    #[inline]\n    pub unsafe fn destroy(&self) {\n}\n}\n\n// not meant to be exported to the outside world, just the containing module\npub fn raw(mutex: &Mutex) -> &imp::Mutex {\n}\n\n#[must_use]\n/// A simple RAII utility for the above Mutex without the poisoning semantics.\npub struct MutexGuard<'a>(&'a imp::Mutex);\n\nimpl Drop for MutexGuard<'_> {\n    #[inline]\n    fn drop(&mut self) {\n}\n}\n}\n#[cfg(any(doc, // see `mod os`, docs are generated for multiple platforms\n          unix,\n          target_os = \"redox\",\n          target_os = \"cloudabi\",\n          target_os = \"hermit\",\n          target_arch = \"wasm32\",\n          all(target_vendor = \"fortanix\", target_env = \"sgx\")))]\npub mod os_str_bytes {\n//! The underlying OsString/OsStr implementation on Unix and many other\n//! systems: just a `Vec<u8>`/`[u8]`.\n\nuse crate::borrow::Cow;\nuse crate::ffi::{OsStr, OsString};\nuse crate::fmt;\nuse crate::mem;\nuse crate::rc::Rc;\nuse crate::str;\nuse crate::sync::Arc;\nuse crate::sys_common::bytestring::debug_fmt_bytestring;\nuse crate::sys_common::{AsInner, FromInner, IntoInner};\n\nuse core::str::lossy::Utf8Lossy;\n\n#[derive(Clone, Hash)]\npub(crate) struct Buf {\n    pub inner: Vec<u8>,\n}\n\n// FIXME:\n// `Buf::as_slice` current implementation relies\n// on `Slice` being layout-compatible with `[u8]`.\n// When attribute privacy is implemented, `Slice` should be annotated as `#[repr(transparent)]`.\n// Anyway, `Slice` representation and layout are considered implementation detail, are\n// not documented and must not be relied upon.\npub(crate) struct Slice {\n    pub inner: [u8],\n}\n\nimpl fmt::Debug for Slice {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl fmt::Display for Slice {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl fmt::Debug for Buf {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl fmt::Display for Buf {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl IntoInner<Vec<u8>> for Buf {\n    fn into_inner(self) -> Vec<u8> {\n}\n}\n\nimpl AsInner<[u8]> for Buf {\n    fn as_inner(&self) -> &[u8] {\n}\n}\n\nimpl Buf {\n    pub fn from_string(s: String) -> Buf {\n}\n\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Buf {\n}\n\n    #[inline]\n    pub fn clear(&mut self) {\n}\n\n    #[inline]\n    pub fn capacity(&self) -> usize {\n}\n\n    #[inline]\n    pub fn reserve(&mut self, additional: usize) {\n}\n\n    #[inline]\n    pub fn reserve_exact(&mut self, additional: usize) {\n}\n\n    #[inline]\n    pub fn shrink_to_fit(&mut self) {\n}\n\n    #[inline]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n}\n\n    #[inline]\n    pub fn as_slice(&self) -> &Slice {\n}\n\n    pub fn into_string(self) -> Result<String, Buf> {\n}\n\n    pub fn push_slice(&mut self, s: &Slice) {\n}\n\n    #[inline]\n    pub fn into_box(self) -> Box<Slice> {\n}\n\n    #[inline]\n    pub fn from_box(boxed: Box<Slice>) -> Buf {\n}\n\n    #[inline]\n    pub fn into_arc(&self) -> Arc<Slice> {\n}\n\n    #[inline]\n    pub fn into_rc(&self) -> Rc<Slice> {\n}\n}\n\nimpl Slice {\n    #[inline]\n    fn from_u8_slice(s: &[u8]) -> &Slice {\n}\n\n    #[inline]\n    pub fn from_str(s: &str) -> &Slice {\n}\n\n    pub fn to_str(&self) -> Option<&str> {\n}\n\n    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n}\n\n    pub fn to_owned(&self) -> Buf {\n}\n\n    #[inline]\n    pub fn into_box(&self) -> Box<Slice> {\n}\n\n    pub fn empty_box() -> Box<Slice> {\n}\n\n    #[inline]\n    pub fn into_arc(&self) -> Arc<Slice> {\n}\n\n    #[inline]\n    pub fn into_rc(&self) -> Rc<Slice> {\n}\n}\n\n/// Platform-specific extensions to [`OsString`].\n///\n/// [`OsString`]: ../../../../std/ffi/struct.OsString.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait OsStringExt {\n    /// Creates an [`OsString`] from a byte vector.\n    ///\n    /// See the module documentation for an example.\n    ///\n    /// [`OsString`]: ../../../ffi/struct.OsString.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn from_vec(vec: Vec<u8>) -> Self;\n\n    /// Yields the underlying byte vector of this [`OsString`].\n    ///\n    /// See the module documentation for an example.\n    ///\n    /// [`OsString`]: ../../../ffi/struct.OsString.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn into_vec(self) -> Vec<u8>;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl OsStringExt for OsString {\n    fn from_vec(vec: Vec<u8>) -> OsString {\n}\n    fn into_vec(self) -> Vec<u8> {\n}\n}\n\n/// Platform-specific extensions to [`OsStr`].\n///\n/// [`OsStr`]: ../../../../std/ffi/struct.OsStr.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait OsStrExt {\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    /// Creates an [`OsStr`] from a byte slice.\n    ///\n    /// See the module documentation for an example.\n    ///\n    /// [`OsStr`]: ../../../ffi/struct.OsStr.html\n    fn from_bytes(slice: &[u8]) -> &Self;\n\n    /// Gets the underlying byte view of the [`OsStr`] slice.\n    ///\n    /// See the module documentation for an example.\n    ///\n    /// [`OsStr`]: ../../../ffi/struct.OsStr.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn as_bytes(&self) -> &[u8];\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl OsStrExt for OsStr {\n    #[inline]\n    fn from_bytes(slice: &[u8]) -> &OsStr {\n}\n    #[inline]\n    fn as_bytes(&self) -> &[u8] {\n}\n}\n}\npub mod poison {\nuse crate::error::Error;\nuse crate::fmt;\nuse crate::sync::atomic::{AtomicBool, Ordering};\nuse crate::thread;\n\npub struct Flag {\n    failed: AtomicBool,\n}\n\n// Note that the Ordering uses to access the `failed` field of `Flag` below is\n// always `Relaxed`, and that's because this isn't actually protecting any data,\n// it's just a flag whether we've panicked or not.\n//\n// The actual location that this matters is when a mutex is **locked** which is\n// where we have external synchronization ensuring that we see memory\n// reads/writes to this flag.\n//\n// As a result, if it matters, we should see the correct value for `failed` in\n// all cases.\n\nimpl Flag {\n    pub const fn new() -> Flag {\n}\n\n    #[inline]\n    pub fn borrow(&self) -> LockResult<Guard> {\n}\n\n    #[inline]\n    pub fn done(&self, guard: &Guard) {\n}\n\n    #[inline]\n    pub fn get(&self) -> bool {\n}\n}\n\npub struct Guard {\n    panicking: bool,\n}\n\n/// A type of error which can be returned whenever a lock is acquired.\n///\n/// Both [`Mutex`]es and [`RwLock`]s are poisoned whenever a thread fails while the lock\n/// is held. The precise semantics for when a lock is poisoned is documented on\n/// each lock, but once a lock is poisoned then all future acquisitions will\n/// return this error.\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::{Arc, Mutex};\n/// use std::thread;\n///\n/// let mutex = Arc::new(Mutex::new(1));\n///\n/// // poison the mutex\n/// let c_mutex = mutex.clone();\n/// let _ = thread::spawn(move || {\n///     let mut data = c_mutex.lock().unwrap();\n///     *data = 2;\n///     panic!();\n/// }).join();\n///\n/// match mutex.lock() {\n///     Ok(_) => unreachable!(),\n///     Err(p_err) => {\n///         let data = p_err.get_ref();\n///         println!(\"recovered: {}\", data);\n///     }\n/// };\n/// ```\n///\n/// [`Mutex`]: ../../std/sync/struct.Mutex.html\n/// [`RwLock`]: ../../std/sync/struct.RwLock.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct PoisonError<T> {\n    guard: T,\n}\n\n/// An enumeration of possible errors associated with a [`TryLockResult`] which\n/// can occur while trying to acquire a lock, from the [`try_lock`] method on a\n/// [`Mutex`] or the [`try_read`] and [`try_write`] methods on an [`RwLock`].\n///\n/// [`Mutex`]: struct.Mutex.html\n/// [`RwLock`]: struct.RwLock.html\n/// [`TryLockResult`]: type.TryLockResult.html\n/// [`try_lock`]: struct.Mutex.html#method.try_lock\n/// [`try_read`]: struct.RwLock.html#method.try_read\n/// [`try_write`]: struct.RwLock.html#method.try_write\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum TryLockError<T> {\n    /// The lock could not be acquired because another thread failed while holding\n    /// the lock.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Poisoned(#[stable(feature = \"rust1\", since = \"1.0.0\")] PoisonError<T>),\n    /// The lock could not be acquired at this time because the operation would\n    /// otherwise block.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    WouldBlock,\n}\n\n/// A type alias for the result of a lock method which can be poisoned.\n///\n/// The [`Ok`] variant of this result indicates that the primitive was not\n/// poisoned, and the `Guard` is contained within. The [`Err`] variant indicates\n/// that the primitive was poisoned. Note that the [`Err`] variant *also* carries\n/// the associated guard, and it can be acquired through the [`into_inner`]\n/// method.\n///\n/// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n/// [`into_inner`]: ../../std/sync/struct.PoisonError.html#method.into_inner\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n\n/// A type alias for the result of a nonblocking locking method.\n///\n/// For more information, see [`LockResult`]. A `TryLockResult` doesn't\n/// necessarily hold the associated guard in the [`Err`] type as the lock may not\n/// have been acquired for other reasons.\n///\n/// [`LockResult`]: ../../std/sync/type.LockResult.html\n/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> fmt::Debug for PoisonError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> fmt::Display for PoisonError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Error for PoisonError<T> {\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n}\n}\n\nimpl<T> PoisonError<T> {\n    /// Creates a `PoisonError`.\n    ///\n    /// This is generally created by methods like [`Mutex::lock`] or [`RwLock::read`].\n    ///\n    /// [`Mutex::lock`]: ../../std/sync/struct.Mutex.html#method.lock\n    /// [`RwLock::read`]: ../../std/sync/struct.RwLock.html#method.read\n    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n    pub fn new(guard: T) -> PoisonError<T> {\n}\n\n    /// Consumes this error indicating that a lock is poisoned, returning the\n    /// underlying guard to allow access regardless.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::HashSet;\n    /// use std::sync::{Arc, Mutex};\n    /// use std::thread;\n    ///\n    /// let mutex = Arc::new(Mutex::new(HashSet::new()));\n    ///\n    /// // poison the mutex\n    /// let c_mutex = mutex.clone();\n    /// let _ = thread::spawn(move || {\n    ///     let mut data = c_mutex.lock().unwrap();\n    ///     data.insert(10);\n    ///     panic!();\n    /// }).join();\n    ///\n    /// let p_err = mutex.lock().unwrap_err();\n    /// let data = p_err.into_inner();\n    /// println!(\"recovered {} items\", data.len());\n    /// ```\n    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n    pub fn into_inner(self) -> T {\n}\n\n    /// Reaches into this error indicating that a lock is poisoned, returning a\n    /// reference to the underlying guard to allow access regardless.\n    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n    pub fn get_ref(&self) -> &T {\n}\n\n    /// Reaches into this error indicating that a lock is poisoned, returning a\n    /// mutable reference to the underlying guard to allow access regardless.\n    #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n    pub fn get_mut(&mut self) -> &mut T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> From<PoisonError<T>> for TryLockError<T> {\n    fn from(err: PoisonError<T>) -> TryLockError<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> fmt::Debug for TryLockError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> fmt::Display for TryLockError<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Error for TryLockError<T> {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n}\n\n    #[allow(deprecated)]\n    fn cause(&self) -> Option<&dyn Error> {\n}\n}\n\npub fn map_result<T, U, F>(result: LockResult<T>, f: F) -> LockResult<U>\nwhere\n    F: FnOnce(T) -> U,\n{\n}\n}\npub mod process {\n#![allow(dead_code)]\n#![unstable(feature = \"process_internals\", issue = \"none\")]\n\nuse crate::collections::BTreeMap;\nuse crate::env;\nuse crate::ffi::{OsStr, OsString};\nuse crate::sys::process::EnvKey;\n\n// Stores a set of changes to an environment\n#[derive(Clone, Debug)]\npub struct CommandEnv {\n    clear: bool,\n    saw_path: bool,\n    vars: BTreeMap<EnvKey, Option<OsString>>,\n}\n\nimpl Default for CommandEnv {\n    fn default() -> Self {\n}\n}\n\nimpl CommandEnv {\n    // Capture the current environment with these changes applied\n    pub fn capture(&self) -> BTreeMap<EnvKey, OsString> {\n}\n\n    // Apply these changes directly to the current environment\n    pub fn apply(&self) {\n}\n\n    pub fn is_unchanged(&self) -> bool {\n}\n\n    pub fn capture_if_changed(&self) -> Option<BTreeMap<EnvKey, OsString>> {\n}\n\n    // The following functions build up changes\n    pub fn set(&mut self, key: &OsStr, value: &OsStr) {\n}\n\n    pub fn remove(&mut self, key: &OsStr) {\n}\n\n    pub fn clear(&mut self) {\n}\n\n    pub fn have_changed_path(&self) -> bool {\n}\n\n    fn maybe_saw_path(&mut self, key: &OsStr) {\n}\n}\n}\npub mod remutex {\nuse crate::fmt;\nuse crate::marker;\nuse crate::ops::Deref;\nuse crate::panic::{RefUnwindSafe, UnwindSafe};\nuse crate::sys::mutex as sys;\nuse crate::sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n\n/// A re-entrant mutual exclusion\n///\n/// This mutex will block *other* threads waiting for the lock to become\n/// available. The thread which has already locked the mutex can lock it\n/// multiple times without blocking, preventing a common source of deadlocks.\npub struct ReentrantMutex<T> {\n    inner: Box<sys::ReentrantMutex>,\n    poison: poison::Flag,\n    data: T,\n}\n\nunsafe impl<T: Send> Send for ReentrantMutex<T> {}\nunsafe impl<T: Send> Sync for ReentrantMutex<T> {}\n\nimpl<T> UnwindSafe for ReentrantMutex<T> {}\nimpl<T> RefUnwindSafe for ReentrantMutex<T> {}\n\n/// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n/// dropped (falls out of scope), the lock will be unlocked.\n///\n/// The data protected by the mutex can be accessed through this guard via its\n/// Deref implementation.\n///\n/// # Mutability\n///\n/// Unlike `MutexGuard`, `ReentrantMutexGuard` does not implement `DerefMut`,\n/// because implementation of the trait would violate Rust’s reference aliasing\n/// rules. Use interior mutability (usually `RefCell`) in order to mutate the\n/// guarded data.\n#[must_use = \"if unused the ReentrantMutex will immediately unlock\"]\npub struct ReentrantMutexGuard<'a, T: 'a> {\n    // funny underscores due to how Deref currently works (it disregards field\n    // privacy).\n    __lock: &'a ReentrantMutex<T>,\n    __poison: poison::Guard,\n}\n\nimpl<T> !marker::Send for ReentrantMutexGuard<'_, T> {}\n\nimpl<T> ReentrantMutex<T> {\n    /// Creates a new reentrant mutex in an unlocked state.\n    pub fn new(t: T) -> ReentrantMutex<T> {\n}\n\n    /// Acquires a mutex, blocking the current thread until it is able to do so.\n    ///\n    /// This function will block the caller until it is available to acquire the mutex.\n    /// Upon returning, the thread is the only thread with the mutex held. When the thread\n    /// calling this method already holds the lock, the call shall succeed without\n    /// blocking.\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return failure if the mutex would otherwise be\n    /// acquired.\n    pub fn lock(&self) -> LockResult<ReentrantMutexGuard<'_, T>> {\n}\n\n    /// Attempts to acquire this lock.\n    ///\n    /// If the lock could not be acquired at this time, then `Err` is returned.\n    /// Otherwise, an RAII guard is returned.\n    ///\n    /// This function does not block.\n    ///\n    /// # Errors\n    ///\n    /// If another user of this mutex panicked while holding the mutex, then\n    /// this call will return failure if the mutex would otherwise be\n    /// acquired.\n    pub fn try_lock(&self) -> TryLockResult<ReentrantMutexGuard<'_, T>> {\n}\n}\n\nimpl<T> Drop for ReentrantMutex<T> {\n    fn drop(&mut self) {\n}\n}\n\nimpl<T: fmt::Debug + 'static> fmt::Debug for ReentrantMutex<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<'mutex, T> ReentrantMutexGuard<'mutex, T> {\n    fn new(lock: &'mutex ReentrantMutex<T>) -> LockResult<ReentrantMutexGuard<'mutex, T>> {\n}\n}\n\nimpl<T> Deref for ReentrantMutexGuard<'_, T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n}\n}\n\nimpl<T> Drop for ReentrantMutexGuard<'_, T> {\n    #[inline]\n    fn drop(&mut self) {\n}\n}\n\n#[cfg(all(test, not(target_os = \"emscripten\")))]\nmod tests {\n    use crate::cell::RefCell;\n    use crate::sync::Arc;\n    use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n    use crate::thread;\n\n    #[test]\n    fn smoke() {\n}\n\n    #[test]\n    fn is_mutex() {\n}\n\n    #[test]\n    fn trylock_works() {\n}\n\n    pub struct Answer<'a>(pub ReentrantMutexGuard<'a, RefCell<u32>>);\n    impl Drop for Answer<'_> {\n        fn drop(&mut self) {\n}\n    }\n\n    #[test]\n    fn poison_works() {\n}\n}\n}\npub mod rwlock {\nuse crate::sys::rwlock as imp;\n\n/// An OS-based reader-writer lock.\n///\n/// This structure is entirely unsafe and serves as the lowest layer of a\n/// cross-platform binding of system rwlocks. It is recommended to use the\n/// safer types at the top level of this crate instead of this type.\npub struct RWLock(imp::RWLock);\n\nimpl RWLock {\n    /// Creates a new reader-writer lock for use.\n    ///\n    /// Behavior is undefined if the reader-writer lock is moved after it is\n    /// first used with any of the functions below.\n    pub const fn new() -> RWLock {\n}\n\n    /// Acquires shared access to the underlying lock, blocking the current\n    /// thread to do so.\n    ///\n    /// Behavior is undefined if the rwlock has been moved between this and any\n    /// previous method call.\n    #[inline]\n    pub unsafe fn read(&self) {\n}\n\n    /// Attempts to acquire shared access to this lock, returning whether it\n    /// succeeded or not.\n    ///\n    /// This function does not block the current thread.\n    ///\n    /// Behavior is undefined if the rwlock has been moved between this and any\n    /// previous method call.\n    #[inline]\n    pub unsafe fn try_read(&self) -> bool {\n}\n\n    /// Acquires write access to the underlying lock, blocking the current thread\n    /// to do so.\n    ///\n    /// Behavior is undefined if the rwlock has been moved between this and any\n    /// previous method call.\n    #[inline]\n    pub unsafe fn write(&self) {\n}\n\n    /// Attempts to acquire exclusive access to this lock, returning whether it\n    /// succeeded or not.\n    ///\n    /// This function does not block the current thread.\n    ///\n    /// Behavior is undefined if the rwlock has been moved between this and any\n    /// previous method call.\n    #[inline]\n    pub unsafe fn try_write(&self) -> bool {\n}\n\n    /// Unlocks previously acquired shared access to this lock.\n    ///\n    /// Behavior is undefined if the current thread does not have shared access.\n    #[inline]\n    pub unsafe fn read_unlock(&self) {\n}\n\n    /// Unlocks previously acquired exclusive access to this lock.\n    ///\n    /// Behavior is undefined if the current thread does not currently have\n    /// exclusive access.\n    #[inline]\n    pub unsafe fn write_unlock(&self) {\n}\n\n    /// Destroys OS-related resources with this RWLock.\n    ///\n    /// Behavior is undefined if there are any currently active users of this\n    /// lock.\n    #[inline]\n    pub unsafe fn destroy(&self) {\n}\n}\n}\npub mod thread {\nuse crate::env;\nuse crate::sync::atomic::{self, Ordering};\nuse crate::sys::stack_overflow;\nuse crate::sys::thread as imp;\n\n#[allow(dead_code)]\npub unsafe fn start_thread(main: *mut u8) {\n}\n\npub fn min_stack() -> usize {\n}\n}\npub mod thread_info {\n#![allow(dead_code)] // stack_guard isn't used right now on all platforms\n\nuse crate::cell::RefCell;\nuse crate::sys::thread::guard::Guard;\nuse crate::thread::Thread;\n\nstruct ThreadInfo {\n    stack_guard: Option<Guard>,\n    thread: Thread,\n}\n\nthread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(None) }\n\nimpl ThreadInfo {\n    fn with<R, F>(f: F) -> Option<R>\n    where\n        F: FnOnce(&mut ThreadInfo) -> R,\n    {\n}\n}\n\npub fn current_thread() -> Option<Thread> {\n}\n\npub fn stack_guard() -> Option<Guard> {\n}\n\npub fn set(stack_guard: Option<Guard>, thread: Thread) {\n}\n\npub fn reset_guard(stack_guard: Option<Guard>) {\n}\n}\npub mod thread_local {\n//! OS-based thread local storage\n//!\n//! This module provides an implementation of OS-based thread local storage,\n//! using the native OS-provided facilities (think `TlsAlloc` or\n//! `pthread_setspecific`). The interface of this differs from the other types\n//! of thread-local-storage provided in this crate in that OS-based TLS can only\n//! get/set pointers,\n//!\n//! This module also provides two flavors of TLS. One is intended for static\n//! initialization, and does not contain a `Drop` implementation to deallocate\n//! the OS-TLS key. The other is a type which does implement `Drop` and hence\n//! has a safe interface.\n//!\n//! # Usage\n//!\n//! This module should likely not be used directly unless other primitives are\n//! being built on. types such as `thread_local::spawn::Key` are likely much\n//! more useful in practice than this OS-based version which likely requires\n//! unsafe code to interoperate with.\n//!\n//! # Examples\n//!\n//! Using a dynamically allocated TLS key. Note that this key can be shared\n//! among many threads via an `Arc`.\n//!\n//! ```ignore (cannot-doctest-private-modules)\n//! let key = Key::new(None);\n//! assert!(key.get().is_null());\n//! key.set(1 as *mut u8);\n//! assert!(!key.get().is_null());\n//!\n//! drop(key); // deallocate this TLS slot.\n//! ```\n//!\n//! Sometimes a statically allocated key is either required or easier to work\n//! with, however.\n//!\n//! ```ignore (cannot-doctest-private-modules)\n//! static KEY: StaticKey = INIT;\n//!\n//! unsafe {\n//!     assert!(KEY.get().is_null());\n//!     KEY.set(1 as *mut u8);\n//! }\n//! ```\n\n#![allow(non_camel_case_types)]\n#![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n#![allow(dead_code)] // sys isn't exported yet\n\nuse crate::ptr;\nuse crate::sync::atomic::{self, AtomicUsize, Ordering};\nuse crate::sys::thread_local as imp;\nuse crate::sys_common::mutex::Mutex;\n\n/// A type for TLS keys that are statically allocated.\n///\n/// This type is entirely `unsafe` to use as it does not protect against\n/// use-after-deallocation or use-during-deallocation.\n///\n/// The actual OS-TLS key is lazily allocated when this is used for the first\n/// time. The key is also deallocated when the Rust runtime exits or `destroy`\n/// is called, whichever comes first.\n///\n/// # Examples\n///\n/// ```ignore (cannot-doctest-private-modules)\n/// use tls::os::{StaticKey, INIT};\n///\n/// static KEY: StaticKey = INIT;\n///\n/// unsafe {\n///     assert!(KEY.get().is_null());\n///     KEY.set(1 as *mut u8);\n/// }\n/// ```\npub struct StaticKey {\n    /// Inner static TLS key (internals).\n    key: AtomicUsize,\n    /// Destructor for the TLS value.\n    ///\n    /// See `Key::new` for information about when the destructor runs and how\n    /// it runs.\n    dtor: Option<unsafe extern \"C\" fn(*mut u8)>,\n}\n\n/// A type for a safely managed OS-based TLS slot.\n///\n/// This type allocates an OS TLS key when it is initialized and will deallocate\n/// the key when it falls out of scope. When compared with `StaticKey`, this\n/// type is entirely safe to use.\n///\n/// Implementations will likely, however, contain unsafe code as this type only\n/// operates on `*mut u8`, a raw pointer.\n///\n/// # Examples\n///\n/// ```ignore (cannot-doctest-private-modules)\n/// use tls::os::Key;\n///\n/// let key = Key::new(None);\n/// assert!(key.get().is_null());\n/// key.set(1 as *mut u8);\n/// assert!(!key.get().is_null());\n///\n/// drop(key); // deallocate this TLS slot.\n/// ```\npub struct Key {\n    key: imp::Key,\n}\n\n/// Constant initialization value for static TLS keys.\n///\n/// This value specifies no destructor by default.\npub const INIT: StaticKey = StaticKey::new(None);\n\nimpl StaticKey {\n    pub const fn new(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> StaticKey {\n}\n\n    /// Gets the value associated with this TLS key\n    ///\n    /// This will lazily allocate a TLS key from the OS if one has not already\n    /// been allocated.\n    #[inline]\n    pub unsafe fn get(&self) -> *mut u8 {\n}\n\n    /// Sets this TLS key to a new value.\n    ///\n    /// This will lazily allocate a TLS key from the OS if one has not already\n    /// been allocated.\n    #[inline]\n    pub unsafe fn set(&self, val: *mut u8) {\n}\n\n    #[inline]\n    unsafe fn key(&self) -> imp::Key {\n}\n\n    unsafe fn lazy_init(&self) -> usize {\n}\n}\n\nimpl Key {\n    /// Creates a new managed OS TLS key.\n    ///\n    /// This key will be deallocated when the key falls out of scope.\n    ///\n    /// The argument provided is an optionally-specified destructor for the\n    /// value of this TLS key. When a thread exits and the value for this key\n    /// is non-null the destructor will be invoked. The TLS value will be reset\n    /// to null before the destructor is invoked.\n    ///\n    /// Note that the destructor will not be run when the `Key` goes out of\n    /// scope.\n    #[inline]\n    pub fn new(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n}\n\n    /// See StaticKey::get\n    #[inline]\n    pub fn get(&self) -> *mut u8 {\n}\n\n    /// See StaticKey::set\n    #[inline]\n    pub fn set(&self, val: *mut u8) {\n}\n}\n\nimpl Drop for Key {\n    fn drop(&mut self) {\n}\n}\n\npub unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\npub mod util {\nuse crate::fmt;\nuse crate::io::prelude::*;\nuse crate::sys::stdio::panic_output;\nuse crate::thread;\n\npub fn dumb_print(args: fmt::Arguments<'_>) {\n}\n\n// Other platforms should use the appropriate platform-specific mechanism for\n// aborting the process.  If no platform-specific mechanism is available,\n// crate::intrinsics::abort() may be used instead.  The above implementations cover\n// all targets currently supported by libstd.\n\npub fn abort(args: fmt::Arguments<'_>) -> ! {\n}\n\n#[allow(dead_code)] // stack overflow detection not enabled on all platforms\npub unsafe fn report_overflow() {\n}' has overflowed its stack\\n\",\n        thread::current().name().unwrap_or(\"<unknown>\")\n    ));\n}\n}\npub mod wtf8 {\n//! Implementation of [the WTF-8 encoding](https://simonsapin.github.io/wtf-8/).\n//!\n//! This library uses Rust’s type system to maintain\n//! [well-formedness](https://simonsapin.github.io/wtf-8/#well-formed),\n//! like the `String` and `&str` types do for UTF-8.\n//!\n//! Since [WTF-8 must not be used\n//! for interchange](https://simonsapin.github.io/wtf-8/#intended-audience),\n//! this library deliberately does not provide access to the underlying bytes\n//! of WTF-8 strings,\n//! nor can it decode WTF-8 from arbitrary bytes.\n//! WTF-8 strings can be obtained from UTF-8, UTF-16, or code points.\n\n// this module is imported from @SimonSapin's repo and has tons of dead code on\n// unix (it's mostly used on windows), so don't worry about dead code here.\n#![allow(dead_code)]\n\nuse core::str::next_code_point;\n\nuse crate::borrow::Cow;\nuse crate::char;\nuse crate::fmt;\nuse crate::hash::{Hash, Hasher};\nuse crate::iter::FromIterator;\nuse crate::mem;\nuse crate::ops;\nuse crate::rc::Rc;\nuse crate::slice;\nuse crate::str;\nuse crate::sync::Arc;\nuse crate::sys_common::AsInner;\n\nconst UTF8_REPLACEMENT_CHARACTER: &str = \"\\u{FFFD}\";\n\n/// A Unicode code point: from U+0000 to U+10FFFF.\n///\n/// Compares with the `char` type,\n/// which represents a Unicode scalar value:\n/// a code point that is not a surrogate (U+D800 to U+DFFF).\n#[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy)]\npub struct CodePoint {\n    value: u32,\n}\n\n/// Format the code point as `U+` followed by four to six hexadecimal digits.\n/// Example: `U+1F4A9`\nimpl fmt::Debug for CodePoint {\n    #[inline]\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl CodePoint {\n    /// Unsafely creates a new `CodePoint` without checking the value.\n    ///\n    /// Only use when `value` is known to be less than or equal to 0x10FFFF.\n    #[inline]\n    pub unsafe fn from_u32_unchecked(value: u32) -> CodePoint {\n}\n\n    /// Creates a new `CodePoint` if the value is a valid code point.\n    ///\n    /// Returns `None` if `value` is above 0x10FFFF.\n    #[inline]\n    pub fn from_u32(value: u32) -> Option<CodePoint> {\n}\n\n    /// Creates a new `CodePoint` from a `char`.\n    ///\n    /// Since all Unicode scalar values are code points, this always succeeds.\n    #[inline]\n    pub fn from_char(value: char) -> CodePoint {\n}\n\n    /// Returns the numeric value of the code point.\n    #[inline]\n    pub fn to_u32(&self) -> u32 {\n}\n\n    /// Optionally returns a Unicode scalar value for the code point.\n    ///\n    /// Returns `None` if the code point is a surrogate (from U+D800 to U+DFFF).\n    #[inline]\n    pub fn to_char(&self) -> Option<char> {\n}\n\n    /// Returns a Unicode scalar value for the code point.\n    ///\n    /// Returns `'\\u{FFFD}'` (the replacement character “�”)\n    /// if the code point is a surrogate (from U+D800 to U+DFFF).\n    #[inline]\n    pub fn to_char_lossy(&self) -> char {\n}\n}\n\n/// An owned, growable string of well-formed WTF-8 data.\n///\n/// Similar to `String`, but can additionally contain surrogate code points\n/// if they’re not in a surrogate pair.\n#[derive(Eq, PartialEq, Ord, PartialOrd, Clone)]\npub struct Wtf8Buf {\n    bytes: Vec<u8>,\n}\n\nimpl ops::Deref for Wtf8Buf {\n    type Target = Wtf8;\n\n    fn deref(&self) -> &Wtf8 {\n}\n}\n\nimpl ops::DerefMut for Wtf8Buf {\n    fn deref_mut(&mut self) -> &mut Wtf8 {\n}\n}\n\n/// Format the string with double quotes,\n/// and surrogates as `\\u` followed by four hexadecimal digits.\n/// Example: `\"a\\u{D800}\"` for a string with code points [U+0061, U+D800]\nimpl fmt::Debug for Wtf8Buf {\n    #[inline]\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl Wtf8Buf {\n    /// Creates a new, empty WTF-8 string.\n    #[inline]\n    pub fn new() -> Wtf8Buf {\n}\n\n    /// Creates a new, empty WTF-8 string with pre-allocated capacity for `capacity` bytes.\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Wtf8Buf {\n}\n\n    /// Creates a WTF-8 string from a UTF-8 `String`.\n    ///\n    /// This takes ownership of the `String` and does not copy.\n    ///\n    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n    #[inline]\n    pub fn from_string(string: String) -> Wtf8Buf {\n}\n\n    /// Creates a WTF-8 string from a UTF-8 `&str` slice.\n    ///\n    /// This copies the content of the slice.\n    ///\n    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n    #[inline]\n    pub fn from_str(str: &str) -> Wtf8Buf {\n}\n\n    pub fn clear(&mut self) {\n}\n\n    /// Creates a WTF-8 string from a potentially ill-formed UTF-16 slice of 16-bit code units.\n    ///\n    /// This is lossless: calling `.encode_wide()` on the resulting string\n    /// will always return the original code units.\n    pub fn from_wide(v: &[u16]) -> Wtf8Buf {\n}\n\n    /// Copied from String::push\n    /// This does **not** include the WTF-8 concatenation check.\n    fn push_code_point_unchecked(&mut self, code_point: CodePoint) {\n}\n\n    #[inline]\n    pub fn as_slice(&self) -> &Wtf8 {\n}\n\n    #[inline]\n    pub fn as_mut_slice(&mut self) -> &mut Wtf8 {\n}\n\n    /// Reserves capacity for at least `additional` more bytes to be inserted\n    /// in the given `Wtf8Buf`.\n    /// The collection may reserve more space to avoid frequent reallocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    #[inline]\n    pub fn reserve(&mut self, additional: usize) {\n}\n\n    #[inline]\n    pub fn reserve_exact(&mut self, additional: usize) {\n}\n\n    #[inline]\n    pub fn shrink_to_fit(&mut self) {\n}\n\n    #[inline]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n}\n\n    /// Returns the number of bytes that this string buffer can hold without reallocating.\n    #[inline]\n    pub fn capacity(&self) -> usize {\n}\n\n    /// Append a UTF-8 slice at the end of the string.\n    #[inline]\n    pub fn push_str(&mut self, other: &str) {\n}\n\n    /// Append a WTF-8 slice at the end of the string.\n    ///\n    /// This replaces newly paired surrogates at the boundary\n    /// with a supplementary code point,\n    /// like concatenating ill-formed UTF-16 strings effectively would.\n    #[inline]\n    pub fn push_wtf8(&mut self, other: &Wtf8) {\n}\n\n    /// Append a Unicode scalar value at the end of the string.\n    #[inline]\n    pub fn push_char(&mut self, c: char) {\n}\n\n    /// Append a code point at the end of the string.\n    ///\n    /// This replaces newly paired surrogates at the boundary\n    /// with a supplementary code point,\n    /// like concatenating ill-formed UTF-16 strings effectively would.\n    #[inline]\n    pub fn push(&mut self, code_point: CodePoint) {\n}\n\n    /// Shortens a string to the specified length.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `new_len` > current length,\n    /// or if `new_len` is not a code point boundary.\n    #[inline]\n    pub fn truncate(&mut self, new_len: usize) {\n}\n\n    /// Consumes the WTF-8 string and tries to convert it to UTF-8.\n    ///\n    /// This does not copy the data.\n    ///\n    /// If the contents are not well-formed UTF-8\n    /// (that is, if the string contains surrogates),\n    /// the original WTF-8 string is returned instead.\n    pub fn into_string(self) -> Result<String, Wtf8Buf> {\n}\n\n    /// Consumes the WTF-8 string and converts it lossily to UTF-8.\n    ///\n    /// This does not copy the data (but may overwrite parts of it in place).\n    ///\n    /// Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character “�”)\n    pub fn into_string_lossy(mut self) -> String {\n}\n\n    /// Converts this `Wtf8Buf` into a boxed `Wtf8`.\n    #[inline]\n    pub fn into_box(self) -> Box<Wtf8> {\n}\n\n    /// Converts a `Box<Wtf8>` into a `Wtf8Buf`.\n    pub fn from_box(boxed: Box<Wtf8>) -> Wtf8Buf {\n}\n}\n\n/// Creates a new WTF-8 string from an iterator of code points.\n///\n/// This replaces surrogate code point pairs with supplementary code points,\n/// like concatenating ill-formed UTF-16 strings effectively would.\nimpl FromIterator<CodePoint> for Wtf8Buf {\n    fn from_iter<T: IntoIterator<Item = CodePoint>>(iter: T) -> Wtf8Buf {\n}\n}\n\n/// Append code points from an iterator to the string.\n///\n/// This replaces surrogate code point pairs with supplementary code points,\n/// like concatenating ill-formed UTF-16 strings effectively would.\nimpl Extend<CodePoint> for Wtf8Buf {\n    fn extend<T: IntoIterator<Item = CodePoint>>(&mut self, iter: T) {\n}\n}\n\n/// A borrowed slice of well-formed WTF-8 data.\n///\n/// Similar to `&str`, but can additionally contain surrogate code points\n/// if they’re not in a surrogate pair.\n#[derive(Eq, Ord, PartialEq, PartialOrd)]\npub struct Wtf8 {\n    bytes: [u8],\n}\n\nimpl AsInner<[u8]> for Wtf8 {\n    fn as_inner(&self) -> &[u8] {\n}\n}\n\n/// Format the slice with double quotes,\n/// and surrogates as `\\u` followed by four hexadecimal digits.\n/// Example: `\"a\\u{D800}\"` for a slice with code points [U+0061, U+D800]\nimpl fmt::Debug for Wtf8 {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl fmt::Display for Wtf8 {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl Wtf8 {\n    /// Creates a WTF-8 slice from a UTF-8 `&str` slice.\n    ///\n    /// Since WTF-8 is a superset of UTF-8, this always succeeds.\n    #[inline]\n    pub fn from_str(value: &str) -> &Wtf8 {\n}\n\n    /// Creates a WTF-8 slice from a WTF-8 byte slice.\n    ///\n    /// Since the byte slice is not checked for valid WTF-8, this functions is\n    /// marked unsafe.\n    #[inline]\n    unsafe fn from_bytes_unchecked(value: &[u8]) -> &Wtf8 {\n}\n\n    /// Creates a mutable WTF-8 slice from a mutable WTF-8 byte slice.\n    ///\n    /// Since the byte slice is not checked for valid WTF-8, this functions is\n    /// marked unsafe.\n    #[inline]\n    unsafe fn from_mut_bytes_unchecked(value: &mut [u8]) -> &mut Wtf8 {\n}\n\n    /// Returns the length, in WTF-8 bytes.\n    #[inline]\n    pub fn len(&self) -> usize {\n}\n\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n}\n\n    /// Returns the code point at `position` if it is in the ASCII range,\n    /// or `b'\\xFF' otherwise.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `position` is beyond the end of the string.\n    #[inline]\n    pub fn ascii_byte_at(&self, position: usize) -> u8 {\n}\n\n    /// Returns an iterator for the string’s code points.\n    #[inline]\n    pub fn code_points(&self) -> Wtf8CodePoints<'_> {\n}\n\n    /// Tries to convert the string to UTF-8 and return a `&str` slice.\n    ///\n    /// Returns `None` if the string contains surrogates.\n    ///\n    /// This does not copy the data.\n    #[inline]\n    pub fn as_str(&self) -> Option<&str> {\n}\n\n    /// Lossily converts the string to UTF-8.\n    /// Returns a UTF-8 `&str` slice if the contents are well-formed in UTF-8.\n    ///\n    /// Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character “�”).\n    ///\n    /// This only copies the data if necessary (if it contains any surrogate).\n    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n}\n\n    /// Converts the WTF-8 string to potentially ill-formed UTF-16\n    /// and return an iterator of 16-bit code units.\n    ///\n    /// This is lossless:\n    /// calling `Wtf8Buf::from_ill_formed_utf16` on the resulting code units\n    /// would always return the original WTF-8 string.\n    #[inline]\n    pub fn encode_wide(&self) -> EncodeWide<'_> {\n}\n\n    #[inline]\n    fn next_surrogate(&self, mut pos: usize) -> Option<(usize, u16)> {\n}\n\n    #[inline]\n    fn final_lead_surrogate(&self) -> Option<u16> {\n}\n\n    #[inline]\n    fn initial_trail_surrogate(&self) -> Option<u16> {\n}\n\n    /// Boxes this `Wtf8`.\n    #[inline]\n    pub fn into_box(&self) -> Box<Wtf8> {\n}\n\n    /// Creates a boxed, empty `Wtf8`.\n    pub fn empty_box() -> Box<Wtf8> {\n}\n\n    #[inline]\n    pub fn into_arc(&self) -> Arc<Wtf8> {\n}\n\n    #[inline]\n    pub fn into_rc(&self) -> Rc<Wtf8> {\n}\n}\n\n/// Returns a slice of the given string for the byte range [`begin`..`end`).\n///\n/// # Panics\n///\n/// Panics when `begin` and `end` do not point to code point boundaries,\n/// or point beyond the end of the string.\nimpl ops::Index<ops::Range<usize>> for Wtf8 {\n    type Output = Wtf8;\n\n    #[inline]\n    fn index(&self, range: ops::Range<usize>) -> &Wtf8 {\n}\n}\n\n/// Returns a slice of the given string from byte `begin` to its end.\n///\n/// # Panics\n///\n/// Panics when `begin` is not at a code point boundary,\n/// or is beyond the end of the string.\nimpl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n    type Output = Wtf8;\n\n    #[inline]\n    fn index(&self, range: ops::RangeFrom<usize>) -> &Wtf8 {\n}\n}\n\n/// Returns a slice of the given string from its beginning to byte `end`.\n///\n/// # Panics\n///\n/// Panics when `end` is not at a code point boundary,\n/// or is beyond the end of the string.\nimpl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n    type Output = Wtf8;\n\n    #[inline]\n    fn index(&self, range: ops::RangeTo<usize>) -> &Wtf8 {\n}\n}\n\nimpl ops::Index<ops::RangeFull> for Wtf8 {\n    type Output = Wtf8;\n\n    #[inline]\n    fn index(&self, _range: ops::RangeFull) -> &Wtf8 {\n}\n}\n\n#[inline]\nfn decode_surrogate(second_byte: u8, third_byte: u8) -> u16 {\n}\n\n#[inline]\nfn decode_surrogate_pair(lead: u16, trail: u16) -> char {\n}\n\n/// Copied from core::str::StrPrelude::is_char_boundary\n#[inline]\npub fn is_code_point_boundary(slice: &Wtf8, index: usize) -> bool {\n}\n\n/// Copied from core::str::raw::slice_unchecked\n#[inline]\npub unsafe fn slice_unchecked(s: &Wtf8, begin: usize, end: usize) -> &Wtf8 {\n}\n\n/// Copied from core::str::raw::slice_error_fail\n#[inline(never)]\npub fn slice_error_fail(s: &Wtf8, begin: usize, end: usize) -> ! {\n}\n\n/// Iterator for the code points of a WTF-8 string.\n///\n/// Created with the method `.code_points()`.\n#[derive(Clone)]\npub struct Wtf8CodePoints<'a> {\n    bytes: slice::Iter<'a, u8>,\n}\n\nimpl<'a> Iterator for Wtf8CodePoints<'a> {\n    type Item = CodePoint;\n\n    #[inline]\n    fn next(&mut self) -> Option<CodePoint> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n/// Generates a wide character sequence for potentially ill-formed UTF-16.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct EncodeWide<'a> {\n    code_points: Wtf8CodePoints<'a>,\n    extra: u16,\n}\n\n// Copied from libunicode/u_str.rs\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for EncodeWide<'a> {\n    type Item = u16;\n\n    #[inline]\n    fn next(&mut self) -> Option<u16> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\nimpl Hash for CodePoint {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n}\n}\n\nimpl Hash for Wtf8Buf {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n}\n}\n\nimpl Hash for Wtf8 {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n}\n}\n\nimpl Wtf8 {\n    pub fn make_ascii_uppercase(&mut self) {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(any(target_os = \"cloudabi\",\n                 target_os = \"l4re\",\n                 target_os = \"hermit\",\n                 all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n                 all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n        pub use crate::sys::net;\n    } else {\n        pub mod net;\n    }\n}\n\n// common error constructors\n\n/// A trait for viewing representations from std types\n#[doc(hidden)]\npub trait AsInner<Inner: ?Sized> {\n    fn as_inner(&self) -> &Inner;\n}\n\n/// A trait for viewing representations from std types\n#[doc(hidden)]\npub trait AsInnerMut<Inner: ?Sized> {\n    fn as_inner_mut(&mut self) -> &mut Inner;\n}\n\n/// A trait for extracting representations from std types\n#[doc(hidden)]\npub trait IntoInner<Inner> {\n    fn into_inner(self) -> Inner;\n}\n\n/// A trait for creating std types from internal representations\n#[doc(hidden)]\npub trait FromInner<Inner> {\n    fn from_inner(inner: Inner) -> Self;\n}\n\n/// Enqueues a procedure to run when the main thread exits.\n///\n/// Currently these closures are only run once the main *Rust* thread exits.\n/// Once the `at_exit` handlers begin running, more may be enqueued, but not\n/// infinitely so. Eventually a handler registration will be forced to fail.\n///\n/// Returns `Ok` if the handler was successfully registered, meaning that the\n/// closure will be run once the main thread exits. Returns `Err` to indicate\n/// that the closure could not be registered, meaning that it is not scheduled\n/// to be run.\npub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n    if at_exit_imp::push(Box::new(f)) { Ok(()) } else { Err(()) }\n}\n\n/// One-time runtime cleanup.\npub fn cleanup() {\n}\n\n// Computes (value*numer)/denom without overflow, as long as both\n// (numer*denom) and the overall result fit into i64 (which is the case\n// for our time conversions).\n#[allow(dead_code)] // not used on all platforms\npub fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64 {\n}\n\n#[test]\nfn test_muldiv() {\n}\n}\nmod sys {\n//! Platform-dependent platform abstraction.\n//!\n//! The `std::sys` module is the abstracted interface through which\n//! `std` talks to the underlying operating system. It has different\n//! implementations for different operating system families, today\n//! just Unix and Windows, and initial support for Redox.\n//!\n//! The centralization of platform-specific code in this module is\n//! enforced by the \"platform abstraction layer\" tidy script in\n//! `tools/tidy/src/pal.rs`.\n//!\n//! This module is closely related to the platform-independent system\n//! integration code in `std::sys_common`. See that module's\n//! documentation for details.\n//!\n//! In the future it would be desirable for the independent\n//! implementations of this module to be extracted to their own crates\n//! that `std` can link to, thus enabling their implementation\n//! out-of-tree via crate replacement. Though due to the complex\n//! inter-dependencies within `std` that will be a challenging goal to\n//! achieve.\n\n#![allow(missing_debug_implementations)]\n\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"vxworks\")] {\n        mod vxworks;\n        pub use self::vxworks::*;\n    } else if #[cfg(unix)] {\n        mod unix;\n        pub use self::unix::*;\n    } else if #[cfg(windows)] {\n        mod windows;\n        pub use self::windows::*;\n    } else if #[cfg(target_os = \"cloudabi\")] {\n        mod cloudabi;\n        pub use self::cloudabi::*;\n    } else if #[cfg(target_os = \"hermit\")] {\n        mod hermit;\n        pub use self::hermit::*;\n    } else if #[cfg(target_os = \"wasi\")] {\n        mod wasi;\n        pub use self::wasi::*;\n    } else if #[cfg(target_arch = \"wasm32\")] {\n        mod wasm;\n        pub use self::wasm::*;\n    } else if #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] {\n        mod sgx;\n        pub use self::sgx::*;\n    } else {\n        compile_error!(\"libstd doesn't compile for this platform yet\");\n    }\n}\n\n// Import essential modules from both platforms when documenting. These are\n// then later used in the `std::os` module when documenting, for example,\n// Windows when we're compiling for Linux.\n\n#[cfg(doc)]\ncfg_if::cfg_if! {\n    if #[cfg(unix)] {\n        // On unix we'll document what's already available\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub use self::ext as unix_ext;\n    } else if #[cfg(any(target_os = \"cloudabi\",\n                        target_os = \"hermit\",\n                        target_arch = \"wasm32\",\n                        all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n        // On CloudABI and wasm right now the module below doesn't compile\n        // (missing things in `libc` which is empty) so just omit everything\n        // with an empty module\n        #[unstable(issue = \"none\", feature = \"std_internals\")]\n        #[allow(missing_docs)]\n        pub mod unix_ext {}\n    } else {\n        // On other platforms like Windows document the bare bones of unix\n        use crate::os::linux as platform;\n        #[path = \"unix/ext/mod.rs\"]\n        pub mod unix_ext;\n    }\n}\n\n#[cfg(doc)]\ncfg_if::cfg_if! {\n    if #[cfg(windows)] {\n        // On windows we'll just be documenting what's already available\n        #[allow(missing_docs)]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        pub use self::ext as windows_ext;\n    } else if #[cfg(any(target_os = \"cloudabi\",\n                        target_arch = \"wasm32\",\n                        all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n        // On CloudABI and wasm right now the shim below doesn't compile, so\n        // just omit it\n        #[unstable(issue = \"none\", feature = \"std_internals\")]\n        #[allow(missing_docs)]\n        pub mod windows_ext {}\n    } else {\n        // On all other platforms (aka linux/osx/etc) then pull in a \"minimal\"\n        // amount of windows goop which ends up compiling\n        #[macro_use]\n        #[path = \"windows/compat.rs\"]\n        mod compat;\n\n        #[path = \"windows/c.rs\"]\n        mod c;\n\n        #[path = \"windows/ext/mod.rs\"]\n        pub mod windows_ext;\n    }\n}\n}\n\npub mod alloc {\n//! Memory allocation APIs\n//!\n//! In a given program, the standard library has one “global” memory allocator\n//! that is used for example by `Box<T>` and `Vec<T>`.\n//!\n//! Currently the default global allocator is unspecified. Libraries, however,\n//! like `cdylib`s and `staticlib`s are guaranteed to use the [`System`] by\n//! default.\n//!\n//! [`System`]: struct.System.html\n//!\n//! # The `#[global_allocator]` attribute\n//!\n//! This attribute allows configuring the choice of global allocator.\n//! You can use this to implement a completely custom global allocator\n//! to route all default allocation requests to a custom object.\n//!\n//! ```rust\n//! use std::alloc::{GlobalAlloc, System, Layout};\n//!\n//! struct MyAllocator;\n//!\n//! unsafe impl GlobalAlloc for MyAllocator {\n//!     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n//!         System.alloc(layout)\n//!     }\n//!\n//!     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n//!         System.dealloc(ptr, layout)\n//!     }\n//! }\n//!\n//! #[global_allocator]\n//! static GLOBAL: MyAllocator = MyAllocator;\n//!\n//! fn main() {\n//!     // This `Vec` will allocate memory through `GLOBAL` above\n//!     let mut v = Vec::new();\n//!     v.push(1);\n//! }\n//! ```\n//!\n//! The attribute is used on a `static` item whose type implements the\n//! [`GlobalAlloc`] trait. This type can be provided by an external library:\n//!\n//! [`GlobalAlloc`]: ../../core/alloc/trait.GlobalAlloc.html\n//!\n//! ```rust,ignore (demonstrates crates.io usage)\n//! extern crate jemallocator;\n//!\n//! use jemallocator::Jemalloc;\n//!\n//! #[global_allocator]\n//! static GLOBAL: Jemalloc = Jemalloc;\n//!\n//! fn main() {}\n//! ```\n//!\n//! The `#[global_allocator]` can only be used once in a crate\n//! or its recursive dependencies.\n\n#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n\nuse core::ptr::NonNull;\nuse core::sync::atomic::{AtomicPtr, Ordering};\nuse core::{mem, ptr};\n\nuse crate::sys_common::util::dumb_print;\n\n#[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n#[doc(inline)]\npub use alloc_crate::alloc::*;\n\n/// The default memory allocator provided by the operating system.\n///\n/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n/// plus related functions.\n///\n/// This type implements the `GlobalAlloc` trait and Rust programs by default\n/// work as if they had this definition:\n///\n/// ```rust\n/// use std::alloc::System;\n///\n/// #[global_allocator]\n/// static A: System = System;\n///\n/// fn main() {\n///     let a = Box::new(4); // Allocates from the system allocator.\n///     println!(\"{}\", a);\n/// }\n/// ```\n///\n/// You can also define your own wrapper around `System` if you'd like, such as\n/// keeping track of the number of all bytes allocated:\n///\n/// ```rust\n/// use std::alloc::{System, GlobalAlloc, Layout};\n/// use std::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n///\n/// struct Counter;\n///\n/// static ALLOCATED: AtomicUsize = AtomicUsize::new(0);\n///\n/// unsafe impl GlobalAlloc for Counter {\n///     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n///         let ret = System.alloc(layout);\n///         if !ret.is_null() {\n///             ALLOCATED.fetch_add(layout.size(), SeqCst);\n///         }\n///         return ret\n///     }\n///\n///     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n///         System.dealloc(ptr, layout);\n///         ALLOCATED.fetch_sub(layout.size(), SeqCst);\n///     }\n/// }\n///\n/// #[global_allocator]\n/// static A: Counter = Counter;\n///\n/// fn main() {\n///     println!(\"allocated bytes before main: {}\", ALLOCATED.load(SeqCst));\n/// }\n/// ```\n///\n/// It can also be used directly to allocate memory independently of whatever\n/// global allocator has been selected for a Rust program. For example if a Rust\n/// program opts in to using jemalloc as the global allocator, `System` will\n/// still allocate memory using `malloc` and `HeapAlloc`.\n#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n#[derive(Debug, Default, Copy, Clone)]\npub struct System;\n\n// The Alloc impl just forwards to the GlobalAlloc impl, which is in `std::sys::*::alloc`.\n#[unstable(feature = \"allocator_api\", issue = \"32838\")]\nunsafe impl Alloc for System {\n}\n\nstatic HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n\n/// Registers a custom allocation error hook, replacing any that was previously registered.\n///\n/// The allocation error hook is invoked when an infallible memory allocation fails, before\n/// the runtime aborts. The default hook prints a message to standard error,\n/// but this behavior can be customized with the [`set_alloc_error_hook`] and\n/// [`take_alloc_error_hook`] functions.\n///\n/// The hook is provided with a `Layout` struct which contains information\n/// about the allocation that failed.\n///\n/// The allocation error hook is a global resource.\n///\n/// [`set_alloc_error_hook`]: fn.set_alloc_error_hook.html\n/// [`take_alloc_error_hook`]: fn.take_alloc_error_hook.html\n#[unstable(feature = \"alloc_error_hook\", issue = \"51245\")]\npub fn set_alloc_error_hook(hook: fn(Layout)) {\n}\n\n/// Unregisters the current allocation error hook, returning it.\n///\n/// *See also the function [`set_alloc_error_hook`].*\n///\n/// If no custom hook is registered, the default hook will be returned.\n///\n/// [`set_alloc_error_hook`]: fn.set_alloc_error_hook.html\n#[unstable(feature = \"alloc_error_hook\", issue = \"51245\")]\npub fn take_alloc_error_hook() -> fn(Layout) {\n}\n\nfn default_alloc_error_hook(layout: Layout) {\n}\n\n#[cfg(not(test))]\n#[doc(hidden)]\n#[alloc_error_handler]\n#[unstable(feature = \"alloc_internals\", issue = \"none\")]\npub fn rust_oom(layout: Layout) -> ! {\n}\n\n#[cfg(not(test))]\n#[doc(hidden)]\n#[allow(unused_attributes)]\n#[unstable(feature = \"alloc_internals\", issue = \"none\")]\npub mod __default_lib_allocator {\n}\n}\n\n// Private support modules\nmod memchr {\n// Original implementation taken from rust-memchr.\n// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n\n/// A safe interface to `memchr`.\n///\n/// Returns the index corresponding to the first occurrence of `needle` in\n/// `haystack`, or `None` if one is not found.\n///\n/// memchr reduces to super-optimized machine code at around an order of\n/// magnitude faster than `haystack.iter().position(|&b| b == needle)`.\n/// (See benchmarks.)\n///\n/// # Examples\n///\n/// This shows how to find the first position of a byte in a byte string.\n///\n/// ```ignore (cannot-doctest-private-modules)\n/// use memchr::memchr;\n///\n/// let haystack = b\"the quick brown fox\";\n/// assert_eq!(memchr(b'k', haystack), Some(8));\n/// ```\n#[inline]\npub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n}\n\n/// A safe interface to `memrchr`.\n///\n/// Returns the index corresponding to the last occurrence of `needle` in\n/// `haystack`, or `None` if one is not found.\n///\n/// # Examples\n///\n/// This shows how to find the last position of a byte in a byte string.\n///\n/// ```ignore (cannot-doctest-private-modules)\n/// use memchr::memrchr;\n///\n/// let haystack = b\"the quick brown fox\";\n/// assert_eq!(memrchr(b'o', haystack), Some(17));\n/// ```\n#[inline]\npub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod panicking {\n//! Implementation of various bits and pieces of the `panic!` macro and\n//! associated runtime pieces.\n//!\n//! Specifically, this module contains the implementation of:\n//!\n//! * Panic hooks\n//! * Executing a panic up to doing the actual implementation\n//! * Shims around \"try\"\n\nuse core::panic::{BoxMeUp, Location, PanicInfo};\n\nuse crate::any::Any;\nuse crate::fmt;\nuse crate::intrinsics;\nuse crate::mem::{self, ManuallyDrop};\nuse crate::process;\nuse crate::raw;\nuse crate::sync::atomic::{AtomicBool, Ordering};\nuse crate::sys::stdio::panic_output;\nuse crate::sys_common::backtrace::{self, RustBacktrace};\nuse crate::sys_common::rwlock::RWLock;\nuse crate::sys_common::{thread_info, util};\nuse crate::thread;\n\n#[cfg(not(test))]\nuse crate::io::set_panic;\n// make sure to use the stderr output configured\n// by libtest in the real copy of std\n#[cfg(test)]\nuse realstd::io::set_panic;\n\n// Binary interface to the panic runtime that the standard library depends on.\n//\n// The standard library is tagged with `#![needs_panic_runtime]` (introduced in\n// RFC 1513) to indicate that it requires some other crate tagged with\n// `#![panic_runtime]` to exist somewhere. Each panic runtime is intended to\n// implement these symbols (with the same signatures) so we can get matched up\n// to them.\n//\n// One day this may look a little less ad-hoc with the compiler helping out to\n// hook up these functions, but it is not this day!\n#[allow(improper_ctypes)]\nextern \"C\" {\n}\n\n/// This function is called by the panic runtime if FFI code catches a Rust\n/// panic but doesn't rethrow it. We don't support this case since it messes\n/// with our panic count.\n#[cfg(not(test))]\n#[rustc_std_internal_symbol]\nextern \"C\" fn __rust_drop_panic() -> ! {\n}\n\n#[derive(Copy, Clone)]\nenum Hook {\n    Default,\n    Custom(*mut (dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send)),\n}\n\nstatic HOOK_LOCK: RWLock = RWLock::new();\nstatic mut HOOK: Hook = Hook::Default;\n\n/// Registers a custom panic hook, replacing any that was previously registered.\n///\n/// The panic hook is invoked when a thread panics, but before the panic runtime\n/// is invoked. As such, the hook will run with both the aborting and unwinding\n/// runtimes. The default hook prints a message to standard error and generates\n/// a backtrace if requested, but this behavior can be customized with the\n/// `set_hook` and [`take_hook`] functions.\n///\n/// [`take_hook`]: ./fn.take_hook.html\n///\n/// The hook is provided with a `PanicInfo` struct which contains information\n/// about the origin of the panic, including the payload passed to `panic!` and\n/// the source code location from which the panic originated.\n///\n/// The panic hook is a global resource.\n///\n/// # Panics\n///\n/// Panics if called from a panicking thread.\n///\n/// # Examples\n///\n/// The following will print \"Custom panic hook\":\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|_| {\n///     println!(\"Custom panic hook\");\n/// }));\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub fn set_hook(hook: Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send>) {\n}\n\n/// Unregisters the current panic hook, returning it.\n///\n/// *See also the function [`set_hook`].*\n///\n/// [`set_hook`]: ./fn.set_hook.html\n///\n/// If no custom hook is registered, the default hook will be returned.\n///\n/// # Panics\n///\n/// Panics if called from a panicking thread.\n///\n/// # Examples\n///\n/// The following will print \"Normal panic\":\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|_| {\n///     println!(\"Custom panic hook\");\n/// }));\n///\n/// let _ = panic::take_hook();\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub fn take_hook() -> Box<dyn Fn(&PanicInfo<'_>) + 'static + Sync + Send> {\n}\n\nfn default_hook(info: &PanicInfo<'_>) {\n}', {}\", name, msg, location);\n\n        static FIRST_PANIC: AtomicBool = AtomicBool::new(true);\n\n        match backtrace_env {\n            RustBacktrace::Print(format) => drop(backtrace::print(err, format)),\n            RustBacktrace::Disabled => {}\n            RustBacktrace::RuntimeDisabled => {\n                if FIRST_PANIC.swap(false, Ordering::SeqCst) {\n                    let _ = writeln!(\n                        err,\n                        \"note: run with `RUST_BACKTRACE=1` \\\n                                           environment variable to display a backtrace\"\n                    );\n                }\n            }\n        }\n    };\n\n    if let Some(mut local) = set_panic(None) {\n        // NB. In `cfg(test)` this uses the forwarding impl\n        // for `Box<dyn (::realstd::io::Write) + Send>`.\n        write(&mut local);\n        set_panic(Some(local));\n    } else if let Some(mut out) = panic_output() {\n        write(&mut out);\n    }\n}\n\n#[cfg(not(test))]\n#[doc(hidden)]\n#[unstable(feature = \"update_panic_count\", issue = \"none\")]\npub fn update_panic_count(amt: isize) -> usize {\n}\n\n#[cfg(test)]\npub use realstd::rt::update_panic_count;\n\n/// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\npub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>> {\n}\n\n/// Determines whether the current thread is unwinding because of panic.\npub fn panicking() -> bool {\n}\n\n/// The entry point for panicking with a formatted message.\n///\n/// This is designed to reduce the amount of code required at the call\n/// site as much as possible (so that `panic!()` has as low an impact\n/// on (e.g.) the inlining of other functions as possible), by moving\n/// the actual formatting into this shared place.\n#[unstable(feature = \"libstd_sys_internals\", reason = \"used by the panic! macro\", issue = \"none\")]\n#[cold]\n// If panic_immediate_abort, inline the abort call,\n// otherwise avoid inlining because of it is cold path.\n#[cfg_attr(not(feature = \"panic_immediate_abort\"), track_caller)]\n#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\npub fn begin_panic_fmt(msg: &fmt::Arguments<'_>) -> ! {\n}\n\n/// Entry point of panics from the libcore crate (`panic_impl` lang item).\n#[cfg_attr(not(test), panic_handler)]\n#[unwind(allowed)]\npub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n}\n\n/// This is the entry point of panicking for the non-format-string variants of\n/// panic!() and assert!(). In particular, this is the only entry point that supports\n/// arbitrary payloads, not just format strings.\n#[unstable(feature = \"libstd_sys_internals\", reason = \"used by the panic! macro\", issue = \"none\")]\n#[cfg_attr(not(test), lang = \"begin_panic\")]\n// lang item for CTFE panic support\n// never inline unless panic_immediate_abort to avoid code\n// bloat at the call sites as much as possible\n#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n#[cold]\n#[track_caller]\npub fn begin_panic<M: Any + Send>(msg: M, #[cfg(bootstrap)] _: &(&str, u32, u32)) -> ! {\n}\n\n/// Central point for dispatching panics.\n///\n/// Executes the primary logic for a panic, including checking for recursive\n/// panics, panic hooks, and finally dispatching to the panic runtime to either\n/// abort or unwind.\nfn rust_panic_with_hook(\n    payload: &mut dyn BoxMeUp,\n    message: Option<&fmt::Arguments<'_>>,\n    location: &Location<'_>,\n) -> ! {\n}\n\n/// This is the entry point for `resume_unwind`.\n/// It just forwards the payload to the panic runtime.\npub fn rust_panic_without_hook(payload: Box<dyn Any + Send>) -> ! {\n}\n\n/// An unmangled function (through `rustc_std_internal_symbol`) on which to slap\n/// yer breakpoints.\n#[inline(never)]\n#[cfg_attr(not(test), rustc_std_internal_symbol)]\nfn rust_panic(mut msg: &mut dyn BoxMeUp) -> ! {\n}\n}\n\n// The runtime entry point and a few unstable public functions used by the\n// compiler\npub mod rt {\n//! Runtime services\n//!\n//! The `rt` module provides a narrow set of runtime services,\n//! including the global heap (exported in `heap`) and unwinding and\n//! backtrace support. The APIs in this module are highly unstable,\n//! and should be considered as private implementation details for the\n//! time being.\n\n#![unstable(\n    feature = \"rt\",\n    reason = \"this public module should not exist and is highly likely \\\n              to disappear\",\n    issue = \"none\"\n)]\n#![doc(hidden)]\n\n// Re-export some of our utilities which are expected by other crates.\npub use crate::panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n\n// To reduce the generated code of the new `lang_start`, this function is doing\n// the real work.\n#[cfg(not(test))]\nfn lang_start_internal(\n    main: &(dyn Fn() -> i32 + Sync + crate::panic::RefUnwindSafe),\n    argc: isize,\n    argv: *const *const u8,\n) -> isize {\n}\n\n#[cfg(not(test))]\n#[lang = \"start\"]\nfn lang_start<T: crate::process::Termination + 'static>(\n    main: fn() -> T,\n    argc: isize,\n    argv: *const *const u8,\n) -> isize {\n}\n}\n\n// Pull in the `std_detect` crate directly into libstd. The contents of\n// `std_detect` are in a different repository: rust-lang/stdarch.\n//\n// `std_detect` depends on libstd, but the contents of this module are\n// set up in such a way that directly pulling it here works such that the\n// crate uses the this crate as its libstd.\n#[path = \"../stdarch/crates/std_detect/src/mod.rs\"]\n#[allow(missing_debug_implementations, missing_docs, dead_code)]\n#[unstable(feature = \"stdsimd\", issue = \"48556\")]\n#[cfg(not(test))]\nmod std_detect {\n}\n\n#[doc(hidden)]\n#[unstable(feature = \"stdsimd\", issue = \"48556\")]\n#[cfg(not(test))]\npub use std_detect::detect;\n\n// Re-export macros defined in libcore.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated, deprecated_in_future)]\npub use core::{\n    // Stable\n    assert_eq,\n    assert_ne,\n    debug_assert,\n    debug_assert_eq,\n    debug_assert_ne,\n    // Unstable\n    matches,\n    r#try,\n    todo,\n    unimplemented,\n    unreachable,\n    write,\n    writeln,\n};\n\n// Re-export built-in macros defined through libcore.\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\npub use core::{\n    // Unstable\n    asm,\n    // Stable\n    assert,\n    cfg,\n    column,\n    compile_error,\n    concat,\n    concat_idents,\n    env,\n    file,\n    format_args,\n    format_args_nl,\n    global_asm,\n    include,\n    include_bytes,\n    include_str,\n    line,\n    log_syntax,\n    module_path,\n    option_env,\n    stringify,\n    trace_macros,\n};\n\n// Include a number of private modules that exist solely to provide\n// the rustdoc documentation for primitive types. Using `include!`\n// because rustdoc only looks for these modules at the crate level.\ninclude!(\"primitive_docs.rs\");\n\n// Include a number of private modules that exist solely to provide\n// the rustdoc documentation for the existing keywords. Using `include!`\n// because rustdoc only looks for these modules at the crate level.\ninclude!(\"keyword_docs.rs\");\n"],[2,"//! # The Rust Core Library\n//!\n//! The Rust Core Library is the dependency-free[^free] foundation of [The\n//! Rust Standard Library](../std/index.html). It is the portable glue\n//! between the language and its libraries, defining the intrinsic and\n//! primitive building blocks of all Rust code. It links to no\n//! upstream libraries, no system libraries, and no libc.\n//!\n//! [^free]: Strictly speaking, there are some symbols which are needed but\n//!          they aren't always necessary.\n//!\n//! The core library is *minimal*: it isn't even aware of heap allocation,\n//! nor does it provide concurrency or I/O. These things require\n//! platform integration, and this library is platform-agnostic.\n//!\n//! # How to use the core library\n//!\n//! Please note that all of these details are currently not considered stable.\n//!\n// FIXME: Fill me in with more detail when the interface settles\n//! This library is built on the assumption of a few existing symbols:\n//!\n//! * `memcpy`, `memcmp`, `memset` - These are core memory routines which are\n//!   often generated by LLVM. Additionally, this library can make explicit\n//!   calls to these functions. Their signatures are the same as found in C.\n//!   These functions are often provided by the system libc, but can also be\n//!   provided by the [compiler-builtins crate](https://crates.io/crates/compiler_builtins).\n//!\n//! * `rust_begin_panic` - This function takes four arguments, a\n//!   `fmt::Arguments`, a `&'static str`, and two `u32`'s. These four arguments\n//!   dictate the panic message, the file at which panic was invoked, and the\n//!   line and column inside the file. It is up to consumers of this core\n//!   library to define this panic function; it is only required to never\n//!   return. This requires a `lang` attribute named `panic_impl`.\n//!\n//! * `rust_eh_personality` - is used by the failure mechanisms of the\n//!    compiler. This is often mapped to GCC's personality function, but crates\n//!    which do not trigger a panic can be assured that this function is never\n//!    called. The `lang` attribute is called `eh_personality`.\n\n// Since libcore defines many fundamental lang items, all tests live in a\n// separate crate, libcoretest, to avoid bizarre issues.\n//\n// Here we explicitly #[cfg]-out this whole crate when testing. If we don't do\n// this, both the generated test artifact and the linked libtest (which\n// transitively includes libcore) will both define the same set of lang items,\n// and this will cause the E0152 \"found duplicate lang item\" error. See\n// discussion in #50466 for details.\n//\n// This cfg won't affect doc tests.\n#![cfg(not(test))]\n#![stable(feature = \"core\", since = \"1.6.0\")]\n#![doc(\n    html_root_url = \"https://doc.rust-lang.org/nightly/\",\n    html_playground_url = \"https://play.rust-lang.org/\",\n    issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n    test(no_crate_inject, attr(deny(warnings))),\n    test(attr(allow(dead_code, deprecated, unused_variables, unused_mut)))\n)]\n#![no_core]\n#![warn(deprecated_in_future)]\n#![warn(missing_docs)]\n#![warn(missing_debug_implementations)]\n#![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n#![allow(explicit_outlives_requirements)]\n#![allow(incomplete_features)]\n#![feature(allow_internal_unstable)]\n#![feature(arbitrary_self_types)]\n#![feature(asm)]\n#![feature(bound_cloned)]\n#![feature(cfg_target_has_atomic)]\n#![feature(concat_idents)]\n#![feature(const_alloc_layout)]\n#![feature(const_if_match)]\n#![feature(const_panic)]\n#![feature(const_fn_union)]\n#![feature(const_generics)]\n#![feature(const_ptr_offset_from)]\n#![feature(const_result)]\n#![feature(const_type_name)]\n#![feature(custom_inner_attributes)]\n#![feature(decl_macro)]\n#![feature(doc_cfg)]\n#![feature(doc_spotlight)]\n#![feature(extern_types)]\n#![feature(fundamental)]\n#![feature(intrinsics)]\n#![feature(try_find)]\n#![feature(is_sorted)]\n#![feature(iter_once_with)]\n#![feature(lang_items)]\n#![feature(link_llvm_intrinsics)]\n#![feature(never_type)]\n#![feature(nll)]\n#![feature(exhaustive_patterns)]\n#![feature(no_core)]\n#![feature(optin_builtin_traits)]\n#![feature(prelude_import)]\n#![feature(repr_simd, platform_intrinsics)]\n#![feature(rustc_attrs)]\n#![feature(simd_ffi)]\n#![feature(specialization)]\n#![feature(staged_api)]\n#![feature(std_internals)]\n#![feature(stmt_expr_attributes)]\n#![feature(track_caller)]\n#![feature(transparent_unions)]\n#![feature(unboxed_closures)]\n#![feature(unsized_locals)]\n#![feature(untagged_unions)]\n#![feature(unwind_attributes)]\n#![feature(doc_alias)]\n#![feature(mmx_target_feature)]\n#![feature(tbm_target_feature)]\n#![feature(sse4a_target_feature)]\n#![feature(arm_target_feature)]\n#![feature(powerpc_target_feature)]\n#![feature(mips_target_feature)]\n#![feature(aarch64_target_feature)]\n#![feature(wasm_target_feature)]\n#![feature(avx512_target_feature)]\n#![feature(cmpxchg16b_target_feature)]\n#![feature(rtm_target_feature)]\n#![feature(f16c_target_feature)]\n#![feature(hexagon_target_feature)]\n#![feature(const_int_conversion)]\n#![feature(const_transmute)]\n#![feature(structural_match)]\n#![feature(abi_unadjusted)]\n#![feature(adx_target_feature)]\n#![feature(maybe_uninit_slice)]\n#![feature(external_doc)]\n#![feature(associated_type_bounds)]\n#![feature(const_type_id)]\n#![feature(const_caller_location)]\n#![cfg_attr(bootstrap, feature(slice_patterns))]\n\n#[prelude_import]\n#[allow(unused)]\nuse prelude::v1::*;\n\n#[cfg(not(test))] // See #65860\n#[macro_use]\nmod macros {\n#[doc(include = \"panic.md\")]\n#[macro_export]\n#[allow_internal_unstable(core_panic, track_caller)]\n#[stable(feature = \"core\", since = \"1.6.0\")]\nmacro_rules! panic {\n    () => (\n        $crate::panic!(\"explicit panic\")\n    );\n    ($msg:expr) => (\n        $crate::panicking::panic($msg)\n    );\n    ($msg:expr,) => (\n        $crate::panic!($msg)\n    );\n    ($fmt:expr, $($arg:tt)+) => (\n        $crate::panicking::panic_fmt(\n            $crate::format_args!($fmt, $($arg)+),\n            $crate::panic::Location::caller(),\n        )\n    );\n}\n\n/// Asserts that two expressions are equal to each other (using [`PartialEq`]).\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Like [`assert!`], this macro has a second form, where a custom\n/// panic message can be provided.\n///\n/// [`PartialEq`]: cmp/trait.PartialEq.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 1 + 2;\n/// assert_eq!(a, b);\n///\n/// assert_eq!(a, b, \"we are testing addition with {} and {}\", a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! assert_eq {\n    ($left:expr, $right:expr) => ({\n        match (&$left, &$right) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    panic!(r#\"assertion failed: `(left == right)`\n  left: `{:?}`,\n right: `{:?}`\"#, &*left_val, &*right_val)\n                }\n            }\n        }\n    });\n    ($left:expr, $right:expr,) => ({\n        $crate::assert_eq!($left, $right)\n    });\n    ($left:expr, $right:expr, $($arg:tt)+) => ({\n        match (&($left), &($right)) {\n            (left_val, right_val) => {\n                if !(*left_val == *right_val) {\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    panic!(r#\"assertion failed: `(left == right)`\n  left: `{:?}`,\n right: `{:?}`: {}\"#, &*left_val, &*right_val,\n                           $crate::format_args!($($arg)+))\n                }\n            }\n        }\n    });\n}\n\n/// Asserts that two expressions are not equal to each other (using [`PartialEq`]).\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Like [`assert!`], this macro has a second form, where a custom\n/// panic message can be provided.\n///\n/// [`PartialEq`]: cmp/trait.PartialEq.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 2;\n/// assert_ne!(a, b);\n///\n/// assert_ne!(a, b, \"we are testing that the values are not equal\");\n/// ```\n#[macro_export]\n#[stable(feature = \"assert_ne\", since = \"1.13.0\")]\nmacro_rules! assert_ne {\n    ($left:expr, $right:expr) => ({\n        match (&$left, &$right) {\n            (left_val, right_val) => {\n                if *left_val == *right_val {\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    panic!(r#\"assertion failed: `(left != right)`\n  left: `{:?}`,\n right: `{:?}`\"#, &*left_val, &*right_val)\n                }\n            }\n        }\n    });\n    ($left:expr, $right:expr,) => {\n        $crate::assert_ne!($left, $right)\n    };\n    ($left:expr, $right:expr, $($arg:tt)+) => ({\n        match (&($left), &($right)) {\n            (left_val, right_val) => {\n                if *left_val == *right_val {\n                    // The reborrows below are intentional. Without them, the stack slot for the\n                    // borrow is initialized even before the values are compared, leading to a\n                    // noticeable slow down.\n                    panic!(r#\"assertion failed: `(left != right)`\n  left: `{:?}`,\n right: `{:?}`: {}\"#, &*left_val, &*right_val,\n                           $crate::format_args!($($arg)+))\n                }\n            }\n        }\n    });\n}\n\n/// Asserts that a boolean expression is `true` at runtime.\n///\n/// This will invoke the [`panic!`] macro if the provided expression cannot be\n/// evaluated to `true` at runtime.\n///\n/// Like [`assert!`], this macro also has a second version, where a custom panic\n/// message can be provided.\n///\n/// # Uses\n///\n/// Unlike [`assert!`], `debug_assert!` statements are only enabled in non\n/// optimized builds by default. An optimized build will not execute\n/// `debug_assert!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development. The result of expanding `debug_assert!` is always type checked.\n///\n/// An unchecked assertion allows a program in an inconsistent state to keep\n/// running, which might have unexpected consequences but does not introduce\n/// unsafety as long as this only happens in safe code. The performance cost\n/// of assertions, is however, not measurable in general. Replacing [`assert!`]\n/// with `debug_assert!` is thus only encouraged after thorough profiling, and\n/// more importantly, only in safe code!\n///\n/// [`panic!`]: macro.panic.html\n/// [`assert!`]: macro.assert.html\n///\n/// # Examples\n///\n/// ```\n/// // the panic message for these assertions is the stringified value of the\n/// // expression given.\n/// debug_assert!(true);\n///\n/// fn some_expensive_computation() -> bool { true } // a very simple function\n/// debug_assert!(some_expensive_computation());\n///\n/// // assert with a custom message\n/// let x = true;\n/// debug_assert!(x, \"x wasn't true!\");\n///\n/// let a = 3; let b = 27;\n/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! debug_assert {\n    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert!($($arg)*); })\n}\n\n/// Asserts that two expressions are equal to each other.\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Unlike [`assert_eq!`], `debug_assert_eq!` statements are only enabled in non\n/// optimized builds by default. An optimized build will not execute\n/// `debug_assert_eq!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert_eq!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development. The result of expanding `debug_assert_eq!` is always type checked.\n///\n/// [`assert_eq!`]: ../std/macro.assert_eq.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 1 + 2;\n/// debug_assert_eq!(a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! debug_assert_eq {\n    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_eq!($($arg)*); })\n}\n\n/// Asserts that two expressions are not equal to each other.\n///\n/// On panic, this macro will print the values of the expressions with their\n/// debug representations.\n///\n/// Unlike [`assert_ne!`], `debug_assert_ne!` statements are only enabled in non\n/// optimized builds by default. An optimized build will not execute\n/// `debug_assert_ne!` statements unless `-C debug-assertions` is passed to the\n/// compiler. This makes `debug_assert_ne!` useful for checks that are too\n/// expensive to be present in a release build but may be helpful during\n/// development. The result of expanding `debug_assert_ne!` is always type checked.\n///\n/// [`assert_ne!`]: ../std/macro.assert_ne.html\n///\n/// # Examples\n///\n/// ```\n/// let a = 3;\n/// let b = 2;\n/// debug_assert_ne!(a, b);\n/// ```\n#[macro_export]\n#[stable(feature = \"assert_ne\", since = \"1.13.0\")]\nmacro_rules! debug_assert_ne {\n    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n}\n\n/// Returns whether the given expression matches any of the given patterns.\n///\n/// Like in a `match` expression, the pattern can be optionally followed by `if`\n/// and a guard expression that has access to names bound by the pattern.\n///\n/// # Examples\n///\n/// ```\n/// let foo = 'f';\n/// assert!(matches!(foo, 'A'..='Z' | 'a'..='z'));\n///\n/// let bar = Some(4);\n/// assert!(matches!(bar, Some(x) if x > 2));\n/// ```\n#[macro_export]\n#[stable(feature = \"matches_macro\", since = \"1.42.0\")]\nmacro_rules! matches {\n    ($expression:expr, $( $pattern:pat )|+ $( if $guard: expr )?) => {\n        match $expression {\n            $( $pattern )|+ $( if $guard )? => true,\n            _ => false\n        }\n    }\n}\n\n/// Unwraps a result or propagates its error.\n///\n/// The `?` operator was added to replace `try!` and should be used instead.\n/// Furthermore, `try` is a reserved word in Rust 2018, so if you must use\n/// it, you will need to use the [raw-identifier syntax][ris]: `r#try`.\n///\n/// [ris]: https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html\n///\n/// `try!` matches the given [`Result`]. In case of the `Ok` variant, the\n/// expression has the value of the wrapped value.\n///\n/// In case of the `Err` variant, it retrieves the inner error. `try!` then\n/// performs conversion using `From`. This provides automatic conversion\n/// between specialized errors and more general ones. The resulting\n/// error is then immediately returned.\n///\n/// Because of the early return, `try!` can only be used in functions that\n/// return [`Result`].\n///\n/// [`Result`]: ../std/result/enum.Result.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io;\n/// use std::fs::File;\n/// use std::io::prelude::*;\n///\n/// enum MyError {\n///     FileWriteError\n/// }\n///\n/// impl From<io::Error> for MyError {\n///     fn from(e: io::Error) -> MyError {\n///         MyError::FileWriteError\n///     }\n/// }\n///\n/// // The preferred method of quick returning Errors\n/// fn write_to_file_question() -> Result<(), MyError> {\n///     let mut file = File::create(\"my_best_friends.txt\")?;\n///     file.write_all(b\"This is a list of my best friends.\")?;\n///     Ok(())\n/// }\n///\n/// // The previous method of quick returning Errors\n/// fn write_to_file_using_try() -> Result<(), MyError> {\n///     let mut file = r#try!(File::create(\"my_best_friends.txt\"));\n///     r#try!(file.write_all(b\"This is a list of my best friends.\"));\n///     Ok(())\n/// }\n///\n/// // This is equivalent to:\n/// fn write_to_file_using_match() -> Result<(), MyError> {\n///     let mut file = r#try!(File::create(\"my_best_friends.txt\"));\n///     match file.write_all(b\"This is a list of my best friends.\") {\n///         Ok(v) => v,\n///         Err(e) => return Err(From::from(e)),\n///     }\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(since = \"1.39.0\", reason = \"use the `?` operator instead\")]\n#[doc(alias = \"?\")]\nmacro_rules! r#try {\n    ($expr:expr) => {\n        match $expr {\n            $crate::result::Result::Ok(val) => val,\n            $crate::result::Result::Err(err) => {\n                return $crate::result::Result::Err($crate::convert::From::from(err));\n            }\n        }\n    };\n    ($expr:expr,) => {\n        $crate::r#try!($expr)\n    };\n}\n\n/// Writes formatted data into a buffer.\n///\n/// This macro accepts a format string, a list of arguments, and a 'writer'. Arguments will be\n/// formatted according to the specified format string and the result will be passed to the writer.\n/// The writer may be any value with a `write_fmt` method; generally this comes from an\n/// implementation of either the [`std::fmt::Write`] or the [`std::io::Write`] trait. The macro\n/// returns whatever the `write_fmt` method returns; commonly a [`std::fmt::Result`], or an\n/// [`io::Result`].\n///\n/// See [`std::fmt`] for more information on the format string syntax.\n///\n/// [`std::fmt`]: ../std/fmt/index.html\n/// [`std::fmt::Write`]: ../std/fmt/trait.Write.html\n/// [`std::io::Write`]: ../std/io/trait.Write.html\n/// [`std::fmt::Result`]: ../std/fmt/type.Result.html\n/// [`io::Result`]: ../std/io/type.Result.html\n///\n/// # Examples\n///\n/// ```\n/// use std::io::Write;\n///\n/// fn main() -> std::io::Result<()> {\n///     let mut w = Vec::new();\n///     write!(&mut w, \"test\")?;\n///     write!(&mut w, \"formatted {}\", \"arguments\")?;\n///\n///     assert_eq!(w, b\"testformatted arguments\");\n///     Ok(())\n/// }\n/// ```\n///\n/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n/// implementing either, as objects do not typically implement both. However, the module must\n/// import the traits qualified so their names do not conflict:\n///\n/// ```\n/// use std::fmt::Write as FmtWrite;\n/// use std::io::Write as IoWrite;\n///\n/// fn main() -> Result<(), Box<dyn std::error::Error>> {\n///     let mut s = String::new();\n///     let mut v = Vec::new();\n///\n///     write!(&mut s, \"{} {}\", \"abc\", 123)?; // uses fmt::Write::write_fmt\n///     write!(&mut v, \"s = {:?}\", s)?; // uses io::Write::write_fmt\n///     assert_eq!(v, b\"s = \\\"abc 123\\\"\");\n///     Ok(())\n/// }\n/// ```\n///\n/// Note: This macro can be used in `no_std` setups as well.\n/// In a `no_std` setup you are responsible for the implementation details of the components.\n///\n/// ```no_run\n/// # extern crate core;\n/// use core::fmt::Write;\n///\n/// struct Example;\n///\n/// impl Write for Example {\n///     fn write_str(&mut self, _s: &str) -> core::fmt::Result {\n///          unimplemented!();\n///     }\n/// }\n///\n/// let mut m = Example{};\n/// write!(&mut m, \"Hello World\").expect(\"Not written\");\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! write {\n    ($dst:expr, $($arg:tt)*) => ($dst.write_fmt($crate::format_args!($($arg)*)))\n}\n\n/// Write formatted data into a buffer, with a newline appended.\n///\n/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n///\n/// For more information, see [`write!`]. For information on the format string syntax, see\n/// [`std::fmt`].\n///\n/// [`write!`]: macro.write.html\n/// [`std::fmt`]: ../std/fmt/index.html\n///\n///\n/// # Examples\n///\n/// ```\n/// use std::io::{Write, Result};\n///\n/// fn main() -> Result<()> {\n///     let mut w = Vec::new();\n///     writeln!(&mut w)?;\n///     writeln!(&mut w, \"test\")?;\n///     writeln!(&mut w, \"formatted {}\", \"arguments\")?;\n///\n///     assert_eq!(&w[..], \"\\ntest\\nformatted arguments\\n\".as_bytes());\n///     Ok(())\n/// }\n/// ```\n///\n/// A module can import both `std::fmt::Write` and `std::io::Write` and call `write!` on objects\n/// implementing either, as objects do not typically implement both. However, the module must\n/// import the traits qualified so their names do not conflict:\n///\n/// ```\n/// use std::fmt::Write as FmtWrite;\n/// use std::io::Write as IoWrite;\n///\n/// fn main() -> Result<(), Box<dyn std::error::Error>> {\n///     let mut s = String::new();\n///     let mut v = Vec::new();\n///\n///     writeln!(&mut s, \"{} {}\", \"abc\", 123)?; // uses fmt::Write::write_fmt\n///     writeln!(&mut v, \"s = {:?}\", s)?; // uses io::Write::write_fmt\n///     assert_eq!(v, b\"s = \\\"abc 123\\\\n\\\"\\n\");\n///     Ok(())\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(format_args_nl)]\nmacro_rules! writeln {\n    ($dst:expr) => (\n        $crate::write!($dst, \"\\n\")\n    );\n    ($dst:expr,) => (\n        $crate::writeln!($dst)\n    );\n    ($dst:expr, $($arg:tt)*) => (\n        $dst.write_fmt($crate::format_args_nl!($($arg)*))\n    );\n}\n\n/// Indicates unreachable code.\n///\n/// This is useful any time that the compiler can't determine that some code is unreachable. For\n/// example:\n///\n/// * Match arms with guard conditions.\n/// * Loops that dynamically terminate.\n/// * Iterators that dynamically terminate.\n///\n/// If the determination that the code is unreachable proves incorrect, the\n/// program immediately terminates with a [`panic!`].\n///\n/// The unsafe counterpart of this macro is the [`unreachable_unchecked`] function, which\n/// will cause undefined behavior if the code is reached.\n///\n/// [`panic!`]: ../std/macro.panic.html\n/// [`unreachable_unchecked`]: ../std/hint/fn.unreachable_unchecked.html\n/// [`std::hint`]: ../std/hint/index.html\n///\n/// # Panics\n///\n/// This will always [`panic!`]\n///\n/// [`panic!`]: ../std/macro.panic.html\n///\n/// # Examples\n///\n/// Match arms:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// fn foo(x: Option<i32>) {\n///     match x {\n///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n///         Some(n) if n <  0 => println!(\"Some(Negative)\"),\n///         Some(_)           => unreachable!(), // compile error if commented out\n///         None              => println!(\"None\")\n///     }\n/// }\n/// ```\n///\n/// Iterators:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n///     for i in 0.. {\n///         if 3*i < i { panic!(\"u32 overflow\"); }\n///         if x < 3*i { return i-1; }\n///     }\n///     unreachable!();\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! unreachable {\n    () => ({\n        panic!(\"internal error: entered unreachable code\")\n    });\n    ($msg:expr) => ({\n        $crate::unreachable!(\"{}\", $msg)\n    });\n    ($msg:expr,) => ({\n        $crate::unreachable!($msg)\n    });\n    ($fmt:expr, $($arg:tt)*) => ({\n        panic!($crate::concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n    });\n}\n\n/// Indicates unimplemented code by panicking with a message of \"not implemented\".\n///\n/// This allows your code to type-check, which is useful if you are prototyping or\n/// implementing a trait that requires multiple methods which you don't plan of using all of.\n///\n/// The difference between `unimplemented!` and [`todo!`](macro.todo.html) is that while `todo!`\n/// conveys an intent of implementing the functionality later and the message is \"not yet\n/// implemented\", `unimplemented!` makes no such claims. Its message is \"not implemented\".\n/// Also some IDEs will mark `todo!`s.\n///\n/// # Panics\n///\n/// This will always [panic!](macro.panic.html) because `unimplemented!` is just a\n/// shorthand for `panic!` with a fixed, specific message.\n///\n/// Like `panic!`, this macro has a second form for displaying custom values.\n///\n/// # Examples\n///\n/// Say we have a trait `Foo`:\n///\n/// ```\n/// trait Foo {\n///     fn bar(&self) -> u8;\n///     fn baz(&self);\n///     fn qux(&self) -> Result<u64, ()>;\n/// }\n/// ```\n///\n/// We want to implement `Foo` for 'MyStruct', but for some reason it only makes sense\n/// to implement the `bar()` function. `baz()` and `qux()` will still need to be defined\n/// in our implementation of `Foo`, but we can use `unimplemented!` in their definitions\n/// to allow our code to compile.\n///\n/// We still want to have our program stop running if the unimplemented methods are\n/// reached.\n///\n/// ```\n/// # trait Foo {\n/// #     fn bar(&self) -> u8;\n/// #     fn baz(&self);\n/// #     fn qux(&self) -> Result<u64, ()>;\n/// # }\n/// struct MyStruct;\n///\n/// impl Foo for MyStruct {\n///     fn bar(&self) -> u8 {\n///         1 + 1\n///     }\n///\n///     fn baz(&self) {\n///         // It makes no sense to `baz` a `MyStruct`, so we have no logic here\n///         // at all.\n///         // This will display \"thread 'main' panicked at 'not implemented'\".\n///         unimplemented!();\n///     }\n///\n///     fn qux(&self) -> Result<u64, ()> {\n///         // We have some logic here,\n///         // We can add a message to unimplemented! to display our omission.\n///         // This will display:\n///         // \"thread 'main' panicked at 'not implemented: MyStruct isn't quxable'\".\n///         unimplemented!(\"MyStruct isn't quxable\");\n///     }\n/// }\n///\n/// fn main() {\n///     let s = MyStruct;\n///     s.bar();\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! unimplemented {\n    () => (panic!(\"not implemented\"));\n    ($($arg:tt)+) => (panic!(\"not implemented: {}\", $crate::format_args!($($arg)+)));\n}\n\n/// Indicates unfinished code.\n///\n/// This can be useful if you are prototyping and are just looking to have your\n/// code typecheck.\n///\n/// The difference between [`unimplemented!`] and `todo!` is that while `todo!` conveys\n/// an intent of implementing the functionality later and the message is \"not yet\n/// implemented\", `unimplemented!` makes no such claims. Its message is \"not implemented\".\n/// Also some IDEs will mark `todo!`s.\n///\n/// [`unimplemented!`]: macro.unimplemented.html\n///\n/// # Panics\n///\n/// This will always [panic!](macro.panic.html)\n///\n/// # Examples\n///\n/// Here's an example of some in-progress code. We have a trait `Foo`:\n///\n/// ```\n/// trait Foo {\n///     fn bar(&self);\n///     fn baz(&self);\n/// }\n/// ```\n///\n/// We want to implement `Foo` on one of our types, but we also want to work on\n/// just `bar()` first. In order for our code to compile, we need to implement\n/// `baz()`, so we can use `todo!`:\n///\n/// ```\n/// # trait Foo {\n/// #     fn bar(&self);\n/// #     fn baz(&self);\n/// # }\n/// struct MyStruct;\n///\n/// impl Foo for MyStruct {\n///     fn bar(&self) {\n///         // implementation goes here\n///     }\n///\n///     fn baz(&self) {\n///         // let's not worry about implementing baz() for now\n///         todo!();\n///     }\n/// }\n///\n/// fn main() {\n///     let s = MyStruct;\n///     s.bar();\n///\n///     // we aren't even using baz(), so this is fine.\n/// }\n/// ```\n#[macro_export]\n#[stable(feature = \"todo_macro\", since = \"1.40.0\")]\nmacro_rules! todo {\n    () => (panic!(\"not yet implemented\"));\n    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", $crate::format_args!($($arg)+)));\n}\n\n/// Definitions of built-in macros.\n///\n/// Most of the macro properties (stability, visibility, etc.) are taken from the source code here,\n/// with exception of expansion functions transforming macro inputs into outputs,\n/// those functions are provided by the compiler.\npub(crate) mod builtin {\n\n    /// Causes compilation to fail with the given error message when encountered.\n    ///\n    /// This macro should be used when a crate uses a conditional compilation strategy to provide\n    /// better error messages for erroneous conditions. It's the compiler-level form of [`panic!`],\n    /// but emits an error during *compilation* rather than at *runtime*.\n    ///\n    /// # Examples\n    ///\n    /// Two such examples are macros and `#[cfg]` environments.\n    ///\n    /// Emit better compiler error if a macro is passed invalid values. Without the final branch,\n    /// the compiler would still emit an error, but the error's message would not mention the two\n    /// valid values.\n    ///\n    /// ```compile_fail\n    /// macro_rules! give_me_foo_or_bar {\n    ///     (foo) => {};\n    ///     (bar) => {};\n    ///     ($x:ident) => {\n    ///         compile_error!(\"This macro only accepts `foo` or `bar`\");\n    ///     }\n    /// }\n    ///\n    /// give_me_foo_or_bar!(neither);\n    /// // ^ will fail at compile time with message \"This macro only accepts `foo` or `bar`\"\n    /// ```\n    ///\n    /// Emit compiler error if one of a number of features isn't available.\n    ///\n    /// ```compile_fail\n    /// #[cfg(not(any(feature = \"foo\", feature = \"bar\")))]\n    /// compile_error!(\"Either feature \\\"foo\\\" or \\\"bar\\\" must be enabled for this crate.\");\n    /// ```\n    ///\n    /// [`panic!`]: ../std/macro.panic.html\n    #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! compile_error {\n        ($msg:expr) => {{ /* compiler built-in */ }};\n        ($msg:expr,) => {{ /* compiler built-in */ }};\n    }\n\n    /// Constructs parameters for the other string-formatting macros.\n    ///\n    /// This macro functions by taking a formatting string literal containing\n    /// `{}` for each additional argument passed. `format_args!` prepares the\n    /// additional parameters to ensure the output can be interpreted as a string\n    /// and canonicalizes the arguments into a single type. Any value that implements\n    /// the [`Display`] trait can be passed to `format_args!`, as can any\n    /// [`Debug`] implementation be passed to a `{:?}` within the formatting string.\n    ///\n    /// This macro produces a value of type [`fmt::Arguments`]. This value can be\n    /// passed to the macros within [`std::fmt`] for performing useful redirection.\n    /// All other formatting macros ([`format!`], [`write!`], [`println!`], etc) are\n    /// proxied through this one. `format_args!`, unlike its derived macros, avoids\n    /// heap allocations.\n    ///\n    /// You can use the [`fmt::Arguments`] value that `format_args!` returns\n    /// in `Debug` and `Display` contexts as seen below. The example also shows\n    /// that `Debug` and `Display` format to the same thing: the interpolated\n    /// format string in `format_args!`.\n    ///\n    /// ```rust\n    /// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n    /// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n    /// assert_eq!(\"1 foo 2\", display);\n    /// assert_eq!(display, debug);\n    /// ```\n    ///\n    /// For more information, see the documentation in [`std::fmt`].\n    ///\n    /// [`Display`]: ../std/fmt/trait.Display.html\n    /// [`Debug`]: ../std/fmt/trait.Debug.html\n    /// [`fmt::Arguments`]: ../std/fmt/struct.Arguments.html\n    /// [`std::fmt`]: ../std/fmt/index.html\n    /// [`format!`]: ../std/macro.format.html\n    /// [`write!`]: ../std/macro.write.html\n    /// [`println!`]: ../std/macro.println.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n    /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow_internal_unstable(fmt_internals)]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! format_args {\n        ($fmt:expr) => {{ /* compiler built-in */ }};\n        ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};\n    }\n\n    /// Same as `format_args`, but adds a newline in the end.\n    #[unstable(\n        feature = \"format_args_nl\",\n        issue = \"none\",\n        reason = \"`format_args_nl` is only for internal \\\n                  language use and is subject to change\"\n    )]\n    #[allow_internal_unstable(fmt_internals)]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! format_args_nl {\n        ($fmt:expr) => {{ /* compiler built-in */ }};\n        ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};\n    }\n\n    /// Inspects an environment variable at compile time.\n    ///\n    /// This macro will expand to the value of the named environment variable at\n    /// compile time, yielding an expression of type `&'static str`.\n    ///\n    /// If the environment variable is not defined, then a compilation error\n    /// will be emitted. To not emit a compile error, use the [`option_env!`]\n    /// macro instead.\n    ///\n    /// [`option_env!`]: ../std/macro.option_env.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let path: &'static str = env!(\"PATH\");\n    /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n    /// ```\n    ///\n    /// You can customize the error message by passing a string as the second\n    /// parameter:\n    ///\n    /// ```compile_fail\n    /// let doc: &'static str = env!(\"documentation\", \"what's that?!\");\n    /// ```\n    ///\n    /// If the `documentation` environment variable is not defined, you'll get\n    /// the following error:\n    ///\n    /// ```text\n    /// error: what's that?!\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! env {\n        ($name:expr) => {{ /* compiler built-in */ }};\n        ($name:expr,) => {{ /* compiler built-in */ }};\n    }\n\n    /// Optionally inspects an environment variable at compile time.\n    ///\n    /// If the named environment variable is present at compile time, this will\n    /// expand into an expression of type `Option<&'static str>` whose value is\n    /// `Some` of the value of the environment variable. If the environment\n    /// variable is not present, then this will expand to `None`. See\n    /// [`Option<T>`][option] for more information on this type.\n    ///\n    /// A compile time error is never emitted when using this macro regardless\n    /// of whether the environment variable is present or not.\n    ///\n    /// [option]: ../std/option/enum.Option.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let key: Option<&'static str> = option_env!(\"SECRET_KEY\");\n    /// println!(\"the secret key might be: {:?}\", key);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! option_env {\n        ($name:expr) => {{ /* compiler built-in */ }};\n        ($name:expr,) => {{ /* compiler built-in */ }};\n    }\n\n    /// Concatenates identifiers into one identifier.\n    ///\n    /// This macro takes any number of comma-separated identifiers, and\n    /// concatenates them all into one, yielding an expression which is a new\n    /// identifier. Note that hygiene makes it such that this macro cannot\n    /// capture local variables. Also, as a general rule, macros are only\n    /// allowed in item, statement or expression position. That means while\n    /// you may use this macro for referring to existing variables, functions or\n    /// modules etc, you cannot define a new one with it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(concat_idents)]\n    ///\n    /// # fn main() {\n    /// fn foobar() -> u32 { 23 }\n    ///\n    /// let f = concat_idents!(foo, bar);\n    /// println!(\"{}\", f());\n    ///\n    /// // fn concat_idents!(new, fun, name) { } // not usable in this way!\n    /// # }\n    /// ```\n    #[unstable(\n        feature = \"concat_idents\",\n        issue = \"29599\",\n        reason = \"`concat_idents` is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! concat_idents {\n        ($($e:ident),+) => {{ /* compiler built-in */ }};\n        ($($e:ident,)+) => {{ /* compiler built-in */ }};\n    }\n\n    /// Concatenates literals into a static string slice.\n    ///\n    /// This macro takes any number of comma-separated literals, yielding an\n    /// expression of type `&'static str` which represents all of the literals\n    /// concatenated left-to-right.\n    ///\n    /// Integer and floating point literals are stringified in order to be\n    /// concatenated.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s = concat!(\"test\", 10, 'b', true);\n    /// assert_eq!(s, \"test10btrue\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! concat {\n        ($($e:expr),*) => {{ /* compiler built-in */ }};\n        ($($e:expr,)*) => {{ /* compiler built-in */ }};\n    }\n\n    /// Expands to the line number on which it was invoked.\n    ///\n    /// With [`column!`] and [`file!`], these macros provide debugging information for\n    /// developers about the location within the source.\n    ///\n    /// The expanded expression has type `u32` and is 1-based, so the first line\n    /// in each file evaluates to 1, the second to 2, etc. This is consistent\n    /// with error messages by common compilers or popular editors.\n    /// The returned line is *not necessarily* the line of the `line!` invocation itself,\n    /// but rather the first macro invocation leading up to the invocation\n    /// of the `line!` macro.\n    ///\n    /// [`column!`]: macro.column.html\n    /// [`file!`]: macro.file.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let current_line = line!();\n    /// println!(\"defined on line: {}\", current_line);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! line {\n        () => {\n            /* compiler built-in */\n        };\n    }\n\n    /// Expands to the column number at which it was invoked.\n    ///\n    /// With [`line!`] and [`file!`], these macros provide debugging information for\n    /// developers about the location within the source.\n    ///\n    /// The expanded expression has type `u32` and is 1-based, so the first column\n    /// in each line evaluates to 1, the second to 2, etc. This is consistent\n    /// with error messages by common compilers or popular editors.\n    /// The returned column is *not necessarily* the line of the `column!` invocation itself,\n    /// but rather the first macro invocation leading up to the invocation\n    /// of the `column!` macro.\n    ///\n    /// [`line!`]: macro.line.html\n    /// [`file!`]: macro.file.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let current_col = column!();\n    /// println!(\"defined on column: {}\", current_col);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! column {\n        () => {\n            /* compiler built-in */\n        };\n    }\n\n    /// Expands to the file name in which it was invoked.\n    ///\n    /// With [`line!`] and [`column!`], these macros provide debugging information for\n    /// developers about the location within the source.\n    ///\n    ///\n    /// The expanded expression has type `&'static str`, and the returned file\n    /// is not the invocation of the `file!` macro itself, but rather the\n    /// first macro invocation leading up to the invocation of the `file!`\n    /// macro.\n    ///\n    /// [`line!`]: macro.line.html\n    /// [`column!`]: macro.column.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let this_file = file!();\n    /// println!(\"defined in file: {}\", this_file);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! file {\n        () => {\n            /* compiler built-in */\n        };\n    }\n\n    /// Stringifies its arguments.\n    ///\n    /// This macro will yield an expression of type `&'static str` which is the\n    /// stringification of all the tokens passed to the macro. No restrictions\n    /// are placed on the syntax of the macro invocation itself.\n    ///\n    /// Note that the expanded results of the input tokens may change in the\n    /// future. You should be careful if you rely on the output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let one_plus_one = stringify!(1 + 1);\n    /// assert_eq!(one_plus_one, \"1 + 1\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! stringify {\n        ($($t:tt)*) => {\n            /* compiler built-in */\n        };\n    }\n\n    /// Includes a utf8-encoded file as a string.\n    ///\n    /// The file is located relative to the current file. (similarly to how\n    /// modules are found)\n    ///\n    /// This macro will yield an expression of type `&'static str` which is the\n    /// contents of the file.\n    ///\n    /// # Examples\n    ///\n    /// Assume there are two files in the same directory with the following\n    /// contents:\n    ///\n    /// File 'spanish.in':\n    ///\n    /// ```text\n    /// adiós\n    /// ```\n    ///\n    /// File 'main.rs':\n    ///\n    /// ```ignore (cannot-doctest-external-file-dependency)\n    /// fn main() {\n    ///     let my_str = include_str!(\"spanish.in\");\n    ///     assert_eq!(my_str, \"adiós\\n\");\n    ///     print!(\"{}\", my_str);\n    /// }\n    /// ```\n    ///\n    /// Compiling 'main.rs' and running the resulting binary will print \"adiós\".\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! include_str {\n        ($file:expr) => {{ /* compiler built-in */ }};\n        ($file:expr,) => {{ /* compiler built-in */ }};\n    }\n\n    /// Includes a file as a reference to a byte array.\n    ///\n    /// The file is located relative to the current file. (similarly to how\n    /// modules are found)\n    ///\n    /// This macro will yield an expression of type `&'static [u8; N]` which is\n    /// the contents of the file.\n    ///\n    /// # Examples\n    ///\n    /// Assume there are two files in the same directory with the following\n    /// contents:\n    ///\n    /// File 'spanish.in':\n    ///\n    /// ```text\n    /// adiós\n    /// ```\n    ///\n    /// File 'main.rs':\n    ///\n    /// ```ignore (cannot-doctest-external-file-dependency)\n    /// fn main() {\n    ///     let bytes = include_bytes!(\"spanish.in\");\n    ///     assert_eq!(bytes, b\"adi\\xc3\\xb3s\\n\");\n    ///     print!(\"{}\", String::from_utf8_lossy(bytes));\n    /// }\n    /// ```\n    ///\n    /// Compiling 'main.rs' and running the resulting binary will print \"adiós\".\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! include_bytes {\n        ($file:expr) => {{ /* compiler built-in */ }};\n        ($file:expr,) => {{ /* compiler built-in */ }};\n    }\n\n    /// Expands to a string that represents the current module path.\n    ///\n    /// The current module path can be thought of as the hierarchy of modules\n    /// leading back up to the crate root. The first component of the path\n    /// returned is the name of the crate currently being compiled.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// mod test {\n    ///     pub fn foo() {\n    ///         assert!(module_path!().ends_with(\"test\"));\n    ///     }\n    /// }\n    ///\n    /// test::foo();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! module_path {\n        () => {\n            /* compiler built-in */\n        };\n    }\n\n    /// Evaluates boolean combinations of configuration flags at compile-time.\n    ///\n    /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n    /// boolean expression evaluation of configuration flags. This frequently\n    /// leads to less duplicated code.\n    ///\n    /// The syntax given to this macro is the same syntax as the [`cfg`]\n    /// attribute.\n    ///\n    /// [`cfg`]: ../reference/conditional-compilation.html#the-cfg-attribute\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let my_directory = if cfg!(windows) {\n    ///     \"windows-specific-directory\"\n    /// } else {\n    ///     \"unix-directory\"\n    /// };\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! cfg {\n        ($($cfg:tt)*) => {\n            /* compiler built-in */\n        };\n    }\n\n    /// Parses a file as an expression or an item according to the context.\n    ///\n    /// The file is located relative to the current file (similarly to how\n    /// modules are found).\n    ///\n    /// Using this macro is often a bad idea, because if the file is\n    /// parsed as an expression, it is going to be placed in the\n    /// surrounding code unhygienically. This could result in variables\n    /// or functions being different from what the file expected if\n    /// there are variables or functions that have the same name in\n    /// the current file.\n    ///\n    /// # Examples\n    ///\n    /// Assume there are two files in the same directory with the following\n    /// contents:\n    ///\n    /// File 'monkeys.in':\n    ///\n    /// ```ignore (only-for-syntax-highlight)\n    /// ['🙈', '🙊', '🙉']\n    ///     .iter()\n    ///     .cycle()\n    ///     .take(6)\n    ///     .collect::<String>()\n    /// ```\n    ///\n    /// File 'main.rs':\n    ///\n    /// ```ignore (cannot-doctest-external-file-dependency)\n    /// fn main() {\n    ///     let my_string = include!(\"monkeys.in\");\n    ///     assert_eq!(\"🙈🙊🙉🙈🙊🙉\", my_string);\n    ///     println!(\"{}\", my_string);\n    /// }\n    /// ```\n    ///\n    /// Compiling 'main.rs' and running the resulting binary will print\n    /// \"🙈🙊🙉🙈🙊🙉\".\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! include {\n        ($file:expr) => {{ /* compiler built-in */ }};\n        ($file:expr,) => {{ /* compiler built-in */ }};\n    }\n\n    /// Asserts that a boolean expression is `true` at runtime.\n    ///\n    /// This will invoke the [`panic!`] macro if the provided expression cannot be\n    /// evaluated to `true` at runtime.\n    ///\n    /// # Uses\n    ///\n    /// Assertions are always checked in both debug and release builds, and cannot\n    /// be disabled. See [`debug_assert!`] for assertions that are not enabled in\n    /// release builds by default.\n    ///\n    /// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n    /// violated could lead to unsafety.\n    ///\n    /// Other use-cases of `assert!` include testing and enforcing run-time\n    /// invariants in safe code (whose violation cannot result in unsafety).\n    ///\n    /// # Custom Messages\n    ///\n    /// This macro has a second form, where a custom panic message can\n    /// be provided with or without arguments for formatting. See [`std::fmt`]\n    /// for syntax for this form.\n    ///\n    /// [`panic!`]: macro.panic.html\n    /// [`debug_assert!`]: macro.debug_assert.html\n    /// [`std::fmt`]: ../std/fmt/index.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// // the panic message for these assertions is the stringified value of the\n    /// // expression given.\n    /// assert!(true);\n    ///\n    /// fn some_computation() -> bool { true } // a very simple function\n    ///\n    /// assert!(some_computation());\n    ///\n    /// // assert with a custom message\n    /// let x = true;\n    /// assert!(x, \"x wasn't true!\");\n    ///\n    /// let a = 3; let b = 27;\n    /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! assert {\n        ($cond:expr) => {{ /* compiler built-in */ }};\n        ($cond:expr,) => {{ /* compiler built-in */ }};\n        ($cond:expr, $($arg:tt)+) => {{ /* compiler built-in */ }};\n    }\n\n    /// Inline assembly.\n    ///\n    /// Read the [unstable book] for the usage.\n    ///\n    /// [unstable book]: ../unstable-book/library-features/asm.html\n    #[unstable(\n        feature = \"asm\",\n        issue = \"29722\",\n        reason = \"inline assembly is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! asm {\n        (\"assembly template\"\n                        : $(\"output\"(operand),)*\n                        : $(\"input\"(operand),)*\n                        : $(\"clobbers\",)*\n                        : $(\"options\",)*) => {\n            /* compiler built-in */\n        };\n    }\n\n    /// Module-level inline assembly.\n    #[unstable(\n        feature = \"global_asm\",\n        issue = \"35119\",\n        reason = \"`global_asm!` is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! global_asm {\n        (\"assembly\") => {\n            /* compiler built-in */\n        };\n    }\n\n    /// Prints passed tokens into the standard output.\n    #[unstable(\n        feature = \"log_syntax\",\n        issue = \"29598\",\n        reason = \"`log_syntax!` is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! log_syntax {\n        ($($arg:tt)*) => {\n            /* compiler built-in */\n        };\n    }\n\n    /// Enables or disables tracing functionality used for debugging other macros.\n    #[unstable(\n        feature = \"trace_macros\",\n        issue = \"29598\",\n        reason = \"`trace_macros` is not stable enough for use and is subject to change\"\n    )]\n    #[rustc_builtin_macro]\n    #[macro_export]\n    macro_rules! trace_macros {\n        (true) => {{ /* compiler built-in */ }};\n        (false) => {{ /* compiler built-in */ }};\n    }\n\n    /// Attribute macro applied to a function to turn it into a unit test.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow_internal_unstable(test, rustc_attrs)]\n    #[rustc_builtin_macro]\n    pub macro test($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Attribute macro applied to a function to turn it into a benchmark test.\n    #[unstable(\n        feature = \"test\",\n        issue = \"50297\",\n        soft,\n        reason = \"`bench` is a part of custom test frameworks which are unstable\"\n    )]\n    #[allow_internal_unstable(test, rustc_attrs)]\n    #[rustc_builtin_macro]\n    pub macro bench($item:item) {\n        /* compiler built-in */\n    }\n\n    /// An implementation detail of the `#[test]` and `#[bench]` macros.\n    #[unstable(\n        feature = \"custom_test_frameworks\",\n        issue = \"50297\",\n        reason = \"custom test frameworks are an unstable feature\"\n    )]\n    #[allow_internal_unstable(test, rustc_attrs)]\n    #[rustc_builtin_macro]\n    pub macro test_case($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Attribute macro applied to a static to register it as a global allocator.\n    #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n    #[allow_internal_unstable(rustc_attrs)]\n    #[rustc_builtin_macro]\n    pub macro global_allocator($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Unstable implementation detail of the `rustc` compiler, do not use.\n    #[rustc_builtin_macro]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n    pub macro RustcDecodable($item:item) {\n        /* compiler built-in */\n    }\n\n    /// Unstable implementation detail of the `rustc` compiler, do not use.\n    #[rustc_builtin_macro]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[allow_internal_unstable(core_intrinsics)]\n    pub macro RustcEncodable($item:item) {\n        /* compiler built-in */\n    }\n}\n}\n\n#[macro_use]\nmod internal_macros {\n// implements the unary operator \"op &T\"\n// based on \"op T\" where T is expected to be `Copy`able\nmacro_rules! forward_ref_unop {\n    (impl $imp:ident, $method:ident for $t:ty) => {\n        forward_ref_unop!(impl $imp, $method for $t,\n                #[stable(feature = \"rust1\", since = \"1.0.0\")]);\n    };\n    (impl $imp:ident, $method:ident for $t:ty, #[$attr:meta]) => {\n        #[$attr]\n        impl $imp for &$t {\n            type Output = <$t as $imp>::Output;\n\n            #[inline]\n            fn $method(self) -> <$t as $imp>::Output {\n}\n        }\n    }\n}\n\n// implements binary operators \"&T op U\", \"T op &U\", \"&T op &U\"\n// based on \"T op U\" where T and U are expected to be `Copy`able\nmacro_rules! forward_ref_binop {\n    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n        forward_ref_binop!(impl $imp, $method for $t, $u,\n                #[stable(feature = \"rust1\", since = \"1.0.0\")]);\n    };\n    (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n        #[$attr]\n        impl<'a> $imp<$u> for &'a $t {\n            type Output = <$t as $imp<$u>>::Output;\n\n            #[inline]\n            fn $method(self, other: $u) -> <$t as $imp<$u>>::Output {\n}\n        }\n\n        #[$attr]\n        impl $imp<&$u> for $t {\n            type Output = <$t as $imp<$u>>::Output;\n\n            #[inline]\n            fn $method(self, other: &$u) -> <$t as $imp<$u>>::Output {\n}\n        }\n\n        #[$attr]\n        impl $imp<&$u> for &$t {\n            type Output = <$t as $imp<$u>>::Output;\n\n            #[inline]\n            fn $method(self, other: &$u) -> <$t as $imp<$u>>::Output {\n}\n        }\n    }\n}\n\n// implements \"T op= &U\", based on \"T op= U\"\n// where U is expected to be `Copy`able\nmacro_rules! forward_ref_op_assign {\n    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n        forward_ref_op_assign!(impl $imp, $method for $t, $u,\n                #[stable(feature = \"op_assign_builtins_by_ref\", since = \"1.22.0\")]);\n    };\n    (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n        #[$attr]\n        impl $imp<&$u> for $t {\n            #[inline]\n            fn $method(&mut self, other: &$u) {\n}\n        }\n    }\n}\n\n/// Create a zero-size type similar to a closure type, but named.\n#[unstable(feature = \"std_internals\", issue = \"none\")]\nmacro_rules! impl_fn_for_zst {\n}\n}\n\n#[path = \"num/int_macros.rs\"]\n#[macro_use]\nmod int_macros {\n#![doc(hidden)]\n\nmacro_rules! int_module {\n    ($T:ident) => (int_module!($T, #[stable(feature = \"rust1\", since = \"1.0.0\")]););\n    ($T:ident, #[$attr:meta]) => (\n        /// The smallest value that can be represented by this integer type.\n        #[$attr]\n        pub const MIN: $T = $T::min_value();\n        /// The largest value that can be represented by this integer type.\n        #[$attr]\n        pub const MAX: $T = $T::max_value();\n    )\n}\n}\n\n#[path = \"num/uint_macros.rs\"]\n#[macro_use]\nmod uint_macros {\n#![doc(hidden)]\n\nmacro_rules! uint_module {\n    ($T:ident) => (uint_module!($T, #[stable(feature = \"rust1\", since = \"1.0.0\")]););\n    ($T:ident, #[$attr:meta]) => (\n        /// The smallest value that can be represented by this integer type.\n        #[$attr]\n        pub const MIN: $T = $T::min_value();\n        /// The largest value that can be represented by this integer type.\n        #[$attr]\n        pub const MAX: $T = $T::max_value();\n    )\n}\n}\n\n#[path = \"num/i128.rs\"]\npub mod i128 {\n//! The 128-bit signed integer type.\n//!\n//! *[See also the `i128` primitive type](../../std/primitive.i128.html).*\n\n#![stable(feature = \"i128\", since = \"1.26.0\")]\n\nint_module! { i128, #[stable(feature = \"i128\", since=\"1.26.0\")] }\n}\n#[path = \"num/i16.rs\"]\npub mod i16 {\n//! The 16-bit signed integer type.\n//!\n//! *[See also the `i16` primitive type](../../std/primitive.i16.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nint_module! { i16 }\n}\n#[path = \"num/i32.rs\"]\npub mod i32 {\n//! The 32-bit signed integer type.\n//!\n//! *[See also the `i32` primitive type](../../std/primitive.i32.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nint_module! { i32 }\n}\n#[path = \"num/i64.rs\"]\npub mod i64 {\n//! The 64-bit signed integer type.\n//!\n//! *[See also the `i64` primitive type](../../std/primitive.i64.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nint_module! { i64 }\n}\n#[path = \"num/i8.rs\"]\npub mod i8 {\n//! The 8-bit signed integer type.\n//!\n//! *[See also the `i8` primitive type](../../std/primitive.i8.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nint_module! { i8 }\n}\n#[path = \"num/isize.rs\"]\npub mod isize {\n//! The pointer-sized signed integer type.\n//!\n//! *[See also the `isize` primitive type](../../std/primitive.isize.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nint_module! { isize }\n}\n\n#[path = \"num/u128.rs\"]\npub mod u128 {\n//! The 128-bit unsigned integer type.\n//!\n//! *[See also the `u128` primitive type](../../std/primitive.u128.html).*\n\n#![stable(feature = \"i128\", since = \"1.26.0\")]\nuint_module! { u128, #[stable(feature = \"i128\", since=\"1.26.0\")] }\n}\n#[path = \"num/u16.rs\"]\npub mod u16 {\n//! The 16-bit unsigned integer type.\n//!\n//! *[See also the `u16` primitive type](../../std/primitive.u16.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuint_module! { u16 }\n}\n#[path = \"num/u32.rs\"]\npub mod u32 {\n//! The 32-bit unsigned integer type.\n//!\n//! *[See also the `u32` primitive type](../../std/primitive.u32.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuint_module! { u32 }\n}\n#[path = \"num/u64.rs\"]\npub mod u64 {\n//! The 64-bit unsigned integer type.\n//!\n//! *[See also the `u64` primitive type](../../std/primitive.u64.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuint_module! { u64 }\n}\n#[path = \"num/u8.rs\"]\npub mod u8 {\n//! The 8-bit unsigned integer type.\n//!\n//! *[See also the `u8` primitive type](../../std/primitive.u8.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuint_module! { u8 }\n}\n#[path = \"num/usize.rs\"]\npub mod usize {\n//! The pointer-sized unsigned integer type.\n//!\n//! *[See also the `usize` primitive type](../../std/primitive.usize.html).*\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuint_module! { usize }\n}\n\n#[path = \"num/f32.rs\"]\npub mod f32 {\n//! This module provides constants which are specific to the implementation\n//! of the `f32` floating point data type.\n//!\n//! *[See also the `f32` primitive type](../../std/primitive.f32.html).*\n//!\n//! Mathematically significant numbers are provided in the `consts` sub-module.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::convert::FloatToInt;\n#[cfg(not(test))]\nuse crate::intrinsics;\nuse crate::mem;\nuse crate::num::FpCategory;\n\n/// The radix or base of the internal representation of `f32`.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const RADIX: u32 = 2;\n\n/// Number of significant digits in base 2.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MANTISSA_DIGITS: u32 = 24;\n/// Approximate number of significant digits in base 10.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const DIGITS: u32 = 6;\n\n/// [Machine epsilon] value for `f32`.\n///\n/// This is the difference between `1.0` and the next larger representable number.\n///\n/// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const EPSILON: f32 = 1.1920929e-7_f32;\n\n/// Smallest finite `f32` value.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MIN: f32 = -3.40282347e+38_f32;\n/// Smallest positive normal `f32` value.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MIN_POSITIVE: f32 = 1.17549435e-38_f32;\n/// Largest finite `f32` value.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MAX: f32 = 3.40282347e+38_f32;\n\n/// One greater than the minimum possible normal power of 2 exponent.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MIN_EXP: i32 = -125;\n/// Maximum possible power of 2 exponent.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MAX_EXP: i32 = 128;\n\n/// Minimum possible normal power of 10 exponent.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MIN_10_EXP: i32 = -37;\n/// Maximum possible power of 10 exponent.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MAX_10_EXP: i32 = 38;\n\n/// Not a Number (NaN).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const NAN: f32 = 0.0_f32 / 0.0_f32;\n/// Infinity (∞).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const INFINITY: f32 = 1.0_f32 / 0.0_f32;\n/// Negative infinity (−∞).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const NEG_INFINITY: f32 = -1.0_f32 / 0.0_f32;\n\n/// Basic mathematical constants.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod consts {\n    // FIXME: replace with mathematical constants from cmath.\n\n    /// Archimedes' constant (π)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const PI: f32 = 3.14159265358979323846264338327950288_f32;\n\n    /// The full circle constant (τ)\n    ///\n    /// Equal to 2π.\n    #[unstable(feature = \"tau_constant\", issue = \"66770\")]\n    pub const TAU: f32 = 6.28318530717958647692528676655900577_f32;\n\n    /// π/2\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n\n    /// π/3\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_3: f32 = 1.04719755119659774615421446109316763_f32;\n\n    /// π/4\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_4: f32 = 0.785398163397448309615660845819875721_f32;\n\n    /// π/6\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_6: f32 = 0.52359877559829887307710723054658381_f32;\n\n    /// π/8\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_8: f32 = 0.39269908169872415480783042290993786_f32;\n\n    /// 1/π\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_1_PI: f32 = 0.318309886183790671537767526745028724_f32;\n\n    /// 2/π\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_2_PI: f32 = 0.636619772367581343075535053490057448_f32;\n\n    /// 2/sqrt(π)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_2_SQRT_PI: f32 = 1.12837916709551257389615890312154517_f32;\n\n    /// sqrt(2)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const SQRT_2: f32 = 1.41421356237309504880168872420969808_f32;\n\n    /// 1/sqrt(2)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_1_SQRT_2: f32 = 0.707106781186547524400844362104849039_f32;\n\n    /// Euler's number (e)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const E: f32 = 2.71828182845904523536028747135266250_f32;\n\n    /// log<sub>2</sub>(e)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LOG2_E: f32 = 1.44269504088896340735992468100189214_f32;\n\n    /// log<sub>2</sub>(10)\n    #[unstable(feature = \"extra_log_consts\", issue = \"50540\")]\n    pub const LOG2_10: f32 = 3.32192809488736234787031942948939018_f32;\n\n    /// log<sub>10</sub>(e)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LOG10_E: f32 = 0.434294481903251827651128918916605082_f32;\n\n    /// log<sub>10</sub>(2)\n    #[unstable(feature = \"extra_log_consts\", issue = \"50540\")]\n    pub const LOG10_2: f32 = 0.301029995663981195213738894724493027_f32;\n\n    /// ln(2)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LN_2: f32 = 0.693147180559945309417232121458176568_f32;\n\n    /// ln(10)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n}\n\n#[lang = \"f32\"]\n#[cfg(not(test))]\nimpl f32 {\n    /// Returns `true` if this value is `NaN`.\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let nan = f32::NAN;\n    /// let f = 7.0_f32;\n    ///\n    /// assert!(nan.is_nan());\n    /// assert!(!f.is_nan());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_nan(self) -> bool {\n}\n\n    // FIXME(#50145): `abs` is publicly unavailable in libcore due to\n    // concerns about portability, so this implementation is for\n    // private use internally.\n    #[inline]\n    fn abs_private(self) -> f32 {\n}\n\n    /// Returns `true` if this value is positive infinity or negative infinity, and\n    /// `false` otherwise.\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let f = 7.0f32;\n    /// let inf = f32::INFINITY;\n    /// let neg_inf = f32::NEG_INFINITY;\n    /// let nan = f32::NAN;\n    ///\n    /// assert!(!f.is_infinite());\n    /// assert!(!nan.is_infinite());\n    ///\n    /// assert!(inf.is_infinite());\n    /// assert!(neg_inf.is_infinite());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_infinite(self) -> bool {\n}\n\n    /// Returns `true` if this number is neither infinite nor `NaN`.\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let f = 7.0f32;\n    /// let inf = f32::INFINITY;\n    /// let neg_inf = f32::NEG_INFINITY;\n    /// let nan = f32::NAN;\n    ///\n    /// assert!(f.is_finite());\n    ///\n    /// assert!(!nan.is_finite());\n    /// assert!(!inf.is_finite());\n    /// assert!(!neg_inf.is_finite());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_finite(self) -> bool {\n}\n\n    /// Returns `true` if the number is neither zero, infinite,\n    /// [subnormal], or `NaN`.\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n    /// let max = f32::MAX;\n    /// let lower_than_min = 1.0e-40_f32;\n    /// let zero = 0.0_f32;\n    ///\n    /// assert!(min.is_normal());\n    /// assert!(max.is_normal());\n    ///\n    /// assert!(!zero.is_normal());\n    /// assert!(!f32::NAN.is_normal());\n    /// assert!(!f32::INFINITY.is_normal());\n    /// // Values between `0` and `min` are Subnormal.\n    /// assert!(!lower_than_min.is_normal());\n    /// ```\n    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_normal(self) -> bool {\n}\n\n    /// Returns the floating point category of the number. If only one property\n    /// is going to be tested, it is generally faster to use the specific\n    /// predicate instead.\n    ///\n    /// ```\n    /// use std::num::FpCategory;\n    /// use std::f32;\n    ///\n    /// let num = 12.4_f32;\n    /// let inf = f32::INFINITY;\n    ///\n    /// assert_eq!(num.classify(), FpCategory::Normal);\n    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn classify(self) -> FpCategory {\n}\n\n    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n    /// positive sign bit and positive infinity.\n    ///\n    /// ```\n    /// let f = 7.0_f32;\n    /// let g = -7.0_f32;\n    ///\n    /// assert!(f.is_sign_positive());\n    /// assert!(!g.is_sign_positive());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_sign_positive(self) -> bool {\n}\n\n    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n    /// negative sign bit and negative infinity.\n    ///\n    /// ```\n    /// let f = 7.0f32;\n    /// let g = -7.0f32;\n    ///\n    /// assert!(!f.is_sign_negative());\n    /// assert!(g.is_sign_negative());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_sign_negative(self) -> bool {\n}\n\n    /// Takes the reciprocal (inverse) of a number, `1/x`.\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// let x = 2.0_f32;\n    /// let abs_difference = (x.recip() - (1.0 / x)).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn recip(self) -> f32 {\n}\n\n    /// Converts radians to degrees.\n    ///\n    /// ```\n    /// use std::f32::{self, consts};\n    ///\n    /// let angle = consts::PI;\n    ///\n    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[stable(feature = \"f32_deg_rad_conversions\", since = \"1.7.0\")]\n    #[inline]\n    pub fn to_degrees(self) -> f32 {\n}\n\n    /// Converts degrees to radians.\n    ///\n    /// ```\n    /// use std::f32::{self, consts};\n    ///\n    /// let angle = 180.0f32;\n    ///\n    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n    ///\n    /// assert!(abs_difference <= f32::EPSILON);\n    /// ```\n    #[stable(feature = \"f32_deg_rad_conversions\", since = \"1.7.0\")]\n    #[inline]\n    pub fn to_radians(self) -> f32 {\n}\n\n    /// Returns the maximum of the two numbers.\n    ///\n    /// ```\n    /// let x = 1.0f32;\n    /// let y = 2.0f32;\n    ///\n    /// assert_eq!(x.max(y), y);\n    /// ```\n    ///\n    /// If one of the arguments is NaN, then the other argument is returned.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn max(self, other: f32) -> f32 {\n}\n\n    /// Returns the minimum of the two numbers.\n    ///\n    /// ```\n    /// let x = 1.0f32;\n    /// let y = 2.0f32;\n    ///\n    /// assert_eq!(x.min(y), x);\n    /// ```\n    ///\n    /// If one of the arguments is NaN, then the other argument is returned.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn min(self, other: f32) -> f32 {\n}\n\n    /// Rounds toward zero and converts to any primitive integer type,\n    /// assuming that the value is finite and fits in that type.\n    ///\n    /// ```\n    /// #![feature(float_approx_unchecked_to)]\n    ///\n    /// let value = 4.6_f32;\n    /// let rounded = unsafe { value.approx_unchecked_to::<u16>() };\n    /// assert_eq!(rounded, 4);\n    ///\n    /// let value = -128.9_f32;\n    /// let rounded = unsafe { value.approx_unchecked_to::<i8>() };\n    /// assert_eq!(rounded, std::i8::MIN);\n    /// ```\n    ///\n    /// # Safety\n    ///\n    /// The value must:\n    ///\n    /// * Not be `NaN`\n    /// * Not be infinite\n    /// * Be representable in the return type `Int`, after truncating off its fractional part\n    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n    #[inline]\n    pub unsafe fn approx_unchecked_to<Int>(self) -> Int\n    where\n        Self: FloatToInt<Int>,\n    {\n}\n\n    /// Raw transmutation to `u32`.\n    ///\n    /// This is currently identical to `transmute::<f32, u32>(self)` on all platforms.\n    ///\n    /// See `from_bits` for some discussion of the portability of this operation\n    /// (there are almost no issues).\n    ///\n    /// Note that this function is distinct from `as` casting, which attempts to\n    /// preserve the *numeric* value, and not the bitwise value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_ne!((1f32).to_bits(), 1f32 as u32); // to_bits() is not casting!\n    /// assert_eq!((12.5f32).to_bits(), 0x41480000);\n    ///\n    /// ```\n    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n    #[inline]\n    pub fn to_bits(self) -> u32 {\n}\n\n    /// Raw transmutation from `u32`.\n    ///\n    /// This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n    /// It turns out this is incredibly portable, for two reasons:\n    ///\n    /// * Floats and Ints have the same endianness on all supported platforms.\n    /// * IEEE-754 very precisely specifies the bit layout of floats.\n    ///\n    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n    /// (notably x86 and ARM) picked the interpretation that was ultimately\n    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n    ///\n    /// Rather than trying to preserve signaling-ness cross-platform, this\n    /// implementation favors preserving the exact bits. This means that\n    /// any payloads encoded in NaNs will be preserved even if the result of\n    /// this method is sent over the network from an x86 machine to a MIPS one.\n    ///\n    /// If the results of this method are only manipulated by the same\n    /// architecture that produced them, then there is no portability concern.\n    ///\n    /// If the input isn't NaN, then there is no portability concern.\n    ///\n    /// If you don't care about signalingness (very likely), then there is no\n    /// portability concern.\n    ///\n    /// Note that this function is distinct from `as` casting, which attempts to\n    /// preserve the *numeric* value, and not the bitwise value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = f32::from_bits(0x41480000);\n    /// assert_eq!(v, 12.5);\n    /// ```\n    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n    #[inline]\n    pub fn from_bits(v: u32) -> Self {\n}\n\n    /// Return the memory representation of this floating point number as a byte array in\n    /// big-endian (network) byte order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let bytes = 12.5f32.to_be_bytes();\n    /// assert_eq!(bytes, [0x41, 0x48, 0x00, 0x00]);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[inline]\n    pub fn to_be_bytes(self) -> [u8; 4] {\n}\n\n    /// Return the memory representation of this floating point number as a byte array in\n    /// little-endian byte order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let bytes = 12.5f32.to_le_bytes();\n    /// assert_eq!(bytes, [0x00, 0x00, 0x48, 0x41]);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[inline]\n    pub fn to_le_bytes(self) -> [u8; 4] {\n}\n\n    /// Return the memory representation of this floating point number as a byte array in\n    /// native byte order.\n    ///\n    /// As the target platform's native endianness is used, portable code\n    /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate, instead.\n    ///\n    /// [`to_be_bytes`]: #method.to_be_bytes\n    /// [`to_le_bytes`]: #method.to_le_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let bytes = 12.5f32.to_ne_bytes();\n    /// assert_eq!(\n    ///     bytes,\n    ///     if cfg!(target_endian = \"big\") {\n    ///         [0x41, 0x48, 0x00, 0x00]\n    ///     } else {\n    ///         [0x00, 0x00, 0x48, 0x41]\n    ///     }\n    /// );\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[inline]\n    pub fn to_ne_bytes(self) -> [u8; 4] {\n}\n\n    /// Create a floating point value from its representation as a byte array in big endian.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let value = f32::from_be_bytes([0x41, 0x48, 0x00, 0x00]);\n    /// assert_eq!(value, 12.5);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[inline]\n    pub fn from_be_bytes(bytes: [u8; 4]) -> Self {\n}\n\n    /// Create a floating point value from its representation as a byte array in little endian.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let value = f32::from_le_bytes([0x00, 0x00, 0x48, 0x41]);\n    /// assert_eq!(value, 12.5);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[inline]\n    pub fn from_le_bytes(bytes: [u8; 4]) -> Self {\n}\n\n    /// Create a floating point value from its representation as a byte array in native endian.\n    ///\n    /// As the target platform's native endianness is used, portable code\n    /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n    /// appropriate instead.\n    ///\n    /// [`from_be_bytes`]: #method.from_be_bytes\n    /// [`from_le_bytes`]: #method.from_le_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let value = f32::from_ne_bytes(if cfg!(target_endian = \"big\") {\n    ///     [0x41, 0x48, 0x00, 0x00]\n    /// } else {\n    ///     [0x00, 0x00, 0x48, 0x41]\n    /// });\n    /// assert_eq!(value, 12.5);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[inline]\n    pub fn from_ne_bytes(bytes: [u8; 4]) -> Self {\n}\n}\n}\n#[path = \"num/f64.rs\"]\npub mod f64 {\n//! This module provides constants which are specific to the implementation\n//! of the `f64` floating point data type.\n//!\n//! *[See also the `f64` primitive type](../../std/primitive.f64.html).*\n//!\n//! Mathematically significant numbers are provided in the `consts` sub-module.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::convert::FloatToInt;\n#[cfg(not(test))]\nuse crate::intrinsics;\nuse crate::mem;\nuse crate::num::FpCategory;\n\n/// The radix or base of the internal representation of `f64`.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const RADIX: u32 = 2;\n\n/// Number of significant digits in base 2.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MANTISSA_DIGITS: u32 = 53;\n/// Approximate number of significant digits in base 10.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const DIGITS: u32 = 15;\n\n/// [Machine epsilon] value for `f64`.\n///\n/// This is the difference between `1.0` and the next larger representable number.\n///\n/// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n\n/// Smallest finite `f64` value.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MIN: f64 = -1.7976931348623157e+308_f64;\n/// Smallest positive normal `f64` value.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MIN_POSITIVE: f64 = 2.2250738585072014e-308_f64;\n/// Largest finite `f64` value.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MAX: f64 = 1.7976931348623157e+308_f64;\n\n/// One greater than the minimum possible normal power of 2 exponent.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MIN_EXP: i32 = -1021;\n/// Maximum possible power of 2 exponent.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MAX_EXP: i32 = 1024;\n\n/// Minimum possible normal power of 10 exponent.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MIN_10_EXP: i32 = -307;\n/// Maximum possible power of 10 exponent.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MAX_10_EXP: i32 = 308;\n\n/// Not a Number (NaN).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const NAN: f64 = 0.0_f64 / 0.0_f64;\n/// Infinity (∞).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const INFINITY: f64 = 1.0_f64 / 0.0_f64;\n/// Negative infinity (−∞).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const NEG_INFINITY: f64 = -1.0_f64 / 0.0_f64;\n\n/// Basic mathematical constants.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod consts {\n    // FIXME: replace with mathematical constants from cmath.\n\n    /// Archimedes' constant (π)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const PI: f64 = 3.14159265358979323846264338327950288_f64;\n\n    /// The full circle constant (τ)\n    ///\n    /// Equal to 2π.\n    #[unstable(feature = \"tau_constant\", issue = \"66770\")]\n    pub const TAU: f64 = 6.28318530717958647692528676655900577_f64;\n\n    /// π/2\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n\n    /// π/3\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_3: f64 = 1.04719755119659774615421446109316763_f64;\n\n    /// π/4\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_4: f64 = 0.785398163397448309615660845819875721_f64;\n\n    /// π/6\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_6: f64 = 0.52359877559829887307710723054658381_f64;\n\n    /// π/8\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_PI_8: f64 = 0.39269908169872415480783042290993786_f64;\n\n    /// 1/π\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_1_PI: f64 = 0.318309886183790671537767526745028724_f64;\n\n    /// 2/π\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_2_PI: f64 = 0.636619772367581343075535053490057448_f64;\n\n    /// 2/sqrt(π)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_2_SQRT_PI: f64 = 1.12837916709551257389615890312154517_f64;\n\n    /// sqrt(2)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const SQRT_2: f64 = 1.41421356237309504880168872420969808_f64;\n\n    /// 1/sqrt(2)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const FRAC_1_SQRT_2: f64 = 0.707106781186547524400844362104849039_f64;\n\n    /// Euler's number (e)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const E: f64 = 2.71828182845904523536028747135266250_f64;\n\n    /// log<sub>2</sub>(10)\n    #[unstable(feature = \"extra_log_consts\", issue = \"50540\")]\n    pub const LOG2_10: f64 = 3.32192809488736234787031942948939018_f64;\n\n    /// log<sub>2</sub>(e)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LOG2_E: f64 = 1.44269504088896340735992468100189214_f64;\n\n    /// log<sub>10</sub>(2)\n    #[unstable(feature = \"extra_log_consts\", issue = \"50540\")]\n    pub const LOG10_2: f64 = 0.301029995663981195213738894724493027_f64;\n\n    /// log<sub>10</sub>(e)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LOG10_E: f64 = 0.434294481903251827651128918916605082_f64;\n\n    /// ln(2)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LN_2: f64 = 0.693147180559945309417232121458176568_f64;\n\n    /// ln(10)\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n}\n\n#[lang = \"f64\"]\n#[cfg(not(test))]\nimpl f64 {\n    /// Returns `true` if this value is `NaN`.\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let nan = f64::NAN;\n    /// let f = 7.0_f64;\n    ///\n    /// assert!(nan.is_nan());\n    /// assert!(!f.is_nan());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_nan(self) -> bool {\n}\n\n    // FIXME(#50145): `abs` is publicly unavailable in libcore due to\n    // concerns about portability, so this implementation is for\n    // private use internally.\n    #[inline]\n    fn abs_private(self) -> f64 {\n}\n\n    /// Returns `true` if this value is positive infinity or negative infinity, and\n    /// `false` otherwise.\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let f = 7.0f64;\n    /// let inf = f64::INFINITY;\n    /// let neg_inf = f64::NEG_INFINITY;\n    /// let nan = f64::NAN;\n    ///\n    /// assert!(!f.is_infinite());\n    /// assert!(!nan.is_infinite());\n    ///\n    /// assert!(inf.is_infinite());\n    /// assert!(neg_inf.is_infinite());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_infinite(self) -> bool {\n}\n\n    /// Returns `true` if this number is neither infinite nor `NaN`.\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let f = 7.0f64;\n    /// let inf: f64 = f64::INFINITY;\n    /// let neg_inf: f64 = f64::NEG_INFINITY;\n    /// let nan: f64 = f64::NAN;\n    ///\n    /// assert!(f.is_finite());\n    ///\n    /// assert!(!nan.is_finite());\n    /// assert!(!inf.is_finite());\n    /// assert!(!neg_inf.is_finite());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_finite(self) -> bool {\n}\n\n    /// Returns `true` if the number is neither zero, infinite,\n    /// [subnormal], or `NaN`.\n    ///\n    /// ```\n    /// use std::f64;\n    ///\n    /// let min = f64::MIN_POSITIVE; // 2.2250738585072014e-308f64\n    /// let max = f64::MAX;\n    /// let lower_than_min = 1.0e-308_f64;\n    /// let zero = 0.0f64;\n    ///\n    /// assert!(min.is_normal());\n    /// assert!(max.is_normal());\n    ///\n    /// assert!(!zero.is_normal());\n    /// assert!(!f64::NAN.is_normal());\n    /// assert!(!f64::INFINITY.is_normal());\n    /// // Values between `0` and `min` are Subnormal.\n    /// assert!(!lower_than_min.is_normal());\n    /// ```\n    /// [subnormal]: https://en.wikipedia.org/wiki/Denormal_number\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_normal(self) -> bool {\n}\n\n    /// Returns the floating point category of the number. If only one property\n    /// is going to be tested, it is generally faster to use the specific\n    /// predicate instead.\n    ///\n    /// ```\n    /// use std::num::FpCategory;\n    /// use std::f64;\n    ///\n    /// let num = 12.4_f64;\n    /// let inf = f64::INFINITY;\n    ///\n    /// assert_eq!(num.classify(), FpCategory::Normal);\n    /// assert_eq!(inf.classify(), FpCategory::Infinite);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn classify(self) -> FpCategory {\n}\n\n    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n    /// positive sign bit and positive infinity.\n    ///\n    /// ```\n    /// let f = 7.0_f64;\n    /// let g = -7.0_f64;\n    ///\n    /// assert!(f.is_sign_positive());\n    /// assert!(!g.is_sign_positive());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_sign_positive(self) -> bool {\n}\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")]\n    #[inline]\n    #[doc(hidden)]\n    pub fn is_positive(self) -> bool {\n}\n\n    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n    /// negative sign bit and negative infinity.\n    ///\n    /// ```\n    /// let f = 7.0_f64;\n    /// let g = -7.0_f64;\n    ///\n    /// assert!(!f.is_sign_negative());\n    /// assert!(g.is_sign_negative());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_sign_negative(self) -> bool {\n}\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")]\n    #[inline]\n    #[doc(hidden)]\n    pub fn is_negative(self) -> bool {\n}\n\n    /// Takes the reciprocal (inverse) of a number, `1/x`.\n    ///\n    /// ```\n    /// let x = 2.0_f64;\n    /// let abs_difference = (x.recip() - (1.0 / x)).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn recip(self) -> f64 {\n}\n\n    /// Converts radians to degrees.\n    ///\n    /// ```\n    /// use std::f64::consts;\n    ///\n    /// let angle = consts::PI;\n    ///\n    /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_degrees(self) -> f64 {\n}\n\n    /// Converts degrees to radians.\n    ///\n    /// ```\n    /// use std::f64::consts;\n    ///\n    /// let angle = 180.0_f64;\n    ///\n    /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n    ///\n    /// assert!(abs_difference < 1e-10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_radians(self) -> f64 {\n}\n\n    /// Returns the maximum of the two numbers.\n    ///\n    /// ```\n    /// let x = 1.0_f64;\n    /// let y = 2.0_f64;\n    ///\n    /// assert_eq!(x.max(y), y);\n    /// ```\n    ///\n    /// If one of the arguments is NaN, then the other argument is returned.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn max(self, other: f64) -> f64 {\n}\n\n    /// Returns the minimum of the two numbers.\n    ///\n    /// ```\n    /// let x = 1.0_f64;\n    /// let y = 2.0_f64;\n    ///\n    /// assert_eq!(x.min(y), x);\n    /// ```\n    ///\n    /// If one of the arguments is NaN, then the other argument is returned.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn min(self, other: f64) -> f64 {\n}\n\n    /// Rounds toward zero and converts to any primitive integer type,\n    /// assuming that the value is finite and fits in that type.\n    ///\n    /// ```\n    /// #![feature(float_approx_unchecked_to)]\n    ///\n    /// let value = 4.6_f32;\n    /// let rounded = unsafe { value.approx_unchecked_to::<u16>() };\n    /// assert_eq!(rounded, 4);\n    ///\n    /// let value = -128.9_f32;\n    /// let rounded = unsafe { value.approx_unchecked_to::<i8>() };\n    /// assert_eq!(rounded, std::i8::MIN);\n    /// ```\n    ///\n    /// # Safety\n    ///\n    /// The value must:\n    ///\n    /// * Not be `NaN`\n    /// * Not be infinite\n    /// * Be representable in the return type `Int`, after truncating off its fractional part\n    #[unstable(feature = \"float_approx_unchecked_to\", issue = \"67058\")]\n    #[inline]\n    pub unsafe fn approx_unchecked_to<Int>(self) -> Int\n    where\n        Self: FloatToInt<Int>,\n    {\n}\n\n    /// Raw transmutation to `u64`.\n    ///\n    /// This is currently identical to `transmute::<f64, u64>(self)` on all platforms.\n    ///\n    /// See `from_bits` for some discussion of the portability of this operation\n    /// (there are almost no issues).\n    ///\n    /// Note that this function is distinct from `as` casting, which attempts to\n    /// preserve the *numeric* value, and not the bitwise value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert!((1f64).to_bits() != 1f64 as u64); // to_bits() is not casting!\n    /// assert_eq!((12.5f64).to_bits(), 0x4029000000000000);\n    ///\n    /// ```\n    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n    #[inline]\n    pub fn to_bits(self) -> u64 {\n}\n\n    /// Raw transmutation from `u64`.\n    ///\n    /// This is currently identical to `transmute::<u64, f64>(v)` on all platforms.\n    /// It turns out this is incredibly portable, for two reasons:\n    ///\n    /// * Floats and Ints have the same endianness on all supported platforms.\n    /// * IEEE-754 very precisely specifies the bit layout of floats.\n    ///\n    /// However there is one caveat: prior to the 2008 version of IEEE-754, how\n    /// to interpret the NaN signaling bit wasn't actually specified. Most platforms\n    /// (notably x86 and ARM) picked the interpretation that was ultimately\n    /// standardized in 2008, but some didn't (notably MIPS). As a result, all\n    /// signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n    ///\n    /// Rather than trying to preserve signaling-ness cross-platform, this\n    /// implementation favours preserving the exact bits. This means that\n    /// any payloads encoded in NaNs will be preserved even if the result of\n    /// this method is sent over the network from an x86 machine to a MIPS one.\n    ///\n    /// If the results of this method are only manipulated by the same\n    /// architecture that produced them, then there is no portability concern.\n    ///\n    /// If the input isn't NaN, then there is no portability concern.\n    ///\n    /// If you don't care about signalingness (very likely), then there is no\n    /// portability concern.\n    ///\n    /// Note that this function is distinct from `as` casting, which attempts to\n    /// preserve the *numeric* value, and not the bitwise value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = f64::from_bits(0x4029000000000000);\n    /// assert_eq!(v, 12.5);\n    /// ```\n    #[stable(feature = \"float_bits_conv\", since = \"1.20.0\")]\n    #[inline]\n    pub fn from_bits(v: u64) -> Self {\n}\n\n    /// Return the memory representation of this floating point number as a byte array in\n    /// big-endian (network) byte order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let bytes = 12.5f64.to_be_bytes();\n    /// assert_eq!(bytes, [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[inline]\n    pub fn to_be_bytes(self) -> [u8; 8] {\n}\n\n    /// Return the memory representation of this floating point number as a byte array in\n    /// little-endian byte order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let bytes = 12.5f64.to_le_bytes();\n    /// assert_eq!(bytes, [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[inline]\n    pub fn to_le_bytes(self) -> [u8; 8] {\n}\n\n    /// Return the memory representation of this floating point number as a byte array in\n    /// native byte order.\n    ///\n    /// As the target platform's native endianness is used, portable code\n    /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate, instead.\n    ///\n    /// [`to_be_bytes`]: #method.to_be_bytes\n    /// [`to_le_bytes`]: #method.to_le_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let bytes = 12.5f64.to_ne_bytes();\n    /// assert_eq!(\n    ///     bytes,\n    ///     if cfg!(target_endian = \"big\") {\n    ///         [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n    ///     } else {\n    ///         [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]\n    ///     }\n    /// );\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[inline]\n    pub fn to_ne_bytes(self) -> [u8; 8] {\n}\n\n    /// Create a floating point value from its representation as a byte array in big endian.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let value = f64::from_be_bytes([0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    /// assert_eq!(value, 12.5);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[inline]\n    pub fn from_be_bytes(bytes: [u8; 8]) -> Self {\n}\n\n    /// Create a floating point value from its representation as a byte array in little endian.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let value = f64::from_le_bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]);\n    /// assert_eq!(value, 12.5);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[inline]\n    pub fn from_le_bytes(bytes: [u8; 8]) -> Self {\n}\n\n    /// Create a floating point value from its representation as a byte array in native endian.\n    ///\n    /// As the target platform's native endianness is used, portable code\n    /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n    /// appropriate instead.\n    ///\n    /// [`from_be_bytes`]: #method.from_be_bytes\n    /// [`from_le_bytes`]: #method.from_le_bytes\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let value = f64::from_ne_bytes(if cfg!(target_endian = \"big\") {\n    ///     [0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n    /// } else {\n    ///     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]\n    /// });\n    /// assert_eq!(value, 12.5);\n    /// ```\n    #[stable(feature = \"float_to_from_bytes\", since = \"1.40.0\")]\n    #[inline]\n    pub fn from_ne_bytes(bytes: [u8; 8]) -> Self {\n}\n}\n}\n\n#[macro_use]\npub mod num {\n// ignore-tidy-filelength\n\n//! Numeric traits and functions for the built-in numeric types.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::convert::Infallible;\nuse crate::fmt;\nuse crate::intrinsics;\nuse crate::mem;\nuse crate::ops;\nuse crate::str::FromStr;\n\nmacro_rules! impl_nonzero_fmt {\n    ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n        $(\n            #[$stability]\n            impl fmt::$Trait for $Ty {\n                #[inline]\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n            }\n        )+\n    }\n}\n\nmacro_rules! doc_comment {\n    ($x:expr, $($tt:tt)*) => {\n        #[doc = $x]\n        $($tt)*\n    };\n}\n\nmacro_rules! nonzero_integers {\n    ( $( #[$stability: meta] $Ty: ident($Int: ty); )+ ) => {\n        $(\n            doc_comment! {\n                concat!(\"An integer that is known not to equal zero.\n\nThis enables some memory layout optimization.\nFor example, `Option<\", stringify!($Ty), \">` is the same size as `\", stringify!($Int), \"`:\n\n```rust\nuse std::mem::size_of;\nassert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", stringify!($Int),\n\">());\n```\"),\n                #[$stability]\n                #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n                #[repr(transparent)]\n                #[rustc_layout_scalar_valid_range_start(1)]\n                #[rustc_nonnull_optimization_guaranteed]\n                pub struct $Ty($Int);\n            }\n\n            impl $Ty {\n                /// Creates a non-zero without checking the value.\n                ///\n                /// # Safety\n                ///\n                /// The value must not be zero.\n                #[$stability]\n                #[rustc_const_stable(feature = \"nonzero\", since = \"1.34.0\")]\n                #[inline]\n                pub const unsafe fn new_unchecked(n: $Int) -> Self {\n}\n\n                /// Creates a non-zero if the given value is not zero.\n                #[$stability]\n                #[inline]\n                pub fn new(n: $Int) -> Option<Self> {\n}\n\n                /// Returns the value as a primitive type.\n                #[$stability]\n                #[inline]\n                #[rustc_const_stable(feature = \"nonzero\", since = \"1.34.0\")]\n                pub const fn get(self) -> $Int {\n}\n\n            }\n\n            #[stable(feature = \"from_nonzero\", since = \"1.31.0\")]\n            impl From<$Ty> for $Int {\n                fn from(nonzero: $Ty) -> Self {\n}\n            }\n\n            impl_nonzero_fmt! {\n                #[$stability] (Debug, Display, Binary, Octal, LowerHex, UpperHex) for $Ty\n            }\n        )+\n    }\n}\n\nnonzero_integers! {\n    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU8(u8);\n    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU16(u16);\n    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU32(u32);\n    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU64(u64);\n    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU128(u128);\n    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroUsize(usize);\n    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI8(i8);\n    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI16(i16);\n    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI32(i32);\n    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI64(i64);\n    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI128(i128);\n    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroIsize(isize);\n}\n\nmacro_rules! from_str_radix_nzint_impl {\n    ($($t:ty)*) => {$(\n        #[stable(feature = \"nonzero_parse\", since = \"1.35.0\")]\n        impl FromStr for $t {\n            type Err = ParseIntError;\n            fn from_str(src: &str) -> Result<Self, Self::Err> {\n}\n        }\n    )*}\n}\n\nfrom_str_radix_nzint_impl! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize\nNonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize }\n\n/// Provides intentionally-wrapped arithmetic on `T`.\n///\n/// Operations like `+` on `u32` values are intended to never overflow,\n/// and in some debug configurations overflow is detected and results\n/// in a panic. While most arithmetic falls into this category, some\n/// code explicitly expects and relies upon modular arithmetic (e.g.,\n/// hashing).\n///\n/// Wrapping arithmetic can be achieved either through methods like\n/// `wrapping_add`, or through the `Wrapping<T>` type, which says that\n/// all standard arithmetic operations on the underlying value are\n/// intended to have wrapping semantics.\n///\n/// The underlying value can be retrieved through the `.0` index of the\n/// `Wrapping` tuple.\n///\n/// # Examples\n///\n/// ```\n/// use std::num::Wrapping;\n///\n/// let zero = Wrapping(0u32);\n/// let one = Wrapping(1u32);\n///\n/// assert_eq!(std::u32::MAX, (zero - one).0);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\n#[repr(transparent)]\npub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"wrapping_display\", since = \"1.10.0\")]\nimpl<T: fmt::Display> fmt::Display for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::Binary> fmt::Binary for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::Octal> fmt::Octal for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::LowerHex> fmt::LowerHex for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"wrapping_fmt\", since = \"1.11.0\")]\nimpl<T: fmt::UpperHex> fmt::UpperHex for Wrapping<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n// All these modules are technically private and only exposed for coretests:\npub mod bignum {\n//! Custom arbitrary-precision number (bignum) implementation.\n//!\n//! This is designed to avoid the heap allocation at expense of stack memory.\n//! The most used bignum type, `Big32x40`, is limited by 32 × 40 = 1,280 bits\n//! and will take at most 160 bytes of stack memory. This is more than enough\n//! for round-tripping all possible finite `f64` values.\n//!\n//! In principle it is possible to have multiple bignum types for different\n//! inputs, but we don't do so to avoid the code bloat. Each bignum is still\n//! tracked for the actual usages, so it normally doesn't matter.\n\n// This module is only for dec2flt and flt2dec, and only public because of coretests.\n// It is not intended to ever be stabilized.\n#![doc(hidden)]\n#![unstable(\n    feature = \"core_private_bignum\",\n    reason = \"internal routines only exposed for testing\",\n    issue = \"none\"\n)]\n#![macro_use]\n\nuse crate::intrinsics;\nuse crate::mem;\n\n/// Arithmetic operations required by bignums.\npub trait FullOps: Sized {\n    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`,\n    /// where `W` is the number of bits in `Self`.\n    fn full_add(self, other: Self, carry: bool) -> (bool /* carry */, Self);\n\n    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + carry`,\n    /// where `W` is the number of bits in `Self`.\n    fn full_mul(self, other: Self, carry: Self) -> (Self /* carry */, Self);\n\n    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + other2 + carry`,\n    /// where `W` is the number of bits in `Self`.\n    fn full_mul_add(self, other: Self, other2: Self, carry: Self) -> (Self /* carry */, Self);\n\n    /// Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem`\n    /// and `0 <= rem < other`, where `W` is the number of bits in `Self`.\n    fn full_div_rem(self, other: Self, borrow: Self)\n    -> (Self /* quotient */, Self /* remainder */);\n}\n\nmacro_rules! impl_full_ops {\n    ($($ty:ty: add($addfn:path), mul/div($bigty:ident);)*) => (\n        $(\n            impl FullOps for $ty {\n                fn full_add(self, other: $ty, carry: bool) -> (bool, $ty) {\n}\n\n                fn full_mul(self, other: $ty, carry: $ty) -> ($ty, $ty) {\n}\n\n                fn full_mul_add(self, other: $ty, other2: $ty, carry: $ty) -> ($ty, $ty) {\n}\n\n                fn full_div_rem(self, other: $ty, borrow: $ty) -> ($ty, $ty) {\n}\n            }\n        )*\n    )\n}\n\nimpl_full_ops! {\n    u8:  add(intrinsics::u8_add_with_overflow),  mul/div(u16);\n    u16: add(intrinsics::u16_add_with_overflow), mul/div(u32);\n    u32: add(intrinsics::u32_add_with_overflow), mul/div(u64);\n    // See RFC #521 for enabling this.\n    // u64: add(intrinsics::u64_add_with_overflow), mul/div(u128);\n}\n\n/// Table of powers of 5 representable in digits. Specifically, the largest {u8, u16, u32} value\n/// that's a power of five, plus the corresponding exponent. Used in `mul_pow5`.\nconst SMALL_POW5: [(u64, usize); 3] = [(125, 3), (15625, 6), (1_220_703_125, 13)];\n\nmacro_rules! define_bignum {\n    ($name:ident: type=$ty:ty, n=$n:expr) => {\n        /// Stack-allocated arbitrary-precision (up to certain limit) integer.\n        ///\n        /// This is backed by a fixed-size array of given type (\"digit\").\n        /// While the array is not very large (normally some hundred bytes),\n        /// copying it recklessly may result in the performance hit.\n        /// Thus this is intentionally not `Copy`.\n        ///\n        /// All operations available to bignums panic in the case of overflows.\n        /// The caller is responsible to use large enough bignum types.\n        pub struct $name {\n            /// One plus the offset to the maximum \"digit\" in use.\n            /// This does not decrease, so be aware of the computation order.\n            /// `base[size..]` should be zero.\n            size: usize,\n            /// Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n            /// where `W` is the number of bits in the digit type.\n            base: [$ty; $n],\n        }\n\n        impl $name {\n            /// Makes a bignum from one digit.\n            pub fn from_small(v: $ty) -> $name {\n}\n\n            /// Makes a bignum from `u64` value.\n            pub fn from_u64(mut v: u64) -> $name {\n}\n\n            /// Returns the internal digits as a slice `[a, b, c, ...]` such that the numeric\n            /// value is `a + b * 2^W + c * 2^(2W) + ...` where `W` is the number of bits in\n            /// the digit type.\n            pub fn digits(&self) -> &[$ty] {\n}\n\n            /// Returns the `i`-th bit where bit 0 is the least significant one.\n            /// In other words, the bit with weight `2^i`.\n            pub fn get_bit(&self, i: usize) -> u8 {\n}\n\n            /// Returns `true` if the bignum is zero.\n            pub fn is_zero(&self) -> bool {\n}\n\n            /// Returns the number of bits necessary to represent this value. Note that zero\n            /// is considered to need 0 bits.\n            pub fn bit_length(&self) -> usize {\n}\n\n            /// Adds `other` to itself and returns its own mutable reference.\n            pub fn add<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n}\n\n            pub fn add_small(&mut self, other: $ty) -> &mut $name {\n}\n\n            /// Subtracts `other` from itself and returns its own mutable reference.\n            pub fn sub<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n}\n\n            /// Multiplies itself by a digit-sized `other` and returns its own\n            /// mutable reference.\n            pub fn mul_small(&mut self, other: $ty) -> &mut $name {\n}\n\n            /// Multiplies itself by `2^bits` and returns its own mutable reference.\n            pub fn mul_pow2(&mut self, bits: usize) -> &mut $name {\n}\n\n            /// Multiplies itself by `5^e` and returns its own mutable reference.\n            pub fn mul_pow5(&mut self, mut e: usize) -> &mut $name {\n}\n\n            /// Multiplies itself by a number described by `other[0] + other[1] * 2^W +\n            /// other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type)\n            /// and returns its own mutable reference.\n            pub fn mul_digits<'a>(&'a mut self, other: &[$ty]) -> &'a mut $name {\n}\n\n            /// Divides itself by a digit-sized `other` and returns its own\n            /// mutable reference *and* the remainder.\n            pub fn div_rem_small(&mut self, other: $ty) -> (&mut $name, $ty) {\n}\n\n            /// Divide self by another bignum, overwriting `q` with the quotient and `r` with the\n            /// remainder.\n            pub fn div_rem(&self, d: &$name, q: &mut $name, r: &mut $name) {\n}\n        }\n\n        impl crate::cmp::PartialEq for $name {\n            fn eq(&self, other: &$name) -> bool {\n}\n        }\n\n        impl crate::cmp::Eq for $name {}\n\n        impl crate::cmp::PartialOrd for $name {\n            fn partial_cmp(&self, other: &$name) -> crate::option::Option<crate::cmp::Ordering> {\n}\n        }\n\n        impl crate::cmp::Ord for $name {\n            fn cmp(&self, other: &$name) -> crate::cmp::Ordering {\n}\n        }\n\n        impl crate::clone::Clone for $name {\n            fn clone(&self) -> Self {\n}\n        }\n\n        impl crate::fmt::Debug for $name {\n            fn fmt(&self, f: &mut crate::fmt::Formatter<'_>) -> crate::fmt::Result {\n}\n        }\n    };\n}\n\n/// The digit type for `Big32x40`.\npub type Digit32 = u32;\n\ndefine_bignum!(Big32x40: type=Digit32, n=40);\n\n// this one is used for testing only.\n#[doc(hidden)]\npub mod tests {\n    define_bignum!(Big8x3: type=u8, n=3);\n}\n}\npub mod dec2flt {\n//! Converting decimal strings into IEEE 754 binary floating point numbers.\n//!\n//! # Problem statement\n//!\n//! We are given a decimal string such as `12.34e56`. This string consists of integral (`12`),\n//! fractional (`45`), and exponent (`56`) parts. All parts are optional and interpreted as zero\n//! when missing.\n//!\n//! We seek the IEEE 754 floating point number that is closest to the exact value of the decimal\n//! string. It is well-known that many decimal strings do not have terminating representations in\n//! base two, so we round to 0.5 units in the last place (in other words, as well as possible).\n//! Ties, decimal values exactly half-way between two consecutive floats, are resolved with the\n//! half-to-even strategy, also known as banker's rounding.\n//!\n//! Needless to say, this is quite hard, both in terms of implementation complexity and in terms\n//! of CPU cycles taken.\n//!\n//! # Implementation\n//!\n//! First, we ignore signs. Or rather, we remove it at the very beginning of the conversion\n//! process and re-apply it at the very end. This is correct in all edge cases since IEEE\n//! floats are symmetric around zero, negating one simply flips the first bit.\n//!\n//! Then we remove the decimal point by adjusting the exponent: Conceptually, `12.34e56` turns\n//! into `1234e54`, which we describe with a positive integer `f = 1234` and an integer `e = 54`.\n//! The `(f, e)` representation is used by almost all code past the parsing stage.\n//!\n//! We then try a long chain of progressively more general and expensive special cases using\n//! machine-sized integers and small, fixed-sized floating point numbers (first `f32`/`f64`, then\n//! a type with 64 bit significand, `Fp`). When all these fail, we bite the bullet and resort to a\n//! simple but very slow algorithm that involved computing `f * 10^e` fully and doing an iterative\n//! search for the best approximation.\n//!\n//! Primarily, this module and its children implement the algorithms described in:\n//! \"How to Read Floating Point Numbers Accurately\" by William D. Clinger,\n//! available online: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4152\n//!\n//! In addition, there are numerous helper functions that are used in the paper but not available\n//! in Rust (or at least in core). Our version is additionally complicated by the need to handle\n//! overflow and underflow and the desire to handle subnormal numbers. Bellerophon and\n//! Algorithm R have trouble with overflow, subnormals, and underflow. We conservatively switch to\n//! Algorithm M (with the modifications described in section 8 of the paper) well before the\n//! inputs get into the critical region.\n//!\n//! Another aspect that needs attention is the ``RawFloat`` trait by which almost all functions\n//! are parametrized. One might think that it's enough to parse to `f64` and cast the result to\n//! `f32`. Unfortunately this is not the world we live in, and this has nothing to do with using\n//! base two or half-to-even rounding.\n//!\n//! Consider for example two types `d2` and `d4` representing a decimal type with two decimal\n//! digits and four decimal digits each and take \"0.01499\" as input. Let's use half-up rounding.\n//! Going directly to two decimal digits gives `0.01`, but if we round to four digits first,\n//! we get `0.0150`, which is then rounded up to `0.02`. The same principle applies to other\n//! operations as well, if you want 0.5 ULP accuracy you need to do *everything* in full precision\n//! and round *exactly once, at the end*, by considering all truncated bits at once.\n//!\n//! FIXME: Although some code duplication is necessary, perhaps parts of the code could be shuffled\n//! around such that less code is duplicated. Large parts of the algorithms are independent of the\n//! float type to output, or only needs access to a few constants, which could be passed in as\n//! parameters.\n//!\n//! # Other\n//!\n//! The conversion should *never* panic. There are assertions and explicit panics in the code,\n//! but they should never be triggered and only serve as internal sanity checks. Any panics should\n//! be considered a bug.\n//!\n//! There are unit tests but they are woefully inadequate at ensuring correctness, they only cover\n//! a small percentage of possible errors. Far more extensive tests are located in the directory\n//! `src/etc/test-float-parse` as a Python script.\n//!\n//! A note on integer overflow: Many parts of this file perform arithmetic with the decimal\n//! exponent `e`. Primarily, we shift the decimal point around: Before the first decimal digit,\n//! after the last decimal digit, and so on. This could overflow if done carelessly. We rely on\n//! the parsing submodule to only hand out sufficiently small exponents, where \"sufficient\" means\n//! \"such that the exponent +/- the number of decimal digits fits into a 64 bit integer\".\n//! Larger exponents are accepted, but we don't do arithmetic with them, they are immediately\n//! turned into {positive,negative} {zero,infinity}.\n\n#![doc(hidden)]\n#![unstable(\n    feature = \"dec2flt\",\n    reason = \"internal routines only exposed for testing\",\n    issue = \"none\"\n)]\n\nuse crate::fmt;\nuse crate::str::FromStr;\n\nuse self::num::digits_to_big;\nuse self::parse::{parse_decimal, Decimal, ParseResult, Sign};\nuse self::rawfp::RawFloat;\n\nmod algorithm {\n//! The various algorithms from the paper.\n\nuse crate::cmp::min;\nuse crate::cmp::Ordering::{Equal, Greater, Less};\nuse crate::num::dec2flt::num::{self, Big};\nuse crate::num::dec2flt::rawfp::{self, fp_to_float, next_float, prev_float, RawFloat, Unpacked};\nuse crate::num::dec2flt::table;\nuse crate::num::diy_float::Fp;\n\n/// Number of significand bits in Fp\nconst P: u32 = 64;\n\n// We simply store the best approximation for *all* exponents, so the variable \"h\" and the\n// associated conditions can be omitted. This trades performance for a couple kilobytes of space.\n\nfn power_of_ten(e: i16) -> Fp {\n}\n\n// In most architectures, floating point operations have an explicit bit size, therefore the\n// precision of the computation is determined on a per-operation basis.\n#[cfg(any(not(target_arch = \"x86\"), target_feature = \"sse2\"))]\nmod fpu_precision {\n    pub fn set_precision<T>() {}}\n\n// On x86, the x87 FPU is used for float operations if the SSE/SSE2 extensions are not available.\n// The x87 FPU operates with 80 bits of precision by default, which means that operations will\n// round to 80 bits causing double rounding to happen when values are eventually represented as\n// 32/64 bit float values. To overcome this, the FPU control word can be set so that the\n// computations are performed in the desired precision.\n#[cfg(all(target_arch = \"x86\", not(target_feature = \"sse2\")))]\nmod fpu_precision {\n    use crate::mem::size_of;\n\n    /// A structure used to preserve the original value of the FPU control word, so that it can be\n    /// restored when the structure is dropped.\n    ///\n    /// The x87 FPU is a 16-bits register whose fields are as follows:\n    ///\n    /// | 12-15 | 10-11 | 8-9 | 6-7 |  5 |  4 |  3 |  2 |  1 |  0 |\n    /// |------:|------:|----:|----:|---:|---:|---:|---:|---:|---:|\n    /// |       | RC    | PC  |     | PM | UM | OM | ZM | DM | IM |\n    ///\n    /// The documentation for all of the fields is available in the IA-32 Architectures Software\n    /// Developer's Manual (Volume 1).\n    ///\n    /// The only field which is relevant for the following code is PC, Precision Control. This\n    /// field determines the precision of the operations performed by the  FPU. It can be set to:\n    ///  - 0b00, single precision i.e., 32-bits\n    ///  - 0b10, double precision i.e., 64-bits\n    ///  - 0b11, double extended precision i.e., 80-bits (default state)\n    /// The 0b01 value is reserved and should not be used.\n    pub struct FPUControlWord(u16);\n\n    fn set_cw(cw: u16) {\n}\n\n    /// Sets the precision field of the FPU to `T` and returns a `FPUControlWord`.\n    pub fn set_precision<T>() -> FPUControlWord {\n}\n\n    impl Drop for FPUControlWord {\n        fn drop(&mut self) {\n}\n    }\n}\n\n/// The fast path of Bellerophon using machine-sized integers and floats.\n///\n/// This is extracted into a separate function so that it can be attempted before constructing\n/// a bignum.\npub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Option<T> {\n}\n\n/// Algorithm Bellerophon is trivial code justified by non-trivial numeric analysis.\n///\n/// It rounds ``f`` to a float with 64 bit significand and multiplies it by the best approximation\n/// of `10^e` (in the same floating point format). This is often enough to get the correct result.\n/// However, when the result is close to halfway between two adjacent (ordinary) floats, the\n/// compound rounding error from multiplying two approximation means the result may be off by a\n/// few bits. When this happens, the iterative Algorithm R fixes things up.\n///\n/// The hand-wavy \"close to halfway\" is made precise by the numeric analysis in the paper.\n/// In the words of Clinger:\n///\n/// > Slop, expressed in units of the least significant bit, is an inclusive bound for the error\n/// > accumulated during the floating point calculation of the approximation to f * 10^e. (Slop is\n/// > not a bound for the true error, but bounds the difference between the approximation z and\n/// > the best possible approximation that uses p bits of significand.)\npub fn bellerophon<T: RawFloat>(f: &Big, e: i16) -> T {\n}\n\n/// An iterative algorithm that improves a floating point approximation of `f * 10^e`.\n///\n/// Each iteration gets one unit in the last place closer, which of course takes terribly long to\n/// converge if `z0` is even mildly off. Luckily, when used as fallback for Bellerophon, the\n/// starting approximation is off by at most one ULP.\nfn algorithm_r<T: RawFloat>(f: &Big, e: i16, z0: T) -> T {\n}\n\n/// Given `x = f` and `y = m` where `f` represent input decimal digits as usual and `m` is the\n/// significand of a floating point approximation, make the ratio `x / y` equal to\n/// `(f * 10^e) / (m * 2^k)`, possibly reduced by a power of two both have in common.\nfn make_ratio(x: &mut Big, y: &mut Big, e: i16, k: i16) {\n}\n\n/// Conceptually, Algorithm M is the simplest way to convert a decimal to a float.\n///\n/// We form a ratio that is equal to `f * 10^e`, then throwing in powers of two until it gives\n/// a valid float significand. The binary exponent `k` is the number of times we multiplied\n/// numerator or denominator by two, i.e., at all times `f * 10^e` equals `(u / v) * 2^k`.\n/// When we have found out significand, we only need to round by inspecting the remainder of the\n/// division, which is done in helper functions further below.\n///\n/// This algorithm is super slow, even with the optimization described in `quick_start()`.\n/// However, it's the simplest of the algorithms to adapt for overflow, underflow, and subnormal\n/// results. This implementation takes over when Bellerophon and Algorithm R are overwhelmed.\n/// Detecting underflow and overflow is easy: The ratio still isn't an in-range significand,\n/// yet the minimum/maximum exponent has been reached. In the case of overflow, we simply return\n/// infinity.\n///\n/// Handling underflow and subnormals is trickier. One big problem is that, with the minimum\n/// exponent, the ratio might still be too large for a significand. See underflow() for details.\npub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n}\n\n/// Skips over most Algorithm M iterations by checking the bit length.\nfn quick_start<T: RawFloat>(u: &mut Big, v: &mut Big, k: &mut i16) {\n}\n\nfn underflow<T: RawFloat>(x: Big, v: Big, rem: Big) -> T {\n}\n\n/// Ordinary round-to-even, obfuscated by having to round based on the remainder of a division.\nfn round_by_remainder<T: RawFloat>(v: Big, r: Big, q: u64, z: T) -> T {\n}\n}\nmod num {\n//! Utility functions for bignums that don't make too much sense to turn into methods.\n\n// FIXME This module's name is a bit unfortunate, since other modules also import `core::num`.\n\nuse crate::cmp::Ordering::{self, Equal, Greater, Less};\n\npub use crate::num::bignum::Big32x40 as Big;\n\n/// Test whether truncating all bits less significant than `ones_place` introduces\n/// a relative error less, equal, or greater than 0.5 ULP.\npub fn compare_with_half_ulp(f: &Big, ones_place: usize) -> Ordering {\n}\n\n/// Converts an ASCII string containing only decimal digits to a `u64`.\n///\n/// Does not perform checks for overflow or invalid characters, so if the caller is not careful,\n/// the result is bogus and can panic (though it won't be `unsafe`). Additionally, empty strings\n/// are treated as zero. This function exists because\n///\n/// 1. using `FromStr` on `&[u8]` requires `from_utf8_unchecked`, which is bad, and\n/// 2. piecing together the results of `integral.parse()` and `fractional.parse()` is\n///    more complicated than this entire function.\npub fn from_str_unchecked<'a, T>(bytes: T) -> u64\nwhere\n    T: IntoIterator<Item = &'a u8>,\n{\n}\n\n/// Converts a string of ASCII digits into a bignum.\n///\n/// Like `from_str_unchecked`, this function relies on the parser to weed out non-digits.\npub fn digits_to_big(integral: &[u8], fractional: &[u8]) -> Big {\n}\n\n/// Unwraps a bignum into a 64 bit integer. Panics if the number is too large.\npub fn to_u64(x: &Big) -> u64 {\n}\n\n/// Extracts a range of bits.\n\n/// Index 0 is the least significant bit and the range is half-open as usual.\n/// Panics if asked to extract more bits than fit into the return type.\npub fn get_bits(x: &Big, start: usize, end: usize) -> u64 {\n}\n}\nmod table {\n//! Tables of approximations of powers of ten.\n//! DO NOT MODIFY: Generated by `src/etc/dec2flt_table.py`\n\npub const MIN_E: i16 = -305;\npub const MAX_E: i16 = 305;\n\n#[rustfmt::skip]\npub const POWERS: ([u64; 611], [i16; 611]) = (\n    [\n        0xe0b62e2929aba83c,\n        0x8c71dcd9ba0b4926,\n        0xaf8e5410288e1b6f,\n        0xdb71e91432b1a24b,\n        0x892731ac9faf056f,\n        0xab70fe17c79ac6ca,\n        0xd64d3d9db981787d,\n        0x85f0468293f0eb4e,\n        0xa76c582338ed2622,\n        0xd1476e2c07286faa,\n        0x82cca4db847945ca,\n        0xa37fce126597973d,\n        0xcc5fc196fefd7d0c,\n        0xff77b1fcbebcdc4f,\n        0x9faacf3df73609b1,\n        0xc795830d75038c1e,\n        0xf97ae3d0d2446f25,\n        0x9becce62836ac577,\n        0xc2e801fb244576d5,\n        0xf3a20279ed56d48a,\n        0x9845418c345644d7,\n        0xbe5691ef416bd60c,\n        0xedec366b11c6cb8f,\n        0x94b3a202eb1c3f39,\n        0xb9e08a83a5e34f08,\n        0xe858ad248f5c22ca,\n        0x91376c36d99995be,\n        0xb58547448ffffb2e,\n        0xe2e69915b3fff9f9,\n        0x8dd01fad907ffc3c,\n        0xb1442798f49ffb4b,\n        0xdd95317f31c7fa1d,\n        0x8a7d3eef7f1cfc52,\n        0xad1c8eab5ee43b67,\n        0xd863b256369d4a41,\n        0x873e4f75e2224e68,\n        0xa90de3535aaae202,\n        0xd3515c2831559a83,\n        0x8412d9991ed58092,\n        0xa5178fff668ae0b6,\n        0xce5d73ff402d98e4,\n        0x80fa687f881c7f8e,\n        0xa139029f6a239f72,\n        0xc987434744ac874f,\n        0xfbe9141915d7a922,\n        0x9d71ac8fada6c9b5,\n        0xc4ce17b399107c23,\n        0xf6019da07f549b2b,\n        0x99c102844f94e0fb,\n        0xc0314325637a193a,\n        0xf03d93eebc589f88,\n        0x96267c7535b763b5,\n        0xbbb01b9283253ca3,\n        0xea9c227723ee8bcb,\n        0x92a1958a7675175f,\n        0xb749faed14125d37,\n        0xe51c79a85916f485,\n        0x8f31cc0937ae58d3,\n        0xb2fe3f0b8599ef08,\n        0xdfbdcece67006ac9,\n        0x8bd6a141006042be,\n        0xaecc49914078536d,\n        0xda7f5bf590966849,\n        0x888f99797a5e012d,\n        0xaab37fd7d8f58179,\n        0xd5605fcdcf32e1d7,\n        0x855c3be0a17fcd26,\n        0xa6b34ad8c9dfc070,\n        0xd0601d8efc57b08c,\n        0x823c12795db6ce57,\n        0xa2cb1717b52481ed,\n        0xcb7ddcdda26da269,\n        0xfe5d54150b090b03,\n        0x9efa548d26e5a6e2,\n        0xc6b8e9b0709f109a,\n        0xf867241c8cc6d4c1,\n        0x9b407691d7fc44f8,\n        0xc21094364dfb5637,\n        0xf294b943e17a2bc4,\n        0x979cf3ca6cec5b5b,\n        0xbd8430bd08277231,\n        0xece53cec4a314ebe,\n        0x940f4613ae5ed137,\n        0xb913179899f68584,\n        0xe757dd7ec07426e5,\n        0x9096ea6f3848984f,\n        0xb4bca50b065abe63,\n        0xe1ebce4dc7f16dfc,\n        0x8d3360f09cf6e4bd,\n        0xb080392cc4349ded,\n        0xdca04777f541c568,\n        0x89e42caaf9491b61,\n        0xac5d37d5b79b6239,\n        0xd77485cb25823ac7,\n        0x86a8d39ef77164bd,\n        0xa8530886b54dbdec,\n        0xd267caa862a12d67,\n        0x8380dea93da4bc60,\n        0xa46116538d0deb78,\n        0xcd795be870516656,\n        0x806bd9714632dff6,\n        0xa086cfcd97bf97f4,\n        0xc8a883c0fdaf7df0,\n        0xfad2a4b13d1b5d6c,\n        0x9cc3a6eec6311a64,\n        0xc3f490aa77bd60fd,\n        0xf4f1b4d515acb93c,\n        0x991711052d8bf3c5,\n        0xbf5cd54678eef0b7,\n        0xef340a98172aace5,\n        0x9580869f0e7aac0f,\n        0xbae0a846d2195713,\n        0xe998d258869facd7,\n        0x91ff83775423cc06,\n        0xb67f6455292cbf08,\n        0xe41f3d6a7377eeca,\n        0x8e938662882af53e,\n        0xb23867fb2a35b28e,\n        0xdec681f9f4c31f31,\n        0x8b3c113c38f9f37f,\n        0xae0b158b4738705f,\n        0xd98ddaee19068c76,\n        0x87f8a8d4cfa417ca,\n        0xa9f6d30a038d1dbc,\n        0xd47487cc8470652b,\n        0x84c8d4dfd2c63f3b,\n        0xa5fb0a17c777cf0a,\n        0xcf79cc9db955c2cc,\n        0x81ac1fe293d599c0,\n        0xa21727db38cb0030,\n        0xca9cf1d206fdc03c,\n        0xfd442e4688bd304b,\n        0x9e4a9cec15763e2f,\n        0xc5dd44271ad3cdba,\n        0xf7549530e188c129,\n        0x9a94dd3e8cf578ba,\n        0xc13a148e3032d6e8,\n        0xf18899b1bc3f8ca2,\n        0x96f5600f15a7b7e5,\n        0xbcb2b812db11a5de,\n        0xebdf661791d60f56,\n        0x936b9fcebb25c996,\n        0xb84687c269ef3bfb,\n        0xe65829b3046b0afa,\n        0x8ff71a0fe2c2e6dc,\n        0xb3f4e093db73a093,\n        0xe0f218b8d25088b8,\n        0x8c974f7383725573,\n        0xafbd2350644eead0,\n        0xdbac6c247d62a584,\n        0x894bc396ce5da772,\n        0xab9eb47c81f5114f,\n        0xd686619ba27255a3,\n        0x8613fd0145877586,\n        0xa798fc4196e952e7,\n        0xd17f3b51fca3a7a1,\n        0x82ef85133de648c5,\n        0xa3ab66580d5fdaf6,\n        0xcc963fee10b7d1b3,\n        0xffbbcfe994e5c620,\n        0x9fd561f1fd0f9bd4,\n        0xc7caba6e7c5382c9,\n        0xf9bd690a1b68637b,\n        0x9c1661a651213e2d,\n        0xc31bfa0fe5698db8,\n        0xf3e2f893dec3f126,\n        0x986ddb5c6b3a76b8,\n        0xbe89523386091466,\n        0xee2ba6c0678b597f,\n        0x94db483840b717f0,\n        0xba121a4650e4ddec,\n        0xe896a0d7e51e1566,\n        0x915e2486ef32cd60,\n        0xb5b5ada8aaff80b8,\n        0xe3231912d5bf60e6,\n        0x8df5efabc5979c90,\n        0xb1736b96b6fd83b4,\n        0xddd0467c64bce4a1,\n        0x8aa22c0dbef60ee4,\n        0xad4ab7112eb3929e,\n        0xd89d64d57a607745,\n        0x87625f056c7c4a8b,\n        0xa93af6c6c79b5d2e,\n        0xd389b47879823479,\n        0x843610cb4bf160cc,\n        0xa54394fe1eedb8ff,\n        0xce947a3da6a9273e,\n        0x811ccc668829b887,\n        0xa163ff802a3426a9,\n        0xc9bcff6034c13053,\n        0xfc2c3f3841f17c68,\n        0x9d9ba7832936edc1,\n        0xc5029163f384a931,\n        0xf64335bcf065d37d,\n        0x99ea0196163fa42e,\n        0xc06481fb9bcf8d3a,\n        0xf07da27a82c37088,\n        0x964e858c91ba2655,\n        0xbbe226efb628afeb,\n        0xeadab0aba3b2dbe5,\n        0x92c8ae6b464fc96f,\n        0xb77ada0617e3bbcb,\n        0xe55990879ddcaabe,\n        0x8f57fa54c2a9eab7,\n        0xb32df8e9f3546564,\n        0xdff9772470297ebd,\n        0x8bfbea76c619ef36,\n        0xaefae51477a06b04,\n        0xdab99e59958885c5,\n        0x88b402f7fd75539b,\n        0xaae103b5fcd2a882,\n        0xd59944a37c0752a2,\n        0x857fcae62d8493a5,\n        0xa6dfbd9fb8e5b88f,\n        0xd097ad07a71f26b2,\n        0x825ecc24c8737830,\n        0xa2f67f2dfa90563b,\n        0xcbb41ef979346bca,\n        0xfea126b7d78186bd,\n        0x9f24b832e6b0f436,\n        0xc6ede63fa05d3144,\n        0xf8a95fcf88747d94,\n        0x9b69dbe1b548ce7d,\n        0xc24452da229b021c,\n        0xf2d56790ab41c2a3,\n        0x97c560ba6b0919a6,\n        0xbdb6b8e905cb600f,\n        0xed246723473e3813,\n        0x9436c0760c86e30c,\n        0xb94470938fa89bcf,\n        0xe7958cb87392c2c3,\n        0x90bd77f3483bb9ba,\n        0xb4ecd5f01a4aa828,\n        0xe2280b6c20dd5232,\n        0x8d590723948a535f,\n        0xb0af48ec79ace837,\n        0xdcdb1b2798182245,\n        0x8a08f0f8bf0f156b,\n        0xac8b2d36eed2dac6,\n        0xd7adf884aa879177,\n        0x86ccbb52ea94baeb,\n        0xa87fea27a539e9a5,\n        0xd29fe4b18e88640f,\n        0x83a3eeeef9153e89,\n        0xa48ceaaab75a8e2b,\n        0xcdb02555653131b6,\n        0x808e17555f3ebf12,\n        0xa0b19d2ab70e6ed6,\n        0xc8de047564d20a8c,\n        0xfb158592be068d2f,\n        0x9ced737bb6c4183d,\n        0xc428d05aa4751e4d,\n        0xf53304714d9265e0,\n        0x993fe2c6d07b7fac,\n        0xbf8fdb78849a5f97,\n        0xef73d256a5c0f77d,\n        0x95a8637627989aae,\n        0xbb127c53b17ec159,\n        0xe9d71b689dde71b0,\n        0x9226712162ab070e,\n        0xb6b00d69bb55c8d1,\n        0xe45c10c42a2b3b06,\n        0x8eb98a7a9a5b04e3,\n        0xb267ed1940f1c61c,\n        0xdf01e85f912e37a3,\n        0x8b61313bbabce2c6,\n        0xae397d8aa96c1b78,\n        0xd9c7dced53c72256,\n        0x881cea14545c7575,\n        0xaa242499697392d3,\n        0xd4ad2dbfc3d07788,\n        0x84ec3c97da624ab5,\n        0xa6274bbdd0fadd62,\n        0xcfb11ead453994ba,\n        0x81ceb32c4b43fcf5,\n        0xa2425ff75e14fc32,\n        0xcad2f7f5359a3b3e,\n        0xfd87b5f28300ca0e,\n        0x9e74d1b791e07e48,\n        0xc612062576589ddb,\n        0xf79687aed3eec551,\n        0x9abe14cd44753b53,\n        0xc16d9a0095928a27,\n        0xf1c90080baf72cb1,\n        0x971da05074da7bef,\n        0xbce5086492111aeb,\n        0xec1e4a7db69561a5,\n        0x9392ee8e921d5d07,\n        0xb877aa3236a4b449,\n        0xe69594bec44de15b,\n        0x901d7cf73ab0acd9,\n        0xb424dc35095cd80f,\n        0xe12e13424bb40e13,\n        0x8cbccc096f5088cc,\n        0xafebff0bcb24aaff,\n        0xdbe6fecebdedd5bf,\n        0x89705f4136b4a597,\n        0xabcc77118461cefd,\n        0xd6bf94d5e57a42bc,\n        0x8637bd05af6c69b6,\n        0xa7c5ac471b478423,\n        0xd1b71758e219652c,\n        0x83126e978d4fdf3b,\n        0xa3d70a3d70a3d70a,\n        0xcccccccccccccccd,\n        0x8000000000000000,\n        0xa000000000000000,\n        0xc800000000000000,\n        0xfa00000000000000,\n        0x9c40000000000000,\n        0xc350000000000000,\n        0xf424000000000000,\n        0x9896800000000000,\n        0xbebc200000000000,\n        0xee6b280000000000,\n        0x9502f90000000000,\n        0xba43b74000000000,\n        0xe8d4a51000000000,\n        0x9184e72a00000000,\n        0xb5e620f480000000,\n        0xe35fa931a0000000,\n        0x8e1bc9bf04000000,\n        0xb1a2bc2ec5000000,\n        0xde0b6b3a76400000,\n        0x8ac7230489e80000,\n        0xad78ebc5ac620000,\n        0xd8d726b7177a8000,\n        0x878678326eac9000,\n        0xa968163f0a57b400,\n        0xd3c21bcecceda100,\n        0x84595161401484a0,\n        0xa56fa5b99019a5c8,\n        0xcecb8f27f4200f3a,\n        0x813f3978f8940984,\n        0xa18f07d736b90be5,\n        0xc9f2c9cd04674edf,\n        0xfc6f7c4045812296,\n        0x9dc5ada82b70b59e,\n        0xc5371912364ce305,\n        0xf684df56c3e01bc7,\n        0x9a130b963a6c115c,\n        0xc097ce7bc90715b3,\n        0xf0bdc21abb48db20,\n        0x96769950b50d88f4,\n        0xbc143fa4e250eb31,\n        0xeb194f8e1ae525fd,\n        0x92efd1b8d0cf37be,\n        0xb7abc627050305ae,\n        0xe596b7b0c643c719,\n        0x8f7e32ce7bea5c70,\n        0xb35dbf821ae4f38c,\n        0xe0352f62a19e306f,\n        0x8c213d9da502de45,\n        0xaf298d050e4395d7,\n        0xdaf3f04651d47b4c,\n        0x88d8762bf324cd10,\n        0xab0e93b6efee0054,\n        0xd5d238a4abe98068,\n        0x85a36366eb71f041,\n        0xa70c3c40a64e6c52,\n        0xd0cf4b50cfe20766,\n        0x82818f1281ed44a0,\n        0xa321f2d7226895c8,\n        0xcbea6f8ceb02bb3a,\n        0xfee50b7025c36a08,\n        0x9f4f2726179a2245,\n        0xc722f0ef9d80aad6,\n        0xf8ebad2b84e0d58c,\n        0x9b934c3b330c8577,\n        0xc2781f49ffcfa6d5,\n        0xf316271c7fc3908b,\n        0x97edd871cfda3a57,\n        0xbde94e8e43d0c8ec,\n        0xed63a231d4c4fb27,\n        0x945e455f24fb1cf9,\n        0xb975d6b6ee39e437,\n        0xe7d34c64a9c85d44,\n        0x90e40fbeea1d3a4b,\n        0xb51d13aea4a488dd,\n        0xe264589a4dcdab15,\n        0x8d7eb76070a08aed,\n        0xb0de65388cc8ada8,\n        0xdd15fe86affad912,\n        0x8a2dbf142dfcc7ab,\n        0xacb92ed9397bf996,\n        0xd7e77a8f87daf7fc,\n        0x86f0ac99b4e8dafd,\n        0xa8acd7c0222311bd,\n        0xd2d80db02aabd62c,\n        0x83c7088e1aab65db,\n        0xa4b8cab1a1563f52,\n        0xcde6fd5e09abcf27,\n        0x80b05e5ac60b6178,\n        0xa0dc75f1778e39d6,\n        0xc913936dd571c84c,\n        0xfb5878494ace3a5f,\n        0x9d174b2dcec0e47b,\n        0xc45d1df942711d9a,\n        0xf5746577930d6501,\n        0x9968bf6abbe85f20,\n        0xbfc2ef456ae276e9,\n        0xefb3ab16c59b14a3,\n        0x95d04aee3b80ece6,\n        0xbb445da9ca61281f,\n        0xea1575143cf97227,\n        0x924d692ca61be758,\n        0xb6e0c377cfa2e12e,\n        0xe498f455c38b997a,\n        0x8edf98b59a373fec,\n        0xb2977ee300c50fe7,\n        0xdf3d5e9bc0f653e1,\n        0x8b865b215899f46d,\n        0xae67f1e9aec07188,\n        0xda01ee641a708dea,\n        0x884134fe908658b2,\n        0xaa51823e34a7eedf,\n        0xd4e5e2cdc1d1ea96,\n        0x850fadc09923329e,\n        0xa6539930bf6bff46,\n        0xcfe87f7cef46ff17,\n        0x81f14fae158c5f6e,\n        0xa26da3999aef774a,\n        0xcb090c8001ab551c,\n        0xfdcb4fa002162a63,\n        0x9e9f11c4014dda7e,\n        0xc646d63501a1511e,\n        0xf7d88bc24209a565,\n        0x9ae757596946075f,\n        0xc1a12d2fc3978937,\n        0xf209787bb47d6b85,\n        0x9745eb4d50ce6333,\n        0xbd176620a501fc00,\n        0xec5d3fa8ce427b00,\n        0x93ba47c980e98ce0,\n        0xb8a8d9bbe123f018,\n        0xe6d3102ad96cec1e,\n        0x9043ea1ac7e41393,\n        0xb454e4a179dd1877,\n        0xe16a1dc9d8545e95,\n        0x8ce2529e2734bb1d,\n        0xb01ae745b101e9e4,\n        0xdc21a1171d42645d,\n        0x899504ae72497eba,\n        0xabfa45da0edbde69,\n        0xd6f8d7509292d603,\n        0x865b86925b9bc5c2,\n        0xa7f26836f282b733,\n        0xd1ef0244af2364ff,\n        0x8335616aed761f1f,\n        0xa402b9c5a8d3a6e7,\n        0xcd036837130890a1,\n        0x802221226be55a65,\n        0xa02aa96b06deb0fe,\n        0xc83553c5c8965d3d,\n        0xfa42a8b73abbf48d,\n        0x9c69a97284b578d8,\n        0xc38413cf25e2d70e,\n        0xf46518c2ef5b8cd1,\n        0x98bf2f79d5993803,\n        0xbeeefb584aff8604,\n        0xeeaaba2e5dbf6785,\n        0x952ab45cfa97a0b3,\n        0xba756174393d88e0,\n        0xe912b9d1478ceb17,\n        0x91abb422ccb812ef,\n        0xb616a12b7fe617aa,\n        0xe39c49765fdf9d95,\n        0x8e41ade9fbebc27d,\n        0xb1d219647ae6b31c,\n        0xde469fbd99a05fe3,\n        0x8aec23d680043bee,\n        0xada72ccc20054aea,\n        0xd910f7ff28069da4,\n        0x87aa9aff79042287,\n        0xa99541bf57452b28,\n        0xd3fa922f2d1675f2,\n        0x847c9b5d7c2e09b7,\n        0xa59bc234db398c25,\n        0xcf02b2c21207ef2f,\n        0x8161afb94b44f57d,\n        0xa1ba1ba79e1632dc,\n        0xca28a291859bbf93,\n        0xfcb2cb35e702af78,\n        0x9defbf01b061adab,\n        0xc56baec21c7a1916,\n        0xf6c69a72a3989f5c,\n        0x9a3c2087a63f6399,\n        0xc0cb28a98fcf3c80,\n        0xf0fdf2d3f3c30b9f,\n        0x969eb7c47859e744,\n        0xbc4665b596706115,\n        0xeb57ff22fc0c795a,\n        0x9316ff75dd87cbd8,\n        0xb7dcbf5354e9bece,\n        0xe5d3ef282a242e82,\n        0x8fa475791a569d11,\n        0xb38d92d760ec4455,\n        0xe070f78d3927556b,\n        0x8c469ab843b89563,\n        0xaf58416654a6babb,\n        0xdb2e51bfe9d0696a,\n        0x88fcf317f22241e2,\n        0xab3c2fddeeaad25b,\n        0xd60b3bd56a5586f2,\n        0x85c7056562757457,\n        0xa738c6bebb12d16d,\n        0xd106f86e69d785c8,\n        0x82a45b450226b39d,\n        0xa34d721642b06084,\n        0xcc20ce9bd35c78a5,\n        0xff290242c83396ce,\n        0x9f79a169bd203e41,\n        0xc75809c42c684dd1,\n        0xf92e0c3537826146,\n        0x9bbcc7a142b17ccc,\n        0xc2abf989935ddbfe,\n        0xf356f7ebf83552fe,\n        0x98165af37b2153df,\n        0xbe1bf1b059e9a8d6,\n        0xeda2ee1c7064130c,\n        0x9485d4d1c63e8be8,\n        0xb9a74a0637ce2ee1,\n        0xe8111c87c5c1ba9a,\n        0x910ab1d4db9914a0,\n        0xb54d5e4a127f59c8,\n        0xe2a0b5dc971f303a,\n        0x8da471a9de737e24,\n        0xb10d8e1456105dad,\n        0xdd50f1996b947519,\n        0x8a5296ffe33cc930,\n        0xace73cbfdc0bfb7b,\n        0xd8210befd30efa5a,\n        0x8714a775e3e95c78,\n        0xa8d9d1535ce3b396,\n        0xd31045a8341ca07c,\n        0x83ea2b892091e44e,\n        0xa4e4b66b68b65d61,\n        0xce1de40642e3f4b9,\n        0x80d2ae83e9ce78f4,\n        0xa1075a24e4421731,\n        0xc94930ae1d529cfd,\n        0xfb9b7cd9a4a7443c,\n        0x9d412e0806e88aa6,\n        0xc491798a08a2ad4f,\n        0xf5b5d7ec8acb58a3,\n        0x9991a6f3d6bf1766,\n        0xbff610b0cc6edd3f,\n        0xeff394dcff8a948f,\n        0x95f83d0a1fb69cd9,\n        0xbb764c4ca7a44410,\n        0xea53df5fd18d5514,\n        0x92746b9be2f8552c,\n        0xb7118682dbb66a77,\n        0xe4d5e82392a40515,\n        0x8f05b1163ba6832d,\n        0xb2c71d5bca9023f8,\n        0xdf78e4b2bd342cf7,\n        0x8bab8eefb6409c1a,\n        0xae9672aba3d0c321,\n        0xda3c0f568cc4f3e9,\n        0x8865899617fb1871,\n        0xaa7eebfb9df9de8e,\n        0xd51ea6fa85785631,\n        0x8533285c936b35df,\n        0xa67ff273b8460357,\n        0xd01fef10a657842c,\n        0x8213f56a67f6b29c,\n        0xa298f2c501f45f43,\n        0xcb3f2f7642717713,\n        0xfe0efb53d30dd4d8,\n        0x9ec95d1463e8a507,\n        0xc67bb4597ce2ce49,\n        0xf81aa16fdc1b81db,\n        0x9b10a4e5e9913129,\n        0xc1d4ce1f63f57d73,\n        0xf24a01a73cf2dcd0,\n        0x976e41088617ca02,\n        0xbd49d14aa79dbc82,\n        0xec9c459d51852ba3,\n        0x93e1ab8252f33b46,\n        0xb8da1662e7b00a17,\n        0xe7109bfba19c0c9d,\n        0x906a617d450187e2,\n        0xb484f9dc9641e9db,\n        0xe1a63853bbd26451,\n        0x8d07e33455637eb3,\n        0xb049dc016abc5e60,\n        0xdc5c5301c56b75f7,\n        0x89b9b3e11b6329bb,\n        0xac2820d9623bf429,\n        0xd732290fbacaf134,\n        0x867f59a9d4bed6c0,\n        0xa81f301449ee8c70,\n        0xd226fc195c6a2f8c,\n        0x83585d8fd9c25db8,\n        0xa42e74f3d032f526,\n        0xcd3a1230c43fb26f,\n        0x80444b5e7aa7cf85,\n        0xa0555e361951c367,\n        0xc86ab5c39fa63441,\n        0xfa856334878fc151,\n        0x9c935e00d4b9d8d2,\n        0xc3b8358109e84f07,\n        0xf4a642e14c6262c9,\n        0x98e7e9cccfbd7dbe,\n        0xbf21e44003acdd2d,\n        0xeeea5d5004981478,\n        0x95527a5202df0ccb,\n        0xbaa718e68396cffe,\n        0xe950df20247c83fd,\n        0x91d28b7416cdd27e,\n    ],\n    [\n        -1077,\n        -1073,\n        -1070,\n        -1067,\n        -1063,\n        -1060,\n        -1057,\n        -1053,\n        -1050,\n        -1047,\n        -1043,\n        -1040,\n        -1037,\n        -1034,\n        -1030,\n        -1027,\n        -1024,\n        -1020,\n        -1017,\n        -1014,\n        -1010,\n        -1007,\n        -1004,\n        -1000,\n        -997,\n        -994,\n        -990,\n        -987,\n        -984,\n        -980,\n        -977,\n        -974,\n        -970,\n        -967,\n        -964,\n        -960,\n        -957,\n        -954,\n        -950,\n        -947,\n        -944,\n        -940,\n        -937,\n        -934,\n        -931,\n        -927,\n        -924,\n        -921,\n        -917,\n        -914,\n        -911,\n        -907,\n        -904,\n        -901,\n        -897,\n        -894,\n        -891,\n        -887,\n        -884,\n        -881,\n        -877,\n        -874,\n        -871,\n        -867,\n        -864,\n        -861,\n        -857,\n        -854,\n        -851,\n        -847,\n        -844,\n        -841,\n        -838,\n        -834,\n        -831,\n        -828,\n        -824,\n        -821,\n        -818,\n        -814,\n        -811,\n        -808,\n        -804,\n        -801,\n        -798,\n        -794,\n        -791,\n        -788,\n        -784,\n        -781,\n        -778,\n        -774,\n        -771,\n        -768,\n        -764,\n        -761,\n        -758,\n        -754,\n        -751,\n        -748,\n        -744,\n        -741,\n        -738,\n        -735,\n        -731,\n        -728,\n        -725,\n        -721,\n        -718,\n        -715,\n        -711,\n        -708,\n        -705,\n        -701,\n        -698,\n        -695,\n        -691,\n        -688,\n        -685,\n        -681,\n        -678,\n        -675,\n        -671,\n        -668,\n        -665,\n        -661,\n        -658,\n        -655,\n        -651,\n        -648,\n        -645,\n        -642,\n        -638,\n        -635,\n        -632,\n        -628,\n        -625,\n        -622,\n        -618,\n        -615,\n        -612,\n        -608,\n        -605,\n        -602,\n        -598,\n        -595,\n        -592,\n        -588,\n        -585,\n        -582,\n        -578,\n        -575,\n        -572,\n        -568,\n        -565,\n        -562,\n        -558,\n        -555,\n        -552,\n        -549,\n        -545,\n        -542,\n        -539,\n        -535,\n        -532,\n        -529,\n        -525,\n        -522,\n        -519,\n        -515,\n        -512,\n        -509,\n        -505,\n        -502,\n        -499,\n        -495,\n        -492,\n        -489,\n        -485,\n        -482,\n        -479,\n        -475,\n        -472,\n        -469,\n        -465,\n        -462,\n        -459,\n        -455,\n        -452,\n        -449,\n        -446,\n        -442,\n        -439,\n        -436,\n        -432,\n        -429,\n        -426,\n        -422,\n        -419,\n        -416,\n        -412,\n        -409,\n        -406,\n        -402,\n        -399,\n        -396,\n        -392,\n        -389,\n        -386,\n        -382,\n        -379,\n        -376,\n        -372,\n        -369,\n        -366,\n        -362,\n        -359,\n        -356,\n        -353,\n        -349,\n        -346,\n        -343,\n        -339,\n        -336,\n        -333,\n        -329,\n        -326,\n        -323,\n        -319,\n        -316,\n        -313,\n        -309,\n        -306,\n        -303,\n        -299,\n        -296,\n        -293,\n        -289,\n        -286,\n        -283,\n        -279,\n        -276,\n        -273,\n        -269,\n        -266,\n        -263,\n        -259,\n        -256,\n        -253,\n        -250,\n        -246,\n        -243,\n        -240,\n        -236,\n        -233,\n        -230,\n        -226,\n        -223,\n        -220,\n        -216,\n        -213,\n        -210,\n        -206,\n        -203,\n        -200,\n        -196,\n        -193,\n        -190,\n        -186,\n        -183,\n        -180,\n        -176,\n        -173,\n        -170,\n        -166,\n        -163,\n        -160,\n        -157,\n        -153,\n        -150,\n        -147,\n        -143,\n        -140,\n        -137,\n        -133,\n        -130,\n        -127,\n        -123,\n        -120,\n        -117,\n        -113,\n        -110,\n        -107,\n        -103,\n        -100,\n        -97,\n        -93,\n        -90,\n        -87,\n        -83,\n        -80,\n        -77,\n        -73,\n        -70,\n        -67,\n        -63,\n        -60,\n        -57,\n        -54,\n        -50,\n        -47,\n        -44,\n        -40,\n        -37,\n        -34,\n        -30,\n        -27,\n        -24,\n        -20,\n        -17,\n        -14,\n        -10,\n        -7,\n        -4,\n        0,\n        3,\n        6,\n        10,\n        13,\n        16,\n        20,\n        23,\n        26,\n        30,\n        33,\n        36,\n        39,\n        43,\n        46,\n        49,\n        53,\n        56,\n        59,\n        63,\n        66,\n        69,\n        73,\n        76,\n        79,\n        83,\n        86,\n        89,\n        93,\n        96,\n        99,\n        103,\n        106,\n        109,\n        113,\n        116,\n        119,\n        123,\n        126,\n        129,\n        132,\n        136,\n        139,\n        142,\n        146,\n        149,\n        152,\n        156,\n        159,\n        162,\n        166,\n        169,\n        172,\n        176,\n        179,\n        182,\n        186,\n        189,\n        192,\n        196,\n        199,\n        202,\n        206,\n        209,\n        212,\n        216,\n        219,\n        222,\n        226,\n        229,\n        232,\n        235,\n        239,\n        242,\n        245,\n        249,\n        252,\n        255,\n        259,\n        262,\n        265,\n        269,\n        272,\n        275,\n        279,\n        282,\n        285,\n        289,\n        292,\n        295,\n        299,\n        302,\n        305,\n        309,\n        312,\n        315,\n        319,\n        322,\n        325,\n        328,\n        332,\n        335,\n        338,\n        342,\n        345,\n        348,\n        352,\n        355,\n        358,\n        362,\n        365,\n        368,\n        372,\n        375,\n        378,\n        382,\n        385,\n        388,\n        392,\n        395,\n        398,\n        402,\n        405,\n        408,\n        412,\n        415,\n        418,\n        422,\n        425,\n        428,\n        431,\n        435,\n        438,\n        441,\n        445,\n        448,\n        451,\n        455,\n        458,\n        461,\n        465,\n        468,\n        471,\n        475,\n        478,\n        481,\n        485,\n        488,\n        491,\n        495,\n        498,\n        501,\n        505,\n        508,\n        511,\n        515,\n        518,\n        521,\n        524,\n        528,\n        531,\n        534,\n        538,\n        541,\n        544,\n        548,\n        551,\n        554,\n        558,\n        561,\n        564,\n        568,\n        571,\n        574,\n        578,\n        581,\n        584,\n        588,\n        591,\n        594,\n        598,\n        601,\n        604,\n        608,\n        611,\n        614,\n        617,\n        621,\n        624,\n        627,\n        631,\n        634,\n        637,\n        641,\n        644,\n        647,\n        651,\n        654,\n        657,\n        661,\n        664,\n        667,\n        671,\n        674,\n        677,\n        681,\n        684,\n        687,\n        691,\n        694,\n        697,\n        701,\n        704,\n        707,\n        711,\n        714,\n        717,\n        720,\n        724,\n        727,\n        730,\n        734,\n        737,\n        740,\n        744,\n        747,\n        750,\n        754,\n        757,\n        760,\n        764,\n        767,\n        770,\n        774,\n        777,\n        780,\n        784,\n        787,\n        790,\n        794,\n        797,\n        800,\n        804,\n        807,\n        810,\n        813,\n        817,\n        820,\n        823,\n        827,\n        830,\n        833,\n        837,\n        840,\n        843,\n        847,\n        850,\n        853,\n        857,\n        860,\n        863,\n        867,\n        870,\n        873,\n        877,\n        880,\n        883,\n        887,\n        890,\n        893,\n        897,\n        900,\n        903,\n        907,\n        910,\n        913,\n        916,\n        920,\n        923,\n        926,\n        930,\n        933,\n        936,\n        940,\n        943,\n        946,\n        950,\n    ],\n);\n\n#[rustfmt::skip]\npub const F32_SHORT_POWERS: [f32; 11] = [\n    1e0,\n    1e1,\n    1e2,\n    1e3,\n    1e4,\n    1e5,\n    1e6,\n    1e7,\n    1e8,\n    1e9,\n    1e10,\n];\n\n#[rustfmt::skip]\npub const F64_SHORT_POWERS: [f64; 23] = [\n    1e0,\n    1e1,\n    1e2,\n    1e3,\n    1e4,\n    1e5,\n    1e6,\n    1e7,\n    1e8,\n    1e9,\n    1e10,\n    1e11,\n    1e12,\n    1e13,\n    1e14,\n    1e15,\n    1e16,\n    1e17,\n    1e18,\n    1e19,\n    1e20,\n    1e21,\n    1e22,\n];\n}\n// These two have their own tests.\npub mod parse {\n//! Validating and decomposing a decimal string of the form:\n//!\n//! `(digits | digits? '.'? digits?) (('e' | 'E') ('+' | '-')? digits)?`\n//!\n//! In other words, standard floating-point syntax, with two exceptions: No sign, and no\n//! handling of \"inf\" and \"NaN\". These are handled by the driver function (super::dec2flt).\n//!\n//! Although recognizing valid inputs is relatively easy, this module also has to reject the\n//! countless invalid variations, never panic, and perform numerous checks that the other\n//! modules rely on to not panic (or overflow) in turn.\n//! To make matters worse, all that happens in a single pass over the input.\n//! So, be careful when modifying anything, and double-check with the other modules.\nuse self::ParseResult::{Invalid, ShortcutToInf, ShortcutToZero, Valid};\nuse super::num;\n\n#[derive(Debug)]\npub enum Sign {\n    Positive,\n    Negative,\n}\n\n#[derive(Debug, PartialEq, Eq)]\n/// The interesting parts of a decimal string.\npub struct Decimal<'a> {\n    pub integral: &'a [u8],\n    pub fractional: &'a [u8],\n    /// The decimal exponent, guaranteed to have fewer than 18 decimal digits.\n    pub exp: i64,\n}\n\nimpl<'a> Decimal<'a> {\n    pub fn new(integral: &'a [u8], fractional: &'a [u8], exp: i64) -> Decimal<'a> {\n}\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub enum ParseResult<'a> {\n    Valid(Decimal<'a>),\n    ShortcutToInf,\n    ShortcutToZero,\n    Invalid,\n}\n\n/// Checks if the input string is a valid floating point number and if so, locate the integral\n/// part, the fractional part, and the exponent in it. Does not handle signs.\npub fn parse_decimal(s: &str) -> ParseResult<'_> {\n}\n\n/// Carves off decimal digits up to the first non-digit character.\nfn eat_digits(s: &[u8]) -> (&[u8], &[u8]) {\n}\n\n/// Exponent extraction and error checking.\nfn parse_exp<'a>(integral: &'a [u8], fractional: &'a [u8], rest: &'a [u8]) -> ParseResult<'a> {\n}\n}\npub mod rawfp {\n//! Bit fiddling on positive IEEE 754 floats. Negative numbers aren't and needn't be handled.\n//! Normal floating point numbers have a canonical representation as (frac, exp) such that the\n//! value is 2<sup>exp</sup> * (1 + sum(frac[N-i] / 2<sup>i</sup>)) where N is the number of bits.\n//! Subnormals are slightly different and weird, but the same principle applies.\n//!\n//! Here, however, we represent them as (sig, k) with f positive, such that the value is f *\n//! 2<sup>e</sup>. Besides making the \"hidden bit\" explicit, this changes the exponent by the\n//! so-called mantissa shift.\n//!\n//! Put another way, normally floats are written as (1) but here they are written as (2):\n//!\n//! 1. `1.101100...11 * 2^m`\n//! 2. `1101100...11 * 2^n`\n//!\n//! We call (1) the **fractional representation** and (2) the **integral representation**.\n//!\n//! Many functions in this module only handle normal numbers. The dec2flt routines conservatively\n//! take the universally-correct slow path (Algorithm M) for very small and very large numbers.\n//! That algorithm needs only next_float() which does handle subnormals and zeros.\nuse crate::cmp::Ordering::{Equal, Greater, Less};\nuse crate::convert::{TryFrom, TryInto};\nuse crate::fmt::{Debug, LowerExp};\nuse crate::num::dec2flt::num::{self, Big};\nuse crate::num::dec2flt::table;\nuse crate::num::diy_float::Fp;\nuse crate::num::FpCategory;\nuse crate::num::FpCategory::{Infinite, Nan, Normal, Subnormal, Zero};\nuse crate::ops::{Add, Div, Mul, Neg};\n\n#[derive(Copy, Clone, Debug)]\npub struct Unpacked {\n    pub sig: u64,\n    pub k: i16,\n}\n\nimpl Unpacked {\n    pub fn new(sig: u64, k: i16) -> Self {\n}\n}\n\n/// A helper trait to avoid duplicating basically all the conversion code for `f32` and `f64`.\n///\n/// See the parent module's doc comment for why this is necessary.\n///\n/// Should **never ever** be implemented for other types or be used outside the dec2flt module.\npub trait RawFloat:\n    Copy + Debug + LowerExp + Mul<Output = Self> + Div<Output = Self> + Neg<Output = Self>\n{\n    const INFINITY: Self;\n    const NAN: Self;\n    const ZERO: Self;\n\n    /// Type used by `to_bits` and `from_bits`.\n    type Bits: Add<Output = Self::Bits> + From<u8> + TryFrom<u64>;\n\n    /// Performs a raw transmutation to an integer.\n    fn to_bits(self) -> Self::Bits;\n\n    /// Performs a raw transmutation from an integer.\n    fn from_bits(v: Self::Bits) -> Self;\n\n    /// Returns the category that this number falls into.\n    fn classify(self) -> FpCategory;\n\n    /// Returns the mantissa, exponent and sign as integers.\n    fn integer_decode(self) -> (u64, i16, i8);\n\n    /// Decodes the float.\n    fn unpack(self) -> Unpacked;\n\n    /// Casts from a small integer that can be represented exactly. Panic if the integer can't be\n    /// represented, the other code in this module makes sure to never let that happen.\n    fn from_int(x: u64) -> Self;\n\n    /// Gets the value 10<sup>e</sup> from a pre-computed table.\n    /// Panics for `e >= CEIL_LOG5_OF_MAX_SIG`.\n    fn short_fast_pow10(e: usize) -> Self;\n\n    /// What the name says. It's easier to hard code than juggling intrinsics and\n    /// hoping LLVM constant folds it.\n    const CEIL_LOG5_OF_MAX_SIG: i16;\n\n    // A conservative bound on the decimal digits of inputs that can't produce overflow or zero or\n    /// subnormals. Probably the decimal exponent of the maximum normal value, hence the name.\n    const MAX_NORMAL_DIGITS: usize;\n\n    /// When the most significant decimal digit has a place value greater than this, the number\n    /// is certainly rounded to infinity.\n    const INF_CUTOFF: i64;\n\n    /// When the most significant decimal digit has a place value less than this, the number\n    /// is certainly rounded to zero.\n    const ZERO_CUTOFF: i64;\n\n    /// The number of bits in the exponent.\n    const EXP_BITS: u8;\n\n    /// The number of bits in the significand, *including* the hidden bit.\n    const SIG_BITS: u8;\n\n    /// The number of bits in the significand, *excluding* the hidden bit.\n    const EXPLICIT_SIG_BITS: u8;\n\n    /// The maximum legal exponent in fractional representation.\n    const MAX_EXP: i16;\n\n    /// The minimum legal exponent in fractional representation, excluding subnormals.\n    const MIN_EXP: i16;\n\n    /// `MAX_EXP` for integral representation, i.e., with the shift applied.\n    const MAX_EXP_INT: i16;\n\n    /// `MAX_EXP` encoded (i.e., with offset bias)\n    const MAX_ENCODED_EXP: i16;\n\n    /// `MIN_EXP` for integral representation, i.e., with the shift applied.\n    const MIN_EXP_INT: i16;\n\n    /// The maximum normalized significand in integral representation.\n    const MAX_SIG: u64;\n\n    /// The minimal normalized significand in integral representation.\n    const MIN_SIG: u64;\n}\n\n// Mostly a workaround for #34344.\nmacro_rules! other_constants {\n    ($type: ident) => {\n        const EXPLICIT_SIG_BITS: u8 = Self::SIG_BITS - 1;\n        const MAX_EXP: i16 = (1 << (Self::EXP_BITS - 1)) - 1;\n        const MIN_EXP: i16 = -Self::MAX_EXP + 1;\n        const MAX_EXP_INT: i16 = Self::MAX_EXP - (Self::SIG_BITS as i16 - 1);\n        const MAX_ENCODED_EXP: i16 = (1 << Self::EXP_BITS) - 1;\n        const MIN_EXP_INT: i16 = Self::MIN_EXP - (Self::SIG_BITS as i16 - 1);\n        const MAX_SIG: u64 = (1 << Self::SIG_BITS) - 1;\n        const MIN_SIG: u64 = 1 << (Self::SIG_BITS - 1);\n\n        const INFINITY: Self = $crate::$type::INFINITY;\n        const NAN: Self = $crate::$type::NAN;\n        const ZERO: Self = 0.0;\n    };\n}\n\nimpl RawFloat for f32 {\n    type Bits = u32;\n\n    const SIG_BITS: u8 = 24;\n    const EXP_BITS: u8 = 8;\n    const CEIL_LOG5_OF_MAX_SIG: i16 = 11;\n    const MAX_NORMAL_DIGITS: usize = 35;\n    const INF_CUTOFF: i64 = 40;\n    const ZERO_CUTOFF: i64 = -48;\n    other_constants!(f32);\n\n    /// Returns the mantissa, exponent and sign as integers.\n    fn integer_decode(self) -> (u64, i16, i8) {\n}\n\n    fn unpack(self) -> Unpacked {\n}\n\n    fn from_int(x: u64) -> f32 {\n}\n\n    fn short_fast_pow10(e: usize) -> Self {\n}\n\n    fn classify(self) -> FpCategory {\n}\n    fn to_bits(self) -> Self::Bits {\n}\n    fn from_bits(v: Self::Bits) -> Self {\n}\n}\n\nimpl RawFloat for f64 {\n    type Bits = u64;\n\n    const SIG_BITS: u8 = 53;\n    const EXP_BITS: u8 = 11;\n    const CEIL_LOG5_OF_MAX_SIG: i16 = 23;\n    const MAX_NORMAL_DIGITS: usize = 305;\n    const INF_CUTOFF: i64 = 310;\n    const ZERO_CUTOFF: i64 = -326;\n    other_constants!(f64);\n\n    /// Returns the mantissa, exponent and sign as integers.\n    fn integer_decode(self) -> (u64, i16, i8) {\n}\n\n    fn unpack(self) -> Unpacked {\n}\n\n    fn from_int(x: u64) -> f64 {\n}\n\n    fn short_fast_pow10(e: usize) -> Self {\n}\n\n    fn classify(self) -> FpCategory {\n}\n    fn to_bits(self) -> Self::Bits {\n}\n    fn from_bits(v: Self::Bits) -> Self {\n}\n}\n\n/// Converts an `Fp` to the closest machine float type.\n/// Does not handle subnormal results.\npub fn fp_to_float<T: RawFloat>(x: Fp) -> T {\n}\n\n/// Round the 64-bit significand to T::SIG_BITS bits with half-to-even.\n/// Does not handle exponent overflow.\npub fn round_normal<T: RawFloat>(x: Fp) -> Unpacked {\n}\n\n/// Inverse of `RawFloat::unpack()` for normalized numbers.\n/// Panics if the significand or exponent are not valid for normalized numbers.\npub fn encode_normal<T: RawFloat>(x: Unpacked) -> T {\n}\n\n/// Construct a subnormal. A mantissa of 0 is allowed and constructs zero.\npub fn encode_subnormal<T: RawFloat>(significand: u64) -> T {\n}\n\n/// Approximate a bignum with an Fp. Rounds within 0.5 ULP with half-to-even.\npub fn big_to_fp(f: &Big) -> Fp {\n}\n\n/// Finds the largest floating point number strictly smaller than the argument.\n/// Does not handle subnormals, zero, or exponent underflow.\npub fn prev_float<T: RawFloat>(x: T) -> T {\n}\n\n// Find the smallest floating point number strictly larger than the argument.\n// This operation is saturating, i.e., next_float(inf) == inf.\n// Unlike most code in this module, this function does handle zero, subnormals, and infinities.\n// However, like all other code here, it does not deal with NaN and negative numbers.\npub fn next_float<T: RawFloat>(x: T) -> T {\n}\n}\n\nmacro_rules! from_str_float_impl {\n    ($t:ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl FromStr for $t {\n            type Err = ParseFloatError;\n\n            /// Converts a string in base 10 to a float.\n            /// Accepts an optional decimal exponent.\n            ///\n            /// This function accepts strings such as\n            ///\n            /// * '3.14'\n            /// * '-3.14'\n            /// * '2.5E10', or equivalently, '2.5e10'\n            /// * '2.5E-10'\n            /// * '5.'\n            /// * '.5', or, equivalently, '0.5'\n            /// * 'inf', '-inf', 'NaN'\n            ///\n            /// Leading and trailing whitespace represent an error.\n            ///\n            /// # Grammar\n            ///\n            /// All strings that adhere to the following [EBNF] grammar\n            /// will result in an [`Ok`] being returned:\n            ///\n            /// ```txt\n            /// Float  ::= Sign? ( 'inf' | 'NaN' | Number )\n            /// Number ::= ( Digit+ |\n            ///              Digit+ '.' Digit* |\n            ///              Digit* '.' Digit+ ) Exp?\n            /// Exp    ::= [eE] Sign? Digit+\n            /// Sign   ::= [+-]\n            /// Digit  ::= [0-9]\n            /// ```\n            ///\n            /// [EBNF]: https://www.w3.org/TR/REC-xml/#sec-notation\n            ///\n            /// # Known bugs\n            ///\n            /// In some situations, some strings that should create a valid float\n            /// instead return an error. See [issue #31407] for details.\n            ///\n            /// [issue #31407]: https://github.com/rust-lang/rust/issues/31407\n            ///\n            /// # Arguments\n            ///\n            /// * src - A string\n            ///\n            /// # Return value\n            ///\n            /// `Err(ParseFloatError)` if the string did not represent a valid\n            /// number. Otherwise, `Ok(n)` where `n` is the floating-point\n            /// number represented by `src`.\n            #[inline]\n            fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n}\n        }\n    };\n}\nfrom_str_float_impl!(f32);\nfrom_str_float_impl!(f64);\n\n/// An error which can be returned when parsing a float.\n///\n/// This error is used as the error type for the [`FromStr`] implementation\n/// for [`f32`] and [`f64`].\n///\n/// [`FromStr`]: ../str/trait.FromStr.html\n/// [`f32`]: ../../std/primitive.f32.html\n/// [`f64`]: ../../std/primitive.f64.html\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ParseFloatError {\n    kind: FloatErrorKind,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nenum FloatErrorKind {\n    Empty,\n    Invalid,\n}\n\nimpl ParseFloatError {\n    #[unstable(\n        feature = \"int_error_internals\",\n        reason = \"available through Error trait and this method should \\\n                  not be exposed publicly\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for ParseFloatError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nfn pfe_empty() -> ParseFloatError {\n}\n\nfn pfe_invalid() -> ParseFloatError {\n}\n\n/// Splits a decimal string into sign and the rest, without inspecting or validating the rest.\nfn extract_sign(s: &str) -> (Sign, &str) {\n}\n\n/// Converts a decimal string into a floating point number.\nfn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n}\n\n/// The main workhorse for the decimal-to-float conversion: Orchestrate all the preprocessing\n/// and figure out which algorithm should do the actual conversion.\nfn convert<T: RawFloat>(mut decimal: Decimal<'_>) -> Result<T, ParseFloatError> {\n}\n\n// As written, this optimizes badly (see #27130, though it refers to an old version of the code).\n// `inline(always)` is a workaround for that. There are only two call sites overall and it doesn't\n// make code size worse.\n\n/// Strip zeros where possible, even when this requires changing the exponent\n#[inline(always)]\nfn simplify(decimal: &mut Decimal<'_>) {\n}\n\n/// Returns a quick-an-dirty upper bound on the size (log10) of the largest value that Algorithm R\n/// and Algorithm M will compute while working on the given decimal.\nfn bound_intermediate_digits(decimal: &Decimal<'_>, e: i64) -> u64 {\n}\n\n/// Detects obvious overflows and underflows without even looking at the decimal digits.\nfn trivial_cases<T: RawFloat>(decimal: &Decimal<'_>) -> Option<T> {\n}\n}\npub mod diy_float {\n//! Extended precision \"soft float\", for internal use only.\n\n// This module is only for dec2flt and flt2dec, and only public because of coretests.\n// It is not intended to ever be stabilized.\n#![doc(hidden)]\n#![unstable(\n    feature = \"core_private_diy_float\",\n    reason = \"internal routines only exposed for testing\",\n    issue = \"none\"\n)]\n\n/// A custom 64-bit floating point type, representing `f * 2^e`.\n#[derive(Copy, Clone, Debug)]\n#[doc(hidden)]\npub struct Fp {\n    /// The integer mantissa.\n    pub f: u64,\n    /// The exponent in base 2.\n    pub e: i16,\n}\n\nimpl Fp {\n    /// Returns a correctly rounded product of itself and `other`.\n    pub fn mul(&self, other: &Fp) -> Fp {\n}\n\n    /// Normalizes itself so that the resulting mantissa is at least `2^63`.\n    pub fn normalize(&self) -> Fp {\n}\n\n    /// Normalizes itself to have the shared exponent.\n    /// It can only decrease the exponent (and thus increase the mantissa).\n    pub fn normalize_to(&self, e: i16) -> Fp {\n}\n}\n}\npub mod flt2dec {\n/*!\n\nFloating-point number to decimal conversion routines.\n\n# Problem statement\n\nWe are given the floating-point number `v = f * 2^e` with an integer `f`,\nand its bounds `minus` and `plus` such that any number between `v - minus` and\n`v + plus` will be rounded to `v`. For the simplicity we assume that\nthis range is exclusive. Then we would like to get the unique decimal\nrepresentation `V = 0.d[0..n-1] * 10^k` such that:\n\n- `d[0]` is non-zero.\n\n- It's correctly rounded when parsed back: `v - minus < V < v + plus`.\n  Furthermore it is shortest such one, i.e., there is no representation\n  with less than `n` digits that is correctly rounded.\n\n- It's closest to the original value: `abs(V - v) <= 10^(k-n) / 2`. Note that\n  there might be two representations satisfying this uniqueness requirement,\n  in which case some tie-breaking mechanism is used.\n\nWe will call this mode of operation as to the *shortest* mode. This mode is used\nwhen there is no additional constraint, and can be thought as a \"natural\" mode\nas it matches the ordinary intuition (it at least prints `0.1f32` as \"0.1\").\n\nWe have two more modes of operation closely related to each other. In these modes\nwe are given either the number of significant digits `n` or the last-digit\nlimitation `limit` (which determines the actual `n`), and we would like to get\nthe representation `V = 0.d[0..n-1] * 10^k` such that:\n\n- `d[0]` is non-zero, unless `n` was zero in which case only `k` is returned.\n\n- It's closest to the original value: `abs(V - v) <= 10^(k-n) / 2`. Again,\n  there might be some tie-breaking mechanism.\n\nWhen `limit` is given but not `n`, we set `n` such that `k - n = limit`\nso that the last digit `d[n-1]` is scaled by `10^(k-n) = 10^limit`.\nIf such `n` is negative, we clip it to zero so that we will only get `k`.\nWe are also limited by the supplied buffer. This limitation is used to print\nthe number up to given number of fractional digits without knowing\nthe correct `k` beforehand.\n\nWe will call the mode of operation requiring `n` as to the *exact* mode,\nand one requiring `limit` as to the *fixed* mode. The exact mode is a subset of\nthe fixed mode: the sufficiently large last-digit limitation will eventually fill\nthe supplied buffer and let the algorithm to return.\n\n# Implementation overview\n\nIt is easy to get the floating point printing correct but slow (Russ Cox has\n[demonstrated](http://research.swtch.com/ftoa) how it's easy), or incorrect but\nfast (naïve division and modulo). But it is surprisingly hard to print\nfloating point numbers correctly *and* efficiently.\n\nThere are two classes of algorithms widely known to be correct.\n\n- The \"Dragon\" family of algorithm is first described by Guy L. Steele Jr. and\n  Jon L. White. They rely on the fixed-size big integer for their correctness.\n  A slight improvement was found later, which is posthumously described by\n  Robert G. Burger and R. Kent Dybvig. David Gay's `dtoa.c` routine is\n  a popular implementation of this strategy.\n\n- The \"Grisu\" family of algorithm is first described by Florian Loitsch.\n  They use very cheap integer-only procedure to determine the close-to-correct\n  representation which is at least guaranteed to be shortest. The variant,\n  Grisu3, actively detects if the resulting representation is incorrect.\n\nWe implement both algorithms with necessary tweaks to suit our requirements.\nIn particular, published literatures are short of the actual implementation\ndifficulties like how to avoid arithmetic overflows. Each implementation,\navailable in `strategy::dragon` and `strategy::grisu` respectively,\nextensively describes all necessary justifications and many proofs for them.\n(It is still difficult to follow though. You have been warned.)\n\nBoth implementations expose two public functions:\n\n- `format_shortest(decoded, buf)`, which always needs at least\n  `MAX_SIG_DIGITS` digits of buffer. Implements the shortest mode.\n\n- `format_exact(decoded, buf, limit)`, which accepts as small as\n  one digit of buffer. Implements exact and fixed modes.\n\nThey try to fill the `u8` buffer with digits and returns the number of digits\nwritten and the exponent `k`. They are total for all finite `f32` and `f64`\ninputs (Grisu internally falls back to Dragon if necessary).\n\nThe rendered digits are formatted into the actual string form with\nfour functions:\n\n- `to_shortest_str` prints the shortest representation, which can be padded by\n  zeroes to make *at least* given number of fractional digits.\n\n- `to_shortest_exp_str` prints the shortest representation, which can be\n  padded by zeroes when its exponent is in the specified ranges,\n  or can be printed in the exponential form such as `1.23e45`.\n\n- `to_exact_exp_str` prints the exact representation with given number of\n  digits in the exponential form.\n\n- `to_exact_fixed_str` prints the fixed representation with *exactly*\n  given number of fractional digits.\n\nThey all return a slice of preallocated `Part` array, which corresponds to\nthe individual part of strings: a fixed string, a part of rendered digits,\na number of zeroes or a small (`u16`) number. The caller is expected to\nprovide a large enough buffer and `Part` array, and to assemble the final\nstring from resulting `Part`s itself.\n\nAll algorithms and formatting functions are accompanied by extensive tests\nin `coretests::num::flt2dec` module. It also shows how to use individual\nfunctions.\n\n*/\n\n// while this is extensively documented, this is in principle private which is\n// only made public for testing. do not expose us.\n#![doc(hidden)]\n#![unstable(\n    feature = \"flt2dec\",\n    reason = \"internal routines only exposed for testing\",\n    issue = \"none\"\n)]\n\npub use self::decoder::{decode, DecodableFloat, Decoded, FullDecoded};\nuse crate::i16;\n\npub mod decoder {\n//! Decodes a floating-point value into individual parts and error ranges.\n\nuse crate::num::dec2flt::rawfp::RawFloat;\nuse crate::num::FpCategory;\nuse crate::{f32, f64};\n\n/// Decoded unsigned finite value, such that:\n///\n/// - The original value equals to `mant * 2^exp`.\n///\n/// - Any number from `(mant - minus) * 2^exp` to `(mant + plus) * 2^exp` will\n///   round to the original value. The range is inclusive only when\n///   `inclusive` is `true`.\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub struct Decoded {\n    /// The scaled mantissa.\n    pub mant: u64,\n    /// The lower error range.\n    pub minus: u64,\n    /// The upper error range.\n    pub plus: u64,\n    /// The shared exponent in base 2.\n    pub exp: i16,\n    /// True when the error range is inclusive.\n    ///\n    /// In IEEE 754, this is true when the original mantissa was even.\n    pub inclusive: bool,\n}\n\n/// Decoded unsigned value.\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub enum FullDecoded {\n    /// Not-a-number.\n    Nan,\n    /// Infinities, either positive or negative.\n    Infinite,\n    /// Zero, either positive or negative.\n    Zero,\n    /// Finite numbers with further decoded fields.\n    Finite(Decoded),\n}\n\n/// A floating point type which can be `decode`d.\npub trait DecodableFloat: RawFloat + Copy {\n    /// The minimum positive normalized value.\n    fn min_pos_norm_value() -> Self;\n}\n\nimpl DecodableFloat for f32 {\n    fn min_pos_norm_value() -> Self {\n}\n}\n\nimpl DecodableFloat for f64 {\n    fn min_pos_norm_value() -> Self {\n}\n}\n\n/// Returns a sign (true when negative) and `FullDecoded` value\n/// from given floating point number.\npub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n}\n}\npub mod estimator {\n//! The exponent estimator.\n\n/// Finds `k_0` such that `10^(k_0-1) < mant * 2^exp <= 10^(k_0+1)`.\n///\n/// This is used to approximate `k = ceil(log_10 (mant * 2^exp))`;\n/// the true `k` is either `k_0` or `k_0+1`.\n#[doc(hidden)]\npub fn estimate_scaling_factor(mant: u64, exp: i16) -> i16 {\n}\n}\n\n/// Digit-generation algorithms.\npub mod strategy {\n    pub mod dragon;\n    pub mod grisu;\n}\n\n/// The minimum size of buffer necessary for the shortest mode.\n///\n/// It is a bit non-trivial to derive, but this is one plus the maximal number of\n/// significant decimal digits from formatting algorithms with the shortest result.\n/// The exact formula is `ceil(# bits in mantissa * log_10 2 + 1)`.\npub const MAX_SIG_DIGITS: usize = 17;\n\n/// When `d[..n]` contains decimal digits, increase the last digit and propagate carry.\n/// Returns a next digit when it causes the length change.\n#[doc(hidden)]\npub fn round_up(d: &mut [u8], n: usize) -> Option<u8> {\n}\n\n/// Formatted parts.\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\npub enum Part<'a> {\n    /// Given number of zero digits.\n    Zero(usize),\n    /// A literal number up to 5 digits.\n    Num(u16),\n    /// A verbatim copy of given bytes.\n    Copy(&'a [u8]),\n}\n\nimpl<'a> Part<'a> {\n    /// Returns the exact byte length of given part.\n    pub fn len(&self) -> usize {\n}\n\n    /// Writes a part into the supplied buffer.\n    /// Returns the number of written bytes, or `None` if the buffer is not enough.\n    /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n    pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n}\n}\n\n/// Formatted result containing one or more parts.\n/// This can be written to the byte buffer or converted to the allocated string.\n#[allow(missing_debug_implementations)]\n#[derive(Clone)]\npub struct Formatted<'a> {\n    /// A byte slice representing a sign, either `\"\"`, `\"-\"` or `\"+\"`.\n    pub sign: &'static [u8],\n    /// Formatted parts to be rendered after a sign and optional zero padding.\n    pub parts: &'a [Part<'a>],\n}\n\nimpl<'a> Formatted<'a> {\n    /// Returns the exact byte length of combined formatted result.\n    pub fn len(&self) -> usize {\n}\n\n    /// Writes all formatted parts into the supplied buffer.\n    /// Returns the number of written bytes, or `None` if the buffer is not enough.\n    /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n    pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n}\n}\n\n/// Formats given decimal digits `0.<...buf...> * 10^exp` into the decimal form\n/// with at least given number of fractional digits. The result is stored to\n/// the supplied parts array and a slice of written parts is returned.\n///\n/// `frac_digits` can be less than the number of actual fractional digits in `buf`;\n/// it will be ignored and full digits will be printed. It is only used to print\n/// additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n/// it will only print given digits and nothing else.\nfn digits_to_dec_str<'a>(\n    buf: &'a [u8],\n    exp: i16,\n    frac_digits: usize,\n    parts: &'a mut [Part<'a>],\n) -> &'a [Part<'a>] {\n}\n\n/// Formats the given decimal digits `0.<...buf...> * 10^exp` into the exponential\n/// form with at least the given number of significant digits. When `upper` is `true`,\n/// the exponent will be prefixed by `E`; otherwise that's `e`. The result is\n/// stored to the supplied parts array and a slice of written parts is returned.\n///\n/// `min_digits` can be less than the number of actual significant digits in `buf`;\n/// it will be ignored and full digits will be printed. It is only used to print\n/// additional zeroes after rendered digits. Thus, `min_digits == 0` means that\n/// it will only print the given digits and nothing else.\nfn digits_to_exp_str<'a>(\n    buf: &'a [u8],\n    exp: i16,\n    min_ndigits: usize,\n    upper: bool,\n    parts: &'a mut [Part<'a>],\n) -> &'a [Part<'a>] {\n}\n\n/// Sign formatting options.\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\npub enum Sign {\n    /// Prints `-` only for the negative non-zero values.\n    Minus, // -inf -1  0  0  1  inf nan\n    /// Prints `-` only for any negative values (including the negative zero).\n    MinusRaw, // -inf -1 -0  0  1  inf nan\n    /// Prints `-` for the negative non-zero values, or `+` otherwise.\n    MinusPlus, // -inf -1 +0 +0 +1 +inf nan\n    /// Prints `-` for any negative values (including the negative zero), or `+` otherwise.\n    MinusPlusRaw, // -inf -1 -0 +0 +1 +inf nan\n}\n\n/// Returns the static byte string corresponding to the sign to be formatted.\n/// It can be either `b\"\"`, `b\"+\"` or `b\"-\"`.\nfn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static [u8] {\n}\n\n/// Formats the given floating point number into the decimal form with at least\n/// given number of fractional digits. The result is stored to the supplied parts\n/// array while utilizing given byte buffer as a scratch. `upper` is currently\n/// unused but left for the future decision to change the case of non-finite values,\n/// i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n/// (which can be an empty string if no sign is rendered).\n///\n/// `format_shortest` should be the underlying digit-generation function.\n/// You probably would want `strategy::grisu::format_shortest` for this.\n///\n/// `frac_digits` can be less than the number of actual fractional digits in `v`;\n/// it will be ignored and full digits will be printed. It is only used to print\n/// additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n/// it will only print given digits and nothing else.\n///\n/// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n/// There should be at least 4 parts available, due to the worst case like\n/// `[+][0.][0000][2][0000]` with `frac_digits = 10`.\npub fn to_shortest_str<'a, T, F>(\n    mut format_shortest: F,\n    v: T,\n    sign: Sign,\n    frac_digits: usize,\n    _upper: bool,\n    buf: &'a mut [u8],\n    parts: &'a mut [Part<'a>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n{\n}\n\n/// Formats the given floating point number into the decimal form or\n/// the exponential form, depending on the resulting exponent. The result is\n/// stored to the supplied parts array while utilizing given byte buffer\n/// as a scratch. `upper` is used to determine the case of non-finite values\n/// (`inf` and `nan`) or the case of the exponent prefix (`e` or `E`).\n/// The first part to be rendered is always a `Part::Sign` (which can be\n/// an empty string if no sign is rendered).\n///\n/// `format_shortest` should be the underlying digit-generation function.\n/// You probably would want `strategy::grisu::format_shortest` for this.\n///\n/// The `dec_bounds` is a tuple `(lo, hi)` such that the number is formatted\n/// as decimal only when `10^lo <= V < 10^hi`. Note that this is the *apparent* `V`\n/// instead of the actual `v`! Thus any printed exponent in the exponential form\n/// cannot be in this range, avoiding any confusion.\n///\n/// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n/// There should be at least 6 parts available, due to the worst case like\n/// `[+][1][.][2345][e][-][6]`.\npub fn to_shortest_exp_str<'a, T, F>(\n    mut format_shortest: F,\n    v: T,\n    sign: Sign,\n    dec_bounds: (i16, i16),\n    upper: bool,\n    buf: &'a mut [u8],\n    parts: &'a mut [Part<'a>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n{\n}\n\n/// Returns a rather crude approximation (upper bound) for the maximum buffer size\n/// calculated from the given decoded exponent.\n///\n/// The exact limit is:\n///\n/// - when `exp < 0`, the maximum length is `ceil(log_10 (5^-exp * (2^64 - 1)))`.\n/// - when `exp >= 0`, the maximum length is `ceil(log_10 (2^exp * (2^64 - 1)))`.\n///\n/// `ceil(log_10 (x^exp * (2^64 - 1)))` is less than `ceil(log_10 (2^64 - 1)) +\n/// ceil(exp * log_10 x)`, which is in turn less than `20 + (1 + exp * log_10 x)`.\n/// We use the facts that `log_10 2 < 5/16` and `log_10 5 < 12/16`, which is\n/// enough for our purposes.\n///\n/// Why do we need this? `format_exact` functions will fill the entire buffer\n/// unless limited by the last digit restriction, but it is possible that\n/// the number of digits requested is ridiculously large (say, 30,000 digits).\n/// The vast majority of buffer will be filled with zeroes, so we don't want to\n/// allocate all the buffer beforehand. Consequently, for any given arguments,\n/// 826 bytes of buffer should be sufficient for `f64`. Compare this with\n/// the actual number for the worst case: 770 bytes (when `exp = -1074`).\nfn estimate_max_buf_len(exp: i16) -> usize {\n}\n\n/// Formats given floating point number into the exponential form with\n/// exactly given number of significant digits. The result is stored to\n/// the supplied parts array while utilizing given byte buffer as a scratch.\n/// `upper` is used to determine the case of the exponent prefix (`e` or `E`).\n/// The first part to be rendered is always a `Part::Sign` (which can be\n/// an empty string if no sign is rendered).\n///\n/// `format_exact` should be the underlying digit-generation function.\n/// You probably would want `strategy::grisu::format_exact` for this.\n///\n/// The byte buffer should be at least `ndigits` bytes long unless `ndigits` is\n/// so large that only the fixed number of digits will be ever written.\n/// (The tipping point for `f64` is about 800, so 1000 bytes should be enough.)\n/// There should be at least 6 parts available, due to the worst case like\n/// `[+][1][.][2345][e][-][6]`.\npub fn to_exact_exp_str<'a, T, F>(\n    mut format_exact: F,\n    v: T,\n    sign: Sign,\n    ndigits: usize,\n    upper: bool,\n    buf: &'a mut [u8],\n    parts: &'a mut [Part<'a>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n{\n}\n\n/// Formats given floating point number into the decimal form with exactly\n/// given number of fractional digits. The result is stored to the supplied parts\n/// array while utilizing given byte buffer as a scratch. `upper` is currently\n/// unused but left for the future decision to change the case of non-finite values,\n/// i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n/// (which can be an empty string if no sign is rendered).\n///\n/// `format_exact` should be the underlying digit-generation function.\n/// You probably would want `strategy::grisu::format_exact` for this.\n///\n/// The byte buffer should be enough for the output unless `frac_digits` is\n/// so large that only the fixed number of digits will be ever written.\n/// (The tipping point for `f64` is about 800, and 1000 bytes should be enough.)\n/// There should be at least 4 parts available, due to the worst case like\n/// `[+][0.][0000][2][0000]` with `frac_digits = 10`.\npub fn to_exact_fixed_str<'a, T, F>(\n    mut format_exact: F,\n    v: T,\n    sign: Sign,\n    frac_digits: usize,\n    _upper: bool,\n    buf: &'a mut [u8],\n    parts: &'a mut [Part<'a>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16),\n{\n}\n}\n\nmod wrapping {\nuse super::Wrapping;\n\nuse crate::ops::*;\n\n#[allow(unused_macros)]\nmacro_rules! sh_impl_signed {\n    ($t:ident, $f:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Shl<$f> for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn shl(self, other: $f) -> Wrapping<$t> {\n}\n        }\n        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl ShlAssign<$f> for Wrapping<$t> {\n            #[inline]\n            fn shl_assign(&mut self, other: $f) {\n}\n        }\n        forward_ref_op_assign! { impl ShlAssign, shl_assign for Wrapping<$t>, $f }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Shr<$f> for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn shr(self, other: $f) -> Wrapping<$t> {\n}\n        }\n        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl ShrAssign<$f> for Wrapping<$t> {\n            #[inline]\n            fn shr_assign(&mut self, other: $f) {\n}\n        }\n        forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n    };\n}\n\nmacro_rules! sh_impl_unsigned {\n    ($t:ident, $f:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Shl<$f> for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn shl(self, other: $f) -> Wrapping<$t> {\n}\n        }\n        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl ShlAssign<$f> for Wrapping<$t> {\n            #[inline]\n            fn shl_assign(&mut self, other: $f) {\n}\n        }\n        forward_ref_op_assign! { impl ShlAssign, shl_assign for Wrapping<$t>, $f }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Shr<$f> for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn shr(self, other: $f) -> Wrapping<$t> {\n}\n        }\n        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n        #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl ShrAssign<$f> for Wrapping<$t> {\n            #[inline]\n            fn shr_assign(&mut self, other: $f) {\n}\n        }\n        forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n    };\n}\n\n// FIXME (#23545): uncomment the remaining impls\nmacro_rules! sh_impl_all {\n    ($($t:ident)*) => ($(\n        //sh_impl_unsigned! { $t, u8 }\n        //sh_impl_unsigned! { $t, u16 }\n        //sh_impl_unsigned! { $t, u32 }\n        //sh_impl_unsigned! { $t, u64 }\n        //sh_impl_unsigned! { $t, u128 }\n        sh_impl_unsigned! { $t, usize }\n\n        //sh_impl_signed! { $t, i8 }\n        //sh_impl_signed! { $t, i16 }\n        //sh_impl_signed! { $t, i32 }\n        //sh_impl_signed! { $t, i64 }\n        //sh_impl_signed! { $t, i128 }\n        //sh_impl_signed! { $t, isize }\n    )*)\n}\n\nsh_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n\n// FIXME(30524): impl Op<T> for Wrapping<T>, impl OpAssign<T> for Wrapping<T>\nmacro_rules! wrapping_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Add for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {\n}\n        }\n        forward_ref_binop! { impl Add, add for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl AddAssign for Wrapping<$t> {\n            #[inline]\n            fn add_assign(&mut self, other: Wrapping<$t>) {\n}\n        }\n        forward_ref_op_assign! { impl AddAssign, add_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Sub for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {\n}\n        }\n        forward_ref_binop! { impl Sub, sub for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl SubAssign for Wrapping<$t> {\n            #[inline]\n            fn sub_assign(&mut self, other: Wrapping<$t>) {\n}\n        }\n        forward_ref_op_assign! { impl SubAssign, sub_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Mul for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {\n}\n        }\n        forward_ref_binop! { impl Mul, mul for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl MulAssign for Wrapping<$t> {\n            #[inline]\n            fn mul_assign(&mut self, other: Wrapping<$t>) {\n}\n        }\n        forward_ref_op_assign! { impl MulAssign, mul_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"wrapping_div\", since = \"1.3.0\")]\n        impl Div for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {\n}\n        }\n        forward_ref_binop! { impl Div, div for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl DivAssign for Wrapping<$t> {\n            #[inline]\n            fn div_assign(&mut self, other: Wrapping<$t>) {\n}\n        }\n        forward_ref_op_assign! { impl DivAssign, div_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n        impl Rem for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {\n}\n        }\n        forward_ref_binop! { impl Rem, rem for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl RemAssign for Wrapping<$t> {\n            #[inline]\n            fn rem_assign(&mut self, other: Wrapping<$t>) {\n}\n        }\n        forward_ref_op_assign! { impl RemAssign, rem_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Not for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn not(self) -> Wrapping<$t> {\n}\n        }\n        forward_ref_unop! { impl Not, not for Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl BitXor for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n}\n        }\n        forward_ref_binop! { impl BitXor, bitxor for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl BitXorAssign for Wrapping<$t> {\n            #[inline]\n            fn bitxor_assign(&mut self, other: Wrapping<$t>) {\n}\n        }\n        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl BitOr for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n}\n        }\n        forward_ref_binop! { impl BitOr, bitor for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl BitOrAssign for Wrapping<$t> {\n            #[inline]\n            fn bitor_assign(&mut self, other: Wrapping<$t>) {\n}\n        }\n        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl BitAnd for Wrapping<$t> {\n            type Output = Wrapping<$t>;\n\n            #[inline]\n            fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {\n}\n        }\n        forward_ref_binop! { impl BitAnd, bitand for Wrapping<$t>, Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl BitAndAssign for Wrapping<$t> {\n            #[inline]\n            fn bitand_assign(&mut self, other: Wrapping<$t>) {\n}\n        }\n        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for Wrapping<$t>, Wrapping<$t> }\n\n        #[stable(feature = \"wrapping_neg\", since = \"1.10.0\")]\n        impl Neg for Wrapping<$t> {\n            type Output = Self;\n            #[inline]\n            fn neg(self) -> Self {\n}\n        }\n        forward_ref_unop! { impl Neg, neg for Wrapping<$t>,\n                #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n\n    )*)\n}\n\nwrapping_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\nmacro_rules! wrapping_int_impl {\n    ($($t:ty)*) => ($(\n        impl Wrapping<$t> {\n            doc_comment! {\n                concat!(\"Returns the smallest value that can be represented by this integer type.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(<Wrapping<\", stringify!($t), \">>::min_value(), \",\n\"Wrapping(\", stringify!($t), \"::min_value()));\n```\"),\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                #[inline]\n                pub const fn min_value() -> Self {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Returns the largest value that can be represented by this integer type.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(<Wrapping<\", stringify!($t), \">>::max_value(), \",\n\"Wrapping(\", stringify!($t), \"::max_value()));\n```\"),\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                #[inline]\n                pub const fn max_value() -> Self {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Returns the number of ones in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(0b01001100\", stringify!($t), \");\n\nassert_eq!(n.count_ones(), 3);\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub const fn count_ones(self) -> u32 {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Returns the number of zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(Wrapping(!0\", stringify!($t), \").count_zeros(), 0);\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub const fn count_zeros(self) -> u32 {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Returns the number of trailing zeros in the binary representation\nof `self`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(0b0101000\", stringify!($t), \");\n\nassert_eq!(n.trailing_zeros(), 3);\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub const fn trailing_zeros(self) -> u32 {\n}\n            }\n\n            /// Shifts the bits to the left by a specified amount, `n`,\n            /// wrapping the truncated bits to the end of the resulting\n            /// integer.\n            ///\n            /// Please note this isn't the same operation as the `<<` shifting\n            /// operator!\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n            /// let m: Wrapping<i64> = Wrapping(-0x76543210FEDCBA99);\n            ///\n            /// assert_eq!(n.rotate_left(32), m);\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn rotate_left(self, n: u32) -> Self {\n}\n\n            /// Shifts the bits to the right by a specified amount, `n`,\n            /// wrapping the truncated bits to the beginning of the resulting\n            /// integer.\n            ///\n            /// Please note this isn't the same operation as the `>>` shifting\n            /// operator!\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n            /// let m: Wrapping<i64> = Wrapping(-0xFEDCBA987654322);\n            ///\n            /// assert_eq!(n.rotate_right(4), m);\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn rotate_right(self, n: u32) -> Self {\n}\n\n            /// Reverses the byte order of the integer.\n            ///\n            /// # Examples\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// #![feature(wrapping_int_impl)]\n            /// use std::num::Wrapping;\n            ///\n            /// let n: Wrapping<i16> = Wrapping(0b0000000_01010101);\n            /// assert_eq!(n, Wrapping(85));\n            ///\n            /// let m = n.swap_bytes();\n            ///\n            /// assert_eq!(m, Wrapping(0b01010101_00000000));\n            /// assert_eq!(m, Wrapping(21760));\n            /// ```\n            #[inline]\n            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n            pub const fn swap_bytes(self) -> Self {\n}\n\n            /// Reverses the bit pattern of the integer.\n            ///\n            /// # Examples\n            ///\n            /// Please note that this example is shared between integer types.\n            /// Which explains why `i16` is used here.\n            ///\n            /// Basic usage:\n            ///\n            /// ```\n            /// use std::num::Wrapping;\n            ///\n            /// let n = Wrapping(0b0000000_01010101i16);\n            /// assert_eq!(n, Wrapping(85));\n            ///\n            /// let m = n.reverse_bits();\n            ///\n            /// assert_eq!(m.0 as u16, 0b10101010_00000000);\n            /// assert_eq!(m, Wrapping(-22016));\n            /// ```\n            #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n            #[rustc_const_stable(feature = \"const_reverse_bits\", since = \"1.37.0\")]\n            #[inline]\n            #[must_use]\n            pub const fn reverse_bits(self) -> Self {\n}\n\n            doc_comment! {\n                concat!(\"Converts an integer from big endian to the target's endianness.\n\nOn big endian this is a no-op. On little endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(0x1A\", stringify!($t), \");\n\nif cfg!(target_endian = \\\"big\\\") {\n    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_be(n), n)\n} else {\n    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_be(n), n.swap_bytes())\n}\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub const fn from_be(x: Self) -> Self {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Converts an integer from little endian to the target's endianness.\n\nOn little endian this is a no-op. On big endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(0x1A\", stringify!($t), \");\n\nif cfg!(target_endian = \\\"little\\\") {\n    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_le(n), n)\n} else {\n    assert_eq!(<Wrapping<\", stringify!($t), \">>::from_le(n), n.swap_bytes())\n}\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub const fn from_le(x: Self) -> Self {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Converts `self` to big endian from the target's endianness.\n\nOn big endian this is a no-op. On little endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(0x1A\", stringify!($t), \");\n\nif cfg!(target_endian = \\\"big\\\") {\n    assert_eq!(n.to_be(), n)\n} else {\n    assert_eq!(n.to_be(), n.swap_bytes())\n}\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub const fn to_be(self) -> Self {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Converts `self` to little endian from the target's endianness.\n\nOn little endian this is a no-op. On big endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(0x1A\", stringify!($t), \");\n\nif cfg!(target_endian = \\\"little\\\") {\n    assert_eq!(n.to_le(), n)\n} else {\n    assert_eq!(n.to_le(), n.swap_bytes())\n}\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub const fn to_le(self) -> Self {\n}\n            }\n\n        doc_comment! {\n            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(Wrapping(3\", stringify!($t), \").pow(4), Wrapping(81));\n```\n\nResults that are too large are wrapped:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(Wrapping(3i8).pow(5), Wrapping(-13));\nassert_eq!(Wrapping(3i8).pow(6), Wrapping(-39));\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub fn pow(self, exp: u32) -> Self {\n}\n            }\n        }\n    )*)\n}\n\nwrapping_int_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\nmacro_rules! wrapping_int_impl_signed {\n    ($($t:ty)*) => ($(\n        impl Wrapping<$t> {\n            doc_comment! {\n                concat!(\"Returns the number of leading zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(\", stringify!($t), \"::max_value()) >> 2;\n\nassert_eq!(n.leading_zeros(), 3);\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub const fn leading_zeros(self) -> u32 {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Computes the absolute value of `self`, wrapping around at\nthe boundary of the type.\n\nThe only case where such wrapping can occur is when one takes the absolute value of the negative\nminimal value for the type this is a positive value that is too large to represent in the type. In\nsuch a case, this function returns `MIN` itself.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(Wrapping(100\", stringify!($t), \").abs(), Wrapping(100));\nassert_eq!(Wrapping(-100\", stringify!($t), \").abs(), Wrapping(100));\nassert_eq!(Wrapping(\", stringify!($t), \"::min_value()).abs(), Wrapping(\", stringify!($t),\n\"::min_value()));\nassert_eq!(Wrapping(-128i8).abs().0 as u8, 128u8);\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub fn abs(self) -> Wrapping<$t> {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Returns a number representing sign of `self`.\n\n - `0` if the number is zero\n - `1` if the number is positive\n - `-1` if the number is negative\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert_eq!(Wrapping(10\", stringify!($t), \").signum(), Wrapping(1));\nassert_eq!(Wrapping(0\", stringify!($t), \").signum(), Wrapping(0));\nassert_eq!(Wrapping(-10\", stringify!($t), \").signum(), Wrapping(-1));\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub fn signum(self) -> Wrapping<$t> {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Returns `true` if `self` is positive and `false` if the number is zero or\nnegative.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert!(Wrapping(10\", stringify!($t), \").is_positive());\nassert!(!Wrapping(-10\", stringify!($t), \").is_positive());\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub const fn is_positive(self) -> bool {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Returns `true` if `self` is negative and `false` if the number is zero or\npositive.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert!(Wrapping(-10\", stringify!($t), \").is_negative());\nassert!(!Wrapping(10\", stringify!($t), \").is_negative());\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub const fn is_negative(self) -> bool {\n}\n            }\n        }\n    )*)\n}\n\nwrapping_int_impl_signed! { isize i8 i16 i32 i64 i128 }\n\nmacro_rules! wrapping_int_impl_unsigned {\n    ($($t:ty)*) => ($(\n        impl Wrapping<$t> {\n            doc_comment! {\n                concat!(\"Returns the number of leading zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nlet n = Wrapping(\", stringify!($t), \"::max_value()) >> 2;\n\nassert_eq!(n.leading_zeros(), 2);\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub const fn leading_zeros(self) -> u32 {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Returns `true` if and only if `self == 2^k` for some `k`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_int_impl)]\nuse std::num::Wrapping;\n\nassert!(Wrapping(16\", stringify!($t), \").is_power_of_two());\nassert!(!Wrapping(10\", stringify!($t), \").is_power_of_two());\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n                pub fn is_power_of_two(self) -> bool {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Returns the smallest power of two greater than or equal to `self`.\n\nWhen return value overflows (i.e., `self > (1 << (N-1))` for type\n`uN`), overflows to `2^N = 0`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_next_power_of_two)]\nuse std::num::Wrapping;\n\nassert_eq!(Wrapping(2\", stringify!($t), \").next_power_of_two(), Wrapping(2));\nassert_eq!(Wrapping(3\", stringify!($t), \").next_power_of_two(), Wrapping(4));\nassert_eq!(Wrapping(200_u8).next_power_of_two(), Wrapping(0));\n```\"),\n                #[inline]\n                #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                           reason = \"needs decision on wrapping behaviour\")]\n                pub fn next_power_of_two(self) -> Self {\n}\n            }\n        }\n    )*)\n}\n\nwrapping_int_impl_unsigned! { usize u8 u16 u32 u64 u128 }\n\nmod shift_max {\n    #![allow(non_upper_case_globals)]\n\n    #[cfg(target_pointer_width = \"16\")]\n    mod platform {\n        pub const usize: u32 = super::u16;\n        pub const isize: u32 = super::i16;\n    }\n\n    #[cfg(target_pointer_width = \"32\")]\n    mod platform {\n        pub const usize: u32 = super::u32;\n        pub const isize: u32 = super::i32;\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    mod platform {\n        pub const usize: u32 = super::u64;\n        pub const isize: u32 = super::i64;\n    }\n\n    pub const i8: u32 = (1 << 3) - 1;\n    pub const i16: u32 = (1 << 4) - 1;\n    pub const i32: u32 = (1 << 5) - 1;\n    pub const i64: u32 = (1 << 6) - 1;\n    pub const i128: u32 = (1 << 7) - 1;\n    pub use self::platform::isize;\n\n    pub const u8: u32 = i8;\n    pub const u16: u32 = i16;\n    pub const u32: u32 = i32;\n    pub const u64: u32 = i64;\n    pub const u128: u32 = i128;\n    pub use self::platform::usize;\n}\n}\n\nmacro_rules! usize_isize_to_xe_bytes_doc {\n    () => {\n        \"\n\n**Note**: This function returns an array of length 2, 4 or 8 bytes\ndepending on the target pointer size.\n\n\"\n    };\n}\n\nmacro_rules! usize_isize_from_xe_bytes_doc {\n    () => {\n        \"\n\n**Note**: This function takes an array of length 2, 4 or 8 bytes\ndepending on the target pointer size.\n\n\"\n    };\n}\n\nmacro_rules! int_impl {\n    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $Min:expr, $Max:expr, $Feature:expr,\n     $EndFeature:expr, $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n     $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n     $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) => {\n        doc_comment! {\n            concat!(\"Returns the smallest value that can be represented by this integer type.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::min_value(), \", stringify!($Min), \");\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[inline(always)]\n            #[rustc_promotable]\n            #[rustc_const_stable(feature = \"const_min_value\", since = \"1.32.0\")]\n            pub const fn min_value() -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the largest value that can be represented by this integer type.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value(), \", stringify!($Max), \");\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[inline(always)]\n            #[rustc_promotable]\n            #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n            pub const fn max_value() -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Converts a string slice in a given base to an integer.\n\nThe string is expected to be an optional `+` or `-` sign followed by digits.\nLeading and trailing whitespace represent an error. Digits are a subset of these characters,\ndepending on `radix`:\n\n * `0-9`\n * `a-z`\n * `A-Z`\n\n# Panics\n\nThis function panics if `radix` is not in the range from 2 to 36.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the number of ones in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = 0b100_0000\", stringify!($SelfT), \";\n\nassert_eq!(n.count_ones(), 1);\",\n$EndFeature, \"\n```\n\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn count_ones(self) -> u32 { }\n        }\n\n        doc_comment! {\n            concat!(\"Returns the number of zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 1);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn count_zeros(self) -> u32 {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the number of leading zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = -1\", stringify!($SelfT), \";\n\nassert_eq!(n.leading_zeros(), 0);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn leading_zeros(self) -> u32 {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the number of trailing zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = -4\", stringify!($SelfT), \";\n\nassert_eq!(n.trailing_zeros(), 2);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn trailing_zeros(self) -> u32 {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the number of leading ones in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"#![feature(leading_trailing_ones)]\nlet n = -1\", stringify!($SelfT), \";\n\nassert_eq!(n.leading_ones(), \", stringify!($BITS), \");\",\n$EndFeature, \"\n```\"),\n            #[unstable(feature = \"leading_trailing_ones\", issue = \"57969\")]\n            #[inline]\n            pub const fn leading_ones(self) -> u32 {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the number of trailing ones in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"#![feature(leading_trailing_ones)]\nlet n = 3\", stringify!($SelfT), \";\n\nassert_eq!(n.trailing_ones(), 2);\",\n$EndFeature, \"\n```\"),\n            #[unstable(feature = \"leading_trailing_ones\", issue = \"57969\")]\n            #[inline]\n            pub const fn trailing_ones(self) -> u32 {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Shifts the bits to the left by a specified amount, `n`,\nwrapping the truncated bits to the end of the resulting integer.\n\nPlease note this isn't the same operation as the `<<` shifting operator!\n\n# Examples\n\nBasic usage:\n\n```\nlet n = \", $rot_op, stringify!($SelfT), \";\nlet m = \", $rot_result, \";\n\nassert_eq!(n.rotate_left(\", $rot, \"), m);\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn rotate_left(self, n: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Shifts the bits to the right by a specified amount, `n`,\nwrapping the truncated bits to the beginning of the resulting\ninteger.\n\nPlease note this isn't the same operation as the `>>` shifting operator!\n\n# Examples\n\nBasic usage:\n\n```\nlet n = \", $rot_result, stringify!($SelfT), \";\nlet m = \", $rot_op, \";\n\nassert_eq!(n.rotate_right(\", $rot, \"), m);\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn rotate_right(self, n: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Reverses the byte order of the integer.\n\n# Examples\n\nBasic usage:\n\n```\nlet n = \", $swap_op, stringify!($SelfT), \";\n\nlet m = n.swap_bytes();\n\nassert_eq!(m, \", $swapped, \");\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn swap_bytes(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Reverses the bit pattern of the integer.\n\n# Examples\n\nBasic usage:\n\n```\nlet n = \", $swap_op, stringify!($SelfT), \";\nlet m = n.reverse_bits();\n\nassert_eq!(m, \", $reversed, \");\n```\"),\n            #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[inline]\n            #[must_use]\n            pub const fn reverse_bits(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Converts an integer from big endian to the target's endianness.\n\nOn big endian this is a no-op. On little endian the bytes are swapped.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n\nif cfg!(target_endian = \\\"big\\\") {\n    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\n} else {\n    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\n}\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn from_be(x: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Converts an integer from little endian to the target's endianness.\n\nOn little endian this is a no-op. On big endian the bytes are swapped.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n\nif cfg!(target_endian = \\\"little\\\") {\n    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\n} else {\n    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\n}\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn from_le(x: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Converts `self` to big endian from the target's endianness.\n\nOn big endian this is a no-op. On little endian the bytes are swapped.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n\nif cfg!(target_endian = \\\"big\\\") {\n    assert_eq!(n.to_be(), n)\n} else {\n    assert_eq!(n.to_be(), n.swap_bytes())\n}\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn to_be(self) -> Self { }\n        }\n\n        doc_comment! {\n            concat!(\"Converts `self` to little endian from the target's endianness.\n\nOn little endian this is a no-op. On big endian the bytes are swapped.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n\nif cfg!(target_endian = \\\"little\\\") {\n    assert_eq!(n.to_le(), n)\n} else {\n    assert_eq!(n.to_le(), n.swap_bytes())\n}\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn to_le(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked integer addition. Computes `self + rhs`, returning `None`\nif overflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!((\", stringify!($SelfT),\n\"::max_value() - 2).checked_add(1), Some(\", stringify!($SelfT), \"::max_value() - 1));\nassert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_add(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked integer subtraction. Computes `self - rhs`, returning `None` if\noverflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!((\", stringify!($SelfT),\n\"::min_value() + 2).checked_sub(1), Some(\", stringify!($SelfT), \"::min_value() + 1));\nassert_eq!((\", stringify!($SelfT), \"::min_value() + 2).checked_sub(3), None);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked integer multiplication. Computes `self * rhs`, returning `None` if\noverflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(\", stringify!($SelfT),\n\"::max_value().checked_mul(1), Some(\", stringify!($SelfT), \"::max_value()));\nassert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`\nor the division results in overflow.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!((\", stringify!($SelfT),\n\"::min_value() + 1).checked_div(-1), Some(\", stringify!($Max), \"));\nassert_eq!(\", stringify!($SelfT), \"::min_value().checked_div(-1), None);\nassert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_div(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked Euclidean division. Computes `self.div_euclid(rhs)`,\nreturning `None` if `rhs == 0` or the division results in overflow.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!((\", stringify!($SelfT),\n\"::min_value() + 1).checked_div_euclid(-1), Some(\", stringify!($Max), \"));\nassert_eq!(\", stringify!($SelfT), \"::min_value().checked_div_euclid(-1), None);\nassert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked integer remainder. Computes `self % rhs`, returning `None` if\n`rhs == 0` or the division results in overflow.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\nassert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\nassert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked Euclidean remainder. Computes `self.rem_euclid(rhs)`, returning `None`\nif `rhs == 0` or the division results in overflow.\n\n# Examples\n\nBasic usage:\n\n```\nuse std::\", stringify!($SelfT), \";\n\nassert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\nassert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\nassert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked negation. Computes `-self`, returning `None` if `self == MIN`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!(5\", stringify!($SelfT), \".checked_neg(), Some(-5));\nassert_eq!(\", stringify!($SelfT), \"::MIN.checked_neg(), None);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[inline]\n            pub fn checked_neg(self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger\nthan or equal to the number of bits in `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\nassert_eq!(0x1\", stringify!($SelfT), \".checked_shl(129), None);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is\nlarger than or equal to the number of bits in `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\nassert_eq!(0x10\", stringify!($SelfT), \".checked_shr(128), None);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked absolute value. Computes `self.abs()`, returning `None` if\n`self == MIN`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!((-5\", stringify!($SelfT), \").checked_abs(), Some(5));\nassert_eq!(\", stringify!($SelfT), \"::MIN.checked_abs(), None);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n            #[inline]\n            pub fn checked_abs(self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\noverflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(8\", stringify!($SelfT), \".checked_pow(2), Some(64));\nassert_eq!(\", stringify!($SelfT), \"::max_value().checked_pow(2), None);\",\n$EndFeature, \"\n```\"),\n\n            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at the numeric\nbounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\nassert_eq!(\", stringify!($SelfT), \"::max_value().saturating_add(100), \", stringify!($SelfT),\n\"::max_value());\nassert_eq!(\", stringify!($SelfT), \"::min_value().saturating_add(-1), \", stringify!($SelfT),\n\"::min_value());\",\n$EndFeature, \"\n```\"),\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_unstable(feature = \"const_saturating_int_methods\", issue = \"53718\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn saturating_add(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating at the\nnumeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\nassert_eq!(\", stringify!($SelfT), \"::min_value().saturating_sub(100), \", stringify!($SelfT),\n\"::min_value());\nassert_eq!(\", stringify!($SelfT), \"::max_value().saturating_sub(-1), \", stringify!($SelfT),\n\"::max_value());\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_unstable(feature = \"const_saturating_int_methods\", issue = \"53718\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn saturating_sub(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Saturating integer negation. Computes `-self`, returning `MAX` if `self == MIN`\ninstead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"#![feature(saturating_neg)]\nassert_eq!(100\", stringify!($SelfT), \".saturating_neg(), -100);\nassert_eq!((-100\", stringify!($SelfT), \").saturating_neg(), 100);\nassert_eq!(\", stringify!($SelfT), \"::min_value().saturating_neg(), \", stringify!($SelfT),\n\"::max_value());\nassert_eq!(\", stringify!($SelfT), \"::max_value().saturating_neg(), \", stringify!($SelfT),\n\"::min_value() + 1);\",\n$EndFeature, \"\n```\"),\n\n            #[unstable(feature = \"saturating_neg\", issue = \"59983\")]\n            #[inline]\n            pub fn saturating_neg(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Saturating absolute value. Computes `self.abs()`, returning `MAX` if `self ==\nMIN` instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"#![feature(saturating_neg)]\nassert_eq!(100\", stringify!($SelfT), \".saturating_abs(), 100);\nassert_eq!((-100\", stringify!($SelfT), \").saturating_abs(), 100);\nassert_eq!(\", stringify!($SelfT), \"::min_value().saturating_abs(), \", stringify!($SelfT),\n\"::max_value());\nassert_eq!((\", stringify!($SelfT), \"::min_value() + 1).saturating_abs(), \", stringify!($SelfT),\n\"::max_value());\",\n$EndFeature, \"\n```\"),\n\n            #[unstable(feature = \"saturating_neg\", issue = \"59983\")]\n            #[inline]\n            pub fn saturating_abs(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Saturating integer multiplication. Computes `self * rhs`, saturating at the\nnumeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!(10\", stringify!($SelfT), \".saturating_mul(12), 120);\nassert_eq!(\", stringify!($SelfT), \"::MAX.saturating_mul(10), \", stringify!($SelfT), \"::MAX);\nassert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(10), \", stringify!($SelfT), \"::MIN);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn saturating_mul(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Saturating integer exponentiation. Computes `self.pow(exp)`,\nsaturating at the numeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!((-4\", stringify!($SelfT), \").saturating_pow(3), -64);\nassert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\nassert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT), \"::MIN);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn saturating_pow(self, exp: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\nboundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_add(27), 127);\nassert_eq!(\", stringify!($SelfT), \"::max_value().wrapping_add(2), \", stringify!($SelfT),\n\"::min_value() + 1);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn wrapping_add(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around at the\nboundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub(127), -127);\nassert_eq!((-2\", stringify!($SelfT), \").wrapping_sub(\", stringify!($SelfT), \"::max_value()), \",\nstringify!($SelfT), \"::max_value());\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn wrapping_sub(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) multiplication. Computes `self * rhs`, wrapping around at\nthe boundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(10\", stringify!($SelfT), \".wrapping_mul(12), 120);\nassert_eq!(11i8.wrapping_mul(12), -124);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn wrapping_mul(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) division. Computes `self / rhs`, wrapping around at the\nboundary of the type.\n\nThe only case where such wrapping can occur is when one divides `MIN / -1` on a signed type (where\n`MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\nthat is too large to represent in the type. In such a case, this function returns `MIN` itself.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\nassert_eq!((-128i8).wrapping_div(-1), -128);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn wrapping_div(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping Euclidean division. Computes `self.div_euclid(rhs)`,\nwrapping around at the boundary of the type.\n\nWrapping will only occur in `MIN / -1` on a signed type (where `MIN` is the negative minimal value\nfor the type). This is equivalent to `-MIN`, a positive value that is too large to represent in the\ntype. In this case, this method returns `MIN` itself.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\nassert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) remainder. Computes `self % rhs`, wrapping around at the\nboundary of the type.\n\nSuch wrap-around never actually occurs mathematically; implementation artifacts make `x % y`\ninvalid for `MIN / -1` on a signed type (where `MIN` is the negative minimal value). In such a case,\nthis function returns `0`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\nassert_eq!((-128i8).wrapping_rem(-1), 0);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn wrapping_rem(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping Euclidean remainder. Computes `self.rem_euclid(rhs)`, wrapping around\nat the boundary of the type.\n\nWrapping will only occur in `MIN % -1` on a signed type (where `MIN` is the negative minimal value\nfor the type). In this case, this method returns 0.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\nassert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\nof the type.\n\nThe only case where such wrapping can occur is when one negates `MIN` on a signed type (where `MIN`\nis the negative minimal value for the type); this is a positive value that is too large to represent\nin the type. In such a case, this function returns `MIN` itself.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_neg(), -100);\nassert_eq!(\", stringify!($SelfT), \"::min_value().wrapping_neg(), \", stringify!($SelfT),\n\"::min_value());\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn wrapping_neg(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes\nany high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n\nNote that this is *not* the same as a rotate-left; the RHS of a wrapping shift-left is restricted to\nthe range of the type, rather than the bits shifted out of the LHS being returned to the other end.\nThe primitive integer types all implement a `rotate_left` function, which may be what you want\ninstead.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(7), -128);\nassert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(128), -1);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn wrapping_shl(self, rhs: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask`\nremoves any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n\nNote that this is *not* the same as a rotate-right; the RHS of a wrapping shift-right is restricted\nto the range of the type, rather than the bits shifted out of the LHS being returned to the other\nend. The primitive integer types all implement a `rotate_right` function, which may be what you want\ninstead.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!((-128\", stringify!($SelfT), \").wrapping_shr(7), -1);\nassert_eq!((-128i16).wrapping_shr(64), -128);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn wrapping_shr(self, rhs: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\nthe boundary of the type.\n\nThe only case where such wrapping can occur is when one takes the absolute value of the negative\nminimal value for the type this is a positive value that is too large to represent in the type. In\nsuch a case, this function returns `MIN` itself.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_abs(), 100);\nassert_eq!((-100\", stringify!($SelfT), \").wrapping_abs(), 100);\nassert_eq!(\", stringify!($SelfT), \"::min_value().wrapping_abs(), \", stringify!($SelfT),\n\"::min_value());\nassert_eq!((-128i8).wrapping_abs() as u8, 128);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[allow(unused_attributes)]\n            #[allow_internal_unstable(const_if_match)]\n            #[inline]\n            pub const fn wrapping_abs(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\nwrapping around at the boundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(4), 81);\nassert_eq!(3i8.wrapping_pow(5), -13);\nassert_eq!(3i8.wrapping_pow(6), -39);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn wrapping_pow(self, mut exp: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Calculates `self` + `rhs`\n\nReturns a tuple of the addition along with a boolean indicating whether an arithmetic overflow would\noccur. If an overflow would have occurred then the wrapped value is returned.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\nassert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($SelfT),\n\"::MIN, true));\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Calculates `self` - `rhs`\n\nReturns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\nwould occur. If an overflow would have occurred then the wrapped value is returned.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\nassert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($SelfT),\n\"::MAX, true));\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Calculates the multiplication of `self` and `rhs`.\n\nReturns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow\nwould occur. If an overflow would have occurred then the wrapped value is returned.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".overflowing_mul(2), (10, false));\nassert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Calculates the divisor when `self` is divided by `rhs`.\n\nReturns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\noccur. If an overflow would occur then self is returned.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\nassert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div(-1), (\", stringify!($SelfT),\n\"::MIN, true));\",\n$EndFeature, \"\n```\"),\n            #[inline]\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n\nReturns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\noccur. If an overflow would occur then `self` is returned.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\nuse std::\", stringify!($SelfT), \";\n\nassert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\nassert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringify!($SelfT),\n\"::MIN, true));\n```\"),\n            #[inline]\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Calculates the remainder when `self` is divided by `rhs`.\n\nReturns a tuple of the remainder after dividing along with a boolean indicating whether an\narithmetic overflow would occur. If an overflow would occur then 0 is returned.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\nassert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem(-1), (0, true));\",\n$EndFeature, \"\n```\"),\n            #[inline]\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n\n        doc_comment! {\n            concat!(\"Overflowing Euclidean remainder. Calculates `self.rem_euclid(rhs)`.\n\nReturns a tuple of the remainder after dividing along with a boolean indicating whether an\narithmetic overflow would occur. If an overflow would occur then 0 is returned.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\nuse std::\", stringify!($SelfT), \";\n\nassert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\nassert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n\n        doc_comment! {\n            concat!(\"Negates self, overflowing if this is equal to the minimum value.\n\nReturns a tuple of the negated version of self along with a boolean indicating whether an overflow\nhappened. If `self` is the minimum value (e.g., `i32::MIN` for values of type `i32`), then the\nminimum value will be returned again and `true` will be returned for an overflow happening.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2, false));\nassert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($SelfT),\n\"::MIN, true));\", $EndFeature, \"\n```\"),\n            #[inline]\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[allow(unused_attributes)]\n            #[allow_internal_unstable(const_if_match)]\n            pub const fn overflowing_neg(self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Shifts self left by `rhs` bits.\n\nReturns a tuple of the shifted version of self along with a boolean indicating whether the shift\nvalue was larger than or equal to the number of bits. If the shift value is too large, then value is\nmasked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(0x1\", stringify!($SelfT),\".overflowing_shl(4), (0x10, false));\nassert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Shifts self right by `rhs` bits.\n\nReturns a tuple of the shifted version of self along with a boolean indicating whether the shift\nvalue was larger than or equal to the number of bits. If the shift value is too large, then value is\nmasked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\nassert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Computes the absolute value of `self`.\n\nReturns a tuple of the absolute version of self along with a boolean indicating whether an overflow\nhappened. If self is the minimum value (e.g., \", stringify!($SelfT), \"::MIN for values of type\n \", stringify!($SelfT), \"), then the minimum value will be returned again and true will be returned\nfor an overflow happening.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(10\", stringify!($SelfT), \".overflowing_abs(), (10, false));\nassert_eq!((-10\", stringify!($SelfT), \").overflowing_abs(), (10, false));\nassert_eq!((\", stringify!($SelfT), \"::min_value()).overflowing_abs(), (\", stringify!($SelfT),\n\"::min_value(), true));\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn overflowing_abs(self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n\nReturns a tuple of the exponentiation along with a bool indicating\nwhether an overflow happened.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(4), (81, false));\nassert_eq!(3i8.overflowing_pow(5), (-13, true));\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let x: \", stringify!($SelfT), \" = 2; // or any other integer type\n\nassert_eq!(x.pow(5), 32);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            pub fn pow(self, mut exp: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Calculates the quotient of Euclidean division of `self` by `rhs`.\n\nThis computes the integer `n` such that `self = n * rhs + self.rem_euclid(rhs)`,\nwith `0 <= self.rem_euclid(rhs) < rhs`.\n\nIn other words, the result is `self / rhs` rounded to the integer `n`\nsuch that `self >= n * rhs`.\nIf `self > 0`, this is equal to round towards zero (the default in Rust);\nif `self < 0`, this is equal to round towards +/- infinity.\n\n# Panics\n\nThis function will panic if `rhs` is 0 or the division results in overflow.\n\n# Examples\n\nBasic usage:\n\n```\nlet a: \", stringify!($SelfT), \" = 7; // or any other integer type\nlet b = 4;\n\nassert_eq!(a.div_euclid(b), 1); // 7 >= 4 * 1\nassert_eq!(a.div_euclid(-b), -1); // 7 >= -4 * -1\nassert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\nassert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            pub fn div_euclid(self, rhs: Self) -> Self {\n}\n        }\n\n\n        doc_comment! {\n            concat!(\"Calculates the least nonnegative remainder of `self (mod rhs)`.\n\nThis is done as if by the Euclidean division algorithm -- given\n`r = self.rem_euclid(rhs)`, `self = rhs * self.div_euclid(rhs) + r`, and\n`0 <= r < abs(rhs)`.\n\n# Panics\n\nThis function will panic if `rhs` is 0 or the division results in overflow.\n\n# Examples\n\nBasic usage:\n\n```\nlet a: \", stringify!($SelfT), \" = 7; // or any other integer type\nlet b = 4;\n\nassert_eq!(a.rem_euclid(b), 3);\nassert_eq!((-a).rem_euclid(b), 1);\nassert_eq!(a.rem_euclid(-b), 3);\nassert_eq!((-a).rem_euclid(-b), 1);\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            pub fn rem_euclid(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Computes the absolute value of `self`.\n\n# Overflow behavior\n\nThe absolute value of `\", stringify!($SelfT), \"::min_value()` cannot be represented as an\n`\", stringify!($SelfT), \"`, and attempting to calculate it will cause an overflow. This means that\ncode in debug mode will trigger a panic on this case and optimized code will return `\",\nstringify!($SelfT), \"::min_value()` without a panic.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(10\", stringify!($SelfT), \".abs(), 10);\nassert_eq!((-10\", stringify!($SelfT), \").abs(), 10);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[allow(unused_attributes)]\n            #[allow_internal_unstable(const_if_match)]\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            pub const fn abs(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns a number representing sign of `self`.\n\n - `0` if the number is zero\n - `1` if the number is positive\n - `-1` if the number is negative\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(10\", stringify!($SelfT), \".signum(), 1);\nassert_eq!(0\", stringify!($SelfT), \".signum(), 0);\nassert_eq!((-10\", stringify!($SelfT), \").signum(), -1);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_unstable(feature = \"const_int_sign\", issue = \"53718\")]\n            #[inline]\n            pub const fn signum(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns `true` if `self` is positive and `false` if the number is zero or\nnegative.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert!(10\", stringify!($SelfT), \".is_positive());\nassert!(!(-10\", stringify!($SelfT), \").is_positive());\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn is_positive(self) -> bool { }\n        }\n\n        doc_comment! {\n            concat!(\"Returns `true` if `self` is negative and `false` if the number is zero or\npositive.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert!((-10\", stringify!($SelfT), \").is_negative());\nassert!(!10\", stringify!($SelfT), \".is_negative());\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn is_negative(self) -> bool { }\n        }\n\n        doc_comment! {\n            concat!(\"Return the memory representation of this integer as a byte array in\nbig-endian (network) byte order.\n\",\n$to_xe_bytes_doc,\n\"\n# Examples\n\n```\nlet bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\nassert_eq!(bytes, \", $be_bytes, \");\n```\"),\n            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n            #[rustc_const_unstable(feature = \"const_int_conversion\", issue = \"53718\")]\n            #[inline]\n            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n}\n        }\n\ndoc_comment! {\n            concat!(\"Return the memory representation of this integer as a byte array in\nlittle-endian byte order.\n\",\n$to_xe_bytes_doc,\n\"\n# Examples\n\n```\nlet bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\nassert_eq!(bytes, \", $le_bytes, \");\n```\"),\n            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n            #[rustc_const_unstable(feature = \"const_int_conversion\", issue = \"53718\")]\n            #[inline]\n            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n}\n        }\n\n        doc_comment! {\n            concat!(\"\nReturn the memory representation of this integer as a byte array in\nnative byte order.\n\nAs the target platform's native endianness is used, portable code\nshould use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\ninstead.\n\",\n$to_xe_bytes_doc,\n\"\n[`to_be_bytes`]: #method.to_be_bytes\n[`to_le_bytes`]: #method.to_le_bytes\n\n# Examples\n\n```\nlet bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\nassert_eq!(\n    bytes,\n    if cfg!(target_endian = \\\"big\\\") {\n        \", $be_bytes, \"\n    } else {\n        \", $le_bytes, \"\n    }\n);\n```\"),\n            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n            #[rustc_const_unstable(feature = \"const_int_conversion\", issue = \"53718\")]\n            #[inline]\n            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n}\n        }\n\ndoc_comment! {\n            concat!(\"Create an integer value from its representation as a byte array in\nbig endian.\n\",\n$from_xe_bytes_doc,\n\"\n# Examples\n\n```\nlet value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\nassert_eq!(value, \", $swap_op, \");\n```\n\nWhen starting from a slice rather than an array, fallible conversion APIs can be used:\n\n```\nuse std::convert::TryInto;\n\nfn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n}\n```\"),\n            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n            #[rustc_const_unstable(feature = \"const_int_conversion\", issue = \"53718\")]\n            #[inline]\n            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n}\n        }\n\ndoc_comment! {\n            concat!(\"\nCreate an integer value from its representation as a byte array in\nlittle endian.\n\",\n$from_xe_bytes_doc,\n\"\n# Examples\n\n```\nlet value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\nassert_eq!(value, \", $swap_op, \");\n```\n\nWhen starting from a slice rather than an array, fallible conversion APIs can be used:\n\n```\nuse std::convert::TryInto;\n\nfn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n}\n```\"),\n            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n            #[rustc_const_unstable(feature = \"const_int_conversion\", issue = \"53718\")]\n            #[inline]\n            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Create an integer value from its memory representation as a byte\narray in native endianness.\n\nAs the target platform's native endianness is used, portable code\nlikely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\nappropriate instead.\n\n[`from_be_bytes`]: #method.from_be_bytes\n[`from_le_bytes`]: #method.from_le_bytes\n\",\n$from_xe_bytes_doc,\n\"\n# Examples\n\n```\nlet value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\n    \", $be_bytes, \"\n} else {\n    \", $le_bytes, \"\n});\nassert_eq!(value, \", $swap_op, \");\n```\n\nWhen starting from a slice rather than an array, fallible conversion APIs can be used:\n\n```\nuse std::convert::TryInto;\n\nfn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n}\n```\"),\n            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n            #[rustc_const_unstable(feature = \"const_int_conversion\", issue = \"53718\")]\n            #[inline]\n            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n}\n        }\n    }\n}\n\n#[lang = \"i8\"]\nimpl i8 {\n    int_impl! { i8, i8, u8, 8, -128, 127, \"\", \"\", 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n    \"[0x12]\", \"[0x12]\", \"\", \"\" }\n}\n\n#[lang = \"i16\"]\nimpl i16 {\n    int_impl! { i16, i16, u16, 16, -32768, 32767, \"\", \"\", 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n    \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n}\n\n#[lang = \"i32\"]\nimpl i32 {\n    int_impl! { i32, i32, u32, 32, -2147483648, 2147483647, \"\", \"\", 8, \"0x10000b3\", \"0xb301\",\n    \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n    \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n}\n\n#[lang = \"i64\"]\nimpl i64 {\n    int_impl! { i64, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\", 12,\n    \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n    \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\", \"\", \"\" }\n}\n\n#[lang = \"i128\"]\nimpl i128 {\n    int_impl! { i128, i128, u128, 128, -170141183460469231731687303715884105728,\n    170141183460469231731687303715884105727, \"\", \"\", 16,\n    \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n    \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n    \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n      0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n      0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\", \"\", \"\" }\n}\n\n#[cfg(target_pointer_width = \"16\")]\n#[lang = \"isize\"]\nimpl isize {\n    int_impl! { isize, i16, u16, 16, -32768, 32767, \"\", \"\", 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n    \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n}\n\n#[cfg(target_pointer_width = \"32\")]\n#[lang = \"isize\"]\nimpl isize {\n    int_impl! { isize, i32, u32, 32, -2147483648, 2147483647, \"\", \"\", 8, \"0x10000b3\", \"0xb301\",\n    \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n    \"[0x12, 0x34, 0x56, 0x78]\",\n    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n}\n\n#[cfg(target_pointer_width = \"64\")]\n#[lang = \"isize\"]\nimpl isize {\n    int_impl! { isize, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\",\n    12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n     \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n}\n\nmacro_rules! uint_impl {\n    ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr,\n        $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n        $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n        $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) => {\n        doc_comment! {\n            concat!(\"Returns the smallest value that can be represented by this integer type.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::min_value(), 0);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_promotable]\n            #[inline(always)]\n            #[rustc_const_stable(feature = \"const_min_value\", since = \"1.32.0\")]\n            pub const fn min_value() -> Self { }\n        }\n\n        doc_comment! {\n            concat!(\"Returns the largest value that can be represented by this integer type.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value(), \",\nstringify!($MaxV), \");\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_promotable]\n            #[inline(always)]\n            #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n            pub const fn max_value() -> Self { }\n        }\n\n        doc_comment! {\n            concat!(\"Converts a string slice in a given base to an integer.\n\nThe string is expected to be an optional `+` sign\nfollowed by digits.\nLeading and trailing whitespace represent an error.\nDigits are a subset of these characters, depending on `radix`:\n\n* `0-9`\n* `a-z`\n* `A-Z`\n\n# Panics\n\nThis function panics if `radix` is not in the range from 2 to 36.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::from_str_radix(\\\"A\\\", 16), Ok(10));\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the number of ones in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = 0b01001100\", stringify!($SelfT), \";\n\nassert_eq!(n.count_ones(), 3);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn count_ones(self) -> u32 {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the number of zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 0);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn count_zeros(self) -> u32 {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the number of leading zeros in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = \", stringify!($SelfT), \"::max_value() >> 2;\n\nassert_eq!(n.leading_zeros(), 2);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn leading_zeros(self) -> u32 {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the number of trailing zeros in the binary representation\nof `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = 0b0101000\", stringify!($SelfT), \";\n\nassert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn trailing_zeros(self) -> u32 {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the number of leading ones in the binary representation of `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"#![feature(leading_trailing_ones)]\nlet n = !(\", stringify!($SelfT), \"::max_value() >> 2);\n\nassert_eq!(n.leading_ones(), 2);\", $EndFeature, \"\n```\"),\n            #[unstable(feature = \"leading_trailing_ones\", issue = \"57969\")]\n            #[inline]\n            pub const fn leading_ones(self) -> u32 {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the number of trailing ones in the binary representation\nof `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"#![feature(leading_trailing_ones)]\nlet n = 0b1010111\", stringify!($SelfT), \";\n\nassert_eq!(n.trailing_ones(), 3);\", $EndFeature, \"\n```\"),\n            #[unstable(feature = \"leading_trailing_ones\", issue = \"57969\")]\n            #[inline]\n            pub const fn trailing_ones(self) -> u32 {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Shifts the bits to the left by a specified amount, `n`,\nwrapping the truncated bits to the end of the resulting integer.\n\nPlease note this isn't the same operation as the `<<` shifting operator!\n\n# Examples\n\nBasic usage:\n\n```\nlet n = \", $rot_op, stringify!($SelfT), \";\nlet m = \", $rot_result, \";\n\nassert_eq!(n.rotate_left(\", $rot, \"), m);\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn rotate_left(self, n: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Shifts the bits to the right by a specified amount, `n`,\nwrapping the truncated bits to the beginning of the resulting\ninteger.\n\nPlease note this isn't the same operation as the `>>` shifting operator!\n\n# Examples\n\nBasic usage:\n\n```\nlet n = \", $rot_result, stringify!($SelfT), \";\nlet m = \", $rot_op, \";\n\nassert_eq!(n.rotate_right(\", $rot, \"), m);\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn rotate_right(self, n: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"\nReverses the byte order of the integer.\n\n# Examples\n\nBasic usage:\n\n```\nlet n = \", $swap_op, stringify!($SelfT), \";\nlet m = n.swap_bytes();\n\nassert_eq!(m, \", $swapped, \");\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn swap_bytes(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Reverses the bit pattern of the integer.\n\n# Examples\n\nBasic usage:\n\n```\nlet n = \", $swap_op, stringify!($SelfT), \";\nlet m = n.reverse_bits();\n\nassert_eq!(m, \", $reversed, \");\n```\"),\n            #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n            #[inline]\n            #[must_use]\n            pub const fn reverse_bits(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Converts an integer from big endian to the target's endianness.\n\nOn big endian this is a no-op. On little endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n\nif cfg!(target_endian = \\\"big\\\") {\n    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\n} else {\n    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\n}\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn from_be(x: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Converts an integer from little endian to the target's endianness.\n\nOn little endian this is a no-op. On big endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n\nif cfg!(target_endian = \\\"little\\\") {\n    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\n} else {\n    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\n}\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn from_le(x: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Converts `self` to big endian from the target's endianness.\n\nOn big endian this is a no-op. On little endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n\nif cfg!(target_endian = \\\"big\\\") {\n    assert_eq!(n.to_be(), n)\n} else {\n    assert_eq!(n.to_be(), n.swap_bytes())\n}\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn to_be(self) -> Self { }\n        }\n\n        doc_comment! {\n            concat!(\"Converts `self` to little endian from the target's endianness.\n\nOn little endian this is a no-op. On big endian the bytes are\nswapped.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"let n = 0x1A\", stringify!($SelfT), \";\n\nif cfg!(target_endian = \\\"little\\\") {\n    assert_eq!(n.to_le(), n)\n} else {\n    assert_eq!(n.to_le(), n.swap_bytes())\n}\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn to_le(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked integer addition. Computes `self + rhs`, returning `None`\nif overflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(1), \",\n\"Some(\", stringify!($SelfT), \"::max_value() - 1));\nassert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_add(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked integer subtraction. Computes `self - rhs`, returning\n`None` if overflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\nassert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked integer multiplication. Computes `self * rhs`, returning\n`None` if overflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\nassert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked integer division. Computes `self / rhs`, returning `None`\nif `rhs == 0`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\nassert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_div(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\nif `rhs == 0`.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\nassert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n\n        doc_comment! {\n            concat!(\"Checked integer remainder. Computes `self % rhs`, returning `None`\nif `rhs == 0`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\nassert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\nif `rhs == 0`.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\nassert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked negation. Computes `-self`, returning `None` unless `self ==\n0`.\n\nNote that negating any positive integer will overflow.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\nassert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[inline]\n            pub fn checked_neg(self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked shift left. Computes `self << rhs`, returning `None`\nif `rhs` is larger than or equal to the number of bits in `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\nassert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked shift right. Computes `self >> rhs`, returning `None`\nif `rhs` is larger than or equal to the number of bits in `self`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\nassert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\noverflow occurred.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\nassert_eq!(\", stringify!($SelfT), \"::max_value().checked_pow(2), None);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Saturating integer addition. Computes `self + rhs`, saturating at\nthe numeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\nassert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n```\"),\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[rustc_const_unstable(feature = \"const_saturating_int_methods\", issue = \"53718\")]\n            #[inline]\n            pub const fn saturating_add(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Saturating integer subtraction. Computes `self - rhs`, saturating\nat the numeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\nassert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[rustc_const_unstable(feature = \"const_saturating_int_methods\", issue = \"53718\")]\n            #[inline]\n            pub const fn saturating_sub(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Saturating integer multiplication. Computes `self * rhs`,\nsaturating at the numeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\nassert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\n\"::MAX);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn saturating_mul(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Saturating integer exponentiation. Computes `self.pow(exp)`,\nsaturating at the numeric bounds instead of overflowing.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\nassert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn saturating_pow(self, exp: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) addition. Computes `self + rhs`,\nwrapping around at the boundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\nassert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::max_value()), 199);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn wrapping_add(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) subtraction. Computes `self - rhs`,\nwrapping around at the boundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\nassert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::max_value()), 101);\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn wrapping_sub(self, rhs: Self) -> Self {\n}\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n}\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) division. Computes `self / rhs`.\nWrapped division on unsigned types is just normal division.\nThere's no way wrapping could ever happen.\nThis function exists, so that all operations\nare accounted for in the wrapping operations.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn wrapping_div(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\nWrapped division on unsigned types is just normal division.\nThere's no way wrapping could ever happen.\nThis function exists, so that all operations\nare accounted for in the wrapping operations.\nSince, for the positive integers, all common\ndefinitions of division are equal, this\nis exactly equal to `self.wrapping_div(rhs)`.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) remainder. Computes `self % rhs`.\nWrapped remainder calculation on unsigned types is\njust the regular remainder calculation.\nThere's no way wrapping could ever happen.\nThis function exists, so that all operations\nare accounted for in the wrapping operations.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn wrapping_rem(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\nWrapped modulo calculation on unsigned types is\njust the regular remainder calculation.\nThere's no way wrapping could ever happen.\nThis function exists, so that all operations\nare accounted for in the wrapping operations.\nSince, for the positive integers, all common\ndefinitions of division are equal, this\nis exactly equal to `self.wrapping_rem(rhs)`.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n}\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(100i8.wrapping_neg(), -100);\n        /// assert_eq!((-128i8).wrapping_neg(), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[inline]\n        pub const fn wrapping_neg(self) -> Self {\n}\n\n        doc_comment! {\n            concat!(\"Panic-free bitwise shift-left; yields `self << mask(rhs)`,\nwhere `mask` removes any high-order bits of `rhs` that\nwould cause the shift to exceed the bitwidth of the type.\n\nNote that this is *not* the same as a rotate-left; the\nRHS of a wrapping shift-left is restricted to the range\nof the type, rather than the bits shifted out of the LHS\nbeing returned to the other end. The primitive integer\ntypes all implement a `rotate_left` function, which may\nbe what you want instead.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\nassert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn wrapping_shl(self, rhs: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\nwhere `mask` removes any high-order bits of `rhs` that\nwould cause the shift to exceed the bitwidth of the type.\n\nNote that this is *not* the same as a rotate-right; the\nRHS of a wrapping shift-right is restricted to the range\nof the type, rather than the bits shifted out of the LHS\nbeing returned to the other end. The primitive integer\ntypes all implement a `rotate_right` function, which may\nbe what you want instead.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\nassert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn wrapping_shr(self, rhs: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\nwrapping around at the boundary of the type.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\nassert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn wrapping_pow(self, mut exp: u32) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Calculates `self` + `rhs`\n\nReturns a tuple of the addition along with a boolean indicating\nwhether an arithmetic overflow would occur. If an overflow would\nhave occurred then the wrapped value is returned.\n\n# Examples\n\nBasic usage\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\nassert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Calculates `self` - `rhs`\n\nReturns a tuple of the subtraction along with a boolean indicating\nwhether an arithmetic overflow would occur. If an overflow would\nhave occurred then the wrapped value is returned.\n\n# Examples\n\nBasic usage\n\n```\n\", $Feature, \"use std::\", stringify!($SelfT), \";\n\nassert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\nassert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\",\n$EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n}\n\n        doc_comment! {\n            concat!(\"Calculates the divisor when `self` is divided by `rhs`.\n\nReturns a tuple of the divisor along with a boolean indicating\nwhether an arithmetic overflow would occur. Note that for unsigned\nintegers overflow never occurs, so the second value is always\n`false`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage\n\n```\n\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\", $EndFeature, \"\n```\"),\n            #[inline]\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n\nReturns a tuple of the divisor along with a boolean indicating\nwhether an arithmetic overflow would occur. Note that for unsigned\nintegers overflow never occurs, so the second value is always\n`false`.\nSince, for the positive integers, all common\ndefinitions of division are equal, this\nis exactly equal to `self.overflowing_div(rhs)`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage\n\n```\nassert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n```\"),\n            #[inline]\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Calculates the remainder when `self` is divided by `rhs`.\n\nReturns a tuple of the remainder after dividing along with a boolean\nindicating whether an arithmetic overflow would occur. Note that for\nunsigned integers overflow never occurs, so the second value is\nalways `false`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage\n\n```\n\", $Feature, \"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\", $EndFeature, \"\n```\"),\n            #[inline]\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n\nReturns a tuple of the modulo after dividing along with a boolean\nindicating whether an arithmetic overflow would occur. Note that for\nunsigned integers overflow never occurs, so the second value is\nalways `false`.\nSince, for the positive integers, all common\ndefinitions of division are equal, this operation\nis exactly equal to `self.overflowing_rem(rhs)`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage\n\n```\nassert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n```\"),\n            #[inline]\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Negates self in an overflowing fashion.\n\nReturns `!self + 1` using wrapping operations to return the value\nthat represents the negation of this unsigned value. Note that for\npositive unsigned values overflow always occurs, but negating 0 does\nnot overflow.\n\n# Examples\n\nBasic usage\n\n```\n\", $Feature, \"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\nassert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT),\n\", true));\", $EndFeature, \"\n```\"),\n            #[inline]\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n            pub const fn overflowing_neg(self) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Shifts self left by `rhs` bits.\n\nReturns a tuple of the shifted version of self along with a boolean\nindicating whether the shift value was larger than or equal to the\nnumber of bits. If the shift value is too large, then value is\nmasked (N-1) where N is the number of bits, and this value is then\nused to perform the shift.\n\n# Examples\n\nBasic usage\n\n```\n\", $Feature, \"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\nassert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Shifts self right by `rhs` bits.\n\nReturns a tuple of the shifted version of self along with a boolean\nindicating whether the shift value was larger than or equal to the\nnumber of bits. If the shift value is too large, then value is\nmasked (N-1) where N is the number of bits, and this value is then\nused to perform the shift.\n\n# Examples\n\nBasic usage\n\n```\n\", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\nassert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n            #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n\nReturns a tuple of the exponentiation along with a bool indicating\nwhether an overflow happened.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\nassert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Raises self to the power of `exp`, using exponentiation by squaring.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\", $EndFeature, \"\n```\"),\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub fn pow(self, mut exp: u32) -> Self {\n}\n    }\n\n            doc_comment! {\n            concat!(\"Performs Euclidean division.\n\nSince, for the positive integers, all common\ndefinitions of division are equal, this\nis exactly equal to `self / rhs`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            pub fn div_euclid(self, rhs: Self) -> Self {\n}\n        }\n\n\n        doc_comment! {\n            concat!(\"Calculates the least remainder of `self (mod rhs)`.\n\nSince, for the positive integers, all common\ndefinitions of division are equal, this\nis exactly equal to `self % rhs`.\n\n# Panics\n\nThis function will panic if `rhs` is 0.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\n```\"),\n            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n            #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            pub fn rem_euclid(self, rhs: Self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns `true` if and only if `self == 2^k` for some `k`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert!(16\", stringify!($SelfT), \".is_power_of_two());\nassert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n            #[inline]\n            pub const fn is_power_of_two(self) -> bool {\n}\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        fn one_less_than_next_power_of_two(self) -> Self {\n}\n\n        doc_comment! {\n            concat!(\"Returns the smallest power of two greater than or equal to `self`.\n\nWhen return value overflows (i.e., `self > (1 << (N-1))` for type\n`uN`), it panics in debug mode and return value is wrapped to 0 in\nrelease mode (the only situation in which method can return 0).\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\nassert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\", $EndFeature, \"\n```\"),\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            #[inline]\n            pub fn next_power_of_two(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the smallest power of two greater than or equal to `n`. If\nthe next power of two is greater than the type's maximum value,\n`None` is returned, otherwise the power of two is wrapped in `Some`.\n\n# Examples\n\nBasic usage:\n\n```\n\", $Feature, \"assert_eq!(2\", stringify!($SelfT),\n\".checked_next_power_of_two(), Some(2));\nassert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\nassert_eq!(\", stringify!($SelfT), \"::max_value().checked_next_power_of_two(), None);\",\n$EndFeature, \"\n```\"),\n            #[inline]\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            pub fn checked_next_power_of_two(self) -> Option<Self> {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Returns the smallest power of two greater than or equal to `n`. If\nthe next power of two is greater than the type's maximum value,\nthe return value is wrapped to `0`.\n\n# Examples\n\nBasic usage:\n\n```\n#![feature(wrapping_next_power_of_two)]\n\", $Feature, \"\nassert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\nassert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\nassert_eq!(\", stringify!($SelfT), \"::max_value().wrapping_next_power_of_two(), 0);\",\n$EndFeature, \"\n```\"),\n            #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                       reason = \"needs decision on wrapping behaviour\")]\n            pub fn wrapping_next_power_of_two(self) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Return the memory representation of this integer as a byte array in\nbig-endian (network) byte order.\n\",\n$to_xe_bytes_doc,\n\"\n# Examples\n\n```\nlet bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\nassert_eq!(bytes, \", $be_bytes, \");\n```\"),\n            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n            #[rustc_const_unstable(feature = \"const_int_conversion\", issue = \"53718\")]\n            #[inline]\n            pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Return the memory representation of this integer as a byte array in\nlittle-endian byte order.\n\",\n$to_xe_bytes_doc,\n\"\n# Examples\n\n```\nlet bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\nassert_eq!(bytes, \", $le_bytes, \");\n```\"),\n            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n            #[rustc_const_unstable(feature = \"const_int_conversion\", issue = \"53718\")]\n            #[inline]\n            pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n}\n        }\n\n        doc_comment! {\n            concat!(\"\nReturn the memory representation of this integer as a byte array in\nnative byte order.\n\nAs the target platform's native endianness is used, portable code\nshould use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\ninstead.\n\",\n$to_xe_bytes_doc,\n\"\n[`to_be_bytes`]: #method.to_be_bytes\n[`to_le_bytes`]: #method.to_le_bytes\n\n# Examples\n\n```\nlet bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\nassert_eq!(\n    bytes,\n    if cfg!(target_endian = \\\"big\\\") {\n        \", $be_bytes, \"\n    } else {\n        \", $le_bytes, \"\n    }\n);\n```\"),\n            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n            #[rustc_const_unstable(feature = \"const_int_conversion\", issue = \"53718\")]\n            #[inline]\n            pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Create an integer value from its representation as a byte array in\nbig endian.\n\",\n$from_xe_bytes_doc,\n\"\n# Examples\n\n```\nlet value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\nassert_eq!(value, \", $swap_op, \");\n```\n\nWhen starting from a slice rather than an array, fallible conversion APIs can be used:\n\n```\nuse std::convert::TryInto;\n\nfn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n}\n```\"),\n            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n            #[rustc_const_unstable(feature = \"const_int_conversion\", issue = \"53718\")]\n            #[inline]\n            pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"\nCreate an integer value from its representation as a byte array in\nlittle endian.\n\",\n$from_xe_bytes_doc,\n\"\n# Examples\n\n```\nlet value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\nassert_eq!(value, \", $swap_op, \");\n```\n\nWhen starting from a slice rather than an array, fallible conversion APIs can be used:\n\n```\nuse std::convert::TryInto;\n\nfn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n}\n```\"),\n            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n            #[rustc_const_unstable(feature = \"const_int_conversion\", issue = \"53718\")]\n            #[inline]\n            pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n}\n        }\n\n        doc_comment! {\n            concat!(\"Create an integer value from its memory representation as a byte\narray in native endianness.\n\nAs the target platform's native endianness is used, portable code\nlikely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\nappropriate instead.\n\n[`from_be_bytes`]: #method.from_be_bytes\n[`from_le_bytes`]: #method.from_le_bytes\n\",\n$from_xe_bytes_doc,\n\"\n# Examples\n\n```\nlet value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\n    \", $be_bytes, \"\n} else {\n    \", $le_bytes, \"\n});\nassert_eq!(value, \", $swap_op, \");\n```\n\nWhen starting from a slice rather than an array, fallible conversion APIs can be used:\n\n```\nuse std::convert::TryInto;\n\nfn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\n}\n```\"),\n            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n            #[rustc_const_unstable(feature = \"const_int_conversion\", issue = \"53718\")]\n            #[inline]\n            pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n}\n        }\n    }\n}\n\n#[lang = \"u8\"]\nimpl u8 {\n    uint_impl! { u8, u8, 8, 255, \"\", \"\", 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n    \"[0x12]\", \"\", \"\" }\n\n    /// Checks if the value is within the ASCII range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let ascii = 97u8;\n    /// let non_ascii = 150u8;\n    ///\n    /// assert!(ascii.is_ascii());\n    /// assert!(!non_ascii.is_ascii());\n    /// ```\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn is_ascii(&self) -> bool {\n}\n\n    /// Makes a copy of the value in its ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let lowercase_a = 97u8;\n    ///\n    /// assert_eq!(65, lowercase_a.to_ascii_uppercase());\n    /// ```\n    ///\n    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_uppercase(&self) -> u8 {\n}\n\n    /// Makes a copy of the value in its ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 65u8;\n    ///\n    /// assert_eq!(97, uppercase_a.to_ascii_lowercase());\n    /// ```\n    ///\n    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_lowercase(&self) -> u8 {\n}\n\n    /// Checks that two values are an ASCII case-insensitive match.\n    ///\n    /// This is equivalent to `to_ascii_lowercase(a) == to_ascii_lowercase(b)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let lowercase_a = 97u8;\n    /// let uppercase_a = 65u8;\n    ///\n    /// assert!(lowercase_a.eq_ignore_ascii_case(&uppercase_a));\n    /// ```\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn eq_ignore_ascii_case(&self, other: &u8) -> bool {\n}\n\n    /// Converts this value to its ASCII upper case equivalent in-place.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new uppercased value without modifying the existing one, use\n    /// [`to_ascii_uppercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut byte = b'a';\n    ///\n    /// byte.make_ascii_uppercase();\n    ///\n    /// assert_eq!(b'A', byte);\n    /// ```\n    ///\n    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n}\n\n    /// Converts this value to its ASCII lower case equivalent in-place.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new lowercased value without modifying the existing one, use\n    /// [`to_ascii_lowercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut byte = b'A';\n    ///\n    /// byte.make_ascii_lowercase();\n    ///\n    /// assert_eq!(b'a', byte);\n    /// ```\n    ///\n    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n}\n\n    /// Checks if the value is an ASCII alphabetic character:\n    ///\n    /// - U+0041 'A' ..= U+005A 'Z', or\n    /// - U+0061 'a' ..= U+007A 'z'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_alphabetic());\n    /// assert!(uppercase_g.is_ascii_alphabetic());\n    /// assert!(a.is_ascii_alphabetic());\n    /// assert!(g.is_ascii_alphabetic());\n    /// assert!(!zero.is_ascii_alphabetic());\n    /// assert!(!percent.is_ascii_alphabetic());\n    /// assert!(!space.is_ascii_alphabetic());\n    /// assert!(!lf.is_ascii_alphabetic());\n    /// assert!(!esc.is_ascii_alphabetic());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_alphabetic(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII uppercase character:\n    /// U+0041 'A' ..= U+005A 'Z'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_uppercase());\n    /// assert!(uppercase_g.is_ascii_uppercase());\n    /// assert!(!a.is_ascii_uppercase());\n    /// assert!(!g.is_ascii_uppercase());\n    /// assert!(!zero.is_ascii_uppercase());\n    /// assert!(!percent.is_ascii_uppercase());\n    /// assert!(!space.is_ascii_uppercase());\n    /// assert!(!lf.is_ascii_uppercase());\n    /// assert!(!esc.is_ascii_uppercase());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_uppercase(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII lowercase character:\n    /// U+0061 'a' ..= U+007A 'z'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_lowercase());\n    /// assert!(!uppercase_g.is_ascii_lowercase());\n    /// assert!(a.is_ascii_lowercase());\n    /// assert!(g.is_ascii_lowercase());\n    /// assert!(!zero.is_ascii_lowercase());\n    /// assert!(!percent.is_ascii_lowercase());\n    /// assert!(!space.is_ascii_lowercase());\n    /// assert!(!lf.is_ascii_lowercase());\n    /// assert!(!esc.is_ascii_lowercase());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_lowercase(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII alphanumeric character:\n    ///\n    /// - U+0041 'A' ..= U+005A 'Z', or\n    /// - U+0061 'a' ..= U+007A 'z', or\n    /// - U+0030 '0' ..= U+0039 '9'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_alphanumeric());\n    /// assert!(uppercase_g.is_ascii_alphanumeric());\n    /// assert!(a.is_ascii_alphanumeric());\n    /// assert!(g.is_ascii_alphanumeric());\n    /// assert!(zero.is_ascii_alphanumeric());\n    /// assert!(!percent.is_ascii_alphanumeric());\n    /// assert!(!space.is_ascii_alphanumeric());\n    /// assert!(!lf.is_ascii_alphanumeric());\n    /// assert!(!esc.is_ascii_alphanumeric());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_alphanumeric(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII decimal digit:\n    /// U+0030 '0' ..= U+0039 '9'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_digit());\n    /// assert!(!uppercase_g.is_ascii_digit());\n    /// assert!(!a.is_ascii_digit());\n    /// assert!(!g.is_ascii_digit());\n    /// assert!(zero.is_ascii_digit());\n    /// assert!(!percent.is_ascii_digit());\n    /// assert!(!space.is_ascii_digit());\n    /// assert!(!lf.is_ascii_digit());\n    /// assert!(!esc.is_ascii_digit());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_digit(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII hexadecimal digit:\n    ///\n    /// - U+0030 '0' ..= U+0039 '9', or\n    /// - U+0041 'A' ..= U+0046 'F', or\n    /// - U+0061 'a' ..= U+0066 'f'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_hexdigit());\n    /// assert!(!uppercase_g.is_ascii_hexdigit());\n    /// assert!(a.is_ascii_hexdigit());\n    /// assert!(!g.is_ascii_hexdigit());\n    /// assert!(zero.is_ascii_hexdigit());\n    /// assert!(!percent.is_ascii_hexdigit());\n    /// assert!(!space.is_ascii_hexdigit());\n    /// assert!(!lf.is_ascii_hexdigit());\n    /// assert!(!esc.is_ascii_hexdigit());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_hexdigit(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII punctuation character:\n    ///\n    /// - U+0021 ..= U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n    /// - U+003A ..= U+0040 `: ; < = > ? @`, or\n    /// - U+005B ..= U+0060 ``[ \\ ] ^ _ ` ``, or\n    /// - U+007B ..= U+007E `{ | } ~`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_punctuation());\n    /// assert!(!uppercase_g.is_ascii_punctuation());\n    /// assert!(!a.is_ascii_punctuation());\n    /// assert!(!g.is_ascii_punctuation());\n    /// assert!(!zero.is_ascii_punctuation());\n    /// assert!(percent.is_ascii_punctuation());\n    /// assert!(!space.is_ascii_punctuation());\n    /// assert!(!lf.is_ascii_punctuation());\n    /// assert!(!esc.is_ascii_punctuation());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_punctuation(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII graphic character:\n    /// U+0021 '!' ..= U+007E '~'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(uppercase_a.is_ascii_graphic());\n    /// assert!(uppercase_g.is_ascii_graphic());\n    /// assert!(a.is_ascii_graphic());\n    /// assert!(g.is_ascii_graphic());\n    /// assert!(zero.is_ascii_graphic());\n    /// assert!(percent.is_ascii_graphic());\n    /// assert!(!space.is_ascii_graphic());\n    /// assert!(!lf.is_ascii_graphic());\n    /// assert!(!esc.is_ascii_graphic());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_graphic(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII whitespace character:\n    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n    ///\n    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n    /// whitespace][infra-aw]. There are several other definitions in\n    /// wide use. For instance, [the POSIX locale][pct] includes\n    /// U+000B VERTICAL TAB as well as all the above characters,\n    /// but—from the very same specification—[the default rule for\n    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n    ///\n    /// If you are writing a program that will process an existing\n    /// file format, check what that format's definition of whitespace is\n    /// before using this function.\n    ///\n    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_whitespace());\n    /// assert!(!uppercase_g.is_ascii_whitespace());\n    /// assert!(!a.is_ascii_whitespace());\n    /// assert!(!g.is_ascii_whitespace());\n    /// assert!(!zero.is_ascii_whitespace());\n    /// assert!(!percent.is_ascii_whitespace());\n    /// assert!(space.is_ascii_whitespace());\n    /// assert!(lf.is_ascii_whitespace());\n    /// assert!(!esc.is_ascii_whitespace());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_whitespace(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII control character:\n    /// U+0000 NUL ..= U+001F UNIT SEPARATOR, or U+007F DELETE.\n    /// Note that most ASCII whitespace characters are control\n    /// characters, but SPACE is not.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = b'A';\n    /// let uppercase_g = b'G';\n    /// let a = b'a';\n    /// let g = b'g';\n    /// let zero = b'0';\n    /// let percent = b'%';\n    /// let space = b' ';\n    /// let lf = b'\\n';\n    /// let esc = 0x1b_u8;\n    ///\n    /// assert!(!uppercase_a.is_ascii_control());\n    /// assert!(!uppercase_g.is_ascii_control());\n    /// assert!(!a.is_ascii_control());\n    /// assert!(!g.is_ascii_control());\n    /// assert!(!zero.is_ascii_control());\n    /// assert!(!percent.is_ascii_control());\n    /// assert!(!space.is_ascii_control());\n    /// assert!(lf.is_ascii_control());\n    /// assert!(esc.is_ascii_control());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_control(&self) -> bool {\n}\n}\n\n#[lang = \"u16\"]\nimpl u16 {\n    uint_impl! { u16, u16, 16, 65535, \"\", \"\", 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n    \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n}\n\n#[lang = \"u32\"]\nimpl u32 {\n    uint_impl! { u32, u32, 32, 4294967295, \"\", \"\", 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n    \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n}\n\n#[lang = \"u64\"]\nimpl u64 {\n    uint_impl! { u64, u64, 64, 18446744073709551615, \"\", \"\", 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n    \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n    \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n    \"\", \"\"}\n}\n\n#[lang = \"u128\"]\nimpl u128 {\n    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, \"\", \"\", 16,\n    \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n    \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n    \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n      0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n      0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\",\n     \"\", \"\"}\n}\n\n#[cfg(target_pointer_width = \"16\")]\n#[lang = \"usize\"]\nimpl usize {\n    uint_impl! { usize, u16, 16, 65535, \"\", \"\", 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n    \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n}\n#[cfg(target_pointer_width = \"32\")]\n#[lang = \"usize\"]\nimpl usize {\n    uint_impl! { usize, u32, 32, 4294967295, \"\", \"\", 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n    \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n}\n\n#[cfg(target_pointer_width = \"64\")]\n#[lang = \"usize\"]\nimpl usize {\n    uint_impl! { usize, u64, 64, 18446744073709551615, \"\", \"\", 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n    \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n    \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n}\n\n/// A classification of floating point numbers.\n///\n/// This `enum` is used as the return type for [`f32::classify`] and [`f64::classify`]. See\n/// their documentation for more.\n///\n/// [`f32::classify`]: ../../std/primitive.f32.html#method.classify\n/// [`f64::classify`]: ../../std/primitive.f64.html#method.classify\n///\n/// # Examples\n///\n/// ```\n/// use std::num::FpCategory;\n/// use std::f32;\n///\n/// let num = 12.4_f32;\n/// let inf = f32::INFINITY;\n/// let zero = 0f32;\n/// let sub: f32 = 1.1754942e-38;\n/// let nan = f32::NAN;\n///\n/// assert_eq!(num.classify(), FpCategory::Normal);\n/// assert_eq!(inf.classify(), FpCategory::Infinite);\n/// assert_eq!(zero.classify(), FpCategory::Zero);\n/// assert_eq!(nan.classify(), FpCategory::Nan);\n/// assert_eq!(sub.classify(), FpCategory::Subnormal);\n/// ```\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum FpCategory {\n    /// \"Not a Number\", often obtained by dividing by zero.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Nan,\n\n    /// Positive or negative infinity.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Infinite,\n\n    /// Positive or negative zero.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Zero,\n\n    /// De-normalized floating point representation (less precise than `Normal`).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Subnormal,\n\n    /// A regular floating point number.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Normal,\n}\n\nmacro_rules! from_str_radix_int_impl {\n    ($($t:ty)*) => {$(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl FromStr for $t {\n            type Err = ParseIntError;\n            fn from_str(src: &str) -> Result<Self, ParseIntError> {\n}\n        }\n    )*}\n}\nfrom_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n\n/// The error type returned when a checked integral type conversion fails.\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub struct TryFromIntError(pub(crate) ());\n\nimpl TryFromIntError {\n    #[unstable(\n        feature = \"int_error_internals\",\n        reason = \"available through Error trait and this method should \\\n                  not be exposed publicly\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl fmt::Display for TryFromIntError {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl From<Infallible> for TryFromIntError {\n    fn from(x: Infallible) -> TryFromIntError {\n}\n}\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl From<!> for TryFromIntError {\n}\n\n#[doc(hidden)]\ntrait FromStrRadixHelper: PartialOrd + Copy {\n    fn min_value() -> Self;\n    fn max_value() -> Self;\n    fn from_u32(u: u32) -> Self;\n    fn checked_mul(&self, other: u32) -> Option<Self>;\n    fn checked_sub(&self, other: u32) -> Option<Self>;\n    fn checked_add(&self, other: u32) -> Option<Self>;\n}\n\nmacro_rules! doit {\n    ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n        #[inline]\n        fn min_value() -> Self { }\n        #[inline]\n        fn max_value() -> Self { }\n        #[inline]\n        fn from_u32(u: u32) -> Self { }\n        #[inline]\n        fn checked_mul(&self, other: u32) -> Option<Self> {\n}\n        #[inline]\n        fn checked_sub(&self, other: u32) -> Option<Self> {\n}\n        #[inline]\n        fn checked_add(&self, other: u32) -> Option<Self> {\n}\n    })*)\n}\ndoit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n\nfn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {\n}\n\n/// An error which can be returned when parsing an integer.\n///\n/// This error is used as the error type for the `from_str_radix()` functions\n/// on the primitive integer types, such as [`i8::from_str_radix`].\n///\n/// # Potential causes\n///\n/// Among other causes, `ParseIntError` can be thrown because of leading or trailing whitespace\n/// in the string e.g., when it is obtained from the standard input.\n/// Using the [`str.trim()`] method ensures that no whitespace remains before parsing.\n///\n/// [`str.trim()`]: ../../std/primitive.str.html#method.trim\n/// [`i8::from_str_radix`]: ../../std/primitive.i8.html#method.from_str_radix\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ParseIntError {\n    kind: IntErrorKind,\n}\n\n/// Enum to store the various types of errors that can cause parsing an integer to fail.\n#[unstable(\n    feature = \"int_error_matching\",\n    reason = \"it can be useful to match errors when making error messages \\\n              for integer parsing\",\n    issue = \"22639\"\n)]\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[non_exhaustive]\npub enum IntErrorKind {\n    /// Value being parsed is empty.\n    ///\n    /// Among other causes, this variant will be constructed when parsing an empty string.\n    Empty,\n    /// Contains an invalid digit.\n    ///\n    /// Among other causes, this variant will be constructed when parsing a string that\n    /// contains a letter.\n    InvalidDigit,\n    /// Integer is too large to store in target integer type.\n    Overflow,\n    /// Integer is too small to store in target integer type.\n    Underflow,\n    /// Value was Zero\n    ///\n    /// This variant will be emitted when the parsing string has a value of zero, which\n    /// would be illegal for non-zero types.\n    Zero,\n}\n\nimpl ParseIntError {\n    /// Outputs the detailed cause of parsing an integer failing.\n    #[unstable(\n        feature = \"int_error_matching\",\n        reason = \"it can be useful to match errors when making error messages \\\n                  for integer parsing\",\n        issue = \"22639\"\n    )]\n    pub fn kind(&self) -> &IntErrorKind {\n}\n    #[unstable(\n        feature = \"int_error_internals\",\n        reason = \"available through Error trait and this method should \\\n                  not be exposed publicly\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for ParseIntError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use crate::num::dec2flt::ParseFloatError;\n}\n\n/* The libcore prelude, not as all-encompassing as the libstd prelude */\n\npub mod prelude {\n//! The libcore prelude\n\n#![stable(feature = \"core_prelude\", since = \"1.4.0\")]\n\npub mod v1 {\n//! The core prelude\n//!\n//! This module is intended for users of libcore which do not link to libstd as\n//! well. This module is imported by default when `#![no_std]` is used in the\n//! same manner as the standard library's prelude.\n\n#![stable(feature = \"core_prelude\", since = \"1.4.0\")]\n\n// Re-exported core operators\n#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n#[doc(no_inline)]\npub use crate::marker::{Copy, Send, Sized, Sync, Unpin};\n#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n#[doc(no_inline)]\npub use crate::ops::{Drop, Fn, FnMut, FnOnce};\n\n// Re-exported functions\n#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n#[doc(no_inline)]\npub use crate::mem::drop;\n\n// Re-exported types and traits\n#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n#[doc(no_inline)]\npub use crate::clone::Clone;\n#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n#[doc(no_inline)]\npub use crate::cmp::{Eq, Ord, PartialEq, PartialOrd};\n#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n#[doc(no_inline)]\npub use crate::convert::{AsMut, AsRef, From, Into};\n#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n#[doc(no_inline)]\npub use crate::default::Default;\n#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n#[doc(no_inline)]\npub use crate::iter::{DoubleEndedIterator, ExactSizeIterator};\n#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n#[doc(no_inline)]\npub use crate::iter::{Extend, IntoIterator, Iterator};\n#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n#[doc(no_inline)]\npub use crate::option::Option::{self, None, Some};\n#[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n#[doc(no_inline)]\npub use crate::result::Result::{self, Err, Ok};\n\n// Re-exported built-in macros\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[doc(no_inline)]\npub use crate::fmt::macros::Debug;\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[doc(no_inline)]\npub use crate::hash::macros::Hash;\n\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[doc(no_inline)]\npub use crate::{\n    asm, assert, cfg, column, compile_error, concat, concat_idents, env, file, format_args,\n    format_args_nl, global_asm, include, include_bytes, include_str, line, log_syntax, module_path,\n    option_env, stringify, trace_macros,\n};\n\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow(deprecated)]\n#[doc(no_inline)]\npub use crate::macros::builtin::{\n    bench, global_allocator, test, test_case, RustcDecodable, RustcEncodable,\n};\n}\n}\n\n/* Core modules for ownership management */\n\npub mod hint {\n#![stable(feature = \"core_hint\", since = \"1.27.0\")]\n\n//! Hints to compiler that affects how code should be emitted or optimized.\n\n// ignore-tidy-undocumented-unsafe\n\nuse crate::intrinsics;\n\n/// Informs the compiler that this point in the code is not reachable, enabling\n/// further optimizations.\n///\n/// # Safety\n///\n/// Reaching this function is completely *undefined behavior* (UB). In\n/// particular, the compiler assumes that all UB must never happen, and\n/// therefore will eliminate all branches that reach to a call to\n/// `unreachable_unchecked()`.\n///\n/// Like all instances of UB, if this assumption turns out to be wrong, i.e., the\n/// `unreachable_unchecked()` call is actually reachable among all possible\n/// control flow, the compiler will apply the wrong optimization strategy, and\n/// may sometimes even corrupt seemingly unrelated code, causing\n/// difficult-to-debug problems.\n///\n/// Use this function only when you can prove that the code will never call it.\n/// Otherwise, consider using the [`unreachable!`] macro, which does not allow\n/// optimizations but will panic when executed.\n///\n/// [`unreachable!`]: ../macro.unreachable.html\n///\n/// # Example\n///\n/// ```\n/// fn div_1(a: u32, b: u32) -> u32 {\n///     use std::hint::unreachable_unchecked;\n///\n///     // `b.saturating_add(1)` is always positive (not zero),\n///     // hence `checked_div` will never return `None`.\n///     // Therefore, the else branch is unreachable.\n///     a.checked_div(b.saturating_add(1))\n///         .unwrap_or_else(|| unsafe { unreachable_unchecked() })\n/// }\n///\n/// assert_eq!(div_1(7, 0), 7);\n/// assert_eq!(div_1(9, 1), 4);\n/// assert_eq!(div_1(11, std::u32::MAX), 0);\n/// ```\n#[inline]\n#[stable(feature = \"unreachable\", since = \"1.27.0\")]\npub unsafe fn unreachable_unchecked() -> ! {\n}\n\n/// Emits a machine instruction hinting to the processor that it is running in busy-wait\n/// spin-loop (\"spin lock\").\n///\n/// For a discussion of different locking strategies and their trade-offs, see\n/// [`core::sync::atomic::spin_loop_hint`].\n///\n/// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n/// do anything at all.\n///\n/// [`core::sync::atomic::spin_loop_hint`]: ../sync/atomic/fn.spin_loop_hint.html\n#[inline]\n#[unstable(feature = \"renamed_spin_loop\", issue = \"55002\")]\npub fn spin_loop() {\n}\n\n/// An identity function that *__hints__* to the compiler to be maximally pessimistic about what\n/// `black_box` could do.\n///\n/// [`std::convert::identity`]: https://doc.rust-lang.org/core/convert/fn.identity.html\n///\n/// Unlike [`std::convert::identity`], a Rust compiler is encouraged to assume that `black_box` can\n/// use `x` in any possible valid way that Rust code is allowed to without introducing undefined\n/// behavior in the calling code. This property makes `black_box` useful for writing code in which\n/// certain optimizations are not desired, such as benchmarks.\n///\n/// Note however, that `black_box` is only (and can only be) provided on a \"best-effort\" basis. The\n/// extent to which it can block optimisations may vary depending upon the platform and code-gen\n/// backend used. Programs cannot rely on `black_box` for *correctness* in any way.\n#[inline]\n#[unstable(feature = \"test\", issue = \"50297\")]\n#[allow(unreachable_code)] // this makes #[cfg] a bit easier below.\npub fn black_box<T>(dummy: T) -> T {\n}\n}\npub mod intrinsics {\n//! Compiler intrinsics.\n//!\n//! The corresponding definitions are in `librustc_codegen_llvm/intrinsic.rs`.\n//! The corresponding const implementations are in `librustc_mir/interpret/intrinsics.rs`\n//!\n//! # Const intrinsics\n//!\n//! Note: any changes to the constness of intrinsics should be discussed with the language team.\n//! This includes changes in the stability of the constness.\n//!\n//! In order to make an intrinsic usable at compile-time, one needs to copy the implementation\n//! from https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs to\n//! `librustc_mir/interpret/intrinsics.rs` and add a\n//! `#[rustc_const_unstable(feature = \"foo\", issue = \"01234\")]` to the intrinsic.\n//!\n//! If an intrinsic is supposed to be used from a `const fn` with a `rustc_const_stable` attribute,\n//! the intrinsic's attribute must be `rustc_const_stable`, too. Such a change should not be done\n//! without T-lang consulation, because it bakes a feature into the language that cannot be\n//! replicated in user code without compiler support.\n//!\n//! # Volatiles\n//!\n//! The volatile intrinsics provide operations intended to act on I/O\n//! memory, which are guaranteed to not be reordered by the compiler\n//! across other volatile intrinsics. See the LLVM documentation on\n//! [[volatile]].\n//!\n//! [volatile]: http://llvm.org/docs/LangRef.html#volatile-memory-accesses\n//!\n//! # Atomics\n//!\n//! The atomic intrinsics provide common atomic operations on machine\n//! words, with multiple possible memory orderings. They obey the same\n//! semantics as C++11. See the LLVM documentation on [[atomics]].\n//!\n//! [atomics]: http://llvm.org/docs/Atomics.html\n//!\n//! A quick refresher on memory ordering:\n//!\n//! * Acquire - a barrier for acquiring a lock. Subsequent reads and writes\n//!   take place after the barrier.\n//! * Release - a barrier for releasing a lock. Preceding reads and writes\n//!   take place before the barrier.\n//! * Sequentially consistent - sequentially consistent operations are\n//!   guaranteed to happen in order. This is the standard mode for working\n//!   with atomic types and is equivalent to Java's `volatile`.\n\n#![unstable(\n    feature = \"core_intrinsics\",\n    reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n                      they should be used through stabilized interfaces \\\n                      in the rest of the standard library\",\n    issue = \"none\"\n)]\n#![allow(missing_docs)]\n\nuse crate::mem;\n\n#[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n#[rustc_deprecated(\n    reason = \"no longer an intrinsic - use `ptr::drop_in_place` directly\",\n    since = \"1.18.0\"\n)]\npub use crate::ptr::drop_in_place;\n\nextern \"rust-intrinsic\" {\n    // N.B., these intrinsics take raw pointers because they mutate aliased\n    // memory, which is not valid for either `&` or `&mut`.\n\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as both the `success` and `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange`][compare_exchange].\n    ///\n    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n    pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as both the `success` and `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange`][compare_exchange].\n    ///\n    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n    pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `success` and\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange`][compare_exchange].\n    ///\n    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n    pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `success` and\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange`][compare_exchange].\n    ///\n    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n    pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as both the `success` and `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange`][compare_exchange].\n    ///\n    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n    pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `success` and\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange`][compare_exchange].\n    ///\n    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n    pub fn atomic_cxchg_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `success` and\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange`][compare_exchange].\n    ///\n    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n    pub fn atomic_cxchg_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `success` and\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange`][compare_exchange].\n    ///\n    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n    pub fn atomic_cxchg_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange` method by passing\n    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `success` and\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange`][compare_exchange].\n    ///\n    /// [compare_exchange]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange\n    pub fn atomic_cxchg_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as both the `success` and `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange_weak`][cew].\n    ///\n    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n    pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as both the `success` and `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange_weak`][cew].\n    ///\n    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n    pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `success` and\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange_weak`][cew].\n    ///\n    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n    pub fn atomic_cxchgweak_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `success` and\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange_weak`][cew].\n    ///\n    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n    pub fn atomic_cxchgweak_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as both the `success` and `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange_weak`][cew].\n    ///\n    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n    pub fn atomic_cxchgweak_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `success` and\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange_weak`][cew].\n    ///\n    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n    pub fn atomic_cxchgweak_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `success` and\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange_weak`][cew].\n    ///\n    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n    pub fn atomic_cxchgweak_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `success` and\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange_weak`][cew].\n    ///\n    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n    pub fn atomic_cxchgweak_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n    /// Stores a value if the current value is the same as the `old` value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `compare_exchange_weak` method by passing\n    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `success` and\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `failure` parameters. For example,\n    /// [`AtomicBool::compare_exchange_weak`][cew].\n    ///\n    /// [cew]: ../../std/sync/atomic/struct.AtomicBool.html#method.compare_exchange_weak\n    pub fn atomic_cxchgweak_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n\n    /// Loads the current value of the pointer.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `load` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n    pub fn atomic_load<T>(src: *const T) -> T;\n    /// Loads the current value of the pointer.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `load` method by passing\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n    pub fn atomic_load_acq<T>(src: *const T) -> T;\n    /// Loads the current value of the pointer.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `load` method by passing\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::load`](../../std/sync/atomic/struct.AtomicBool.html#method.load).\n    pub fn atomic_load_relaxed<T>(src: *const T) -> T;\n    pub fn atomic_load_unordered<T>(src: *const T) -> T;\n\n    /// Stores the value at the specified memory location.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `store` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n    pub fn atomic_store<T>(dst: *mut T, val: T);\n    /// Stores the value at the specified memory location.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `store` method by passing\n    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n    pub fn atomic_store_rel<T>(dst: *mut T, val: T);\n    /// Stores the value at the specified memory location.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `store` method by passing\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::store`](../../std/sync/atomic/struct.AtomicBool.html#method.store).\n    pub fn atomic_store_relaxed<T>(dst: *mut T, val: T);\n    pub fn atomic_store_unordered<T>(dst: *mut T, val: T);\n\n    /// Stores the value at the specified memory location, returning the old value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `swap` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n    pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n    /// Stores the value at the specified memory location, returning the old value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `swap` method by passing\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n    pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;\n    /// Stores the value at the specified memory location, returning the old value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `swap` method by passing\n    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n    pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;\n    /// Stores the value at the specified memory location, returning the old value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `swap` method by passing\n    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n    pub fn atomic_xchg_acqrel<T>(dst: *mut T, src: T) -> T;\n    /// Stores the value at the specified memory location, returning the old value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `swap` method by passing\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n    pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;\n\n    /// Adds to the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_add` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n    pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n    /// Adds to the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_add` method by passing\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n    pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n    /// Adds to the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_add` method by passing\n    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n    pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n    /// Adds to the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_add` method by passing\n    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n    pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;\n    /// Adds to the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_add` method by passing\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n    pub fn atomic_xadd_relaxed<T>(dst: *mut T, src: T) -> T;\n\n    /// Subtract from the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n    pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;\n    /// Subtract from the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n    pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;\n    /// Subtract from the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n    pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;\n    /// Subtract from the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n    pub fn atomic_xsub_acqrel<T>(dst: *mut T, src: T) -> T;\n    /// Subtract from the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_sub` method by passing\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicIsize::fetch_sub`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_sub).\n    pub fn atomic_xsub_relaxed<T>(dst: *mut T, src: T) -> T;\n\n    /// Bitwise and with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_and` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n    pub fn atomic_and<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise and with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_and` method by passing\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n    pub fn atomic_and_acq<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise and with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_and` method by passing\n    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n    pub fn atomic_and_rel<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise and with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_and` method by passing\n    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n    pub fn atomic_and_acqrel<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise and with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_and` method by passing\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_and`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_and).\n    pub fn atomic_and_relaxed<T>(dst: *mut T, src: T) -> T;\n\n    /// Bitwise nand with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n    pub fn atomic_nand<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise nand with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n    pub fn atomic_nand_acq<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise nand with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n    pub fn atomic_nand_rel<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise nand with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n    pub fn atomic_nand_acqrel<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise nand with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic::AtomicBool` type via the `fetch_nand` method by passing\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_nand`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_nand).\n    pub fn atomic_nand_relaxed<T>(dst: *mut T, src: T) -> T;\n\n    /// Bitwise or with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_or` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n    pub fn atomic_or<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise or with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_or` method by passing\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n    pub fn atomic_or_acq<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise or with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_or` method by passing\n    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n    pub fn atomic_or_rel<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise or with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_or` method by passing\n    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n    pub fn atomic_or_acqrel<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise or with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_or` method by passing\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_or`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_or).\n    pub fn atomic_or_relaxed<T>(dst: *mut T, src: T) -> T;\n\n    /// Bitwise xor with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n    /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n    pub fn atomic_xor<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise xor with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n    /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n    pub fn atomic_xor_acq<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise xor with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n    /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n    pub fn atomic_xor_rel<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise xor with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n    /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n    pub fn atomic_xor_acqrel<T>(dst: *mut T, src: T) -> T;\n    /// Bitwise xor with the current value, returning the previous value.\n    /// The stabilized version of this intrinsic is available on the\n    /// `std::sync::atomic` types via the `fetch_xor` method by passing\n    /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n    /// as the `order`. For example,\n    /// [`AtomicBool::fetch_xor`](../../std/sync/atomic/struct.AtomicBool.html#method.fetch_xor).\n    pub fn atomic_xor_relaxed<T>(dst: *mut T, src: T) -> T;\n\n    pub fn atomic_max<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_max_acq<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_max_rel<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_max_acqrel<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_max_relaxed<T>(dst: *mut T, src: T) -> T;\n\n    pub fn atomic_min<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_min_acq<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_min_rel<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_min_acqrel<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_min_relaxed<T>(dst: *mut T, src: T) -> T;\n\n    pub fn atomic_umin<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_umin_acq<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_umin_rel<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_umin_acqrel<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_umin_relaxed<T>(dst: *mut T, src: T) -> T;\n\n    pub fn atomic_umax<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_umax_acq<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_umax_rel<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_umax_acqrel<T>(dst: *mut T, src: T) -> T;\n    pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;\n\n    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n    /// if supported; otherwise, it is a no-op.\n    /// Prefetches have no effect on the behavior of the program but can change its performance\n    /// characteristics.\n    ///\n    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n    /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n    pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n    /// if supported; otherwise, it is a no-op.\n    /// Prefetches have no effect on the behavior of the program but can change its performance\n    /// characteristics.\n    ///\n    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n    /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n    pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n    /// if supported; otherwise, it is a no-op.\n    /// Prefetches have no effect on the behavior of the program but can change its performance\n    /// characteristics.\n    ///\n    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n    /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n    pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n    /// if supported; otherwise, it is a no-op.\n    /// Prefetches have no effect on the behavior of the program but can change its performance\n    /// characteristics.\n    ///\n    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n    /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n    pub fn prefetch_write_instruction<T>(data: *const T, locality: i32);\n}\n\nextern \"rust-intrinsic\" {\n\n    pub fn atomic_fence();\n    pub fn atomic_fence_acq();\n    pub fn atomic_fence_rel();\n    pub fn atomic_fence_acqrel();\n\n    /// A compiler-only memory barrier.\n    ///\n    /// Memory accesses will never be reordered across this barrier by the\n    /// compiler, but no instructions will be emitted for it. This is\n    /// appropriate for operations on the same thread that may be preempted,\n    /// such as when interacting with signal handlers.\n    pub fn atomic_singlethreadfence();\n    pub fn atomic_singlethreadfence_acq();\n    pub fn atomic_singlethreadfence_rel();\n    pub fn atomic_singlethreadfence_acqrel();\n\n    /// Magic intrinsic that derives its meaning from attributes\n    /// attached to the function.\n    ///\n    /// For example, dataflow uses this to inject static assertions so\n    /// that `rustc_peek(potentially_uninitialized)` would actually\n    /// double-check that dataflow did indeed compute that it is\n    /// uninitialized at that point in the control flow.\n    pub fn rustc_peek<T>(_: T) -> T;\n\n    /// Aborts the execution of the process.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`std::process::abort`](../../std/process/fn.abort.html)\n    pub fn abort() -> !;\n\n    /// Tells LLVM that this point in the code is not reachable, enabling\n    /// further optimizations.\n    ///\n    /// N.B., this is very different from the `unreachable!()` macro: Unlike the\n    /// macro, which panics when it is executed, it is *undefined behavior* to\n    /// reach code marked with this function.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`std::hint::unreachable_unchecked`](../../std/hint/fn.unreachable_unchecked.html).\n    pub fn unreachable() -> !;\n\n    /// Informs the optimizer that a condition is always true.\n    /// If the condition is false, the behavior is undefined.\n    ///\n    /// No code is generated for this intrinsic, but the optimizer will try\n    /// to preserve it (and its condition) between passes, which may interfere\n    /// with optimization of surrounding code and reduce performance. It should\n    /// not be used if the invariant can be discovered by the optimizer on its\n    /// own, or if it does not enable any significant optimizations.\n    pub fn assume(b: bool);\n\n    /// Hints to the compiler that branch condition is likely to be true.\n    /// Returns the value passed to it.\n    ///\n    /// Any use other than with `if` statements will probably not have an effect.\n    pub fn likely(b: bool) -> bool;\n\n    /// Hints to the compiler that branch condition is likely to be false.\n    /// Returns the value passed to it.\n    ///\n    /// Any use other than with `if` statements will probably not have an effect.\n    pub fn unlikely(b: bool) -> bool;\n\n    /// Executes a breakpoint trap, for inspection by a debugger.\n    pub fn breakpoint();\n\n    /// The size of a type in bytes.\n    ///\n    /// More specifically, this is the offset in bytes between successive\n    /// items of the same type, including alignment padding.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`std::mem::size_of`](../../std/mem/fn.size_of.html).\n    #[rustc_const_stable(feature = \"const_size_of\", since = \"1.40.0\")]\n    pub fn size_of<T>() -> usize;\n\n    /// Moves a value to an uninitialized memory location.\n    ///\n    /// Drop glue is not run on the destination.\n    pub fn move_val_init<T>(dst: *mut T, src: T);\n\n    #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n    pub fn min_align_of<T>() -> usize;\n    #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"none\")]\n    pub fn pref_align_of<T>() -> usize;\n\n    /// The size of the referenced value in bytes.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`std::mem::size_of_val`](../../std/mem/fn.size_of_val.html).\n    pub fn size_of_val<T: ?Sized>(_: &T) -> usize;\n    pub fn min_align_of_val<T: ?Sized>(_: &T) -> usize;\n\n    /// Gets a static string slice containing the name of a type.\n    #[rustc_const_unstable(feature = \"const_type_name\", issue = \"none\")]\n    pub fn type_name<T: ?Sized>() -> &'static str;\n\n    /// Gets an identifier which is globally unique to the specified type. This\n    /// function will return the same value for a type regardless of whichever\n    /// crate it is invoked in.\n    #[rustc_const_unstable(feature = \"const_type_id\", issue = \"none\")]\n    pub fn type_id<T: ?Sized + 'static>() -> u64;\n\n    /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n    /// This will statically either panic, or do nothing.\n    pub fn panic_if_uninhabited<T>();\n\n    /// Gets a reference to a static `Location` indicating where it was called.\n    #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"47809\")]\n    pub fn caller_location() -> &'static crate::panic::Location<'static>;\n\n    /// Creates a value initialized to zero.\n    ///\n    /// `init` is unsafe because it returns a zeroed-out datum,\n    /// which is unsafe unless `T` is `Copy`. Also, even if T is\n    /// `Copy`, an all-zero value may not correspond to any legitimate\n    /// state for the type in question.\n    #[unstable(\n        feature = \"core_intrinsics\",\n        reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n                         they should be used through stabilized interfaces \\\n                         in the rest of the standard library\",\n        issue = \"none\"\n    )]\n    #[rustc_deprecated(reason = \"superseded by MaybeUninit, removal planned\", since = \"1.38.0\")]\n    pub fn init<T>() -> T;\n\n    /// Creates an uninitialized value.\n    ///\n    /// `uninit` is unsafe because there is no guarantee of what its\n    /// contents are. In particular its drop-flag may be set to any\n    /// state, which means it may claim either dropped or\n    /// undropped. In the general case one must use `ptr::write` to\n    /// initialize memory previous set to the result of `uninit`.\n    #[unstable(\n        feature = \"core_intrinsics\",\n        reason = \"intrinsics are unlikely to ever be stabilized, instead \\\n                         they should be used through stabilized interfaces \\\n                         in the rest of the standard library\",\n        issue = \"none\"\n    )]\n    #[rustc_deprecated(reason = \"superseded by MaybeUninit, removal planned\", since = \"1.38.0\")]\n    pub fn uninit<T>() -> T;\n\n    /// Moves a value out of scope without running drop glue.\n    pub fn forget<T: ?Sized>(_: T);\n\n    /// Reinterprets the bits of a value of one type as another type.\n    ///\n    /// Both types must have the same size. Neither the original, nor the result,\n    /// may be an [invalid value](../../nomicon/what-unsafe-does.html).\n    ///\n    /// `transmute` is semantically equivalent to a bitwise move of one type\n    /// into another. It copies the bits from the source value into the\n    /// destination value, then forgets the original. It's equivalent to C's\n    /// `memcpy` under the hood, just like `transmute_copy`.\n    ///\n    /// `transmute` is **incredibly** unsafe. There are a vast number of ways to\n    /// cause [undefined behavior][ub] with this function. `transmute` should be\n    /// the absolute last resort.\n    ///\n    /// The [nomicon](../../nomicon/transmutes.html) has additional\n    /// documentation.\n    ///\n    /// [ub]: ../../reference/behavior-considered-undefined.html\n    ///\n    /// # Examples\n    ///\n    /// There are a few things that `transmute` is really useful for.\n    ///\n    /// Turning a pointer into a function pointer. This is *not* portable to\n    /// machines where function pointers and data pointers have different sizes.\n    ///\n    /// ```\n    /// fn foo() -> i32 {\n    ///     0\n    /// }\n    /// let pointer = foo as *const ();\n    /// let function = unsafe {\n    ///     std::mem::transmute::<*const (), fn() -> i32>(pointer)\n    /// };\n    /// assert_eq!(function(), 0);\n    /// ```\n    ///\n    /// Extending a lifetime, or shortening an invariant lifetime. This is\n    /// advanced, very unsafe Rust!\n    ///\n    /// ```\n    /// struct R<'a>(&'a i32);\n    /// unsafe fn extend_lifetime<'b>(r: R<'b>) -> R<'static> {\n    ///     std::mem::transmute::<R<'b>, R<'static>>(r)\n    /// }\n    ///\n    /// unsafe fn shorten_invariant_lifetime<'b, 'c>(r: &'b mut R<'static>)\n    ///                                              -> &'b mut R<'c> {\n    ///     std::mem::transmute::<&'b mut R<'static>, &'b mut R<'c>>(r)\n    /// }\n    /// ```\n    ///\n    /// # Alternatives\n    ///\n    /// Don't despair: many uses of `transmute` can be achieved through other means.\n    /// Below are common applications of `transmute` which can be replaced with safer\n    /// constructs.\n    ///\n    /// Turning a pointer into a `usize`:\n    ///\n    /// ```\n    /// let ptr = &0;\n    /// let ptr_num_transmute = unsafe {\n    ///     std::mem::transmute::<&i32, usize>(ptr)\n    /// };\n    ///\n    /// // Use an `as` cast instead\n    /// let ptr_num_cast = ptr as *const i32 as usize;\n    /// ```\n    ///\n    /// Turning a `*mut T` into an `&mut T`:\n    ///\n    /// ```\n    /// let ptr: *mut i32 = &mut 0;\n    /// let ref_transmuted = unsafe {\n    ///     std::mem::transmute::<*mut i32, &mut i32>(ptr)\n    /// };\n    ///\n    /// // Use a reborrow instead\n    /// let ref_casted = unsafe { &mut *ptr };\n    /// ```\n    ///\n    /// Turning an `&mut T` into an `&mut U`:\n    ///\n    /// ```\n    /// let ptr = &mut 0;\n    /// let val_transmuted = unsafe {\n    ///     std::mem::transmute::<&mut i32, &mut u32>(ptr)\n    /// };\n    ///\n    /// // Now, put together `as` and reborrowing - note the chaining of `as`\n    /// // `as` is not transitive\n    /// let val_casts = unsafe { &mut *(ptr as *mut i32 as *mut u32) };\n    /// ```\n    ///\n    /// Turning an `&str` into an `&[u8]`:\n    ///\n    /// ```\n    /// // this is not a good way to do this.\n    /// let slice = unsafe { std::mem::transmute::<&str, &[u8]>(\"Rust\") };\n    /// assert_eq!(slice, &[82, 117, 115, 116]);\n    ///\n    /// // You could use `str::as_bytes`\n    /// let slice = \"Rust\".as_bytes();\n    /// assert_eq!(slice, &[82, 117, 115, 116]);\n    ///\n    /// // Or, just use a byte string, if you have control over the string\n    /// // literal\n    /// assert_eq!(b\"Rust\", &[82, 117, 115, 116]);\n    /// ```\n    ///\n    /// Turning a `Vec<&T>` into a `Vec<Option<&T>>`:\n    ///\n    /// ```\n    /// let store = [0, 1, 2, 3];\n    /// let v_orig = store.iter().collect::<Vec<&i32>>();\n    ///\n    /// // clone the vector as we will reuse them later\n    /// let v_clone = v_orig.clone();\n    ///\n    /// // Using transmute: this is Undefined Behavior, and a bad idea.\n    /// // However, it is no-copy.\n    /// let v_transmuted = unsafe {\n    ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(v_clone)\n    /// };\n    ///\n    /// let v_clone = v_orig.clone();\n    ///\n    /// // This is the suggested, safe way.\n    /// // It does copy the entire vector, though, into a new array.\n    /// let v_collected = v_clone.into_iter()\n    ///                          .map(Some)\n    ///                          .collect::<Vec<Option<&i32>>>();\n    ///\n    /// let v_clone = v_orig.clone();\n    ///\n    /// // The no-copy, unsafe way, still using transmute, but not UB.\n    /// // This is equivalent to the original, but safer, and reuses the\n    /// // same `Vec` internals. Therefore, the new inner type must have the\n    /// // exact same size, and the same alignment, as the old type.\n    /// // The same caveats exist for this method as transmute, for\n    /// // the original inner type (`&i32`) to the converted inner type\n    /// // (`Option<&i32>`), so read the nomicon pages linked above.\n    /// let v_from_raw = unsafe {\n    // FIXME Update this when vec_into_raw_parts is stabilized\n    ///     // Ensure the original vector is not dropped.\n    ///     let mut v_clone = std::mem::ManuallyDrop::new(v_clone);\n    ///     Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut Option<&i32>,\n    ///                         v_clone.len(),\n    ///                         v_clone.capacity())\n    /// };\n    /// ```\n    ///\n    /// Implementing `split_at_mut`:\n    ///\n    /// ```\n    /// use std::{slice, mem};\n    ///\n    /// // There are multiple ways to do this, and there are multiple problems\n    /// // with the following (transmute) way.\n    /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n    ///                              -> (&mut [T], &mut [T]) {\n    ///     let len = slice.len();\n    ///     assert!(mid <= len);\n    ///     unsafe {\n    ///         let slice2 = mem::transmute::<&mut [T], &mut [T]>(slice);\n    ///         // first: transmute is not typesafe; all it checks is that T and\n    ///         // U are of the same size. Second, right here, you have two\n    ///         // mutable references pointing to the same memory.\n    ///         (&mut slice[0..mid], &mut slice2[mid..len])\n    ///     }\n    /// }\n    ///\n    /// // This gets rid of the typesafety problems; `&mut *` will *only* give\n    /// // you an `&mut T` from an `&mut T` or `*mut T`.\n    /// fn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\n    ///                          -> (&mut [T], &mut [T]) {\n    ///     let len = slice.len();\n    ///     assert!(mid <= len);\n    ///     unsafe {\n    ///         let slice2 = &mut *(slice as *mut [T]);\n    ///         // however, you still have two mutable references pointing to\n    ///         // the same memory.\n    ///         (&mut slice[0..mid], &mut slice2[mid..len])\n    ///     }\n    /// }\n    ///\n    /// // This is how the standard library does it. This is the best method, if\n    /// // you need to do something like this\n    /// fn split_at_stdlib<T>(slice: &mut [T], mid: usize)\n    ///                       -> (&mut [T], &mut [T]) {\n    ///     let len = slice.len();\n    ///     assert!(mid <= len);\n    ///     unsafe {\n    ///         let ptr = slice.as_mut_ptr();\n    ///         // This now has three mutable references pointing at the same\n    ///         // memory. `slice`, the rvalue ret.0, and the rvalue ret.1.\n    ///         // `slice` is never used after `let ptr = ...`, and so one can\n    ///         // treat it as \"dead\", and therefore, you only have two real\n    ///         // mutable slices.\n    ///         (slice::from_raw_parts_mut(ptr, mid),\n    ///          slice::from_raw_parts_mut(ptr.add(mid), len - mid))\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_transmute\", issue = \"53605\")]\n    pub fn transmute<T, U>(e: T) -> U;\n\n    /// Returns `true` if the actual type given as `T` requires drop\n    /// glue; returns `false` if the actual type provided for `T`\n    /// implements `Copy`.\n    ///\n    /// If the actual type neither requires drop glue nor implements\n    /// `Copy`, then may return `true` or `false`.\n    ///\n    /// The stabilized version of this intrinsic is\n    /// [`std::mem::needs_drop`](../../std/mem/fn.needs_drop.html).\n    #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n    pub fn needs_drop<T>() -> bool;\n\n    /// Calculates the offset from a pointer.\n    ///\n    /// This is implemented as an intrinsic to avoid converting to and from an\n    /// integer, since the conversion would throw away aliasing information.\n    ///\n    /// # Safety\n    ///\n    /// Both the starting and resulting pointer must be either in bounds or one\n    /// byte past the end of an allocated object. If either pointer is out of\n    /// bounds or arithmetic overflow occurs then any further use of the\n    /// returned value will result in undefined behavior.\n    pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n\n    /// Calculates the offset from a pointer, potentially wrapping.\n    ///\n    /// This is implemented as an intrinsic to avoid converting to and from an\n    /// integer, since the conversion inhibits certain optimizations.\n    ///\n    /// # Safety\n    ///\n    /// Unlike the `offset` intrinsic, this intrinsic does not restrict the\n    /// resulting pointer to point into or one byte past the end of an allocated\n    /// object, and it wraps with two's complement arithmetic. The resulting\n    /// value is not necessarily valid to be used to actually access memory.\n    pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n\n    /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n    /// a size of `count` * `size_of::<T>()` and an alignment of\n    /// `min_align_of::<T>()`\n    ///\n    /// The volatile parameter is set to `true`, so it will not be optimized out\n    /// unless size is equal to zero.\n    pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n    /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n    /// a size of `count` * `size_of::<T>()` and an alignment of\n    /// `min_align_of::<T>()`\n    ///\n    /// The volatile parameter is set to `true`, so it will not be optimized out\n    /// unless size is equal to zero.\n    pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n    /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n    /// size of `count` * `size_of::<T>()` and an alignment of\n    /// `min_align_of::<T>()`.\n    ///\n    /// The volatile parameter is set to `true`, so it will not be optimized out\n    /// unless size is equal to zero.\n    pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n\n    /// Performs a volatile load from the `src` pointer.\n    /// The stabilized version of this intrinsic is\n    /// [`std::ptr::read_volatile`](../../std/ptr/fn.read_volatile.html).\n    pub fn volatile_load<T>(src: *const T) -> T;\n    /// Performs a volatile store to the `dst` pointer.\n    /// The stabilized version of this intrinsic is\n    /// [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n    pub fn volatile_store<T>(dst: *mut T, val: T);\n\n    /// Performs a volatile load from the `src` pointer\n    /// The pointer is not required to be aligned.\n    pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n    /// Performs a volatile store to the `dst` pointer.\n    /// The pointer is not required to be aligned.\n    pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n\n    /// Returns the square root of an `f32`\n    pub fn sqrtf32(x: f32) -> f32;\n    /// Returns the square root of an `f64`\n    pub fn sqrtf64(x: f64) -> f64;\n\n    /// Raises an `f32` to an integer power.\n    pub fn powif32(a: f32, x: i32) -> f32;\n    /// Raises an `f64` to an integer power.\n    pub fn powif64(a: f64, x: i32) -> f64;\n\n    /// Returns the sine of an `f32`.\n    pub fn sinf32(x: f32) -> f32;\n    /// Returns the sine of an `f64`.\n    pub fn sinf64(x: f64) -> f64;\n\n    /// Returns the cosine of an `f32`.\n    pub fn cosf32(x: f32) -> f32;\n    /// Returns the cosine of an `f64`.\n    pub fn cosf64(x: f64) -> f64;\n\n    /// Raises an `f32` to an `f32` power.\n    pub fn powf32(a: f32, x: f32) -> f32;\n    /// Raises an `f64` to an `f64` power.\n    pub fn powf64(a: f64, x: f64) -> f64;\n\n    /// Returns the exponential of an `f32`.\n    pub fn expf32(x: f32) -> f32;\n    /// Returns the exponential of an `f64`.\n    pub fn expf64(x: f64) -> f64;\n\n    /// Returns 2 raised to the power of an `f32`.\n    pub fn exp2f32(x: f32) -> f32;\n    /// Returns 2 raised to the power of an `f64`.\n    pub fn exp2f64(x: f64) -> f64;\n\n    /// Returns the natural logarithm of an `f32`.\n    pub fn logf32(x: f32) -> f32;\n    /// Returns the natural logarithm of an `f64`.\n    pub fn logf64(x: f64) -> f64;\n\n    /// Returns the base 10 logarithm of an `f32`.\n    pub fn log10f32(x: f32) -> f32;\n    /// Returns the base 10 logarithm of an `f64`.\n    pub fn log10f64(x: f64) -> f64;\n\n    /// Returns the base 2 logarithm of an `f32`.\n    pub fn log2f32(x: f32) -> f32;\n    /// Returns the base 2 logarithm of an `f64`.\n    pub fn log2f64(x: f64) -> f64;\n\n    /// Returns `a * b + c` for `f32` values.\n    pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;\n    /// Returns `a * b + c` for `f64` values.\n    pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;\n\n    /// Returns the absolute value of an `f32`.\n    pub fn fabsf32(x: f32) -> f32;\n    /// Returns the absolute value of an `f64`.\n    pub fn fabsf64(x: f64) -> f64;\n\n    /// Returns the minimum of two `f32` values.\n    pub fn minnumf32(x: f32, y: f32) -> f32;\n    /// Returns the minimum of two `f64` values.\n    pub fn minnumf64(x: f64, y: f64) -> f64;\n    /// Returns the maximum of two `f32` values.\n    pub fn maxnumf32(x: f32, y: f32) -> f32;\n    /// Returns the maximum of two `f64` values.\n    pub fn maxnumf64(x: f64, y: f64) -> f64;\n\n    /// Copies the sign from `y` to `x` for `f32` values.\n    pub fn copysignf32(x: f32, y: f32) -> f32;\n    /// Copies the sign from `y` to `x` for `f64` values.\n    pub fn copysignf64(x: f64, y: f64) -> f64;\n\n    /// Returns the largest integer less than or equal to an `f32`.\n    pub fn floorf32(x: f32) -> f32;\n    /// Returns the largest integer less than or equal to an `f64`.\n    pub fn floorf64(x: f64) -> f64;\n\n    /// Returns the smallest integer greater than or equal to an `f32`.\n    pub fn ceilf32(x: f32) -> f32;\n    /// Returns the smallest integer greater than or equal to an `f64`.\n    pub fn ceilf64(x: f64) -> f64;\n\n    /// Returns the integer part of an `f32`.\n    pub fn truncf32(x: f32) -> f32;\n    /// Returns the integer part of an `f64`.\n    pub fn truncf64(x: f64) -> f64;\n\n    /// Returns the nearest integer to an `f32`. May raise an inexact floating-point exception\n    /// if the argument is not an integer.\n    pub fn rintf32(x: f32) -> f32;\n    /// Returns the nearest integer to an `f64`. May raise an inexact floating-point exception\n    /// if the argument is not an integer.\n    pub fn rintf64(x: f64) -> f64;\n\n    /// Returns the nearest integer to an `f32`.\n    pub fn nearbyintf32(x: f32) -> f32;\n    /// Returns the nearest integer to an `f64`.\n    pub fn nearbyintf64(x: f64) -> f64;\n\n    /// Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.\n    pub fn roundf32(x: f32) -> f32;\n    /// Returns the nearest integer to an `f64`. Rounds half-way cases away from zero.\n    pub fn roundf64(x: f64) -> f64;\n\n    /// Float addition that allows optimizations based on algebraic rules.\n    /// May assume inputs are finite.\n    pub fn fadd_fast<T>(a: T, b: T) -> T;\n\n    /// Float subtraction that allows optimizations based on algebraic rules.\n    /// May assume inputs are finite.\n    pub fn fsub_fast<T>(a: T, b: T) -> T;\n\n    /// Float multiplication that allows optimizations based on algebraic rules.\n    /// May assume inputs are finite.\n    pub fn fmul_fast<T>(a: T, b: T) -> T;\n\n    /// Float division that allows optimizations based on algebraic rules.\n    /// May assume inputs are finite.\n    pub fn fdiv_fast<T>(a: T, b: T) -> T;\n\n    /// Float remainder that allows optimizations based on algebraic rules.\n    /// May assume inputs are finite.\n    pub fn frem_fast<T>(a: T, b: T) -> T;\n\n    /// Convert with LLVM’s fptoui/fptosi, which may return undef for values out of range\n    /// https://github.com/rust-lang/rust/issues/10184\n    pub fn float_to_int_approx_unchecked<Float, Int>(value: Float) -> Int;\n\n    /// Returns the number of bits set in an integer type `T`\n    #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n    pub fn ctpop<T>(x: T) -> T;\n\n    /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(core_intrinsics)]\n    ///\n    /// use std::intrinsics::ctlz;\n    ///\n    /// let x = 0b0001_1100_u8;\n    /// let num_leading = ctlz(x);\n    /// assert_eq!(num_leading, 3);\n    /// ```\n    ///\n    /// An `x` with value `0` will return the bit width of `T`.\n    ///\n    /// ```\n    /// #![feature(core_intrinsics)]\n    ///\n    /// use std::intrinsics::ctlz;\n    ///\n    /// let x = 0u16;\n    /// let num_leading = ctlz(x);\n    /// assert_eq!(num_leading, 16);\n    /// ```\n    #[rustc_const_stable(feature = \"const_ctlz\", since = \"1.40.0\")]\n    pub fn ctlz<T>(x: T) -> T;\n\n    /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n    /// given an `x` with value `0`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(core_intrinsics)]\n    ///\n    /// use std::intrinsics::ctlz_nonzero;\n    ///\n    /// let x = 0b0001_1100_u8;\n    /// let num_leading = unsafe { ctlz_nonzero(x) };\n    /// assert_eq!(num_leading, 3);\n    /// ```\n    #[rustc_const_unstable(feature = \"constctlz\", issue = \"none\")]\n    pub fn ctlz_nonzero<T>(x: T) -> T;\n\n    /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(core_intrinsics)]\n    ///\n    /// use std::intrinsics::cttz;\n    ///\n    /// let x = 0b0011_1000_u8;\n    /// let num_trailing = cttz(x);\n    /// assert_eq!(num_trailing, 3);\n    /// ```\n    ///\n    /// An `x` with value `0` will return the bit width of `T`:\n    ///\n    /// ```\n    /// #![feature(core_intrinsics)]\n    ///\n    /// use std::intrinsics::cttz;\n    ///\n    /// let x = 0u16;\n    /// let num_trailing = cttz(x);\n    /// assert_eq!(num_trailing, 16);\n    /// ```\n    #[rustc_const_stable(feature = \"const_cttz\", since = \"1.40.0\")]\n    pub fn cttz<T>(x: T) -> T;\n\n    /// Like `cttz`, but extra-unsafe as it returns `undef` when\n    /// given an `x` with value `0`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(core_intrinsics)]\n    ///\n    /// use std::intrinsics::cttz_nonzero;\n    ///\n    /// let x = 0b0011_1000_u8;\n    /// let num_trailing = unsafe { cttz_nonzero(x) };\n    /// assert_eq!(num_trailing, 3);\n    /// ```\n    #[rustc_const_unstable(feature = \"const_cttz\", issue = \"none\")]\n    pub fn cttz_nonzero<T>(x: T) -> T;\n\n    /// Reverses the bytes in an integer type `T`.\n    #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n    pub fn bswap<T>(x: T) -> T;\n\n    /// Reverses the bits in an integer type `T`.\n    #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n    pub fn bitreverse<T>(x: T) -> T;\n\n    /// Performs checked integer addition.\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `overflowing_add` method. For example,\n    /// [`std::u32::overflowing_add`](../../std/primitive.u32.html#method.overflowing_add)\n    #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n    pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);\n\n    /// Performs checked integer subtraction\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `overflowing_sub` method. For example,\n    /// [`std::u32::overflowing_sub`](../../std/primitive.u32.html#method.overflowing_sub)\n    #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n    pub fn sub_with_overflow<T>(x: T, y: T) -> (T, bool);\n\n    /// Performs checked integer multiplication\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `overflowing_mul` method. For example,\n    /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n    #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n    pub fn mul_with_overflow<T>(x: T, y: T) -> (T, bool);\n\n    /// Performs an exact division, resulting in undefined behavior where\n    /// `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n    pub fn exact_div<T>(x: T, y: T) -> T;\n\n    /// Performs an unchecked division, resulting in undefined behavior\n    /// where y = 0 or x = `T::min_value()` and y = -1\n    pub fn unchecked_div<T>(x: T, y: T) -> T;\n    /// Returns the remainder of an unchecked division, resulting in\n    /// undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n    pub fn unchecked_rem<T>(x: T, y: T) -> T;\n\n    /// Performs an unchecked left shift, resulting in undefined behavior when\n    /// y < 0 or y >= N, where N is the width of T in bits.\n    #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n    pub fn unchecked_shl<T>(x: T, y: T) -> T;\n    /// Performs an unchecked right shift, resulting in undefined behavior when\n    /// y < 0 or y >= N, where N is the width of T in bits.\n    #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n    pub fn unchecked_shr<T>(x: T, y: T) -> T;\n\n    /// Returns the result of an unchecked addition, resulting in\n    /// undefined behavior when `x + y > T::max_value()` or `x + y < T::min_value()`.\n    pub fn unchecked_add<T>(x: T, y: T) -> T;\n\n    /// Returns the result of an unchecked subtraction, resulting in\n    /// undefined behavior when `x - y > T::max_value()` or `x - y < T::min_value()`.\n    pub fn unchecked_sub<T>(x: T, y: T) -> T;\n\n    /// Returns the result of an unchecked multiplication, resulting in\n    /// undefined behavior when `x * y > T::max_value()` or `x * y < T::min_value()`.\n    pub fn unchecked_mul<T>(x: T, y: T) -> T;\n\n    /// Performs rotate left.\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `rotate_left` method. For example,\n    /// [`std::u32::rotate_left`](../../std/primitive.u32.html#method.rotate_left)\n    #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n    pub fn rotate_left<T>(x: T, y: T) -> T;\n\n    /// Performs rotate right.\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `rotate_right` method. For example,\n    /// [`std::u32::rotate_right`](../../std/primitive.u32.html#method.rotate_right)\n    #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n    pub fn rotate_right<T>(x: T, y: T) -> T;\n\n    /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `wrapping_add` method. For example,\n    /// [`std::u32::wrapping_add`](../../std/primitive.u32.html#method.wrapping_add)\n    #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n    pub fn wrapping_add<T>(a: T, b: T) -> T;\n    /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `wrapping_sub` method. For example,\n    /// [`std::u32::wrapping_sub`](../../std/primitive.u32.html#method.wrapping_sub)\n    #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n    pub fn wrapping_sub<T>(a: T, b: T) -> T;\n    /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `wrapping_mul` method. For example,\n    /// [`std::u32::wrapping_mul`](../../std/primitive.u32.html#method.wrapping_mul)\n    #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n    pub fn wrapping_mul<T>(a: T, b: T) -> T;\n\n    /// Computes `a + b`, while saturating at numeric bounds.\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `saturating_add` method. For example,\n    /// [`std::u32::saturating_add`](../../std/primitive.u32.html#method.saturating_add)\n    #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n    pub fn saturating_add<T>(a: T, b: T) -> T;\n    /// Computes `a - b`, while saturating at numeric bounds.\n    /// The stabilized versions of this intrinsic are available on the integer\n    /// primitives via the `saturating_sub` method. For example,\n    /// [`std::u32::saturating_sub`](../../std/primitive.u32.html#method.saturating_sub)\n    #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n    pub fn saturating_sub<T>(a: T, b: T) -> T;\n\n    /// Returns the value of the discriminant for the variant in 'v',\n    /// cast to a `u64`; if `T` has no discriminant, returns 0.\n    pub fn discriminant_value<T>(v: &T) -> u64;\n\n    /// Rust's \"try catch\" construct which invokes the function pointer `f` with\n    /// the data pointer `data`.\n    ///\n    /// The third pointer is a target-specific data pointer which is filled in\n    /// with the specifics of the exception that occurred. For examples on Unix\n    /// platforms this is a `*mut *mut T` which is filled in by the compiler and\n    /// on MSVC it's `*mut [usize; 2]`. For more information see the compiler's\n    /// source as well as std's catch implementation.\n    pub fn r#try(f: fn(*mut u8), data: *mut u8, local_ptr: *mut u8) -> i32;\n\n    /// Emits a `!nontemporal` store according to LLVM (see their docs).\n    /// Probably will never become stable.\n    pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n\n    /// See documentation of `<*const T>::offset_from` for details.\n    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"none\")]\n    pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n\n    /// Internal hook used by Miri to implement unwinding.\n    /// Compiles to a NOP during non-Miri codegen.\n    ///\n    /// Perma-unstable: do not use\n    pub fn miri_start_panic(data: *mut (dyn crate::any::Any + crate::marker::Send)) -> ();\n}\n\n// Some functions are defined here because they accidentally got made\n// available in this module on stable. See <https://github.com/rust-lang/rust/issues/15702>.\n// (`transmute` also falls into this category, but it cannot be wrapped due to the\n// check that `T` and `U` have the same size.)\n\n/// Checks whether `ptr` is properly aligned with respect to\n/// `align_of::<T>()`.\npub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n    !ptr.is_null() && ptr as usize % mem::align_of::<T>() == 0\n}\n\n/// Checks whether the regions of memory starting at `src` and `dst` of size\n/// `count * size_of::<T>()` overlap.\nfn overlaps<T>(src: *const T, dst: *const T, count: usize) -> bool {\n}\n\n/// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n/// and destination must *not* overlap.\n///\n/// For regions of memory which might overlap, use [`copy`] instead.\n///\n/// `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n/// with the argument order swapped.\n///\n/// [`copy`]: ./fn.copy.html\n/// [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n///\n/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n///\n/// * Both `src` and `dst` must be properly aligned.\n///\n/// * The region of memory beginning at `src` with a size of `count *\n///   size_of::<T>()` bytes must *not* overlap with the region of memory\n///   beginning at `dst` with the same size.\n///\n/// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n/// in the region beginning at `*src` and the region beginning at `*dst` can\n/// [violate memory safety][read-ownership].\n///\n/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n/// `0`, the pointers must be non-NULL and properly aligned.\n///\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`read`]: ../ptr/fn.read.html\n/// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n/// [valid]: ../ptr/index.html#safety\n///\n/// # Examples\n///\n/// Manually implement [`Vec::append`]:\n///\n/// ```\n/// use std::ptr;\n///\n/// /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n/// fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n///     let src_len = src.len();\n///     let dst_len = dst.len();\n///\n///     // Ensure that `dst` has enough capacity to hold all of `src`.\n///     dst.reserve(src_len);\n///\n///     unsafe {\n///         // The call to offset is always safe because `Vec` will never\n///         // allocate more than `isize::MAX` bytes.\n///         let dst_ptr = dst.as_mut_ptr().offset(dst_len as isize);\n///         let src_ptr = src.as_ptr();\n///\n///         // Truncate `src` without dropping its contents. We do this first,\n///         // to avoid problems in case something further down panics.\n///         src.set_len(0);\n///\n///         // The two regions cannot overlap because mutable references do\n///         // not alias, and two different vectors cannot own the same\n///         // memory.\n///         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n///\n///         // Notify `dst` that it now holds the contents of `src`.\n///         dst.set_len(dst_len + src_len);\n///     }\n/// }\n///\n/// let mut a = vec!['r'];\n/// let mut b = vec!['u', 's', 't'];\n///\n/// append(&mut a, &mut b);\n///\n/// assert_eq!(a, &['r', 'u', 's', 't']);\n/// assert!(b.is_empty());\n/// ```\n///\n/// [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[inline]\npub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n}\n\n/// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n/// and destination may overlap.\n///\n/// If the source and destination will *never* overlap,\n/// [`copy_nonoverlapping`] can be used instead.\n///\n/// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n/// order swapped. Copying takes place as if the bytes were copied from `src`\n/// to a temporary array and then copied from the array to `dst`.\n///\n/// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n/// [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n///\n/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n///\n/// * Both `src` and `dst` must be properly aligned.\n///\n/// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n/// in the region beginning at `*src` and the region beginning at `*dst` can\n/// [violate memory safety][read-ownership].\n///\n/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n/// `0`, the pointers must be non-NULL and properly aligned.\n///\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`read`]: ../ptr/fn.read.html\n/// [read-ownership]: ../ptr/fn.read.html#ownership-of-the-returned-value\n/// [valid]: ../ptr/index.html#safety\n///\n/// # Examples\n///\n/// Efficiently create a Rust vector from an unsafe buffer:\n///\n/// ```\n/// use std::ptr;\n///\n/// # #[allow(dead_code)]\n/// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n///     let mut dst = Vec::with_capacity(elts);\n///     dst.set_len(elts);\n///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n///     dst\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[inline]\npub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n}\n\n/// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n/// `val`.\n///\n/// `write_bytes` is similar to C's [`memset`], but sets `count *\n/// size_of::<T>()` bytes to `val`.\n///\n/// [`memset`]: https://en.cppreference.com/w/c/string/byte/memset\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n///\n/// * `dst` must be properly aligned.\n///\n/// Additionally, the caller must ensure that writing `count *\n/// size_of::<T>()` bytes to the given region of memory results in a valid\n/// value of `T`. Using a region of memory typed as a `T` that contains an\n/// invalid value of `T` is undefined behavior.\n///\n/// Note that even if the effectively copied size (`count * size_of::<T>()`) is\n/// `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut vec = vec![0u32; 4];\n/// unsafe {\n///     let vec_ptr = vec.as_mut_ptr();\n///     ptr::write_bytes(vec_ptr, 0xfe, 2);\n/// }\n/// assert_eq!(vec, [0xfefefefe, 0xfefefefe, 0, 0]);\n/// ```\n///\n/// Creating an invalid value:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut v = Box::new(0i32);\n///\n/// unsafe {\n///     // Leaks the previously held value by overwriting the `Box<T>` with\n///     // a null pointer.\n///     ptr::write_bytes(&mut v as *mut Box<i32>, 0, 1);\n/// }\n///\n/// // At this point, using or dropping `v` results in undefined behavior.\n/// // drop(v); // ERROR\n///\n/// // Even leaking `v` \"uses\" it, and hence is undefined behavior.\n/// // mem::forget(v); // ERROR\n///\n/// // In fact, `v` is invalid according to basic type layout invariants, so *any*\n/// // operation touching it is undefined behavior.\n/// // let v2 = v; // ERROR\n///\n/// unsafe {\n///     // Let us instead put in a valid value\n///     ptr::write(&mut v as *mut Box<i32>, Box::new(42i32));\n/// }\n///\n/// // Now the box is fine\n/// assert_eq!(*v, 42);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[inline]\npub unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n}\n}\npub mod mem {\n//! Basic functions for dealing with memory.\n//!\n//! This module contains functions for querying the size and alignment of\n//! types, initializing and manipulating memory.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::clone;\nuse crate::cmp;\nuse crate::fmt;\nuse crate::hash;\nuse crate::intrinsics;\nuse crate::marker::{Copy, PhantomData, Sized};\nuse crate::ptr;\n\nmod manually_drop {\nuse crate::ops::{Deref, DerefMut};\nuse crate::ptr;\n\n/// A wrapper to inhibit compiler from automatically calling `T`’s destructor.\n///\n/// This wrapper is 0-cost.\n///\n/// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n/// As a consequence, it has *no effect* on the assumptions that the compiler makes\n/// about all values being initialized at their type.  In particular, initializing\n/// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n/// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n///\n/// # Examples\n///\n/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n/// the type:\n///\n/// ```rust\n/// use std::mem::ManuallyDrop;\n/// struct Peach;\n/// struct Banana;\n/// struct Melon;\n/// struct FruitBox {\n///     // Immediately clear there’s something non-trivial going on with these fields.\n///     peach: ManuallyDrop<Peach>,\n///     melon: Melon, // Field that’s independent of the other two.\n///     banana: ManuallyDrop<Banana>,\n/// }\n///\n/// impl Drop for FruitBox {\n///     fn drop(&mut self) {\n///         unsafe {\n///             // Explicit ordering in which field destructors are run specified in the intuitive\n///             // location – the destructor of the structure containing the fields.\n///             // Moreover, one can now reorder fields within the struct however much they want.\n///             ManuallyDrop::drop(&mut self.peach);\n///             ManuallyDrop::drop(&mut self.banana);\n///         }\n///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n///     }\n/// }\n/// ```\n///\n/// [`mem::zeroed`]: fn.zeroed.html\n/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n#[lang = \"manually_drop\"]\n#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n#[repr(transparent)]\npub struct ManuallyDrop<T: ?Sized> {\n    value: T,\n}\n\nimpl<T> ManuallyDrop<T> {\n    /// Wrap a value to be manually dropped.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::mem::ManuallyDrop;\n    /// ManuallyDrop::new(Box::new(()));\n    /// ```\n    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n    #[rustc_const_stable(feature = \"const_manually_drop\", since = \"1.36.0\")]\n    #[inline(always)]\n    pub const fn new(value: T) -> ManuallyDrop<T> {\n}\n\n    /// Extracts the value from the `ManuallyDrop` container.\n    ///\n    /// This allows the value to be dropped again.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::mem::ManuallyDrop;\n    /// let x = ManuallyDrop::new(Box::new(()));\n    /// let _: Box<()> = ManuallyDrop::into_inner(x); // This drops the `Box`.\n    /// ```\n    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n    #[rustc_const_stable(feature = \"const_manually_drop\", since = \"1.36.0\")]\n    #[inline(always)]\n    pub const fn into_inner(slot: ManuallyDrop<T>) -> T {\n}\n\n    /// Takes the value from the `ManuallyDrop<T>` container out.\n    ///\n    /// This method is primarily intended for moving out values in drop.\n    /// Instead of using [`ManuallyDrop::drop`] to manually drop the value,\n    /// you can use this method to take the value and use it however desired.\n    ///\n    /// Whenever possible, it is preferrable to use [`into_inner`][`ManuallyDrop::into_inner`]\n    /// instead, which prevents duplicating the content of the `ManuallyDrop<T>`.\n    ///\n    /// # Safety\n    ///\n    /// This function semantically moves out the contained value without preventing further usage,\n    /// leaving the state of this container unchanged.\n    /// It is your responsibility to ensure that this `ManuallyDrop` is not used again.\n    ///\n    /// [`ManuallyDrop::drop`]: #method.drop\n    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n    #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n    #[stable(feature = \"manually_drop_take\", since = \"1.42.0\")]\n    #[inline]\n    pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n}\n}\n\nimpl<T: ?Sized> ManuallyDrop<T> {\n    /// Manually drops the contained value.\n    ///\n    /// If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n    ///\n    /// # Safety\n    ///\n    /// This function runs the destructor of the contained value and thus the wrapped value\n    /// now represents uninitialized data. It is up to the user of this method to ensure the\n    /// uninitialized data is not actually used.\n    /// In particular, this function can only be called at most once\n    /// for a given instance of `ManuallyDrop<T>`.\n    ///\n    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n    #[inline]\n    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n}\n}\n\n#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\nimpl<T: ?Sized> Deref for ManuallyDrop<T> {\n    type Target = T;\n    #[inline(always)]\n    fn deref(&self) -> &T {\n}\n}\n\n#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\nimpl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n    #[inline(always)]\n    fn deref_mut(&mut self) -> &mut T {\n}\n}\n}\n#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\npub use manually_drop::ManuallyDrop;\n\nmod maybe_uninit {\nuse crate::any::type_name;\nuse crate::fmt;\nuse crate::intrinsics;\nuse crate::mem::ManuallyDrop;\n\n// ignore-tidy-undocumented-unsafe\n\n/// A wrapper type to construct uninitialized instances of `T`.\n///\n/// # Initialization invariant\n///\n/// The compiler, in general, assumes that a variable is properly initialized\n/// according to the requirements of the variable's type. For example, a variable of\n/// reference type must be aligned and non-NULL. This is an invariant that must\n/// *always* be upheld, even in unsafe code. As a consequence, zero-initializing a\n/// variable of reference type causes instantaneous [undefined behavior][ub],\n/// no matter whether that reference ever gets used to access memory:\n///\n/// ```rust,no_run\n/// # #![allow(invalid_value)]\n/// use std::mem::{self, MaybeUninit};\n///\n/// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n/// // The equivalent code with `MaybeUninit<&i32>`:\n/// let x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior!\n/// ```\n///\n/// This is exploited by the compiler for various optimizations, such as eliding\n/// run-time checks and optimizing `enum` layout.\n///\n/// Similarly, entirely uninitialized memory may have any content, while a `bool` must\n/// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n///\n/// ```rust,no_run\n/// # #![allow(invalid_value)]\n/// use std::mem::{self, MaybeUninit};\n///\n/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n/// // The equivalent code with `MaybeUninit<bool>`:\n/// let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n/// ```\n///\n/// Moreover, uninitialized memory is special in that the compiler knows that\n/// it does not have a fixed value. This makes it undefined behavior to have\n/// uninitialized data in a variable even if that variable has an integer type,\n/// which otherwise can hold any *fixed* bit pattern:\n///\n/// ```rust,no_run\n/// # #![allow(invalid_value)]\n/// use std::mem::{self, MaybeUninit};\n///\n/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n/// // The equivalent code with `MaybeUninit<i32>`:\n/// let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n/// ```\n/// (Notice that the rules around uninitialized integers are not finalized yet, but\n/// until they are, it is advisable to avoid them.)\n///\n/// On top of that, remember that most types have additional invariants beyond merely\n/// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n/// is considered initialized (under the current implementation; this does not constitute\n/// a stable guarantee) because the only requirement the compiler knows about it\n/// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n/// *immediate* undefined behavior, but will cause undefined behavior with most\n/// safe operations (including dropping it).\n///\n/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n///\n/// # Examples\n///\n/// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n/// It is a signal to the compiler indicating that the data here might *not*\n/// be initialized:\n///\n/// ```rust\n/// use std::mem::MaybeUninit;\n///\n/// // Create an explicitly uninitialized reference. The compiler knows that data inside\n/// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n/// let mut x = MaybeUninit::<&i32>::uninit();\n/// // Set it to a valid value.\n/// unsafe { x.as_mut_ptr().write(&0); }\n/// // Extract the initialized data -- this is only allowed *after* properly\n/// // initializing `x`!\n/// let x = unsafe { x.assume_init() };\n/// ```\n///\n/// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n///\n/// You can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without\n/// any of the run-time tracking and without any of the safety checks.\n///\n/// ## out-pointers\n///\n/// You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data\n/// from a function, pass it a pointer to some (uninitialized) memory to put the\n/// result into. This can be useful when it is important for the caller to control\n/// how the memory the result is stored in gets allocated, and you want to avoid\n/// unnecessary moves.\n///\n/// ```\n/// use std::mem::MaybeUninit;\n///\n/// unsafe fn make_vec(out: *mut Vec<i32>) {\n///     // `write` does not drop the old contents, which is important.\n///     out.write(vec![1, 2, 3]);\n/// }\n///\n/// let mut v = MaybeUninit::uninit();\n/// unsafe { make_vec(v.as_mut_ptr()); }\n/// // Now we know `v` is initialized! This also makes sure the vector gets\n/// // properly dropped.\n/// let v = unsafe { v.assume_init() };\n/// assert_eq!(&v, &[1, 2, 3]);\n/// ```\n///\n/// ## Initializing an array element-by-element\n///\n/// `MaybeUninit<T>` can be used to initialize a large array element-by-element:\n///\n/// ```\n/// use std::mem::{self, MaybeUninit};\n///\n/// let data = {\n///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n///     // safe because the type we are claiming to have initialized here is a\n///     // bunch of `MaybeUninit`s, which do not require initialization.\n///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {\n///         MaybeUninit::uninit().assume_init()\n///     };\n///\n///     // Dropping a `MaybeUninit` does nothing. Thus using raw pointer\n///     // assignment instead of `ptr::write` does not cause the old\n///     // uninitialized value to be dropped. Also if there is a panic during\n///     // this loop, we have a memory leak, but there is no memory safety\n///     // issue.\n///     for elem in &mut data[..] {\n///         *elem = MaybeUninit::new(vec![42]);\n///     }\n///\n///     // Everything is initialized. Transmute the array to the\n///     // initialized type.\n///     unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n/// };\n///\n/// assert_eq!(&data[0], &[42]);\n/// ```\n///\n/// You can also work with partially initialized arrays, which could\n/// be found in low-level datastructures.\n///\n/// ```\n/// use std::mem::MaybeUninit;\n/// use std::ptr;\n///\n/// // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n/// // safe because the type we are claiming to have initialized here is a\n/// // bunch of `MaybeUninit`s, which do not require initialization.\n/// let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };\n/// // Count the number of elements we have assigned.\n/// let mut data_len: usize = 0;\n///\n/// for elem in &mut data[0..500] {\n///     *elem = MaybeUninit::new(String::from(\"hello\"));\n///     data_len += 1;\n/// }\n///\n/// // For each item in the array, drop if we allocated it.\n/// for elem in &mut data[0..data_len] {\n///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n/// }\n/// ```\n///\n/// ## Initializing a struct field-by-field\n///\n/// There is currently no supported way to create a raw pointer or reference\n/// to a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\n/// to create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\n/// to its fields.\n///\n/// [ub]: ../../reference/behavior-considered-undefined.html\n///\n/// # Layout\n///\n/// `MaybeUninit<T>` is guaranteed to have the same size, alignment, and ABI as `T`:\n///\n/// ```rust\n/// use std::mem::{MaybeUninit, size_of, align_of};\n/// assert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\n/// assert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\n/// ```\n///\n/// However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same\n/// layout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as\n/// a `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit\n/// value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling\n/// optimizations, potentially resulting in a larger size:\n///\n/// ```rust\n/// # use std::mem::{MaybeUninit, size_of};\n/// assert_eq!(size_of::<Option<bool>>(), 1);\n/// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n/// ```\n///\n/// If `T` is FFI-safe, then so is `MaybeUninit<T>`.\n///\n/// While `MaybeUninit` is `#[repr(transparent)]` (indicating it guarantees the same size,\n/// alignment, and ABI as `T`), this does *not* change any of the previous caveats. `Option<T>` and\n/// `Option<MaybeUninit<T>>` may still have different sizes, and types containing a field of type\n/// `T` may be laid out (and sized) differently than if that field were `MaybeUninit<T>`.\n/// `MaybeUninit` is a union type, and `#[repr(transparent)]` on unions is unstable (see [the\n/// tracking issue](https://github.com/rust-lang/rust/issues/60405)). Over time, the exact\n/// guarantees of `#[repr(transparent)]` on unions may evolve, and `MaybeUninit` may or may not\n/// remain `#[repr(transparent)]`. That said, `MaybeUninit<T>` will *always* guarantee that it has\n/// the same size, alignment, and ABI as `T`; it's just that the way `MaybeUninit` implements that\n/// guarantee may evolve.\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n// Lang item so we can wrap other types in it. This is useful for generators.\n#[lang = \"maybe_uninit\"]\n#[derive(Copy)]\n#[repr(transparent)]\npub union MaybeUninit<T> {\n    uninit: (),\n    value: ManuallyDrop<T>,\n}\n\n#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\nimpl<T: Copy> Clone for MaybeUninit<T> {\n    #[inline(always)]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"maybe_uninit_debug\", since = \"1.41.0\")]\nimpl<T> fmt::Debug for MaybeUninit<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<T> MaybeUninit<T> {\n    /// Creates a new `MaybeUninit<T>` initialized with the given value.\n    /// It is safe to call [`assume_init`] on the return value of this function.\n    ///\n    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n    ///\n    /// [`assume_init`]: #method.assume_init\n    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n    #[rustc_const_stable(feature = \"const_maybe_uninit\", since = \"1.36.0\")]\n    #[inline(always)]\n    pub const fn new(val: T) -> MaybeUninit<T> {\n}\n\n    /// Creates a new `MaybeUninit<T>` in an uninitialized state.\n    ///\n    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n    ///\n    /// See the [type-level documentation][type] for some examples.\n    ///\n    /// [type]: union.MaybeUninit.html\n    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n    #[rustc_const_stable(feature = \"const_maybe_uninit\", since = \"1.36.0\")]\n    #[inline(always)]\n    #[rustc_diagnostic_item = \"maybe_uninit_uninit\"]\n    pub const fn uninit() -> MaybeUninit<T> {\n}\n\n    /// Create a new array of `MaybeUninit<T>` items, in an uninitialized state.\n    ///\n    /// Note: in a future Rust version this method may become unnecessary\n    /// when array literal syntax allows\n    /// [repeating const expressions](https://github.com/rust-lang/rust/issues/49147).\n    /// The example below could then use `let mut buf = [MaybeUninit::<u8>::uninit(); 32];`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// #![feature(maybe_uninit_uninit_array, maybe_uninit_extra, maybe_uninit_slice_assume_init)]\n    ///\n    /// use std::mem::MaybeUninit;\n    ///\n    /// extern \"C\" {\n    ///     fn read_into_buffer(ptr: *mut u8, max_len: usize) -> usize;\n    /// }\n    ///\n    /// /// Returns a (possibly smaller) slice of data that was actually read\n    /// fn read(buf: &mut [MaybeUninit<u8>]) -> &[u8] {\n    ///     unsafe {\n    ///         let len = read_into_buffer(buf.as_mut_ptr() as *mut u8, buf.len());\n    ///         MaybeUninit::slice_get_ref(&buf[..len])\n    ///     }\n    /// }\n    ///\n    /// let mut buf: [MaybeUninit<u8>; 32] = MaybeUninit::uninit_array();\n    /// let data = read(&mut buf);\n    /// ```\n    #[unstable(feature = \"maybe_uninit_uninit_array\", issue = \"none\")]\n    #[inline(always)]\n    pub fn uninit_array<const LEN: usize>() -> [Self; LEN] {\n}\n\n    /// A promotable constant, equivalent to `uninit()`.\n    #[unstable(\n        feature = \"internal_uninit_const\",\n        issue = \"none\",\n        reason = \"hack to work around promotability\"\n    )]\n    pub const UNINIT: Self = Self::uninit();\n\n    /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n    /// filled with `0` bytes. It depends on `T` whether that already makes for\n    /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n    /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n    /// be null.\n    ///\n    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n    ///\n    /// # Example\n    ///\n    /// Correct usage of this function: initializing a struct with zero, where all\n    /// fields of the struct can hold the bit-pattern 0 as a valid value.\n    ///\n    /// ```rust\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n    /// let x = unsafe { x.assume_init() };\n    /// assert_eq!(x, (0, false));\n    /// ```\n    ///\n    /// *Incorrect* usage of this function: initializing a struct with zero, where some fields\n    /// cannot hold 0 as a valid value.\n    ///\n    /// ```rust,no_run\n    /// use std::mem::MaybeUninit;\n    ///\n    /// enum NotZero { One = 1, Two = 2 };\n    ///\n    /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n    /// let x = unsafe { x.assume_init() };\n    /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n    /// // This is undefined behavior.\n    /// ```\n    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n    #[inline]\n    #[rustc_diagnostic_item = \"maybe_uninit_zeroed\"]\n    pub fn zeroed() -> MaybeUninit<T> {\n}\n\n    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n    /// without dropping it, so be careful not to use this twice unless you want to\n    /// skip running the destructor. For your convenience, this also returns a mutable\n    /// reference to the (now safely initialized) contents of `self`.\n    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n    #[inline(always)]\n    pub fn write(&mut self, val: T) -> &mut T {\n}\n\n    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n    /// Writing to memory that this pointer (non-transitively) points to is undefined behavior\n    /// (except inside an `UnsafeCell<T>`).\n    ///\n    /// # Examples\n    ///\n    /// Correct usage of this method:\n    ///\n    /// ```rust\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n    /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n    /// let x_vec = unsafe { &*x.as_ptr() };\n    /// assert_eq!(x_vec.len(), 3);\n    /// ```\n    ///\n    /// *Incorrect* usage of this method:\n    ///\n    /// ```rust,no_run\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n    /// let x_vec = unsafe { &*x.as_ptr() };\n    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n    /// ```\n    ///\n    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n    /// until they are, it is advisable to avoid them.)\n    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n    #[inline(always)]\n    pub fn as_ptr(&self) -> *const T {\n}\n\n    /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n    ///\n    /// # Examples\n    ///\n    /// Correct usage of this method:\n    ///\n    /// ```rust\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n    /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n    /// // This is okay because we initialized it.\n    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n    /// x_vec.push(3);\n    /// assert_eq!(x_vec.len(), 4);\n    /// ```\n    ///\n    /// *Incorrect* usage of this method:\n    ///\n    /// ```rust,no_run\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n    /// ```\n    ///\n    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n    /// until they are, it is advisable to avoid them.)\n    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n    #[inline(always)]\n    pub fn as_mut_ptr(&mut self) -> *mut T {\n}\n\n    /// Extracts the value from the `MaybeUninit<T>` container. This is a great way\n    /// to ensure that the data will get dropped, because the resulting `T` is\n    /// subject to the usual drop handling.\n    ///\n    /// # Safety\n    ///\n    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n    /// state. Calling this when the content is not yet fully initialized causes immediate undefined\n    /// behavior. The [type-level documentation][inv] contains more information about\n    /// this initialization invariant.\n    ///\n    /// [inv]: #initialization-invariant\n    ///\n    /// On top of that, remember that most types have additional invariants beyond merely\n    /// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n    /// is considered initialized (under the current implementation; this does not constitute\n    /// a stable guarantee) because the only requirement the compiler knows about it\n    /// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n    /// *immediate* undefined behavior, but will cause undefined behavior with most\n    /// safe operations (including dropping it).\n    ///\n    /// # Examples\n    ///\n    /// Correct usage of this method:\n    ///\n    /// ```rust\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<bool>::uninit();\n    /// unsafe { x.as_mut_ptr().write(true); }\n    /// let x_init = unsafe { x.assume_init() };\n    /// assert_eq!(x_init, true);\n    /// ```\n    ///\n    /// *Incorrect* usage of this method:\n    ///\n    /// ```rust,no_run\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n    /// let x_init = unsafe { x.assume_init() };\n    /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n    /// ```\n    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n    #[inline(always)]\n    #[rustc_diagnostic_item = \"assume_init\"]\n    pub unsafe fn assume_init(self) -> T {\n}\n\n    /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n    /// to the usual drop handling.\n    ///\n    /// Whenever possible, it is preferable to use [`assume_init`] instead, which\n    /// prevents duplicating the content of the `MaybeUninit<T>`.\n    ///\n    /// # Safety\n    ///\n    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n    /// state. Calling this when the content is not yet fully initialized causes undefined\n    /// behavior. The [type-level documentation][inv] contains more information about\n    /// this initialization invariant.\n    ///\n    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n    /// multiple copies of the data (by calling `read` multiple times, or first\n    /// calling `read` and then [`assume_init`]), it is your responsibility\n    /// to ensure that that data may indeed be duplicated.\n    ///\n    /// [inv]: #initialization-invariant\n    /// [`assume_init`]: #method.assume_init\n    ///\n    /// # Examples\n    ///\n    /// Correct usage of this method:\n    ///\n    /// ```rust\n    /// #![feature(maybe_uninit_extra)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<u32>::uninit();\n    /// x.write(13);\n    /// let x1 = unsafe { x.read() };\n    /// // `u32` is `Copy`, so we may read multiple times.\n    /// let x2 = unsafe { x.read() };\n    /// assert_eq!(x1, x2);\n    ///\n    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n    /// x.write(None);\n    /// let x1 = unsafe { x.read() };\n    /// // Duplicating a `None` value is okay, so we may read multiple times.\n    /// let x2 = unsafe { x.read() };\n    /// assert_eq!(x1, x2);\n    /// ```\n    ///\n    /// *Incorrect* usage of this method:\n    ///\n    /// ```rust,no_run\n    /// #![feature(maybe_uninit_extra)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n    /// x.write(Some(vec![0,1,2]));\n    /// let x1 = unsafe { x.read() };\n    /// let x2 = unsafe { x.read() };\n    /// // We now created two copies of the same vector, leading to a double-free when\n    /// // they both get dropped!\n    /// ```\n    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n    #[inline(always)]\n    pub unsafe fn read(&self) -> T {\n}\n\n    /// Gets a shared reference to the contained value.\n    ///\n    /// This can be useful when we want to access a `MaybeUninit` that has been\n    /// initialized but don't have ownership of the `MaybeUninit` (preventing the use\n    /// of `.assume_init()`).\n    ///\n    /// # Safety\n    ///\n    /// Calling this when the content is not yet fully initialized causes undefined\n    /// behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\n    /// is in an initialized state.\n    ///\n    /// # Examples\n    ///\n    /// ### Correct usage of this method:\n    ///\n    /// ```rust\n    /// #![feature(maybe_uninit_ref)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n    /// // Initialize `x`:\n    /// unsafe { x.as_mut_ptr().write(vec![1, 2, 3]); }\n    /// // Now that our `MaybeUninit<_>` is known to be initialized, it is okay to\n    /// // create a shared reference to it:\n    /// let x: &Vec<u32> = unsafe {\n    ///     // Safety: `x` has been initialized.\n    ///     x.get_ref()\n    /// };\n    /// assert_eq!(x, &vec![1, 2, 3]);\n    /// ```\n    ///\n    /// ### *Incorrect* usages of this method:\n    ///\n    /// ```rust,no_run\n    /// #![feature(maybe_uninit_ref)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n    /// let x_vec: &Vec<u32> = unsafe { x.get_ref() };\n    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n    /// ```\n    ///\n    /// ```rust,no_run\n    /// #![feature(maybe_uninit_ref)]\n    /// use std::{cell::Cell, mem::MaybeUninit};\n    ///\n    /// let b = MaybeUninit::<Cell<bool>>::uninit();\n    /// // Initialize the `MaybeUninit` using `Cell::set`:\n    /// unsafe {\n    ///     b.get_ref().set(true);\n    ///  // ^^^^^^^^^^^\n    ///  // Reference to an uninitialized `Cell<bool>`: UB!\n    /// }\n    /// ```\n    #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n    #[inline(always)]\n    pub unsafe fn get_ref(&self) -> &T {\n}\n\n    /// Gets a mutable (unique) reference to the contained value.\n    ///\n    /// This can be useful when we want to access a `MaybeUninit` that has been\n    /// initialized but don't have ownership of the `MaybeUninit` (preventing the use\n    /// of `.assume_init()`).\n    ///\n    /// # Safety\n    ///\n    /// Calling this when the content is not yet fully initialized causes undefined\n    /// behavior: it is up to the caller to guarantee that the `MaybeUninit<T>` really\n    /// is in an initialized state. For instance, `.get_mut()` cannot be used to\n    /// initialize a `MaybeUninit`.\n    ///\n    /// # Examples\n    ///\n    /// ### Correct usage of this method:\n    ///\n    /// ```rust\n    /// #![feature(maybe_uninit_ref)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// # unsafe extern \"C\" fn initialize_buffer(buf: *mut [u8; 2048]) { *buf = [0; 2048] }\n    /// # #[cfg(FALSE)]\n    /// extern \"C\" {\n    ///     /// Initializes *all* the bytes of the input buffer.\n    ///     fn initialize_buffer(buf: *mut [u8; 2048]);\n    /// }\n    ///\n    /// let mut buf = MaybeUninit::<[u8; 2048]>::uninit();\n    ///\n    /// // Initialize `buf`:\n    /// unsafe { initialize_buffer(buf.as_mut_ptr()); }\n    /// // Now we know that `buf` has been initialized, so we could `.assume_init()` it.\n    /// // However, using `.assume_init()` may trigger a `memcpy` of the 2048 bytes.\n    /// // To assert our buffer has been initialized without copying it, we upgrade\n    /// // the `&mut MaybeUninit<[u8; 2048]>` to a `&mut [u8; 2048]`:\n    /// let buf: &mut [u8; 2048] = unsafe {\n    ///     // Safety: `buf` has been initialized.\n    ///     buf.get_mut()\n    /// };\n    ///\n    /// // Now we can use `buf` as a normal slice:\n    /// buf.sort_unstable();\n    /// assert!(\n    ///     buf.chunks(2).all(|chunk| chunk[0] <= chunk[1]),\n    ///     \"buffer is sorted\",\n    /// );\n    /// ```\n    ///\n    /// ### *Incorrect* usages of this method:\n    ///\n    /// You cannot use `.get_mut()` to initialize a value:\n    ///\n    /// ```rust,no_run\n    /// #![feature(maybe_uninit_ref)]\n    /// use std::mem::MaybeUninit;\n    ///\n    /// let mut b = MaybeUninit::<bool>::uninit();\n    /// unsafe {\n    ///     *b.get_mut() = true;\n    ///     // We have created a (mutable) reference to an uninitialized `bool`!\n    ///     // This is undefined behavior.\n    /// }\n    /// ```\n    ///\n    /// For instance, you cannot [`Read`] into an uninitialized buffer:\n    ///\n    /// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html\n    ///\n    /// ```rust,no_run\n    /// #![feature(maybe_uninit_ref)]\n    /// use std::{io, mem::MaybeUninit};\n    ///\n    /// fn read_chunk (reader: &'_ mut dyn io::Read) -> io::Result<[u8; 64]>\n    /// {\n    ///     let mut buffer = MaybeUninit::<[u8; 64]>::uninit();\n    ///     reader.read_exact(unsafe { buffer.get_mut() })?;\n    ///                             // ^^^^^^^^^^^^^^^^\n    ///                             // (mutable) reference to uninitialized memory!\n    ///                             // This is undefined behavior.\n    ///     Ok(unsafe { buffer.assume_init() })\n    /// }\n    /// ```\n    ///\n    /// Nor can you use direct field access to do field-by-field gradual initialization:\n    ///\n    /// ```rust,no_run\n    /// #![feature(maybe_uninit_ref)]\n    /// use std::{mem::MaybeUninit, ptr};\n    ///\n    /// struct Foo {\n    ///     a: u32,\n    ///     b: u8,\n    /// }\n    ///\n    /// let foo: Foo = unsafe {\n    ///     let mut foo = MaybeUninit::<Foo>::uninit();\n    ///     ptr::write(&mut foo.get_mut().a as *mut u32, 1337);\n    ///                  // ^^^^^^^^^^^^^\n    ///                  // (mutable) reference to uninitialized memory!\n    ///                  // This is undefined behavior.\n    ///     ptr::write(&mut foo.get_mut().b as *mut u8, 42);\n    ///                  // ^^^^^^^^^^^^^\n    ///                  // (mutable) reference to uninitialized memory!\n    ///                  // This is undefined behavior.\n    ///     foo.assume_init()\n    /// };\n    /// ```\n    // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n    // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n    // a final decision about the rules before stabilization.\n    #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n    #[inline(always)]\n    pub unsafe fn get_mut(&mut self) -> &mut T {\n}\n\n    /// Assuming all the elements are initialized, get a slice to them.\n    ///\n    /// # Safety\n    ///\n    /// It is up to the caller to guarantee that the `MaybeUninit<T>` elements\n    /// really are in an initialized state.\n    /// Calling this when the content is not yet fully initialized causes undefined behavior.\n    #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"none\")]\n    #[inline(always)]\n    pub unsafe fn slice_get_ref(slice: &[Self]) -> &[T] {\n}\n\n    /// Assuming all the elements are initialized, get a mutable slice to them.\n    ///\n    /// # Safety\n    ///\n    /// It is up to the caller to guarantee that the `MaybeUninit<T>` elements\n    /// really are in an initialized state.\n    /// Calling this when the content is not yet fully initialized causes undefined behavior.\n    #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"none\")]\n    #[inline(always)]\n    pub unsafe fn slice_get_mut(slice: &mut [Self]) -> &mut [T] {\n}\n\n    /// Gets a pointer to the first element of the array.\n    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n    #[inline(always)]\n    pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n}\n\n    /// Gets a mutable pointer to the first element of the array.\n    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n    #[inline(always)]\n    pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n}\n}\n}\n#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\npub use maybe_uninit::MaybeUninit;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(inline)]\npub use crate::intrinsics::transmute;\n\n/// Takes ownership and \"forgets\" about the value **without running its destructor**.\n///\n/// Any resources the value manages, such as heap memory or a file handle, will linger\n/// forever in an unreachable state. However, it does not guarantee that pointers\n/// to this memory will remain valid.\n///\n/// * If you want to leak memory, see [`Box::leak`][leak].\n/// * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`][into_raw].\n/// * If you want to dispose of a value properly, running its destructor, see\n/// [`mem::drop`][drop].\n///\n/// # Safety\n///\n/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n/// do not include a guarantee that destructors will always run. For example,\n/// a program can create a reference cycle using [`Rc`][rc], or call\n/// [`process::exit`][exit] to exit without running destructors. Thus, allowing\n/// `mem::forget` from safe code does not fundamentally change Rust's safety\n/// guarantees.\n///\n/// That said, leaking resources such as memory or I/O objects is usually undesirable.\n/// The need comes up in some specialized use cases for FFI or unsafe code, but even\n/// then, [`ManuallyDrop`] is typically preferred.\n///\n/// Because forgetting a value is allowed, any `unsafe` code you write must\n/// allow for this possibility. You cannot return a value and expect that the\n/// caller will necessarily run the value's destructor.\n///\n/// [rc]: ../../std/rc/struct.Rc.html\n/// [exit]: ../../std/process/fn.exit.html\n///\n/// # Examples\n///\n/// Leak an I/O object, never closing the file:\n///\n/// ```no_run\n/// use std::mem;\n/// use std::fs::File;\n///\n/// let file = File::open(\"foo.txt\").unwrap();\n/// mem::forget(file);\n/// ```\n///\n/// The practical use cases for `forget` are rather specialized and mainly come\n/// up in unsafe or FFI code. However, [`ManuallyDrop`] is usually preferred\n/// for such cases, e.g.:\n///\n/// ```\n/// use std::mem::ManuallyDrop;\n///\n/// let v = vec![65, 122];\n/// // Before we disassemble `v` into its raw parts, make sure it\n/// // does not get dropped!\n/// let mut v = ManuallyDrop::new(v);\n/// // Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n/// let ptr = v.as_mut_ptr();\n/// let cap = v.capacity();\n/// // Finally, build a `String`.\n/// let s = unsafe { String::from_raw_parts(ptr, 2, cap) };\n/// assert_eq!(s, \"Az\");\n/// // `s` is implicitly dropped and its memory deallocated.\n/// ```\n///\n/// Using `ManuallyDrop` here has two advantages:\n///\n/// * We do not \"touch\" `v` after disassembling it. For some types, operations\n///   such as passing ownership (to a funcion like `mem::forget`) requires them to actually\n///   be fully owned right now; that is a promise we do not want to make here as we are\n///   in the process of transferring ownership to the new `String` we are building.\n/// * In case of an unexpected panic, `ManuallyDrop` is not dropped, but if the panic\n///   occurs before `mem::forget` was called we might end up dropping invalid data,\n///   or double-dropping. In other words, `ManuallyDrop` errs on the side of leaking\n///   instead of erring on the side of dropping.\n///\n/// [drop]: fn.drop.html\n/// [uninit]: fn.uninitialized.html\n/// [clone]: ../clone/trait.Clone.html\n/// [swap]: fn.swap.html\n/// [box]: ../../std/boxed/struct.Box.html\n/// [leak]: ../../std/boxed/struct.Box.html#method.leak\n/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n/// [ub]: ../../reference/behavior-considered-undefined.html\n/// [`ManuallyDrop`]: struct.ManuallyDrop.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn forget<T>(t: T) {\n}\n\n/// Like [`forget`], but also accepts unsized values.\n///\n/// This function is just a shim intended to be removed when the `unsized_locals` feature gets\n/// stabilized.\n///\n/// [`forget`]: fn.forget.html\n#[inline]\n#[unstable(feature = \"forget_unsized\", issue = \"none\")]\npub fn forget_unsized<T: ?Sized>(t: T) {\n}\n\n/// Returns the size of a type in bytes.\n///\n/// More specifically, this is the offset in bytes between successive elements\n/// in an array with that item type including alignment padding. Thus, for any\n/// type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n///\n/// In general, the size of a type is not stable across compilations, but\n/// specific types such as primitives are.\n///\n/// The following table gives the size for primitives.\n///\n/// Type | size_of::\\<Type>()\n/// ---- | ---------------\n/// () | 0\n/// bool | 1\n/// u8 | 1\n/// u16 | 2\n/// u32 | 4\n/// u64 | 8\n/// u128 | 16\n/// i8 | 1\n/// i16 | 2\n/// i32 | 4\n/// i64 | 8\n/// i128 | 16\n/// f32 | 4\n/// f64 | 8\n/// char | 4\n///\n/// Furthermore, `usize` and `isize` have the same size.\n///\n/// The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have\n/// the same size. If `T` is Sized, all of those types have the same size as `usize`.\n///\n/// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n/// have the same size. Likewise for `*const T` and `*mut T`.\n///\n/// # Size of `#[repr(C)]` items\n///\n/// The `C` representation for items has a defined layout. With this layout,\n/// the size of items is also stable as long as all fields have a stable size.\n///\n/// ## Size of Structs\n///\n/// For `structs`, the size is determined by the following algorithm.\n///\n/// For each field in the struct ordered by declaration order:\n///\n/// 1. Add the size of the field.\n/// 2. Round up the current size to the nearest multiple of the next field's [alignment].\n///\n/// Finally, round the size of the struct to the nearest multiple of its [alignment].\n/// The alignment of the struct is usually the largest alignment of all its\n/// fields; this can be changed with the use of `repr(align(N))`.\n///\n/// Unlike `C`, zero sized structs are not rounded up to one byte in size.\n///\n/// ## Size of Enums\n///\n/// Enums that carry no data other than the discriminant have the same size as C enums\n/// on the platform they are compiled for.\n///\n/// ## Size of Unions\n///\n/// The size of a union is the size of its largest field.\n///\n/// Unlike `C`, zero sized unions are not rounded up to one byte in size.\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// // Some primitives\n/// assert_eq!(4, mem::size_of::<i32>());\n/// assert_eq!(8, mem::size_of::<f64>());\n/// assert_eq!(0, mem::size_of::<()>());\n///\n/// // Some arrays\n/// assert_eq!(8, mem::size_of::<[i32; 2]>());\n/// assert_eq!(12, mem::size_of::<[i32; 3]>());\n/// assert_eq!(0, mem::size_of::<[i32; 0]>());\n///\n///\n/// // Pointer size equality\n/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\n/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\n/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n/// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n/// ```\n///\n/// Using `#[repr(C)]`.\n///\n/// ```\n/// use std::mem;\n///\n/// #[repr(C)]\n/// struct FieldStruct {\n///     first: u8,\n///     second: u16,\n///     third: u8\n/// }\n///\n/// // The size of the first field is 1, so add 1 to the size. Size is 1.\n/// // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n/// // The size of the second field is 2, so add 2 to the size. Size is 4.\n/// // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n/// // The size of the third field is 1, so add 1 to the size. Size is 5.\n/// // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n/// // fields is 2), so add 1 to the size for padding. Size is 6.\n/// assert_eq!(6, mem::size_of::<FieldStruct>());\n///\n/// #[repr(C)]\n/// struct TupleStruct(u8, u16, u8);\n///\n/// // Tuple structs follow the same rules.\n/// assert_eq!(6, mem::size_of::<TupleStruct>());\n///\n/// // Note that reordering the fields can lower the size. We can remove both padding bytes\n/// // by putting `third` before `second`.\n/// #[repr(C)]\n/// struct FieldStructOptimized {\n///     first: u8,\n///     third: u8,\n///     second: u16\n/// }\n///\n/// assert_eq!(4, mem::size_of::<FieldStructOptimized>());\n///\n/// // Union size is the size of the largest field.\n/// #[repr(C)]\n/// union ExampleUnion {\n///     smaller: u8,\n///     larger: u16\n/// }\n///\n/// assert_eq!(2, mem::size_of::<ExampleUnion>());\n/// ```\n///\n/// [alignment]: ./fn.align_of.html\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_promotable]\n#[rustc_const_stable(feature = \"const_size_of\", since = \"1.32.0\")]\npub const fn size_of<T>() -> usize {\n}\n\n/// Returns the size of the pointed-to value in bytes.\n///\n/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n/// then `size_of_val` can be used to get the dynamically-known size.\n///\n/// [slice]: ../../std/primitive.slice.html\n/// [trait object]: ../../book/ch17-02-trait-objects.html\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::size_of_val(&5i32));\n///\n/// let x: [u8; 13] = [0; 13];\n/// let y: &[u8] = &x;\n/// assert_eq!(13, mem::size_of_val(y));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n}\n\n/// Returns the [ABI]-required minimum alignment of a type.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// # #![allow(deprecated)]\n/// use std::mem;\n///\n/// assert_eq!(4, mem::min_align_of::<i32>());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\npub fn min_align_of<T>() -> usize {\n}\n\n/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// # #![allow(deprecated)]\n/// use std::mem;\n///\n/// assert_eq!(4, mem::min_align_of_val(&5i32));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\npub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n}\n\n/// Returns the [ABI]-required minimum alignment of a type.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::align_of::<i32>());\n/// ```\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_promotable]\n#[rustc_const_stable(feature = \"const_align_of\", since = \"1.32.0\")]\npub const fn align_of<T>() -> usize {\n}\n\n/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n///\n/// Every reference to a value of the type `T` must be a multiple of this number.\n///\n/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// assert_eq!(4, mem::align_of_val(&5i32));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\npub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n}\n\n/// Returns `true` if dropping values of type `T` matters.\n///\n/// This is purely an optimization hint, and may be implemented conservatively:\n/// it may return `true` for types that don't actually need to be dropped.\n/// As such always returning `true` would be a valid implementation of\n/// this function. However if this function actually returns `false`, then you\n/// can be certain dropping `T` has no side effect.\n///\n/// Low level implementations of things like collections, which need to manually\n/// drop their data, should use this function to avoid unnecessarily\n/// trying to drop all their contents when they are destroyed. This might not\n/// make a difference in release builds (where a loop that has no side-effects\n/// is easily detected and eliminated), but is often a big win for debug builds.\n///\n/// Note that [`drop_in_place`] already performs this check, so if your workload\n/// can be reduced to some small number of [`drop_in_place`] calls, using this is\n/// unnecessary. In particular note that you can [`drop_in_place`] a slice, and that\n/// will do a single needs_drop check for all the values.\n///\n/// Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n/// `needs_drop` explicitly. Types like [`HashMap`], on the other hand, have to drop\n/// values one at a time and should use this API.\n///\n/// [`drop_in_place`]: ../ptr/fn.drop_in_place.html\n/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n///\n/// # Examples\n///\n/// Here's an example of how a collection might make use of `needs_drop`:\n///\n/// ```\n/// use std::{mem, ptr};\n///\n/// pub struct MyCollection<T> {\n/// #   data: [T; 1],\n///     /* ... */\n/// }\n/// # impl<T> MyCollection<T> {\n/// #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n/// #   fn free_buffer(&mut self) {}\n/// # }\n///\n/// impl<T> Drop for MyCollection<T> {\n///     fn drop(&mut self) {\n///         unsafe {\n///             // drop the data\n///             if mem::needs_drop::<T>() {\n///                 for x in self.iter_mut() {\n///                     ptr::drop_in_place(x);\n///                 }\n///             }\n///             self.free_buffer();\n///         }\n///     }\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"needs_drop\", since = \"1.21.0\")]\n#[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.36.0\")]\npub const fn needs_drop<T>() -> bool {\n}\n\n/// Returns the value of type `T` represented by the all-zero byte-pattern.\n///\n/// This means that, for example, the padding byte in `(u8, u16)` is not\n/// necessarily zeroed.\n///\n/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n/// some type `T`. For example, the all-zero byte-pattern is not a valid value\n/// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n/// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n/// that there always is a valid value in a variable it considers initialized.\n///\n/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n/// It is useful for FFI sometimes, but should generally be avoided.\n///\n/// [zeroed]: union.MaybeUninit.html#method.zeroed\n/// [ub]: ../../reference/behavior-considered-undefined.html\n/// [inv]: union.MaybeUninit.html#initialization-invariant\n///\n/// # Examples\n///\n/// Correct usage of this function: initializing an integer with zero.\n///\n/// ```\n/// use std::mem;\n///\n/// let x: i32 = unsafe { mem::zeroed() };\n/// assert_eq!(0, x);\n/// ```\n///\n/// *Incorrect* usage of this function: initializing a reference with zero.\n///\n/// ```rust,no_run\n/// # #![allow(invalid_value)]\n/// use std::mem;\n///\n/// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated_in_future)]\n#[allow(deprecated)]\n#[rustc_diagnostic_item = \"mem_zeroed\"]\npub unsafe fn zeroed<T>() -> T {\n}\n\n/// Bypasses Rust's normal memory-initialization checks by pretending to\n/// produce a value of type `T`, while doing nothing at all.\n///\n/// **This function is deprecated.** Use [`MaybeUninit<T>`] instead.\n///\n/// The reason for deprecation is that the function basically cannot be used\n/// correctly: it has the same effect as [`MaybeUninit::uninit().assume_init()`][uninit].\n/// As the [`assume_init` documentation][assume_init] explains,\n/// [the Rust compiler assumes][inv] that values are properly initialized.\n/// As a consequence, calling e.g. `mem::uninitialized::<bool>()` causes immediate\n/// undefined behavior for returning a `bool` that is not definitely either `true`\n/// or `false`. Worse, truly uninitialized memory like what gets returned here\n/// is special in that the compiler knows that it does not have a fixed value.\n/// This makes it undefined behavior to have uninitialized data in a variable even\n/// if that variable has an integer type.\n/// (Notice that the rules around uninitialized integers are not finalized yet, but\n/// until they are, it is advisable to avoid them.)\n///\n/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n/// [uninit]: union.MaybeUninit.html#method.uninit\n/// [assume_init]: union.MaybeUninit.html#method.assume_init\n/// [inv]: union.MaybeUninit.html#initialization-invariant\n#[inline]\n#[rustc_deprecated(since = \"1.39.0\", reason = \"use `mem::MaybeUninit` instead\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated_in_future)]\n#[allow(deprecated)]\n#[rustc_diagnostic_item = \"mem_uninitialized\"]\npub unsafe fn uninitialized<T>() -> T {\n}\n\n/// Swaps the values at two mutable locations, without deinitializing either one.\n///\n/// # Examples\n///\n/// ```\n/// use std::mem;\n///\n/// let mut x = 5;\n/// let mut y = 42;\n///\n/// mem::swap(&mut x, &mut y);\n///\n/// assert_eq!(42, x);\n/// assert_eq!(5, y);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn swap<T>(x: &mut T, y: &mut T) {\n}\n\n/// Replaces `dest` with the default value of `T`, returning the previous `dest` value.\n///\n/// # Examples\n///\n/// A simple example:\n///\n/// ```\n/// use std::mem;\n///\n/// let mut v: Vec<i32> = vec![1, 2];\n///\n/// let old_v = mem::take(&mut v);\n/// assert_eq!(vec![1, 2], old_v);\n/// assert!(v.is_empty());\n/// ```\n///\n/// `take` allows taking ownership of a struct field by replacing it with an \"empty\" value.\n/// Without `take` you can run into issues like these:\n///\n/// ```compile_fail,E0507\n/// struct Buffer<T> { buf: Vec<T> }\n///\n/// impl<T> Buffer<T> {\n///     fn get_and_reset(&mut self) -> Vec<T> {\n///         // error: cannot move out of dereference of `&mut`-pointer\n///         let buf = self.buf;\n///         self.buf = Vec::new();\n///         buf\n///     }\n/// }\n/// ```\n///\n/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n/// `self.buf`. But `take` can be used to disassociate the original value of `self.buf` from\n/// `self`, allowing it to be returned:\n///\n/// ```\n/// use std::mem;\n///\n/// # struct Buffer<T> { buf: Vec<T> }\n/// impl<T> Buffer<T> {\n///     fn get_and_reset(&mut self) -> Vec<T> {\n///         mem::take(&mut self.buf)\n///     }\n/// }\n///\n/// let mut buffer = Buffer { buf: vec![0, 1] };\n/// assert_eq!(buffer.buf.len(), 2);\n///\n/// assert_eq!(buffer.get_and_reset(), vec![0, 1]);\n/// assert_eq!(buffer.buf.len(), 0);\n/// ```\n///\n/// [`Clone`]: ../../std/clone/trait.Clone.html\n#[inline]\n#[stable(feature = \"mem_take\", since = \"1.40.0\")]\npub fn take<T: Default>(dest: &mut T) -> T {\n}\n\n/// Moves `src` into the referenced `dest`, returning the previous `dest` value.\n///\n/// Neither value is dropped.\n///\n/// # Examples\n///\n/// A simple example:\n///\n/// ```\n/// use std::mem;\n///\n/// let mut v: Vec<i32> = vec![1, 2];\n///\n/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n/// assert_eq!(vec![1, 2], old_v);\n/// assert_eq!(vec![3, 4, 5], v);\n/// ```\n///\n/// `replace` allows consumption of a struct field by replacing it with another value.\n/// Without `replace` you can run into issues like these:\n///\n/// ```compile_fail,E0507\n/// struct Buffer<T> { buf: Vec<T> }\n///\n/// impl<T> Buffer<T> {\n///     fn replace_index(&mut self, i: usize, v: T) -> T {\n///         // error: cannot move out of dereference of `&mut`-pointer\n///         let t = self.buf[i];\n///         self.buf[i] = v;\n///         t\n///     }\n/// }\n/// ```\n///\n/// Note that `T` does not necessarily implement [`Clone`], so we can't even clone `self.buf[i]` to\n/// avoid the move. But `replace` can be used to disassociate the original value at that index from\n/// `self`, allowing it to be returned:\n///\n/// ```\n/// # #![allow(dead_code)]\n/// use std::mem;\n///\n/// # struct Buffer<T> { buf: Vec<T> }\n/// impl<T> Buffer<T> {\n///     fn replace_index(&mut self, i: usize, v: T) -> T {\n///         mem::replace(&mut self.buf[i], v)\n///     }\n/// }\n///\n/// let mut buffer = Buffer { buf: vec![0, 1] };\n/// assert_eq!(buffer.buf[0], 0);\n///\n/// assert_eq!(buffer.replace_index(0, 2), 0);\n/// assert_eq!(buffer.buf[0], 2);\n/// ```\n///\n/// [`Clone`]: ../../std/clone/trait.Clone.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn replace<T>(dest: &mut T, mut src: T) -> T {\n}\n\n/// Disposes of a value.\n///\n/// This does call the argument's implementation of [`Drop`][drop].\n///\n/// This effectively does nothing for types which implement `Copy`, e.g.\n/// integers. Such values are copied and _then_ moved into the function, so the\n/// value persists after this function call.\n///\n/// This function is not magic; it is literally defined as\n///\n/// ```\n/// pub fn drop<T>(_x: T) { }\n/// ```\n///\n/// Because `_x` is moved into the function, it is automatically dropped before\n/// the function returns.\n///\n/// [drop]: ../ops/trait.Drop.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let v = vec![1, 2, 3];\n///\n/// drop(v); // explicitly drop the vector\n/// ```\n///\n/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n/// release a [`RefCell`] borrow:\n///\n/// ```\n/// use std::cell::RefCell;\n///\n/// let x = RefCell::new(1);\n///\n/// let mut mutable_borrow = x.borrow_mut();\n/// *mutable_borrow = 1;\n///\n/// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n///\n/// let borrow = x.borrow();\n/// println!(\"{}\", *borrow);\n/// ```\n///\n/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n///\n/// ```\n/// #[derive(Copy, Clone)]\n/// struct Foo(u8);\n///\n/// let x = 1;\n/// let y = Foo(2);\n/// drop(x); // a copy of `x` is moved and dropped\n/// drop(y); // a copy of `y` is moved and dropped\n///\n/// println!(\"x: {}, y: {}\", x, y.0); // still available\n/// ```\n///\n/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n/// [`Copy`]: ../../std/marker/trait.Copy.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn drop<T>(_x: T) {}}\npub mod ptr {\n//! Manually manage memory through raw pointers.\n//!\n//! *[See also the pointer primitive types](../../std/primitive.pointer.html).*\n//!\n//! # Safety\n//!\n//! Many functions in this module take raw pointers as arguments and read from\n//! or write to them. For this to be safe, these pointers must be *valid*.\n//! Whether a pointer is valid depends on the operation it is used for\n//! (read or write), and the extent of the memory that is accessed (i.e.,\n//! how many bytes are read/written). Most functions use `*mut T` and `*const T`\n//! to access only a single value, in which case the documentation omits the size\n//! and implicitly assumes it to be `size_of::<T>()` bytes.\n//!\n//! The precise rules for validity are not determined yet. The guarantees that are\n//! provided at this point are very minimal:\n//!\n//! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n//! * All pointers (except for the null pointer) are valid for all operations of\n//!   [size zero][zst].\n//! * For a pointer to be valid, it is necessary, but not always sufficient, that the pointer\n//!   be *dereferencable*: the memory range of the given size starting at the pointer must all be\n//!   within the bounds of a single allocated object. Note that in Rust,\n//!   every (stack-allocated) variable is considered a separate allocated object.\n//! * All accesses performed by functions in this module are *non-atomic* in the sense\n//!   of [atomic operations] used to synchronize between threads. This means it is\n//!   undefined behavior to perform two concurrent accesses to the same location from different\n//!   threads unless both accesses only read from memory. Notice that this explicitly\n//!   includes [`read_volatile`] and [`write_volatile`]: Volatile accesses cannot\n//!   be used for inter-thread synchronization.\n//! * The result of casting a reference to a pointer is valid for as long as the\n//!   underlying object is live and no reference (just raw pointers) is used to\n//!   access the same memory.\n//!\n//! These axioms, along with careful use of [`offset`] for pointer arithmetic,\n//! are enough to correctly implement many useful things in unsafe code. Stronger guarantees\n//! will be provided eventually, as the [aliasing] rules are being determined. For more\n//! information, see the [book] as well as the section in the reference devoted\n//! to [undefined behavior][ub].\n//!\n//! ## Alignment\n//!\n//! Valid raw pointers as defined above are not necessarily properly aligned (where\n//! \"proper\" alignment is defined by the pointee type, i.e., `*const T` must be\n//! aligned to `mem::align_of::<T>()`). However, most functions require their\n//! arguments to be properly aligned, and will explicitly state\n//! this requirement in their documentation. Notable exceptions to this are\n//! [`read_unaligned`] and [`write_unaligned`].\n//!\n//! When a function requires proper alignment, it does so even if the access\n//! has size 0, i.e., even if memory is not actually touched. Consider using\n//! [`NonNull::dangling`] in such cases.\n//!\n//! [aliasing]: ../../nomicon/aliasing.html\n//! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n//! [ub]: ../../reference/behavior-considered-undefined.html\n//! [null]: ./fn.null.html\n//! [zst]: ../../nomicon/exotic-sizes.html#zero-sized-types-zsts\n//! [atomic operations]: ../../std/sync/atomic/index.html\n//! [`copy`]: ../../std/ptr/fn.copy.html\n//! [`offset`]: ../../std/primitive.pointer.html#method.offset\n//! [`read_unaligned`]: ./fn.read_unaligned.html\n//! [`write_unaligned`]: ./fn.write_unaligned.html\n//! [`read_volatile`]: ./fn.read_volatile.html\n//! [`write_volatile`]: ./fn.write_volatile.html\n//! [`NonNull::dangling`]: ./struct.NonNull.html#method.dangling\n\n// ignore-tidy-undocumented-unsafe\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::cmp::Ordering;\nuse crate::fmt;\nuse crate::hash;\nuse crate::intrinsics;\nuse crate::mem::{self, MaybeUninit};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use crate::intrinsics::copy_nonoverlapping;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use crate::intrinsics::copy;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use crate::intrinsics::write_bytes;\n\nmod non_null {\nuse crate::cmp::Ordering;\nuse crate::convert::From;\nuse crate::fmt;\nuse crate::hash;\nuse crate::marker::Unsize;\nuse crate::mem;\nuse crate::ops::{CoerceUnsized, DispatchFromDyn};\nuse crate::ptr::Unique;\n\n// ignore-tidy-undocumented-unsafe\n\n/// `*mut T` but non-zero and covariant.\n///\n/// This is often the correct thing to use when building data structures using\n/// raw pointers, but is ultimately more dangerous to use because of its additional\n/// properties. If you're not sure if you should use `NonNull<T>`, just use `*mut T`!\n///\n/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n/// is never dereferenced. This is so that enums may use this forbidden value\n/// as a discriminant -- `Option<NonNull<T>>` has the same size as `*mut T`.\n/// However the pointer may still dangle if it isn't dereferenced.\n///\n/// Unlike `*mut T`, `NonNull<T>` is covariant over `T`. If this is incorrect\n/// for your use case, you should include some [`PhantomData`] in your type to\n/// provide invariance, such as `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n/// Usually this won't be necessary; covariance is correct for most safe abstractions,\n/// such as `Box`, `Rc`, `Arc`, `Vec`, and `LinkedList`. This is the case because they\n/// provide a public API that follows the normal shared XOR mutable rules of Rust.\n///\n/// Notice that `NonNull<T>` has a `From` instance for `&T`. However, this does\n/// not change the fact that mutating through a (pointer derived from a) shared\n/// reference is undefined behavior unless the mutation happens inside an\n/// [`UnsafeCell<T>`]. The same goes for creating a mutable reference from a shared\n/// reference. When using this `From` instance without an `UnsafeCell<T>`,\n/// it is your responsibility to ensure that `as_mut` is never called, and `as_ptr`\n/// is never used for mutation.\n///\n/// [`PhantomData`]: ../marker/struct.PhantomData.html\n/// [`UnsafeCell<T>`]: ../cell/struct.UnsafeCell.html\n#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n#[repr(transparent)]\n#[rustc_layout_scalar_valid_range_start(1)]\n#[rustc_nonnull_optimization_guaranteed]\npub struct NonNull<T: ?Sized> {\n    pointer: *const T,\n}\n\n/// `NonNull` pointers are not `Send` because the data they reference may be aliased.\n// N.B., this impl is unnecessary, but should provide better error messages.\n#[stable(feature = \"nonnull\", since = \"1.25.0\")]\nimpl<T: ?Sized> !Send for NonNull<T> {}\n\n/// `NonNull` pointers are not `Sync` because the data they reference may be aliased.\n// N.B., this impl is unnecessary, but should provide better error messages.\n#[stable(feature = \"nonnull\", since = \"1.25.0\")]\nimpl<T: ?Sized> !Sync for NonNull<T> {}\n\nimpl<T: Sized> NonNull<T> {\n    /// Creates a new `NonNull` that is dangling, but well-aligned.\n    ///\n    /// This is useful for initializing types which lazily allocate, like\n    /// `Vec::new` does.\n    ///\n    /// Note that the pointer value may potentially represent a valid pointer to\n    /// a `T`, which means this must not be used as a \"not yet initialized\"\n    /// sentinel value. Types that lazily allocate must track initialization by\n    /// some other means.\n    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n    #[rustc_const_stable(feature = \"const_nonnull_dangling\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn dangling() -> Self {\n}\n}\n\nimpl<T: ?Sized> NonNull<T> {\n    /// Creates a new `NonNull`.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n    #[rustc_const_stable(feature = \"const_nonnull_new_unchecked\", since = \"1.32.0\")]\n    #[inline]\n    pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n}\n\n    /// Creates a new `NonNull` if `ptr` is non-null.\n    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n    #[inline]\n    pub fn new(ptr: *mut T) -> Option<Self> {\n}\n\n    /// Acquires the underlying `*mut` pointer.\n    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n    #[rustc_const_stable(feature = \"const_nonnull_as_ptr\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn as_ptr(self) -> *mut T {\n}\n\n    /// Dereferences the content.\n    ///\n    /// The resulting lifetime is bound to self so this behaves \"as if\"\n    /// it were actually an instance of T that is getting borrowed. If a longer\n    /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n    #[inline]\n    pub unsafe fn as_ref(&self) -> &T {\n}\n\n    /// Mutably dereferences the content.\n    ///\n    /// The resulting lifetime is bound to self so this behaves \"as if\"\n    /// it were actually an instance of T that is getting borrowed. If a longer\n    /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n    #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n    #[inline]\n    pub unsafe fn as_mut(&mut self) -> &mut T {\n}\n\n    /// Casts to a pointer of another type.\n    #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n    #[rustc_const_stable(feature = \"const_nonnull_cast\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn cast<U>(self) -> NonNull<U> {\n}\n}\n\n#[stable(feature = \"nonnull\", since = \"1.25.0\")]\nimpl<T: ?Sized> Clone for NonNull<T> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"nonnull\", since = \"1.25.0\")]\nimpl<T: ?Sized> Copy for NonNull<T> {}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> {}}\n#[stable(feature = \"nonnull\", since = \"1.25.0\")]\npub use non_null::NonNull;\n\nmod unique {\nuse crate::convert::From;\nuse crate::fmt;\nuse crate::marker::{PhantomData, Unsize};\nuse crate::mem;\nuse crate::ops::{CoerceUnsized, DispatchFromDyn};\nuse crate::ptr::NonNull;\n\n// ignore-tidy-undocumented-unsafe\n\n/// A wrapper around a raw non-null `*mut T` that indicates that the possessor\n/// of this wrapper owns the referent. Useful for building abstractions like\n/// `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n///\n/// Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n/// It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n/// the kind of strong aliasing guarantees an instance of `T` can expect:\n/// the referent of the pointer should not be modified without a unique path to\n/// its owning Unique.\n///\n/// If you're uncertain of whether it's correct to use `Unique` for your purposes,\n/// consider using `NonNull`, which has weaker semantics.\n///\n/// Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n/// is never dereferenced. This is so that enums may use this forbidden value\n/// as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n/// However the pointer may still dangle if it isn't dereferenced.\n///\n/// Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n/// for any type which upholds Unique's aliasing requirements.\n#[unstable(\n    feature = \"ptr_internals\",\n    issue = \"none\",\n    reason = \"use `NonNull` instead and consider `PhantomData<T>` \\\n              (if you also use `#[may_dangle]`), `Send`, and/or `Sync`\"\n)]\n#[doc(hidden)]\n#[repr(transparent)]\n#[rustc_layout_scalar_valid_range_start(1)]\npub struct Unique<T: ?Sized> {\n    pointer: *const T,\n    // NOTE: this marker has no consequences for variance, but is necessary\n    // for dropck to understand that we logically own a `T`.\n    //\n    // For details, see:\n    // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data\n    _marker: PhantomData<T>,\n}\n\n/// `Unique` pointers are `Send` if `T` is `Send` because the data they\n/// reference is unaliased. Note that this aliasing invariant is\n/// unenforced by the type system; the abstraction using the\n/// `Unique` must enforce it.\n#[unstable(feature = \"ptr_internals\", issue = \"none\")]\nunsafe impl<T: Send + ?Sized> Send for Unique<T> {}}\n#[unstable(feature = \"ptr_internals\", issue = \"none\")]\npub use unique::Unique;\n\nmod const_ptr {\nuse super::*;\nuse crate::cmp::Ordering::{self, Equal, Greater, Less};\nuse crate::intrinsics;\nuse crate::mem;\n\n// ignore-tidy-undocumented-unsafe\n\n#[lang = \"const_ptr\"]\nimpl<T: ?Sized> *const T {\n    /// Returns `true` if the pointer is null.\n    ///\n    /// Note that unsized types have many possible null pointers, as only the\n    /// raw data pointer is considered, not their length, vtable, etc.\n    /// Therefore, two pointers that are null may still not compare equal to\n    /// each other.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s: &str = \"Follow the rabbit\";\n    /// let ptr: *const u8 = s.as_ptr();\n    /// assert!(!ptr.is_null());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_null(self) -> bool {\n}\n\n    /// Casts to a pointer of another type.\n    #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n    #[rustc_const_stable(feature = \"const_ptr_cast\", since = \"1.38.0\")]\n    #[inline]\n    pub const fn cast<U>(self) -> *const U {\n}\n\n    /// Returns `None` if the pointer is null, or else returns a reference to\n    /// the value wrapped in `Some`.\n    ///\n    /// # Safety\n    ///\n    /// While this method and its mutable counterpart are useful for\n    /// null-safety, it is important to note that this is still an unsafe\n    /// operation because the returned value could be pointing to invalid\n    /// memory.\n    ///\n    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n    /// all of the following is true:\n    /// - it is properly aligned\n    /// - it must point to an initialized instance of T; in particular, the pointer must be\n    ///   \"dereferencable\" in the sense defined [here].\n    ///\n    /// This applies even if the result of this method is unused!\n    /// (The part about being initialized is not yet fully decided, but until\n    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n    ///\n    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n    /// the memory the pointer points to must not get mutated (except inside `UnsafeCell`).\n    ///\n    /// [here]: crate::ptr#safety\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let ptr: *const u8 = &10u8 as *const u8;\n    ///\n    /// unsafe {\n    ///     if let Some(val_back) = ptr.as_ref() {\n    ///         println!(\"We got back the value: {}!\", val_back);\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// # Null-unchecked version\n    ///\n    /// If you are sure the pointer can never be null and are looking for some kind of\n    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can\n    /// dereference the pointer directly.\n    ///\n    /// ```\n    /// let ptr: *const u8 = &10u8 as *const u8;\n    ///\n    /// unsafe {\n    ///     let val_back = &*ptr;\n    ///     println!(\"We got back the value: {}!\", val_back);\n    /// }\n    /// ```\n    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n    #[inline]\n    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n}\n\n    /// Calculates the offset from a pointer.\n    ///\n    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and resulting pointer must be either in bounds or one\n    ///   byte past the end of the same allocated object. Note that in Rust,\n    ///   every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n    ///\n    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n    ///   space. That is, the infinite-precision sum, **in bytes** must fit in a usize.\n    ///\n    /// The compiler and standard library generally tries to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `vec.as_ptr().add(vec.len())` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using [`wrapping_offset`] instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// [`wrapping_offset`]: #method.wrapping_offset\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s: &str = \"123\";\n    /// let ptr: *const u8 = s.as_ptr();\n    ///\n    /// unsafe {\n    ///     println!(\"{}\", *ptr.offset(1) as char);\n    ///     println!(\"{}\", *ptr.offset(2) as char);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn offset(self, count: isize) -> *const T\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    ///\n    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// In particular, the resulting pointer remains attached to the same allocated\n    /// object that `self` points to. It may *not* be used to access a\n    /// different allocated object. Note that in Rust,\n    /// every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// In other words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n    /// *not* the same as `y`, and dereferencing it is undefined behavior\n    /// unless `x` and `y` point into the same allocated object.\n    ///\n    /// Compared to [`offset`], this method basically delays the requirement of staying\n    /// within the same allocated object: [`offset`] is immediate Undefined Behavior when\n    /// crossing object boundaries; `wrapping_offset` produces a pointer but still leads\n    /// to Undefined Behavior if that pointer is dereferenced. [`offset`] can be optimized\n    /// better and is thus preferrable in performance-sensitive code.\n    ///\n    /// If you need to cross object boundaries, cast the pointer to an integer and\n    /// do the arithmetic there.\n    ///\n    /// [`offset`]: #method.offset\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // Iterate using a raw pointer in increments of two elements\n    /// let data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *const u8 = data.as_ptr();\n    /// let step = 2;\n    /// let end_rounded_up = ptr.wrapping_offset(6);\n    ///\n    /// // This loop prints \"1, 3, 5, \"\n    /// while ptr != end_rounded_up {\n    ///     unsafe {\n    ///         print!(\"{}, \", *ptr);\n    ///     }\n    ///     ptr = ptr.wrapping_offset(step);\n    /// }\n    /// ```\n    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n    #[inline]\n    pub fn wrapping_offset(self, count: isize) -> *const T\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the distance between two pointers. The returned value is in\n    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n    ///\n    /// This function is the inverse of [`offset`].\n    ///\n    /// [`offset`]: #method.offset\n    /// [`wrapping_offset_from`]: #method.wrapping_offset_from\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and other pointer must be either in bounds or one\n    ///   byte past the end of the same allocated object. Note that in Rust,\n    ///   every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n    ///\n    /// * The distance between the pointers, in bytes, must be an exact multiple\n    ///   of the size of `T`.\n    ///\n    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n    ///\n    /// The compiler and standard library generally try to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(ptr_offset_from)]\n    ///\n    /// let a = [0; 5];\n    /// let ptr1: *const i32 = &a[1];\n    /// let ptr2: *const i32 = &a[3];\n    /// unsafe {\n    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n    ///     assert_eq!(ptr1.offset(2), ptr2);\n    ///     assert_eq!(ptr2.offset(-2), ptr1);\n    /// }\n    /// ```\n    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n    #[inline]\n    pub const unsafe fn offset_from(self, origin: *const T) -> isize\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the distance between two pointers. The returned value is in\n    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n    ///\n    /// If the address different between the two pointers is not a multiple of\n    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n    /// zero.\n    ///\n    /// Though this method is safe for any two pointers, note that its result\n    /// will be mostly useless if the two pointers aren't into the same allocated\n    /// object, for example if they point to two different local variables.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if `T` is a zero-sized type.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(ptr_wrapping_offset_from)]\n    ///\n    /// let a = [0; 5];\n    /// let ptr1: *const i32 = &a[1];\n    /// let ptr2: *const i32 = &a[3];\n    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n    ///\n    /// let ptr1: *const i32 = 3 as _;\n    /// let ptr2: *const i32 = 13 as _;\n    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n    /// ```\n    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n    #[inline]\n    pub fn wrapping_offset_from(self, origin: *const T) -> isize\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n    ///\n    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and resulting pointer must be either in bounds or one\n    ///   byte past the end of the same allocated object. Note that in Rust,\n    ///   every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n    ///\n    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n    ///   space. That is, the infinite-precision sum must fit in a `usize`.\n    ///\n    /// The compiler and standard library generally tries to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `vec.as_ptr().add(vec.len())` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using [`wrapping_add`] instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// [`wrapping_add`]: #method.wrapping_add\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s: &str = \"123\";\n    /// let ptr: *const u8 = s.as_ptr();\n    ///\n    /// unsafe {\n    ///     println!(\"{}\", *ptr.add(1) as char);\n    ///     println!(\"{}\", *ptr.add(2) as char);\n    /// }\n    /// ```\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the offset from a pointer (convenience for\n    /// `.offset((count as isize).wrapping_neg())`).\n    ///\n    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and resulting pointer must be either in bounds or one\n    ///   byte past the end of the same allocated object. Note that in Rust,\n    ///   every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n    ///\n    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n    ///   space. That is, the infinite-precision sum must fit in a usize.\n    ///\n    /// The compiler and standard library generally tries to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `vec.as_ptr().add(vec.len()).sub(vec.len())` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using [`wrapping_sub`] instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// [`wrapping_sub`]: #method.wrapping_sub\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s: &str = \"123\";\n    ///\n    /// unsafe {\n    ///     let end: *const u8 = s.as_ptr().add(3);\n    ///     println!(\"{}\", *end.sub(1) as char);\n    ///     println!(\"{}\", *end.sub(2) as char);\n    /// }\n    /// ```\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn sub(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    /// (convenience for `.wrapping_offset(count as isize)`)\n    ///\n    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// In particular, the resulting pointer remains attached to the same allocated\n    /// object that `self` points to. It may *not* be used to access a\n    /// different allocated object. Note that in Rust,\n    /// every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// Compared to [`add`], this method basically delays the requirement of staying\n    /// within the same allocated object: [`add`] is immediate Undefined Behavior when\n    /// crossing object boundaries; `wrapping_add` produces a pointer but still leads\n    /// to Undefined Behavior if that pointer is dereferenced. [`add`] can be optimized\n    /// better and is thus preferrable in performance-sensitive code.\n    ///\n    /// If you need to cross object boundaries, cast the pointer to an integer and\n    /// do the arithmetic there.\n    ///\n    /// [`add`]: #method.add\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // Iterate using a raw pointer in increments of two elements\n    /// let data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *const u8 = data.as_ptr();\n    /// let step = 2;\n    /// let end_rounded_up = ptr.wrapping_add(6);\n    ///\n    /// // This loop prints \"1, 3, 5, \"\n    /// while ptr != end_rounded_up {\n    ///     unsafe {\n    ///         print!(\"{}, \", *ptr);\n    ///     }\n    ///     ptr = ptr.wrapping_add(step);\n    /// }\n    /// ```\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub fn wrapping_add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    /// (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)\n    ///\n    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// In particular, the resulting pointer remains attached to the same allocated\n    /// object that `self` points to. It may *not* be used to access a\n    /// different allocated object. Note that in Rust,\n    /// every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// Compared to [`sub`], this method basically delays the requirement of staying\n    /// within the same allocated object: [`sub`] is immediate Undefined Behavior when\n    /// crossing object boundaries; `wrapping_sub` produces a pointer but still leads\n    /// to Undefined Behavior if that pointer is dereferenced. [`sub`] can be optimized\n    /// better and is thus preferrable in performance-sensitive code.\n    ///\n    /// If you need to cross object boundaries, cast the pointer to an integer and\n    /// do the arithmetic there.\n    ///\n    /// [`sub`]: #method.sub\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // Iterate using a raw pointer in increments of two elements (backwards)\n    /// let data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *const u8 = data.as_ptr();\n    /// let start_rounded_down = ptr.wrapping_sub(2);\n    /// ptr = ptr.wrapping_add(4);\n    /// let step = 2;\n    /// // This loop prints \"5, 3, 1, \"\n    /// while ptr != start_rounded_down {\n    ///     unsafe {\n    ///         print!(\"{}, \", *ptr);\n    ///     }\n    ///     ptr = ptr.wrapping_sub(step);\n    /// }\n    /// ```\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub fn wrapping_sub(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n}\n\n    /// Reads the value from `self` without moving it. This leaves the\n    /// memory in `self` unchanged.\n    ///\n    /// See [`ptr::read`] for safety concerns and examples.\n    ///\n    /// [`ptr::read`]: ./ptr/fn.read.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn read(self) -> T\n    where\n        T: Sized,\n    {\n}\n\n    /// Performs a volatile read of the value from `self` without moving it. This\n    /// leaves the memory in `self` unchanged.\n    ///\n    /// Volatile operations are intended to act on I/O memory, and are guaranteed\n    /// to not be elided or reordered by the compiler across other volatile\n    /// operations.\n    ///\n    /// See [`ptr::read_volatile`] for safety concerns and examples.\n    ///\n    /// [`ptr::read_volatile`]: ./ptr/fn.read_volatile.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn read_volatile(self) -> T\n    where\n        T: Sized,\n    {\n}\n\n    /// Reads the value from `self` without moving it. This leaves the\n    /// memory in `self` unchanged.\n    ///\n    /// Unlike `read`, the pointer may be unaligned.\n    ///\n    /// See [`ptr::read_unaligned`] for safety concerns and examples.\n    ///\n    /// [`ptr::read_unaligned`]: ./ptr/fn.read_unaligned.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn read_unaligned(self) -> T\n    where\n        T: Sized,\n    {\n}\n\n    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n    /// and destination may overlap.\n    ///\n    /// NOTE: this has the *same* argument order as [`ptr::copy`].\n    ///\n    /// See [`ptr::copy`] for safety concerns and examples.\n    ///\n    /// [`ptr::copy`]: ./ptr/fn.copy.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n    where\n        T: Sized,\n    {\n}\n\n    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n    /// and destination may *not* overlap.\n    ///\n    /// NOTE: this has the *same* argument order as [`ptr::copy_nonoverlapping`].\n    ///\n    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n    ///\n    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n    where\n        T: Sized,\n    {\n}\n\n    /// Computes the offset that needs to be applied to the pointer in order to make it aligned to\n    /// `align`.\n    ///\n    /// If it is not possible to align the pointer, the implementation returns\n    /// `usize::max_value()`. It is permissible for the implementation to *always*\n    /// return `usize::max_value()`. Only your algorithm's performance can depend\n    /// on getting a usable offset here, not its correctness.\n    ///\n    /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n    /// used with the `wrapping_add` method.\n    ///\n    /// There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n    /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n    /// the returned offset is correct in all terms other than alignment.\n    ///\n    /// # Panics\n    ///\n    /// The function panics if `align` is not a power-of-two.\n    ///\n    /// # Examples\n    ///\n    /// Accessing adjacent `u8` as `u16`\n    ///\n    /// ```\n    /// # fn foo(n: usize) {\n    /// # use std::mem::align_of;\n    /// # unsafe {\n    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n    /// let ptr = &x[n] as *const u8;\n    /// let offset = ptr.align_offset(align_of::<u16>());\n    /// if offset < x.len() - n - 1 {\n    ///     let u16_ptr = ptr.add(offset) as *const u16;\n    ///     assert_ne!(*u16_ptr, 500);\n    /// } else {\n    ///     // while the pointer can be aligned via `offset`, it would point\n    ///     // outside the allocation\n    /// }\n    /// # } }\n    /// ```\n    #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n    pub fn align_offset(self, align: usize) -> usize\n    where\n        T: Sized,\n    {\n}\n}\n\n// Equality for pointers\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> PartialEq for *const T {\n    #[inline]\n    fn eq(&self, other: &*const T) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Eq for *const T {}\n\n// Comparison for pointers\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Ord for *const T {\n    #[inline]\n    fn cmp(&self, other: &*const T) -> Ordering {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> PartialOrd for *const T {\n    #[inline]\n    fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n}\n\n    #[inline]\n    fn lt(&self, other: &*const T) -> bool {\n}\n\n    #[inline]\n    fn le(&self, other: &*const T) -> bool {\n}\n\n    #[inline]\n    fn gt(&self, other: &*const T) -> bool {\n}\n\n    #[inline]\n    fn ge(&self, other: &*const T) -> bool {\n}\n}\n}\nmod mut_ptr {\nuse super::*;\nuse crate::cmp::Ordering::{self, Equal, Greater, Less};\nuse crate::intrinsics;\n\n// ignore-tidy-undocumented-unsafe\n\n#[lang = \"mut_ptr\"]\nimpl<T: ?Sized> *mut T {\n    /// Returns `true` if the pointer is null.\n    ///\n    /// Note that unsized types have many possible null pointers, as only the\n    /// raw data pointer is considered, not their length, vtable, etc.\n    /// Therefore, two pointers that are null may still not compare equal to\n    /// each other.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = [1, 2, 3];\n    /// let ptr: *mut u32 = s.as_mut_ptr();\n    /// assert!(!ptr.is_null());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_null(self) -> bool {\n}\n\n    /// Casts to a pointer of another type.\n    #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n    #[rustc_const_stable(feature = \"const_ptr_cast\", since = \"1.38.0\")]\n    #[inline]\n    pub const fn cast<U>(self) -> *mut U {\n}\n\n    /// Returns `None` if the pointer is null, or else returns a reference to\n    /// the value wrapped in `Some`.\n    ///\n    /// # Safety\n    ///\n    /// While this method and its mutable counterpart are useful for\n    /// null-safety, it is important to note that this is still an unsafe\n    /// operation because the returned value could be pointing to invalid\n    /// memory.\n    ///\n    /// When calling this method, you have to ensure that if the pointer is\n    /// non-NULL, then it is properly aligned, dereferencable (for the whole\n    /// size of `T`) and points to an initialized instance of `T`. This applies\n    /// even if the result of this method is unused!\n    /// (The part about being initialized is not yet fully decided, but until\n    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n    ///\n    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n    /// not necessarily reflect the actual lifetime of the data. It is up to the\n    /// caller to ensure that for the duration of this lifetime, the memory this\n    /// pointer points to does not get written to outside of `UnsafeCell<U>`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let ptr: *mut u8 = &mut 10u8 as *mut u8;\n    ///\n    /// unsafe {\n    ///     if let Some(val_back) = ptr.as_ref() {\n    ///         println!(\"We got back the value: {}!\", val_back);\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// # Null-unchecked version\n    ///\n    /// If you are sure the pointer can never be null and are looking for some kind of\n    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can\n    /// dereference the pointer directly.\n    ///\n    /// ```\n    /// let ptr: *mut u8 = &mut 10u8 as *mut u8;\n    ///\n    /// unsafe {\n    ///     let val_back = &*ptr;\n    ///     println!(\"We got back the value: {}!\", val_back);\n    /// }\n    /// ```\n    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n    #[inline]\n    pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n}\n\n    /// Calculates the offset from a pointer.\n    ///\n    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and resulting pointer must be either in bounds or one\n    ///   byte past the end of the same allocated object. Note that in Rust,\n    ///   every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n    ///\n    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n    ///   space. That is, the infinite-precision sum, **in bytes** must fit in a usize.\n    ///\n    /// The compiler and standard library generally tries to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `vec.as_ptr().add(vec.len())` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using [`wrapping_offset`] instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// [`wrapping_offset`]: #method.wrapping_offset\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = [1, 2, 3];\n    /// let ptr: *mut u32 = s.as_mut_ptr();\n    ///\n    /// unsafe {\n    ///     println!(\"{}\", *ptr.offset(1));\n    ///     println!(\"{}\", *ptr.offset(2));\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn offset(self, count: isize) -> *mut T\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// In particular, the resulting pointer remains attached to the same allocated\n    /// object that `self` points to. It may *not* be used to access a\n    /// different allocated object. Note that in Rust,\n    /// every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// In other words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n    /// *not* the same as `y`, and dereferencing it is undefined behavior\n    /// unless `x` and `y` point into the same allocated object.\n    ///\n    /// Compared to [`offset`], this method basically delays the requirement of staying\n    /// within the same allocated object: [`offset`] is immediate Undefined Behavior when\n    /// crossing object boundaries; `wrapping_offset` produces a pointer but still leads\n    /// to Undefined Behavior if that pointer is dereferenced. [`offset`] can be optimized\n    /// better and is thus preferrable in performance-sensitive code.\n    ///\n    /// If you need to cross object boundaries, cast the pointer to an integer and\n    /// do the arithmetic there.\n    ///\n    /// [`offset`]: #method.offset\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // Iterate using a raw pointer in increments of two elements\n    /// let mut data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *mut u8 = data.as_mut_ptr();\n    /// let step = 2;\n    /// let end_rounded_up = ptr.wrapping_offset(6);\n    ///\n    /// while ptr != end_rounded_up {\n    ///     unsafe {\n    ///         *ptr = 0;\n    ///     }\n    ///     ptr = ptr.wrapping_offset(step);\n    /// }\n    /// assert_eq!(&data, &[0, 2, 0, 4, 0]);\n    /// ```\n    #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n    #[inline]\n    pub fn wrapping_offset(self, count: isize) -> *mut T\n    where\n        T: Sized,\n    {\n}\n\n    /// Returns `None` if the pointer is null, or else returns a mutable\n    /// reference to the value wrapped in `Some`.\n    ///\n    /// # Safety\n    ///\n    /// As with [`as_ref`], this is unsafe because it cannot verify the validity\n    /// of the returned pointer, nor can it ensure that the lifetime `'a`\n    /// returned is indeed a valid lifetime for the contained data.\n    ///\n    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n    /// all of the following is true:\n    /// - it is properly aligned\n    /// - it must point to an initialized instance of T; in particular, the pointer must be\n    ///   \"dereferencable\" in the sense defined [here].\n    ///\n    /// This applies even if the result of this method is unused!\n    /// (The part about being initialized is not yet fully decided, but until\n    /// it is the only safe approach is to ensure that they are indeed initialized.)\n    ///\n    /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n    /// the memory this pointer points to must not get accessed (read or written)\n    /// through any other pointer.\n    ///\n    /// [here]: crate::ptr#safety\n    /// [`as_ref`]: #method.as_ref\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = [1, 2, 3];\n    /// let ptr: *mut u32 = s.as_mut_ptr();\n    /// let first_value = unsafe { ptr.as_mut().unwrap() };\n    /// *first_value = 4;\n    /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n    /// ```\n    ///\n    /// # Null-unchecked version\n    ///\n    /// If you are sure the pointer can never be null and are looking for some kind of\n    /// `as_mut_unchecked` that returns the `&mut T` instead of `Option<&mut T>`, know that\n    /// you can dereference the pointer directly.\n    ///\n    /// ```\n    /// let mut s = [1, 2, 3];\n    /// let ptr: *mut u32 = s.as_mut_ptr();\n    /// let first_value = unsafe { &mut *ptr };\n    /// *first_value = 4;\n    /// println!(\"{:?}\", s); // It'll print: \"[4, 2, 3]\".\n    /// ```\n    #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n    #[inline]\n    pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n}\n\n    /// Calculates the distance between two pointers. The returned value is in\n    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n    ///\n    /// This function is the inverse of [`offset`].\n    ///\n    /// [`offset`]: #method.offset-1\n    /// [`wrapping_offset_from`]: #method.wrapping_offset_from-1\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and other pointer must be either in bounds or one\n    ///   byte past the end of the same allocated object. Note that in Rust,\n    ///   every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n    ///\n    /// * The distance between the pointers, in bytes, must be an exact multiple\n    ///   of the size of `T`.\n    ///\n    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n    ///\n    /// The compiler and standard library generally try to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(ptr_offset_from)]\n    ///\n    /// let mut a = [0; 5];\n    /// let ptr1: *mut i32 = &mut a[1];\n    /// let ptr2: *mut i32 = &mut a[3];\n    /// unsafe {\n    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n    ///     assert_eq!(ptr1.offset(2), ptr2);\n    ///     assert_eq!(ptr2.offset(-2), ptr1);\n    /// }\n    /// ```\n    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n    #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n    #[inline]\n    pub const unsafe fn offset_from(self, origin: *const T) -> isize\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the distance between two pointers. The returned value is in\n    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n    ///\n    /// If the address different between the two pointers is not a multiple of\n    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n    /// zero.\n    ///\n    /// Though this method is safe for any two pointers, note that its result\n    /// will be mostly useless if the two pointers aren't into the same allocated\n    /// object, for example if they point to two different local variables.\n    ///\n    /// # Panics\n    ///\n    /// This function panics if `T` is a zero-sized type.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(ptr_wrapping_offset_from)]\n    ///\n    /// let mut a = [0; 5];\n    /// let ptr1: *mut i32 = &mut a[1];\n    /// let ptr2: *mut i32 = &mut a[3];\n    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n    ///\n    /// let ptr1: *mut i32 = 3 as _;\n    /// let ptr2: *mut i32 = 13 as _;\n    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n    /// ```\n    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n    #[inline]\n    pub fn wrapping_offset_from(self, origin: *const T) -> isize\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n    ///\n    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and resulting pointer must be either in bounds or one\n    ///   byte past the end of the same allocated object. Note that in Rust,\n    ///   every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// * The computed offset, **in bytes**, cannot overflow an `isize`.\n    ///\n    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n    ///   space. That is, the infinite-precision sum must fit in a `usize`.\n    ///\n    /// The compiler and standard library generally tries to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `vec.as_ptr().add(vec.len())` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using [`wrapping_add`] instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// [`wrapping_add`]: #method.wrapping_add\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s: &str = \"123\";\n    /// let ptr: *const u8 = s.as_ptr();\n    ///\n    /// unsafe {\n    ///     println!(\"{}\", *ptr.add(1) as char);\n    ///     println!(\"{}\", *ptr.add(2) as char);\n    /// }\n    /// ```\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the offset from a pointer (convenience for\n    /// `.offset((count as isize).wrapping_neg())`).\n    ///\n    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// If any of the following conditions are violated, the result is Undefined\n    /// Behavior:\n    ///\n    /// * Both the starting and resulting pointer must be either in bounds or one\n    ///   byte past the end of the same allocated object. Note that in Rust,\n    ///   every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// * The computed offset cannot exceed `isize::MAX` **bytes**.\n    ///\n    /// * The offset being in bounds cannot rely on \"wrapping around\" the address\n    ///   space. That is, the infinite-precision sum must fit in a usize.\n    ///\n    /// The compiler and standard library generally tries to ensure allocations\n    /// never reach a size where an offset is a concern. For instance, `Vec`\n    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n    /// `vec.as_ptr().add(vec.len()).sub(vec.len())` is always safe.\n    ///\n    /// Most platforms fundamentally can't even construct such an allocation.\n    /// For instance, no known 64-bit platform can ever serve a request\n    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n    /// more than `isize::MAX` bytes with things like Physical Address\n    /// Extension. As such, memory acquired directly from allocators or memory\n    /// mapped files *may* be too large to handle with this function.\n    ///\n    /// Consider using [`wrapping_sub`] instead if these constraints are\n    /// difficult to satisfy. The only advantage of this method is that it\n    /// enables more aggressive compiler optimizations.\n    ///\n    /// [`wrapping_sub`]: #method.wrapping_sub\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s: &str = \"123\";\n    ///\n    /// unsafe {\n    ///     let end: *const u8 = s.as_ptr().add(3);\n    ///     println!(\"{}\", *end.sub(1) as char);\n    ///     println!(\"{}\", *end.sub(2) as char);\n    /// }\n    /// ```\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn sub(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    /// (convenience for `.wrapping_offset(count as isize)`)\n    ///\n    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// In particular, the resulting pointer remains attached to the same allocated\n    /// object that `self` points to. It may *not* be used to access a\n    /// different allocated object. Note that in Rust,\n    /// every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// Compared to [`add`], this method basically delays the requirement of staying\n    /// within the same allocated object: [`add`] is immediate Undefined Behavior when\n    /// crossing object boundaries; `wrapping_add` produces a pointer but still leads\n    /// to Undefined Behavior if that pointer is dereferenced. [`add`] can be optimized\n    /// better and is thus preferrable in performance-sensitive code.\n    ///\n    /// If you need to cross object boundaries, cast the pointer to an integer and\n    /// do the arithmetic there.\n    ///\n    /// [`add`]: #method.add\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // Iterate using a raw pointer in increments of two elements\n    /// let data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *const u8 = data.as_ptr();\n    /// let step = 2;\n    /// let end_rounded_up = ptr.wrapping_add(6);\n    ///\n    /// // This loop prints \"1, 3, 5, \"\n    /// while ptr != end_rounded_up {\n    ///     unsafe {\n    ///         print!(\"{}, \", *ptr);\n    ///     }\n    ///     ptr = ptr.wrapping_add(step);\n    /// }\n    /// ```\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub fn wrapping_add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n}\n\n    /// Calculates the offset from a pointer using wrapping arithmetic.\n    /// (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)\n    ///\n    /// `count` is in units of T; e.g., a `count` of 3 represents a pointer\n    /// offset of `3 * size_of::<T>()` bytes.\n    ///\n    /// # Safety\n    ///\n    /// The resulting pointer does not need to be in bounds, but it is\n    /// potentially hazardous to dereference (which requires `unsafe`).\n    ///\n    /// In particular, the resulting pointer remains attached to the same allocated\n    /// object that `self` points to. It may *not* be used to access a\n    /// different allocated object. Note that in Rust,\n    /// every (stack-allocated) variable is considered a separate allocated object.\n    ///\n    /// Compared to [`sub`], this method basically delays the requirement of staying\n    /// within the same allocated object: [`sub`] is immediate Undefined Behavior when\n    /// crossing object boundaries; `wrapping_sub` produces a pointer but still leads\n    /// to Undefined Behavior if that pointer is dereferenced. [`sub`] can be optimized\n    /// better and is thus preferrable in performance-sensitive code.\n    ///\n    /// If you need to cross object boundaries, cast the pointer to an integer and\n    /// do the arithmetic there.\n    ///\n    /// [`sub`]: #method.sub\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // Iterate using a raw pointer in increments of two elements (backwards)\n    /// let data = [1u8, 2, 3, 4, 5];\n    /// let mut ptr: *const u8 = data.as_ptr();\n    /// let start_rounded_down = ptr.wrapping_sub(2);\n    /// ptr = ptr.wrapping_add(4);\n    /// let step = 2;\n    /// // This loop prints \"5, 3, 1, \"\n    /// while ptr != start_rounded_down {\n    ///     unsafe {\n    ///         print!(\"{}, \", *ptr);\n    ///     }\n    ///     ptr = ptr.wrapping_sub(step);\n    /// }\n    /// ```\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub fn wrapping_sub(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n}\n\n    /// Reads the value from `self` without moving it. This leaves the\n    /// memory in `self` unchanged.\n    ///\n    /// See [`ptr::read`] for safety concerns and examples.\n    ///\n    /// [`ptr::read`]: ./ptr/fn.read.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn read(self) -> T\n    where\n        T: Sized,\n    {\n}\n\n    /// Performs a volatile read of the value from `self` without moving it. This\n    /// leaves the memory in `self` unchanged.\n    ///\n    /// Volatile operations are intended to act on I/O memory, and are guaranteed\n    /// to not be elided or reordered by the compiler across other volatile\n    /// operations.\n    ///\n    /// See [`ptr::read_volatile`] for safety concerns and examples.\n    ///\n    /// [`ptr::read_volatile`]: ./ptr/fn.read_volatile.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn read_volatile(self) -> T\n    where\n        T: Sized,\n    {\n}\n\n    /// Reads the value from `self` without moving it. This leaves the\n    /// memory in `self` unchanged.\n    ///\n    /// Unlike `read`, the pointer may be unaligned.\n    ///\n    /// See [`ptr::read_unaligned`] for safety concerns and examples.\n    ///\n    /// [`ptr::read_unaligned`]: ./ptr/fn.read_unaligned.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn read_unaligned(self) -> T\n    where\n        T: Sized,\n    {\n}\n\n    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n    /// and destination may overlap.\n    ///\n    /// NOTE: this has the *same* argument order as [`ptr::copy`].\n    ///\n    /// See [`ptr::copy`] for safety concerns and examples.\n    ///\n    /// [`ptr::copy`]: ./ptr/fn.copy.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn copy_to(self, dest: *mut T, count: usize)\n    where\n        T: Sized,\n    {\n}\n\n    /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n    /// and destination may *not* overlap.\n    ///\n    /// NOTE: this has the *same* argument order as [`ptr::copy_nonoverlapping`].\n    ///\n    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n    ///\n    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn copy_to_nonoverlapping(self, dest: *mut T, count: usize)\n    where\n        T: Sized,\n    {\n}\n\n    /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n    /// and destination may overlap.\n    ///\n    /// NOTE: this has the *opposite* argument order of [`ptr::copy`].\n    ///\n    /// See [`ptr::copy`] for safety concerns and examples.\n    ///\n    /// [`ptr::copy`]: ./ptr/fn.copy.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn copy_from(self, src: *const T, count: usize)\n    where\n        T: Sized,\n    {\n}\n\n    /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n    /// and destination may *not* overlap.\n    ///\n    /// NOTE: this has the *opposite* argument order of [`ptr::copy_nonoverlapping`].\n    ///\n    /// See [`ptr::copy_nonoverlapping`] for safety concerns and examples.\n    ///\n    /// [`ptr::copy_nonoverlapping`]: ./ptr/fn.copy_nonoverlapping.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn copy_from_nonoverlapping(self, src: *const T, count: usize)\n    where\n        T: Sized,\n    {\n}\n\n    /// Executes the destructor (if any) of the pointed-to value.\n    ///\n    /// See [`ptr::drop_in_place`] for safety concerns and examples.\n    ///\n    /// [`ptr::drop_in_place`]: ./ptr/fn.drop_in_place.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn drop_in_place(self) {\n}\n\n    /// Overwrites a memory location with the given value without reading or\n    /// dropping the old value.\n    ///\n    /// See [`ptr::write`] for safety concerns and examples.\n    ///\n    /// [`ptr::write`]: ./ptr/fn.write.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn write(self, val: T)\n    where\n        T: Sized,\n    {\n}\n\n    /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n    /// bytes of memory starting at `self` to `val`.\n    ///\n    /// See [`ptr::write_bytes`] for safety concerns and examples.\n    ///\n    /// [`ptr::write_bytes`]: ./ptr/fn.write_bytes.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn write_bytes(self, val: u8, count: usize)\n    where\n        T: Sized,\n    {\n}\n\n    /// Performs a volatile write of a memory location with the given value without\n    /// reading or dropping the old value.\n    ///\n    /// Volatile operations are intended to act on I/O memory, and are guaranteed\n    /// to not be elided or reordered by the compiler across other volatile\n    /// operations.\n    ///\n    /// See [`ptr::write_volatile`] for safety concerns and examples.\n    ///\n    /// [`ptr::write_volatile`]: ./ptr/fn.write_volatile.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn write_volatile(self, val: T)\n    where\n        T: Sized,\n    {\n}\n\n    /// Overwrites a memory location with the given value without reading or\n    /// dropping the old value.\n    ///\n    /// Unlike `write`, the pointer may be unaligned.\n    ///\n    /// See [`ptr::write_unaligned`] for safety concerns and examples.\n    ///\n    /// [`ptr::write_unaligned`]: ./ptr/fn.write_unaligned.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn write_unaligned(self, val: T)\n    where\n        T: Sized,\n    {\n}\n\n    /// Replaces the value at `self` with `src`, returning the old\n    /// value, without dropping either.\n    ///\n    /// See [`ptr::replace`] for safety concerns and examples.\n    ///\n    /// [`ptr::replace`]: ./ptr/fn.replace.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn replace(self, src: T) -> T\n    where\n        T: Sized,\n    {\n}\n\n    /// Swaps the values at two mutable locations of the same type, without\n    /// deinitializing either. They may overlap, unlike `mem::swap` which is\n    /// otherwise equivalent.\n    ///\n    /// See [`ptr::swap`] for safety concerns and examples.\n    ///\n    /// [`ptr::swap`]: ./ptr/fn.swap.html\n    #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n    #[inline]\n    pub unsafe fn swap(self, with: *mut T)\n    where\n        T: Sized,\n    {\n}\n\n    /// Computes the offset that needs to be applied to the pointer in order to make it aligned to\n    /// `align`.\n    ///\n    /// If it is not possible to align the pointer, the implementation returns\n    /// `usize::max_value()`. It is permissible for the implementation to *always*\n    /// return `usize::max_value()`. Only your algorithm's performance can depend\n    /// on getting a usable offset here, not its correctness.\n    ///\n    /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n    /// used with the `wrapping_add` method.\n    ///\n    /// There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n    /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n    /// the returned offset is correct in all terms other than alignment.\n    ///\n    /// # Panics\n    ///\n    /// The function panics if `align` is not a power-of-two.\n    ///\n    /// # Examples\n    ///\n    /// Accessing adjacent `u8` as `u16`\n    ///\n    /// ```\n    /// # fn foo(n: usize) {\n    /// # use std::mem::align_of;\n    /// # unsafe {\n    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n    /// let ptr = &x[n] as *const u8;\n    /// let offset = ptr.align_offset(align_of::<u16>());\n    /// if offset < x.len() - n - 1 {\n    ///     let u16_ptr = ptr.add(offset) as *const u16;\n    ///     assert_ne!(*u16_ptr, 500);\n    /// } else {\n    ///     // while the pointer can be aligned via `offset`, it would point\n    ///     // outside the allocation\n    /// }\n    /// # } }\n    /// ```\n    #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n    pub fn align_offset(self, align: usize) -> usize\n    where\n        T: Sized,\n    {\n}\n}\n\n// Equality for pointers\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> PartialEq for *mut T {\n    #[inline]\n    fn eq(&self, other: &*mut T) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Eq for *mut T {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Ord for *mut T {\n    #[inline]\n    fn cmp(&self, other: &*mut T) -> Ordering {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> PartialOrd for *mut T {\n    #[inline]\n    fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {\n}\n\n    #[inline]\n    fn lt(&self, other: &*mut T) -> bool {\n}\n\n    #[inline]\n    fn le(&self, other: &*mut T) -> bool {\n}\n\n    #[inline]\n    fn gt(&self, other: &*mut T) -> bool {\n}\n\n    #[inline]\n    fn ge(&self, other: &*mut T) -> bool {\n}\n}\n}\n\n/// Executes the destructor (if any) of the pointed-to value.\n///\n/// This is semantically equivalent to calling [`ptr::read`] and discarding\n/// the result, but has the following advantages:\n///\n/// * It is *required* to use `drop_in_place` to drop unsized types like\n///   trait objects, because they can't be read out onto the stack and\n///   dropped normally.\n///\n/// * It is friendlier to the optimizer to do this over [`ptr::read`] when\n///   dropping manually allocated memory (e.g., when writing Box/Rc/Vec),\n///   as the compiler doesn't need to prove that it's sound to elide the\n///   copy.\n///\n/// Unaligned values cannot be dropped in place, they must be copied to an aligned\n/// location first using [`ptr::read_unaligned`].\n///\n/// [`ptr::read`]: ../ptr/fn.read.html\n/// [`ptr::read_unaligned`]: ../ptr/fn.read_unaligned.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `to_drop` must be [valid] for reads.\n///\n/// * `to_drop` must be properly aligned.\n///\n/// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n/// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n/// foo` counts as a use because it will cause the value to be dropped\n/// again. [`write`] can be used to overwrite data without causing it to be\n/// dropped.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`write`]: ../ptr/fn.write.html\n///\n/// # Examples\n///\n/// Manually remove the last item from a vector:\n///\n/// ```\n/// use std::ptr;\n/// use std::rc::Rc;\n///\n/// let last = Rc::new(1);\n/// let weak = Rc::downgrade(&last);\n///\n/// let mut v = vec![Rc::new(0), last];\n///\n/// unsafe {\n///     // Get a raw pointer to the last element in `v`.\n///     let ptr = &mut v[1] as *mut _;\n///     // Shorten `v` to prevent the last item from being dropped. We do that first,\n///     // to prevent issues if the `drop_in_place` below panics.\n///     v.set_len(1);\n///     // Without a call `drop_in_place`, the last item would never be dropped,\n///     // and the memory it manages would be leaked.\n///     ptr::drop_in_place(ptr);\n/// }\n///\n/// assert_eq!(v, &[0.into()]);\n///\n/// // Ensure that the last item was dropped.\n/// assert!(weak.upgrade().is_none());\n/// ```\n///\n/// Notice that the compiler performs this copy automatically when dropping packed structs,\n/// i.e., you do not usually have to worry about such issues unless you call `drop_in_place`\n/// manually.\n#[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n#[lang = \"drop_in_place\"]\n#[allow(unconditional_recursion)]\npub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n}\n\n/// Creates a null raw pointer.\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let p: *const i32 = ptr::null();\n/// assert!(p.is_null());\n/// ```\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_promotable]\n#[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.32.0\")]\npub const fn null<T>() -> *const T {\n}\n\n/// Creates a null mutable raw pointer.\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let p: *mut i32 = ptr::null_mut();\n/// assert!(p.is_null());\n/// ```\n#[inline(always)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_promotable]\n#[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.32.0\")]\npub const fn null_mut<T>() -> *mut T {\n}\n\n#[repr(C)]\npub(crate) union Repr<T> {\n    pub(crate) rust: *const [T],\n    rust_mut: *mut [T],\n    pub(crate) raw: FatPtr<T>,\n}\n\n#[repr(C)]\npub(crate) struct FatPtr<T> {\n    data: *const T,\n    pub(crate) len: usize,\n}\n\n/// Forms a raw slice from a pointer and a length.\n///\n/// The `len` argument is the number of **elements**, not the number of bytes.\n///\n/// This function is safe, but actually using the return value is unsafe.\n/// See the documentation of [`from_raw_parts`] for slice safety requirements.\n///\n/// [`from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n///\n/// # Examples\n///\n/// ```rust\n/// use std::ptr;\n///\n/// // create a slice pointer when starting out with a pointer to the first element\n/// let x = [5, 6, 7];\n/// let ptr = x.as_ptr();\n/// let slice = ptr::slice_from_raw_parts(ptr, 3);\n/// assert_eq!(unsafe { &*slice }[2], 7);\n/// ```\n#[inline]\n#[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n#[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\npub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n}\n\n/// Performs the same functionality as [`slice_from_raw_parts`], except that a\n/// raw mutable slice is returned, as opposed to a raw immutable slice.\n///\n/// See the documentation of [`slice_from_raw_parts`] for more details.\n///\n/// This function is safe, but actually using the return value is unsafe.\n/// See the documentation of [`from_raw_parts_mut`] for slice safety requirements.\n///\n/// [`slice_from_raw_parts`]: fn.slice_from_raw_parts.html\n/// [`from_raw_parts_mut`]: ../../std/slice/fn.from_raw_parts_mut.html\n#[inline]\n#[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n#[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\npub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n}\n\n/// Swaps the values at two mutable locations of the same type, without\n/// deinitializing either.\n///\n/// But for the following two exceptions, this function is semantically\n/// equivalent to [`mem::swap`]:\n///\n/// * It operates on raw pointers instead of references. When references are\n///   available, [`mem::swap`] should be preferred.\n///\n/// * The two pointed-to values may overlap. If the values do overlap, then the\n///   overlapping region of memory from `x` will be used. This is demonstrated\n///   in the second example below.\n///\n/// [`mem::swap`]: ../mem/fn.swap.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * Both `x` and `y` must be [valid] for reads and writes.\n///\n/// * Both `x` and `y` must be properly aligned.\n///\n/// Note that even if `T` has size `0`, the pointers must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// # Examples\n///\n/// Swapping two non-overlapping regions:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut array = [0, 1, 2, 3];\n///\n/// let x = array[0..].as_mut_ptr() as *mut [u32; 2]; // this is `array[0..2]`\n/// let y = array[2..].as_mut_ptr() as *mut [u32; 2]; // this is `array[2..4]`\n///\n/// unsafe {\n///     ptr::swap(x, y);\n///     assert_eq!([2, 3, 0, 1], array);\n/// }\n/// ```\n///\n/// Swapping two overlapping regions:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut array = [0, 1, 2, 3];\n///\n/// let x = array[0..].as_mut_ptr() as *mut [u32; 3]; // this is `array[0..3]`\n/// let y = array[1..].as_mut_ptr() as *mut [u32; 3]; // this is `array[1..4]`\n///\n/// unsafe {\n///     ptr::swap(x, y);\n///     // The indices `1..3` of the slice overlap between `x` and `y`.\n///     // Reasonable results would be for to them be `[2, 3]`, so that indices `0..3` are\n///     // `[1, 2, 3]` (matching `y` before the `swap`); or for them to be `[0, 1]`\n///     // so that indices `1..4` are `[0, 1, 2]` (matching `x` before the `swap`).\n///     // This implementation is defined to make the latter choice.\n///     assert_eq!([1, 0, 1, 2], array);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n}\n\n/// Swaps `count * size_of::<T>()` bytes between the two regions of memory\n/// beginning at `x` and `y`. The two regions must *not* overlap.\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * Both `x` and `y` must be [valid] for reads and writes of `count *\n///   size_of::<T>()` bytes.\n///\n/// * Both `x` and `y` must be properly aligned.\n///\n/// * The region of memory beginning at `x` with a size of `count *\n///   size_of::<T>()` bytes must *not* overlap with the region of memory\n///   beginning at `y` with the same size.\n///\n/// Note that even if the effectively copied size (`count * size_of::<T>()`) is `0`,\n/// the pointers must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut x = [1, 2, 3, 4];\n/// let mut y = [7, 8, 9];\n///\n/// unsafe {\n///     ptr::swap_nonoverlapping(x.as_mut_ptr(), y.as_mut_ptr(), 2);\n/// }\n///\n/// assert_eq!(x, [7, 8, 3, 4]);\n/// assert_eq!(y, [1, 2, 9]);\n/// ```\n#[inline]\n#[stable(feature = \"swap_nonoverlapping\", since = \"1.27.0\")]\npub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n}\n\n#[inline]\npub(crate) unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n}\n\n#[inline]\nunsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n}\n\n/// Moves `src` into the pointed `dst`, returning the previous `dst` value.\n///\n/// Neither value is dropped.\n///\n/// This function is semantically equivalent to [`mem::replace`] except that it\n/// operates on raw pointers instead of references. When references are\n/// available, [`mem::replace`] should be preferred.\n///\n/// [`mem::replace`]: ../mem/fn.replace.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for writes.\n///\n/// * `dst` must be properly aligned.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut rust = vec!['b', 'u', 's', 't'];\n///\n/// // `mem::replace` would have the same effect without requiring the unsafe\n/// // block.\n/// let b = unsafe {\n///     ptr::replace(&mut rust[0], 'r')\n/// };\n///\n/// assert_eq!(b, 'b');\n/// assert_eq!(rust, &['r', 'u', 's', 't']);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n}\n\n/// Reads the value from `src` without moving it. This leaves the\n/// memory in `src` unchanged.\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads.\n///\n/// * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n///   case.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let x = 12;\n/// let y = &x as *const i32;\n///\n/// unsafe {\n///     assert_eq!(std::ptr::read(y), 12);\n/// }\n/// ```\n///\n/// Manually implement [`mem::swap`]:\n///\n/// ```\n/// use std::ptr;\n///\n/// fn swap<T>(a: &mut T, b: &mut T) {\n///     unsafe {\n///         // Create a bitwise copy of the value at `a` in `tmp`.\n///         let tmp = ptr::read(a);\n///\n///         // Exiting at this point (either by explicitly returning or by\n///         // calling a function which panics) would cause the value in `tmp` to\n///         // be dropped while the same value is still referenced by `a`. This\n///         // could trigger undefined behavior if `T` is not `Copy`.\n///\n///         // Create a bitwise copy of the value at `b` in `a`.\n///         // This is safe because mutable references cannot alias.\n///         ptr::copy_nonoverlapping(b, a, 1);\n///\n///         // As above, exiting here could trigger undefined behavior because\n///         // the same value is referenced by `a` and `b`.\n///\n///         // Move `tmp` into `b`.\n///         ptr::write(b, tmp);\n///\n///         // `tmp` has been moved (`write` takes ownership of its second argument),\n///         // so nothing is dropped implicitly here.\n///     }\n/// }\n///\n/// let mut foo = \"foo\".to_owned();\n/// let mut bar = \"bar\".to_owned();\n///\n/// swap(&mut foo, &mut bar);\n///\n/// assert_eq!(foo, \"bar\");\n/// assert_eq!(bar, \"foo\");\n/// ```\n///\n/// ## Ownership of the Returned Value\n///\n/// `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n/// If `T` is not [`Copy`], using both the returned value and the value at\n/// `*src` can violate memory safety. Note that assigning to `*src` counts as a\n/// use because it will attempt to drop the value at `*src`.\n///\n/// [`write`] can be used to overwrite data without causing it to be dropped.\n///\n/// ```\n/// use std::ptr;\n///\n/// let mut s = String::from(\"foo\");\n/// unsafe {\n///     // `s2` now points to the same underlying memory as `s`.\n///     let mut s2: String = ptr::read(&s);\n///\n///     assert_eq!(s2, \"foo\");\n///\n///     // Assigning to `s2` causes its original value to be dropped. Beyond\n///     // this point, `s` must no longer be used, as the underlying memory has\n///     // been freed.\n///     s2 = String::default();\n///     assert_eq!(s2, \"\");\n///\n///     // Assigning to `s` would cause the old value to be dropped again,\n///     // resulting in undefined behavior.\n///     // s = String::from(\"bar\"); // ERROR\n///\n///     // `ptr::write` can be used to overwrite a value without dropping it.\n///     ptr::write(&mut s, String::from(\"bar\"));\n/// }\n///\n/// assert_eq!(s, \"bar\");\n/// ```\n///\n/// [`mem::swap`]: ../mem/fn.swap.html\n/// [valid]: ../ptr/index.html#safety\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`read_unaligned`]: ./fn.read_unaligned.html\n/// [`write`]: ./fn.write.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn read<T>(src: *const T) -> T {\n}\n\n/// Reads the value from `src` without moving it. This leaves the\n/// memory in `src` unchanged.\n///\n/// Unlike [`read`], `read_unaligned` works with unaligned pointers.\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads.\n///\n/// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n/// value and the value at `*src` can [violate memory safety][read-ownership].\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL.\n///\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`read`]: ./fn.read.html\n/// [`write_unaligned`]: ./fn.write_unaligned.html\n/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n/// [valid]: ../ptr/index.html#safety\n///\n/// ## On `packed` structs\n///\n/// It is currently impossible to create raw pointers to unaligned fields\n/// of a packed struct.\n///\n/// Attempting to create a raw pointer to an `unaligned` struct field with\n/// an expression such as `&packed.unaligned as *const FieldType` creates an\n/// intermediate unaligned reference before converting that to a raw pointer.\n/// That this reference is temporary and immediately cast is inconsequential\n/// as the compiler always expects references to be properly aligned.\n/// As a result, using `&packed.unaligned as *const FieldType` causes immediate\n/// *undefined behavior* in your program.\n///\n/// An example of what not to do and how this relates to `read_unaligned` is:\n///\n/// ```no_run\n/// #[repr(packed, C)]\n/// struct Packed {\n///     _padding: u8,\n///     unaligned: u32,\n/// }\n///\n/// let packed = Packed {\n///     _padding: 0x00,\n///     unaligned: 0x01020304,\n/// };\n///\n/// let v = unsafe {\n///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n///     let unaligned =\n///         // A temporary unaligned reference is created here which results in\n///         // undefined behavior regardless of whether the reference is used or not.\n///         &packed.unaligned\n///         // Casting to a raw pointer doesn't help; the mistake already happened.\n///         as *const u32;\n///\n///     let v = std::ptr::read_unaligned(unaligned);\n///\n///     v\n/// };\n/// ```\n///\n/// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n// FIXME: Update docs based on outcome of RFC #2582 and friends.\n///\n/// # Examples\n///\n/// Read an usize value from a byte buffer:\n///\n/// ```\n/// use std::mem;\n///\n/// fn read_usize(x: &[u8]) -> usize {\n///     assert!(x.len() >= mem::size_of::<usize>());\n///\n///     let ptr = x.as_ptr() as *const usize;\n///\n///     unsafe { ptr.read_unaligned() }\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\npub unsafe fn read_unaligned<T>(src: *const T) -> T {\n}\n\n/// Overwrites a memory location with the given value without reading or\n/// dropping the old value.\n///\n/// `write` does not drop the contents of `dst`. This is safe, but it could leak\n/// allocations or resources, so care should be taken not to overwrite an object\n/// that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// This is appropriate for initializing uninitialized memory, or overwriting\n/// memory that has previously been [`read`] from.\n///\n/// [`read`]: ./fn.read.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for writes.\n///\n/// * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n///   case.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n/// [`write_unaligned`]: ./fn.write_unaligned.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let mut x = 0;\n/// let y = &mut x as *mut i32;\n/// let z = 12;\n///\n/// unsafe {\n///     std::ptr::write(y, z);\n///     assert_eq!(std::ptr::read(y), 12);\n/// }\n/// ```\n///\n/// Manually implement [`mem::swap`]:\n///\n/// ```\n/// use std::ptr;\n///\n/// fn swap<T>(a: &mut T, b: &mut T) {\n///     unsafe {\n///         // Create a bitwise copy of the value at `a` in `tmp`.\n///         let tmp = ptr::read(a);\n///\n///         // Exiting at this point (either by explicitly returning or by\n///         // calling a function which panics) would cause the value in `tmp` to\n///         // be dropped while the same value is still referenced by `a`. This\n///         // could trigger undefined behavior if `T` is not `Copy`.\n///\n///         // Create a bitwise copy of the value at `b` in `a`.\n///         // This is safe because mutable references cannot alias.\n///         ptr::copy_nonoverlapping(b, a, 1);\n///\n///         // As above, exiting here could trigger undefined behavior because\n///         // the same value is referenced by `a` and `b`.\n///\n///         // Move `tmp` into `b`.\n///         ptr::write(b, tmp);\n///\n///         // `tmp` has been moved (`write` takes ownership of its second argument),\n///         // so nothing is dropped implicitly here.\n///     }\n/// }\n///\n/// let mut foo = \"foo\".to_owned();\n/// let mut bar = \"bar\".to_owned();\n///\n/// swap(&mut foo, &mut bar);\n///\n/// assert_eq!(foo, \"bar\");\n/// assert_eq!(bar, \"foo\");\n/// ```\n///\n/// [`mem::swap`]: ../mem/fn.swap.html\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn write<T>(dst: *mut T, src: T) {\n}\n\n/// Overwrites a memory location with the given value without reading or\n/// dropping the old value.\n///\n/// Unlike [`write`], the pointer may be unaligned.\n///\n/// `write_unaligned` does not drop the contents of `dst`. This is safe, but it\n/// could leak allocations or resources, so care should be taken not to overwrite\n/// an object that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// This is appropriate for initializing uninitialized memory, or overwriting\n/// memory that has previously been read with [`read_unaligned`].\n///\n/// [`write`]: ./fn.write.html\n/// [`read_unaligned`]: ./fn.read_unaligned.html\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for writes.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// ## On `packed` structs\n///\n/// It is currently impossible to create raw pointers to unaligned fields\n/// of a packed struct.\n///\n/// Attempting to create a raw pointer to an `unaligned` struct field with\n/// an expression such as `&packed.unaligned as *const FieldType` creates an\n/// intermediate unaligned reference before converting that to a raw pointer.\n/// That this reference is temporary and immediately cast is inconsequential\n/// as the compiler always expects references to be properly aligned.\n/// As a result, using `&packed.unaligned as *const FieldType` causes immediate\n/// *undefined behavior* in your program.\n///\n/// An example of what not to do and how this relates to `write_unaligned` is:\n///\n/// ```no_run\n/// #[repr(packed, C)]\n/// struct Packed {\n///     _padding: u8,\n///     unaligned: u32,\n/// }\n///\n/// let v = 0x01020304;\n/// let mut packed: Packed = unsafe { std::mem::zeroed() };\n///\n/// let v = unsafe {\n///     // Here we attempt to take the address of a 32-bit integer which is not aligned.\n///     let unaligned =\n///         // A temporary unaligned reference is created here which results in\n///         // undefined behavior regardless of whether the reference is used or not.\n///         &mut packed.unaligned\n///         // Casting to a raw pointer doesn't help; the mistake already happened.\n///         as *mut u32;\n///\n///     std::ptr::write_unaligned(unaligned, v);\n///\n///     v\n/// };\n/// ```\n///\n/// Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n// FIXME: Update docs based on outcome of RFC #2582 and friends.\n///\n/// # Examples\n///\n/// Write an usize value to a byte buffer:\n///\n/// ```\n/// use std::mem;\n///\n/// fn write_usize(x: &mut [u8], val: usize) {\n///     assert!(x.len() >= mem::size_of::<usize>());\n///\n///     let ptr = x.as_mut_ptr() as *mut usize;\n///\n///     unsafe { ptr.write_unaligned(val) }\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\npub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n}\n\n/// Performs a volatile read of the value from `src` without moving it. This\n/// leaves the memory in `src` unchanged.\n///\n/// Volatile operations are intended to act on I/O memory, and are guaranteed\n/// to not be elided or reordered by the compiler across other volatile\n/// operations.\n///\n/// [`write_volatile`]: ./fn.write_volatile.html\n///\n/// # Notes\n///\n/// Rust does not currently have a rigorously and formally defined memory model,\n/// so the precise semantics of what \"volatile\" means here is subject to change\n/// over time. That being said, the semantics will almost always end up pretty\n/// similar to [C11's definition of volatile][c11].\n///\n/// The compiler shouldn't change the relative order or number of volatile\n/// memory operations. However, volatile memory operations on zero-sized types\n/// (e.g., if a zero-sized type is passed to `read_volatile`) are noops\n/// and may be ignored.\n///\n/// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `src` must be [valid] for reads.\n///\n/// * `src` must be properly aligned.\n///\n/// Like [`read`], `read_volatile` creates a bitwise copy of `T`, regardless of\n/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n/// value and the value at `*src` can [violate memory safety][read-ownership].\n/// However, storing non-[`Copy`] types in volatile memory is almost certainly\n/// incorrect.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n/// [`Copy`]: ../marker/trait.Copy.html\n/// [`read`]: ./fn.read.html\n/// [read-ownership]: ./fn.read.html#ownership-of-the-returned-value\n///\n/// Just like in C, whether an operation is volatile has no bearing whatsoever\n/// on questions involving concurrent access from multiple threads. Volatile\n/// accesses behave exactly like non-atomic accesses in that regard. In particular,\n/// a race between a `read_volatile` and any write operation to the same location\n/// is undefined behavior.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let x = 12;\n/// let y = &x as *const i32;\n///\n/// unsafe {\n///     assert_eq!(std::ptr::read_volatile(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"volatile\", since = \"1.9.0\")]\npub unsafe fn read_volatile<T>(src: *const T) -> T {\n}\n\n/// Performs a volatile write of a memory location with the given value without\n/// reading or dropping the old value.\n///\n/// Volatile operations are intended to act on I/O memory, and are guaranteed\n/// to not be elided or reordered by the compiler across other volatile\n/// operations.\n///\n/// `write_volatile` does not drop the contents of `dst`. This is safe, but it\n/// could leak allocations or resources, so care should be taken not to overwrite\n/// an object that should be dropped.\n///\n/// Additionally, it does not drop `src`. Semantically, `src` is moved into the\n/// location pointed to by `dst`.\n///\n/// [`read_volatile`]: ./fn.read_volatile.html\n///\n/// # Notes\n///\n/// Rust does not currently have a rigorously and formally defined memory model,\n/// so the precise semantics of what \"volatile\" means here is subject to change\n/// over time. That being said, the semantics will almost always end up pretty\n/// similar to [C11's definition of volatile][c11].\n///\n/// The compiler shouldn't change the relative order or number of volatile\n/// memory operations. However, volatile memory operations on zero-sized types\n/// (e.g., if a zero-sized type is passed to `write_volatile`) are noops\n/// and may be ignored.\n///\n/// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n///\n/// # Safety\n///\n/// Behavior is undefined if any of the following conditions are violated:\n///\n/// * `dst` must be [valid] for writes.\n///\n/// * `dst` must be properly aligned.\n///\n/// Note that even if `T` has size `0`, the pointer must be non-NULL and properly aligned.\n///\n/// [valid]: ../ptr/index.html#safety\n///\n/// Just like in C, whether an operation is volatile has no bearing whatsoever\n/// on questions involving concurrent access from multiple threads. Volatile\n/// accesses behave exactly like non-atomic accesses in that regard. In particular,\n/// a race between a `write_volatile` and any other operation (reading or writing)\n/// on the same location is undefined behavior.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let mut x = 0;\n/// let y = &mut x as *mut i32;\n/// let z = 12;\n///\n/// unsafe {\n///     std::ptr::write_volatile(y, z);\n///     assert_eq!(std::ptr::read_volatile(y), 12);\n/// }\n/// ```\n#[inline]\n#[stable(feature = \"volatile\", since = \"1.9.0\")]\npub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n}\n\n/// Align pointer `p`.\n///\n/// Calculate offset (in terms of elements of `stride` stride) that has to be applied\n/// to pointer `p` so that pointer `p` would get aligned to `a`.\n///\n/// Note: This implementation has been carefully tailored to not panic. It is UB for this to panic.\n/// The only real change that can be made here is change of `INV_TABLE_MOD_16` and associated\n/// constants.\n///\n/// If we ever decide to make it possible to call the intrinsic with `a` that is not a\n/// power-of-two, it will probably be more prudent to just change to a naive implementation rather\n/// than trying to adapt this to accommodate that change.\n///\n/// Any questions go to @nagisa.\n#[lang = \"align_offset\"]\npub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n}\n\n/// Compares raw pointers for equality.\n///\n/// This is the same as using the `==` operator, but less generic:\n/// the arguments have to be `*const T` raw pointers,\n/// not anything that implements `PartialEq`.\n///\n/// This can be used to compare `&T` references (which coerce to `*const T` implicitly)\n/// by their address rather than comparing the values they point to\n/// (which is what the `PartialEq for &T` implementation does).\n///\n/// # Examples\n///\n/// ```\n/// use std::ptr;\n///\n/// let five = 5;\n/// let other_five = 5;\n/// let five_ref = &five;\n/// let same_five_ref = &five;\n/// let other_five_ref = &other_five;\n///\n/// assert!(five_ref == same_five_ref);\n/// assert!(ptr::eq(five_ref, same_five_ref));\n///\n/// assert!(five_ref == other_five_ref);\n/// assert!(!ptr::eq(five_ref, other_five_ref));\n/// ```\n///\n/// Slices are also compared by their length (fat pointers):\n///\n/// ```\n/// let a = [1, 2, 3];\n/// assert!(std::ptr::eq(&a[..3], &a[..3]));\n/// assert!(!std::ptr::eq(&a[..2], &a[..3]));\n/// assert!(!std::ptr::eq(&a[0..2], &a[1..3]));\n/// ```\n///\n/// Traits are also compared by their implementation:\n///\n/// ```\n/// #[repr(transparent)]\n/// struct Wrapper { member: i32 }\n///\n/// trait Trait {}\n/// impl Trait for Wrapper {}\n/// impl Trait for i32 {}\n///\n/// let wrapper = Wrapper { member: 10 };\n///\n/// // Pointers have equal addresses.\n/// assert!(std::ptr::eq(\n///     &wrapper as *const Wrapper as *const u8,\n///     &wrapper.member as *const i32 as *const u8\n/// ));\n///\n/// // Objects have equal addresses, but `Trait` has different implementations.\n/// assert!(!std::ptr::eq(\n///     &wrapper as &dyn Trait,\n///     &wrapper.member as &dyn Trait,\n/// ));\n/// assert!(!std::ptr::eq(\n///     &wrapper as &dyn Trait as *const dyn Trait,\n///     &wrapper.member as &dyn Trait as *const dyn Trait,\n/// ));\n///\n/// // Converting the reference to a `*const u8` compares by address.\n/// assert!(std::ptr::eq(\n///     &wrapper as &dyn Trait as *const dyn Trait as *const u8,\n///     &wrapper.member as &dyn Trait as *const dyn Trait as *const u8,\n/// ));\n/// ```\n#[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n#[inline]\npub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n}\n\n/// Hash a raw pointer.\n///\n/// This can be used to hash a `&T` reference (which coerces to `*const T` implicitly)\n/// by its address rather than the value it points to\n/// (which is what the `Hash for &T` implementation does).\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::hash_map::DefaultHasher;\n/// use std::hash::{Hash, Hasher};\n/// use std::ptr;\n///\n/// let five = 5;\n/// let five_ref = &five;\n///\n/// let mut hasher = DefaultHasher::new();\n/// ptr::hash(five_ref, &mut hasher);\n/// let actual = hasher.finish();\n///\n/// let mut hasher = DefaultHasher::new();\n/// (five_ref as *const i32).hash(&mut hasher);\n/// let expected = hasher.finish();\n///\n/// assert_eq!(actual, expected);\n/// ```\n#[stable(feature = \"ptr_hash\", since = \"1.35.0\")]\npub fn hash<T: ?Sized, S: hash::Hasher>(hashee: *const T, into: &mut S) {\n}\n\n// Impls for function pointers\nmacro_rules! fnptr_impls_safety_abi {\n    ($FnTy: ty, $($Arg: ident),*) => {\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> PartialEq for $FnTy {\n            #[inline]\n            fn eq(&self, other: &Self) -> bool {\n}\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> Eq for $FnTy {}\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> PartialOrd for $FnTy {\n            #[inline]\n            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n}\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> Ord for $FnTy {\n            #[inline]\n            fn cmp(&self, other: &Self) -> Ordering {\n}\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> hash::Hash for $FnTy {\n            fn hash<HH: hash::Hasher>(&self, state: &mut HH) {\n}\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> fmt::Pointer for $FnTy {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n        }\n\n        #[stable(feature = \"fnptr_impls\", since = \"1.4.0\")]\n        impl<Ret, $($Arg),*> fmt::Debug for $FnTy {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n        }\n    }\n}\n\nmacro_rules! fnptr_impls_args {\n    ($($Arg: ident),+) => {\n        fnptr_impls_safety_abi! { extern \"Rust\" fn($($Arg),+) -> Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { extern \"C\" fn($($Arg),+) -> Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { }\n        fnptr_impls_safety_abi! { }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn($($Arg),+) -> Ret, $($Arg),+ }\n        fnptr_impls_safety_abi! { }\n    };\n    () => {\n        // No variadic functions with 0 parameters\n        fnptr_impls_safety_abi! { extern \"Rust\" fn() -> Ret, }\n        fnptr_impls_safety_abi! { extern \"C\" fn() -> Ret, }\n        fnptr_impls_safety_abi! { }\n        fnptr_impls_safety_abi! { unsafe extern \"C\" fn() -> Ret, }\n    };\n}\n\nfnptr_impls_args! {}\nfnptr_impls_args! { A }\nfnptr_impls_args! { A, B }\nfnptr_impls_args! { A, B, C }\nfnptr_impls_args! { A, B, C, D }\nfnptr_impls_args! { A, B, C, D, E }\nfnptr_impls_args! { A, B, C, D, E, F }\nfnptr_impls_args! { A, B, C, D, E, F, G }\nfnptr_impls_args! { A, B, C, D, E, F, G, H }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K }\nfnptr_impls_args! { A, B, C, D, E, F, G, H, I, J, K, L }\n}\n\n/* Core language traits */\n\npub mod borrow {\n//! A module for working with borrowed data.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n/// A trait for borrowing data.\n///\n/// In Rust, it is common to provide different representations of a type for\n/// different use cases. For instance, storage location and management for a\n/// value can be specifically chosen as appropriate for a particular use via\n/// pointer types such as [`Box<T>`] or [`Rc<T>`]. Beyond these generic\n/// wrappers that can be used with any type, some types provide optional\n/// facets providing potentially costly functionality. An example for such a\n/// type is [`String`] which adds the ability to extend a string to the basic\n/// [`str`]. This requires keeping additional information unnecessary for a\n/// simple, immutable string.\n///\n/// These types provide access to the underlying data through references\n/// to the type of that data. They are said to be ‘borrowed as’ that type.\n/// For instance, a [`Box<T>`] can be borrowed as `T` while a [`String`]\n/// can be borrowed as `str`.\n///\n/// Types express that they can be borrowed as some type `T` by implementing\n/// `Borrow<T>`, providing a reference to a `T` in the trait’s\n/// [`borrow`] method. A type is free to borrow as several different types.\n/// If it wishes to mutably borrow as the type – allowing the underlying data\n/// to be modified, it can additionally implement [`BorrowMut<T>`].\n///\n/// Further, when providing implementations for additional traits, it needs\n/// to be considered whether they should behave identical to those of the\n/// underlying type as a consequence of acting as a representation of that\n/// underlying type. Generic code typically uses `Borrow<T>` when it relies\n/// on the identical behavior of these additional trait implementations.\n/// These traits will likely appear as additional trait bounds.\n///\n/// In particular `Eq`, `Ord` and `Hash` must be equivalent for\n/// borrowed and owned values: `x.borrow() == y.borrow()` should give the\n/// same result as `x == y`.\n///\n/// If generic code merely needs to work for all types that can\n/// provide a reference to related type `T`, it is often better to use\n/// [`AsRef<T>`] as more types can safely implement it.\n///\n/// [`AsRef<T>`]: ../../std/convert/trait.AsRef.html\n/// [`BorrowMut<T>`]: trait.BorrowMut.html\n/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n/// [`Mutex<T>`]: ../../std/sync/struct.Mutex.html\n/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n/// [`str`]: ../../std/primitive.str.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [`borrow`]: #tymethod.borrow\n///\n/// # Examples\n///\n/// As a data collection, [`HashMap<K, V>`] owns both keys and values. If\n/// the key’s actual data is wrapped in a managing type of some kind, it\n/// should, however, still be possible to search for a value using a\n/// reference to the key’s data. For instance, if the key is a string, then\n/// it is likely stored with the hash map as a [`String`], while it should\n/// be possible to search using a [`&str`][`str`]. Thus, `insert` needs to\n/// operate on a `String` while `get` needs to be able to use a `&str`.\n///\n/// Slightly simplified, the relevant parts of `HashMap<K, V>` look like\n/// this:\n///\n/// ```\n/// use std::borrow::Borrow;\n/// use std::hash::Hash;\n///\n/// pub struct HashMap<K, V> {\n///     # marker: ::std::marker::PhantomData<(K, V)>,\n///     // fields omitted\n/// }\n///\n/// impl<K, V> HashMap<K, V> {\n///     pub fn insert(&self, key: K, value: V) -> Option<V>\n///     where K: Hash + Eq\n///     {\n///         # unimplemented!()\n///         // ...\n///     }\n///\n///     pub fn get<Q>(&self, k: &Q) -> Option<&V>\n///     where\n///         K: Borrow<Q>,\n///         Q: Hash + Eq + ?Sized\n///     {\n///         # unimplemented!()\n///         // ...\n///     }\n/// }\n/// ```\n///\n/// The entire hash map is generic over a key type `K`. Because these keys\n/// are stored with the hash map, this type has to own the key’s data.\n/// When inserting a key-value pair, the map is given such a `K` and needs\n/// to find the correct hash bucket and check if the key is already present\n/// based on that `K`. It therefore requires `K: Hash + Eq`.\n///\n/// When searching for a value in the map, however, having to provide a\n/// reference to a `K` as the key to search for would require to always\n/// create such an owned value. For string keys, this would mean a `String`\n/// value needs to be created just for the search for cases where only a\n/// `str` is available.\n///\n/// Instead, the `get` method is generic over the type of the underlying key\n/// data, called `Q` in the method signature above. It states that `K`\n/// borrows as a `Q` by requiring that `K: Borrow<Q>`. By additionally\n/// requiring `Q: Hash + Eq`, it signals the requirement that `K` and `Q`\n/// have implementations of the `Hash` and `Eq` traits that produce identical\n/// results.\n///\n/// The implementation of `get` relies in particular on identical\n/// implementations of `Hash` by determining the key’s hash bucket by calling\n/// `Hash::hash` on the `Q` value even though it inserted the key based on\n/// the hash value calculated from the `K` value.\n///\n/// As a consequence, the hash map breaks if a `K` wrapping a `Q` value\n/// produces a different hash than `Q`. For instance, imagine you have a\n/// type that wraps a string but compares ASCII letters ignoring their case:\n///\n/// ```\n/// pub struct CaseInsensitiveString(String);\n///\n/// impl PartialEq for CaseInsensitiveString {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.0.eq_ignore_ascii_case(&other.0)\n///     }\n/// }\n///\n/// impl Eq for CaseInsensitiveString { }\n/// ```\n///\n/// Because two equal values need to produce the same hash value, the\n/// implementation of `Hash` needs to ignore ASCII case, too:\n///\n/// ```\n/// # use std::hash::{Hash, Hasher};\n/// # pub struct CaseInsensitiveString(String);\n/// impl Hash for CaseInsensitiveString {\n///     fn hash<H: Hasher>(&self, state: &mut H) {\n///         for c in self.0.as_bytes() {\n///             c.to_ascii_lowercase().hash(state)\n///         }\n///     }\n/// }\n/// ```\n///\n/// Can `CaseInsensitiveString` implement `Borrow<str>`? It certainly can\n/// provide a reference to a string slice via its contained owned string.\n/// But because its `Hash` implementation differs, it behaves differently\n/// from `str` and therefore must not, in fact, implement `Borrow<str>`.\n/// If it wants to allow others access to the underlying `str`, it can do\n/// that via `AsRef<str>` which doesn’t carry any extra requirements.\n///\n/// [`Hash`]: ../../std/hash/trait.Hash.html\n/// [`HashMap<K, V>`]: ../../std/collections/struct.HashMap.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [`str`]: ../../std/primitive.str.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Borrow<Borrowed: ?Sized> {\n    /// Immutably borrows from an owned value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::borrow::Borrow;\n    ///\n    /// fn check<T: Borrow<str>>(s: T) {\n    ///     assert_eq!(\"Hello\", s.borrow());\n    /// }\n    ///\n    /// let s = \"Hello\".to_string();\n    ///\n    /// check(s);\n    ///\n    /// let s = \"Hello\";\n    ///\n    /// check(s);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn borrow(&self) -> &Borrowed;\n}\n\n/// A trait for mutably borrowing data.\n///\n/// As a companion to [`Borrow<T>`] this trait allows a type to borrow as\n/// an underlying type by providing a mutable reference. See [`Borrow<T>`]\n/// for more information on borrowing as another type.\n///\n/// [`Borrow<T>`]: trait.Borrow.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {\n    /// Mutably borrows from an owned value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::borrow::BorrowMut;\n    ///\n    /// fn check<T: BorrowMut<[i32]>>(mut v: T) {\n    ///     assert_eq!(&mut [1, 2, 3], v.borrow_mut());\n    /// }\n    ///\n    /// let v = vec![1, 2, 3];\n    ///\n    /// check(v);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn borrow_mut(&mut self) -> &mut Borrowed;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Borrow<T> for T {\n    fn borrow(&self) -> &T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> BorrowMut<T> for T {\n    fn borrow_mut(&mut self) -> &mut T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Borrow<T> for &T {\n    fn borrow(&self) -> &T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Borrow<T> for &mut T {\n    fn borrow(&self) -> &T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> BorrowMut<T> for &mut T {\n    fn borrow_mut(&mut self) -> &mut T {\n}\n}\n}\n#[cfg(not(test))] // See #65860\npub mod clone {\n//! The `Clone` trait for types that cannot be 'implicitly copied'.\n//!\n//! In Rust, some simple types are \"implicitly copyable\" and when you\n//! assign them or pass them as arguments, the receiver will get a copy,\n//! leaving the original value in place. These types do not require\n//! allocation to copy and do not have finalizers (i.e., they do not\n//! contain owned boxes or implement [`Drop`]), so the compiler considers\n//! them cheap and safe to copy. For other types copies must be made\n//! explicitly, by convention implementing the [`Clone`] trait and calling\n//! the [`clone`][clone] method.\n//!\n//! [`Clone`]: trait.Clone.html\n//! [clone]: trait.Clone.html#tymethod.clone\n//! [`Drop`]: ../../std/ops/trait.Drop.html\n//!\n//! Basic usage example:\n//!\n//! ```\n//! let s = String::new(); // String type implements Clone\n//! let copy = s.clone(); // so we can clone it\n//! ```\n//!\n//! To easily implement the Clone trait, you can also use\n//! `#[derive(Clone)]`. Example:\n//!\n//! ```\n//! #[derive(Clone)] // we add the Clone trait to Morpheus struct\n//! struct Morpheus {\n//!    blue_pill: f32,\n//!    red_pill: i64,\n//! }\n//!\n//! fn main() {\n//!    let f = Morpheus { blue_pill: 0.0, red_pill: 0 };\n//!    let copy = f.clone(); // and now we can clone it!\n//! }\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n/// A common trait for the ability to explicitly duplicate an object.\n///\n/// Differs from [`Copy`] in that [`Copy`] is implicit and extremely inexpensive, while\n/// `Clone` is always explicit and may or may not be expensive. In order to enforce\n/// these characteristics, Rust does not allow you to reimplement [`Copy`], but you\n/// may reimplement `Clone` and run arbitrary code.\n///\n/// Since `Clone` is more general than [`Copy`], you can automatically make anything\n/// [`Copy`] be `Clone` as well.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d\n/// implementation of [`clone`] calls [`clone`] on each field.\n///\n/// For a generic struct, `#[derive]` implements `Clone` conditionally by adding bound `Clone` on\n/// generic parameters.\n///\n/// ```\n/// // `derive` implements Clone for Reading<T> when T is Clone.\n/// #[derive(Clone)]\n/// struct Reading<T> {\n///     frequency: T,\n/// }\n/// ```\n///\n/// ## How can I implement `Clone`?\n///\n/// Types that are [`Copy`] should have a trivial implementation of `Clone`. More formally:\n/// if `T: Copy`, `x: T`, and `y: &T`, then `let x = y.clone();` is equivalent to `let x = *y;`.\n/// Manual implementations should be careful to uphold this invariant; however, unsafe code\n/// must not rely on it to ensure memory safety.\n///\n/// An example is a generic struct holding a function pointer. In this case, the\n/// implementation of `Clone` cannot be `derive`d, but can be implemented as:\n///\n/// [`Copy`]: ../../std/marker/trait.Copy.html\n/// [`clone`]: trait.Clone.html#tymethod.clone\n///\n/// ```\n/// struct Generate<T>(fn() -> T);\n///\n/// impl<T> Copy for Generate<T> {}\n///\n/// impl<T> Clone for Generate<T> {\n///     fn clone(&self) -> Self {\n///         *self\n///     }\n/// }\n/// ```\n///\n/// ## Additional implementors\n///\n/// In addition to the [implementors listed below][impls],\n/// the following types also implement `Clone`:\n///\n/// * Function item types (i.e., the distinct types defined for each function)\n/// * Function pointer types (e.g., `fn() -> i32`)\n/// * Array types, for all sizes, if the item type also implements `Clone` (e.g., `[i32; 123456]`)\n/// * Tuple types, if each component also implements `Clone` (e.g., `()`, `(i32, bool)`)\n/// * Closure types, if they capture no value from the environment\n///   or if all such captured values implement `Clone` themselves.\n///   Note that variables captured by shared reference always implement `Clone`\n///   (even if the referent doesn't),\n///   while variables captured by mutable reference never implement `Clone`.\n///\n/// [impls]: #implementors\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[lang = \"clone\"]\npub trait Clone: Sized {\n    /// Returns a copy of the value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let hello = \"Hello\"; // &str implements Clone\n    ///\n    /// assert_eq!(\"Hello\", hello.clone());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[must_use = \"cloning is often expensive and is not expected to have side effects\"]\n    fn clone(&self) -> Self;\n\n    /// Performs copy-assignment from `source`.\n    ///\n    /// `a.clone_from(&b)` is equivalent to `a = b.clone()` in functionality,\n    /// but can be overridden to reuse the resources of `a` to avoid unnecessary\n    /// allocations.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn clone_from(&mut self, source: &Self) {\n        *self = source.clone()\n    }\n}\n\n/// Derive macro generating an impl of the trait `Clone`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\npub macro Clone($item:item) {\n    /* compiler built-in */\n}\n\n// FIXME(aburka): these structs are used solely by #[derive] to\n// assert that every component of a type implements Clone or Copy.\n//\n// These structs should never appear in user code.\n#[doc(hidden)]\n#[allow(missing_debug_implementations)]\n#[unstable(\n    feature = \"derive_clone_copy\",\n    reason = \"deriving hack, should not be public\",\n    issue = \"none\"\n)]\npub struct AssertParamIsClone<T: Clone + ?Sized> {\n    _field: crate::marker::PhantomData<T>,\n}\n#[doc(hidden)]\n#[allow(missing_debug_implementations)]\n#[unstable(\n    feature = \"derive_clone_copy\",\n    reason = \"deriving hack, should not be public\",\n    issue = \"none\"\n)]\npub struct AssertParamIsCopy<T: Copy + ?Sized> {\n    _field: crate::marker::PhantomData<T>,\n}\n\n/// Implementations of `Clone` for primitive types.\n///\n/// Implementations that cannot be described in Rust\n/// are implemented in `SelectionContext::copy_clone_conditions()` in librustc.\nmod impls {\n\n    use super::Clone;\n\n    macro_rules! impl_clone {\n        ($($t:ty)*) => {\n            $(\n                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                impl Clone for $t {\n                    #[inline]\n                    fn clone(&self) -> Self {\n}\n                }\n            )*\n        }\n    }\n\n    impl_clone! {\n        usize u8 u16 u32 u64 u128\n        isize i8 i16 i32 i64 i128\n        f32 f64\n        bool char\n    }\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl Clone for ! {\n}\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> Clone for *const T {\n        #[inline]\n        fn clone(&self) -> Self {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> Clone for *mut T {\n        #[inline]\n        fn clone(&self) -> Self {\n}\n    }\n\n    // Shared references can be cloned, but mutable references *cannot*!\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> Clone for &T {\n        #[inline]\n        fn clone(&self) -> Self {\n}\n    }\n}\n}\n#[cfg(not(test))] // See #65860\npub mod cmp {\n//! Functionality for ordering and comparison.\n//!\n//! This module contains various tools for ordering and comparing values. In\n//! summary:\n//!\n//! * [`Eq`] and [`PartialEq`] are traits that allow you to define total and\n//!   partial equality between values, respectively. Implementing them overloads\n//!   the `==` and `!=` operators.\n//! * [`Ord`] and [`PartialOrd`] are traits that allow you to define total and\n//!   partial orderings between values, respectively. Implementing them overloads\n//!   the `<`, `<=`, `>`, and `>=` operators.\n//! * [`Ordering`] is an enum returned by the main functions of [`Ord`] and\n//!   [`PartialOrd`], and describes an ordering.\n//! * [`Reverse`] is a struct that allows you to easily reverse an ordering.\n//! * [`max`] and [`min`] are functions that build off of [`Ord`] and allow you\n//!   to find the maximum or minimum of two values.\n//!\n//! For more details, see the respective documentation of each item in the list.\n//!\n//! [`Eq`]: trait.Eq.html\n//! [`PartialEq`]: trait.PartialEq.html\n//! [`Ord`]: trait.Ord.html\n//! [`PartialOrd`]: trait.PartialOrd.html\n//! [`Ordering`]: enum.Ordering.html\n//! [`Reverse`]: struct.Reverse.html\n//! [`max`]: fn.max.html\n//! [`min`]: fn.min.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse self::Ordering::*;\n\n/// Trait for equality comparisons which are [partial equivalence\n/// relations](http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n///\n/// This trait allows for partial equality, for types that do not have a full\n/// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n/// so floating point types implement `PartialEq` but not `Eq`.\n///\n/// Formally, the equality must be (for all `a`, `b` and `c`):\n///\n/// - symmetric: `a == b` implies `b == a`; and\n/// - transitive: `a == b` and `b == c` implies `a == c`.\n///\n/// Note that these requirements mean that the trait itself must be implemented\n/// symmetrically and transitively: if `T: PartialEq<U>` and `U: PartialEq<V>`\n/// then `U: PartialEq<T>` and `T: PartialEq<V>`.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d on structs, two\n/// instances are equal if all fields are equal, and not equal if any fields\n/// are not equal. When `derive`d on enums, each variant is equal to itself\n/// and not equal to the other variants.\n///\n/// ## How can I implement `PartialEq`?\n///\n/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n/// in terms of it by default. Any manual implementation of `ne` *must* respect\n/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n/// only if `a != b`.\n///\n/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with\n/// each other. It's easy to accidentally make them disagree by deriving some\n/// of the traits and manually implementing others.\n///\n/// An example implementation for a domain in which two books are considered\n/// the same book if their ISBN matches, even if the formats differ:\n///\n/// ```\n/// enum BookFormat {\n///     Paperback,\n///     Hardback,\n///     Ebook,\n/// }\n///\n/// struct Book {\n///     isbn: i32,\n///     format: BookFormat,\n/// }\n///\n/// impl PartialEq for Book {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.isbn == other.isbn\n///     }\n/// }\n///\n/// let b1 = Book { isbn: 3, format: BookFormat::Paperback };\n/// let b2 = Book { isbn: 3, format: BookFormat::Ebook };\n/// let b3 = Book { isbn: 10, format: BookFormat::Paperback };\n///\n/// assert!(b1 == b2);\n/// assert!(b1 != b3);\n/// ```\n///\n/// ## How can I compare two different types?\n///\n/// The type you can compare with is controlled by `PartialEq`'s type parameter.\n/// For example, let's tweak our previous code a bit:\n///\n/// ```\n/// // The derive implements <BookFormat> == <BookFormat> comparisons\n/// #[derive(PartialEq)]\n/// enum BookFormat {\n///     Paperback,\n///     Hardback,\n///     Ebook,\n/// }\n///\n/// struct Book {\n///     isbn: i32,\n///     format: BookFormat,\n/// }\n///\n/// // Implement <Book> == <BookFormat> comparisons\n/// impl PartialEq<BookFormat> for Book {\n///     fn eq(&self, other: &BookFormat) -> bool {\n///         self.format == *other\n///     }\n/// }\n///\n/// // Implement <BookFormat> == <Book> comparisons\n/// impl PartialEq<Book> for BookFormat {\n///     fn eq(&self, other: &Book) -> bool {\n///         *self == other.format\n///     }\n/// }\n///\n/// let b1 = Book { isbn: 3, format: BookFormat::Paperback };\n///\n/// assert!(b1 == BookFormat::Paperback);\n/// assert!(BookFormat::Ebook != b1);\n/// ```\n///\n/// By changing `impl PartialEq for Book` to `impl PartialEq<BookFormat> for Book`,\n/// we allow `BookFormat`s to be compared with `Book`s.\n///\n/// A comparison like the one above, which ignores some fields of the struct,\n/// can be dangerous. It can easily lead to an unintended violation of the\n/// requirements for a partial equivalence relation. For example, if we kept\n/// the above implementation of `PartialEq<Book>` for `BookFormat` and added an\n/// implementation of `PartialEq<Book>` for `Book` (either via a `#[derive]` or\n/// via the manual implementation from the first example) then the result would\n/// violate transitivity:\n///\n/// ```should_panic\n/// #[derive(PartialEq)]\n/// enum BookFormat {\n///     Paperback,\n///     Hardback,\n///     Ebook,\n/// }\n///\n/// #[derive(PartialEq)]\n/// struct Book {\n///     isbn: i32,\n///     format: BookFormat,\n/// }\n///\n/// impl PartialEq<BookFormat> for Book {\n///     fn eq(&self, other: &BookFormat) -> bool {\n///         self.format == *other\n///     }\n/// }\n///\n/// impl PartialEq<Book> for BookFormat {\n///     fn eq(&self, other: &Book) -> bool {\n///         *self == other.format\n///     }\n/// }\n///\n/// fn main() {\n///     let b1 = Book { isbn: 1, format: BookFormat::Paperback };\n///     let b2 = Book { isbn: 2, format: BookFormat::Paperback };\n///\n///     assert!(b1 == BookFormat::Paperback);\n///     assert!(BookFormat::Paperback == b2);\n///\n///     // The following should hold by transitivity but doesn't.\n///     assert!(b1 == b2); // <-- PANICS\n/// }\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// let x: u32 = 0;\n/// let y: u32 = 1;\n///\n/// assert_eq!(x == y, false);\n/// assert_eq!(x.eq(&y), false);\n/// ```\n#[lang = \"eq\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(alias = \"==\")]\n#[doc(alias = \"!=\")]\n#[rustc_on_unimplemented(\n    message = \"can't compare `{Self}` with `{Rhs}`\",\n    label = \"no implementation for `{Self} == {Rhs}`\"\n)]\npub trait PartialEq<Rhs: ?Sized = Self> {\n    /// This method tests for `self` and `other` values to be equal, and is used\n    /// by `==`.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn eq(&self, other: &Rhs) -> bool;\n\n    /// This method tests for `!=`.\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn ne(&self, other: &Rhs) -> bool {\n        !self.eq(other)\n    }\n}\n\n/// Derive macro generating an impl of the trait `PartialEq`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics, structural_match)]\npub macro PartialEq($item:item) {\n    /* compiler built-in */\n}\n\n/// Trait for equality comparisons which are [equivalence relations](\n/// https://en.wikipedia.org/wiki/Equivalence_relation).\n///\n/// This means, that in addition to `a == b` and `a != b` being strict inverses, the equality must\n/// be (for all `a`, `b` and `c`):\n///\n/// - reflexive: `a == a`;\n/// - symmetric: `a == b` implies `b == a`; and\n/// - transitive: `a == b` and `b == c` implies `a == c`.\n///\n/// This property cannot be checked by the compiler, and therefore `Eq` implies\n/// `PartialEq`, and has no extra methods.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d, because `Eq` has\n/// no extra methods, it is only informing the compiler that this is an\n/// equivalence relation rather than a partial equivalence relation. Note that\n/// the `derive` strategy requires all fields are `Eq`, which isn't\n/// always desired.\n///\n/// ## How can I implement `Eq`?\n///\n/// If you cannot use the `derive` strategy, specify that your type implements\n/// `Eq`, which has no methods:\n///\n/// ```\n/// enum BookFormat { Paperback, Hardback, Ebook }\n/// struct Book {\n///     isbn: i32,\n///     format: BookFormat,\n/// }\n/// impl PartialEq for Book {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.isbn == other.isbn\n///     }\n/// }\n/// impl Eq for Book {}\n/// ```\n#[doc(alias = \"==\")]\n#[doc(alias = \"!=\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Eq: PartialEq<Self> {\n    // this method is used solely by #[deriving] to assert\n    // that every component of a type implements #[deriving]\n    // itself, the current deriving infrastructure means doing this\n    // assertion without using a method on this trait is nearly\n    // impossible.\n    //\n    // This should never be implemented by hand.\n    #[doc(hidden)]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn assert_receiver_is_total_eq(&self) {}}\n\n/// Derive macro generating an impl of the trait `Eq`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics, derive_eq, structural_match)]\npub macro Eq($item:item) {\n    /* compiler built-in */\n}\n\n// FIXME: this struct is used solely by #[derive] to\n// assert that every component of a type implements Eq.\n//\n// This struct should never appear in user code.\n#[doc(hidden)]\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"derive_eq\", reason = \"deriving hack, should not be public\", issue = \"none\")]\npub struct AssertParamIsEq<T: Eq + ?Sized> {\n}\n\n/// An `Ordering` is the result of a comparison between two values.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// let result = 1.cmp(&2);\n/// assert_eq!(Ordering::Less, result);\n///\n/// let result = 1.cmp(&1);\n/// assert_eq!(Ordering::Equal, result);\n///\n/// let result = 2.cmp(&1);\n/// assert_eq!(Ordering::Greater, result);\n/// ```\n#[derive(Clone, Copy, PartialEq, Debug, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Ordering {\n    /// An ordering where a compared value is less than another.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Less = -1,\n    /// An ordering where a compared value is equal to another.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Equal = 0,\n    /// An ordering where a compared value is greater than another.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Greater = 1,\n}\n\nimpl Ordering {\n    /// Reverses the `Ordering`.\n    ///\n    /// * `Less` becomes `Greater`.\n    /// * `Greater` becomes `Less`.\n    /// * `Equal` becomes `Equal`.\n    ///\n    /// # Examples\n    ///\n    /// Basic behavior:\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(Ordering::Less.reverse(), Ordering::Greater);\n    /// assert_eq!(Ordering::Equal.reverse(), Ordering::Equal);\n    /// assert_eq!(Ordering::Greater.reverse(), Ordering::Less);\n    /// ```\n    ///\n    /// This method can be used to reverse a comparison:\n    ///\n    /// ```\n    /// let data: &mut [_] = &mut [2, 10, 5, 8];\n    ///\n    /// // sort the array from largest to smallest.\n    /// data.sort_by(|a, b| a.cmp(b).reverse());\n    ///\n    /// let b: &mut [_] = &mut [10, 8, 5, 2];\n    /// assert!(data == b);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reverse(self) -> Ordering {\n}\n\n    /// Chains two orderings.\n    ///\n    /// Returns `self` when it's not `Equal`. Otherwise returns `other`.\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// let result = Ordering::Equal.then(Ordering::Less);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then(Ordering::Equal);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then(Ordering::Greater);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Equal.then(Ordering::Equal);\n    /// assert_eq!(result, Ordering::Equal);\n    ///\n    /// let x: (i64, i64, i64) = (1, 2, 7);\n    /// let y: (i64, i64, i64) = (1, 5, 3);\n    /// let result = x.0.cmp(&y.0).then(x.1.cmp(&y.1)).then(x.2.cmp(&y.2));\n    ///\n    /// assert_eq!(result, Ordering::Less);\n    /// ```\n    #[inline]\n    #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n    pub fn then(self, other: Ordering) -> Ordering {\n}\n\n    /// Chains the ordering with the given function.\n    ///\n    /// Returns `self` when it's not `Equal`. Otherwise calls `f` and returns\n    /// the result.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// let result = Ordering::Equal.then_with(|| Ordering::Less);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then_with(|| Ordering::Equal);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Less.then_with(|| Ordering::Greater);\n    /// assert_eq!(result, Ordering::Less);\n    ///\n    /// let result = Ordering::Equal.then_with(|| Ordering::Equal);\n    /// assert_eq!(result, Ordering::Equal);\n    ///\n    /// let x: (i64, i64, i64) = (1, 2, 7);\n    /// let y: (i64, i64, i64)  = (1, 5, 3);\n    /// let result = x.0.cmp(&y.0).then_with(|| x.1.cmp(&y.1)).then_with(|| x.2.cmp(&y.2));\n    ///\n    /// assert_eq!(result, Ordering::Less);\n    /// ```\n    #[inline]\n    #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n    pub fn then_with<F: FnOnce() -> Ordering>(self, f: F) -> Ordering {\n}\n}\n\n/// A helper struct for reverse ordering.\n///\n/// This struct is a helper to be used with functions like `Vec::sort_by_key` and\n/// can be used to reverse order a part of a key.\n///\n/// Example usage:\n///\n/// ```\n/// use std::cmp::Reverse;\n///\n/// let mut v = vec![1, 2, 3, 4, 5, 6];\n/// v.sort_by_key(|&num| (num > 3, Reverse(num)));\n/// assert_eq!(v, vec![3, 2, 1, 6, 5, 4]);\n/// ```\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\npub struct Reverse<T>(#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")] pub T);\n\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n}\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n}\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n}\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n}\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n}\n}\n\n#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n}\n}\n\n/// Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).\n///\n/// An order is a total order if it is (for all `a`, `b` and `c`):\n///\n/// - total and asymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and\n/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n/// lexicographic ordering based on the top-to-bottom declaration order of the struct's members.\n/// When `derive`d on enums, variants are ordered by their top-to-bottom declaration order.\n///\n/// ## How can I implement `Ord`?\n///\n/// `Ord` requires that the type also be `PartialOrd` and `Eq` (which requires `PartialEq`).\n///\n/// Then you must define an implementation for `cmp()`. You may find it useful to use\n/// `cmp()` on your type's fields.\n///\n/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must*\n/// agree with each other. That is, `a.cmp(b) == Ordering::Equal` if\n/// and only if `a == b` and `Some(a.cmp(b)) == a.partial_cmp(b)` for\n/// all `a` and `b`. It's easy to accidentally make them disagree by\n/// deriving some of the traits and manually implementing others.\n///\n/// Here's an example where you want to sort people by height only, disregarding `id`\n/// and `name`:\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// #[derive(Eq)]\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     height: u32,\n/// }\n///\n/// impl Ord for Person {\n///     fn cmp(&self, other: &Self) -> Ordering {\n///         self.height.cmp(&other.height)\n///     }\n/// }\n///\n/// impl PartialOrd for Person {\n///     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n///         Some(self.cmp(other))\n///     }\n/// }\n///\n/// impl PartialEq for Person {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.height == other.height\n///     }\n/// }\n/// ```\n#[doc(alias = \"<\")]\n#[doc(alias = \">\")]\n#[doc(alias = \"<=\")]\n#[doc(alias = \">=\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Ord: Eq + PartialOrd<Self> {\n    /// This method returns an `Ordering` between `self` and `other`.\n    ///\n    /// By convention, `self.cmp(&other)` returns the ordering matching the expression\n    /// `self <operator> other` if true.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// assert_eq!(5.cmp(&10), Ordering::Less);\n    /// assert_eq!(10.cmp(&5), Ordering::Greater);\n    /// assert_eq!(5.cmp(&5), Ordering::Equal);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn cmp(&self, other: &Self) -> Ordering;\n\n    /// Compares and returns the maximum of two values.\n    ///\n    /// Returns the second argument if the comparison determines them to be equal.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(2, 1.max(2));\n    /// assert_eq!(2, 2.max(2));\n    /// ```\n    #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n    #[inline]\n    fn max(self, other: Self) -> Self\n    where\n        Self: Sized,\n    {\n        max_by(self, other, Ord::cmp)\n    }\n\n    /// Compares and returns the minimum of two values.\n    ///\n    /// Returns the first argument if the comparison determines them to be equal.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(1, 1.min(2));\n    /// assert_eq!(2, 2.min(2));\n    /// ```\n    #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n    #[inline]\n    fn min(self, other: Self) -> Self\n    where\n        Self: Sized,\n    {\n}\n\n    /// Restrict a value to a certain interval.\n    ///\n    /// Returns `max` if `self` is greater than `max`, and `min` if `self` is\n    /// less than `min`. Otherwise this returns `self`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `min > max`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(clamp)]\n    ///\n    /// assert!((-3).clamp(-2, 1) == -2);\n    /// assert!(0.clamp(-2, 1) == 0);\n    /// assert!(2.clamp(-2, 1) == 1);\n    /// ```\n    #[unstable(feature = \"clamp\", issue = \"44095\")]\n    fn clamp(self, min: Self, max: Self) -> Self\n    where\n        Self: Sized,\n    {\n}\n}\n\n/// Derive macro generating an impl of the trait `Ord`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics)]\npub macro Ord($item:item) {\n    /* compiler built-in */\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Eq for Ordering {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Ord for Ordering {\n    #[inline]\n    fn cmp(&self, other: &Ordering) -> Ordering {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialOrd for Ordering {\n    #[inline]\n    fn partial_cmp(&self, other: &Ordering) -> Option<Ordering> {\n}\n}\n\n/// Trait for values that can be compared for a sort-order.\n///\n/// The comparison must satisfy, for all `a`, `b` and `c`:\n///\n/// - asymmetry: if `a < b` then `!(a > b)`, as well as `a > b` implying `!(a < b)`; and\n/// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n///\n/// Note that these requirements mean that the trait itself must be implemented symmetrically and\n/// transitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n/// PartialOrd<V>`.\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n/// lexicographic ordering based on the top-to-bottom declaration order of the struct's members.\n/// When `derive`d on enums, variants are ordered by their top-to-bottom declaration order.\n///\n/// ## How can I implement `PartialOrd`?\n///\n/// `PartialOrd` only requires implementation of the `partial_cmp` method, with the others\n/// generated from default implementations.\n///\n/// However it remains possible to implement the others separately for types which do not have a\n/// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n/// false` (cf. IEEE 754-2008 section 5.11).\n///\n/// `PartialOrd` requires your type to be `PartialEq`.\n///\n/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n/// easy to accidentally make them disagree by deriving some of the traits and manually\n/// implementing others.\n///\n/// If your type is `Ord`, you can implement `partial_cmp()` by using `cmp()`:\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// #[derive(Eq)]\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     height: u32,\n/// }\n///\n/// impl PartialOrd for Person {\n///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n///         Some(self.cmp(other))\n///     }\n/// }\n///\n/// impl Ord for Person {\n///     fn cmp(&self, other: &Person) -> Ordering {\n///         self.height.cmp(&other.height)\n///     }\n/// }\n///\n/// impl PartialEq for Person {\n///     fn eq(&self, other: &Person) -> bool {\n///         self.height == other.height\n///     }\n/// }\n/// ```\n///\n/// You may also find it useful to use `partial_cmp()` on your type's fields. Here\n/// is an example of `Person` types who have a floating-point `height` field that\n/// is the only field to be used for sorting:\n///\n/// ```\n/// use std::cmp::Ordering;\n///\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     height: f64,\n/// }\n///\n/// impl PartialOrd for Person {\n///     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n///         self.height.partial_cmp(&other.height)\n///     }\n/// }\n///\n/// impl PartialEq for Person {\n///     fn eq(&self, other: &Self) -> bool {\n///         self.height == other.height\n///     }\n/// }\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// let x : u32 = 0;\n/// let y : u32 = 1;\n///\n/// assert_eq!(x < y, true);\n/// assert_eq!(x.lt(&y), true);\n/// ```\n#[lang = \"partial_ord\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(alias = \">\")]\n#[doc(alias = \"<\")]\n#[doc(alias = \"<=\")]\n#[doc(alias = \">=\")]\n#[rustc_on_unimplemented(\n    message = \"can't compare `{Self}` with `{Rhs}`\",\n    label = \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\"\n)]\npub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n    /// This method returns an ordering between `self` and `other` values if one exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cmp::Ordering;\n    ///\n    /// let result = 1.0.partial_cmp(&2.0);\n    /// assert_eq!(result, Some(Ordering::Less));\n    ///\n    /// let result = 1.0.partial_cmp(&1.0);\n    /// assert_eq!(result, Some(Ordering::Equal));\n    ///\n    /// let result = 2.0.partial_cmp(&1.0);\n    /// assert_eq!(result, Some(Ordering::Greater));\n    /// ```\n    ///\n    /// When comparison is impossible:\n    ///\n    /// ```\n    /// let result = std::f64::NAN.partial_cmp(&1.0);\n    /// assert_eq!(result, None);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n\n    /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 1.0 < 2.0;\n    /// assert_eq!(result, true);\n    ///\n    /// let result = 2.0 < 1.0;\n    /// assert_eq!(result, false);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn lt(&self, other: &Rhs) -> bool {\n        matches!(self.partial_cmp(other), Some(Less))\n    }\n\n    /// This method tests less than or equal to (for `self` and `other`) and is used by the `<=`\n    /// operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 1.0 <= 2.0;\n    /// assert_eq!(result, true);\n    ///\n    /// let result = 2.0 <= 2.0;\n    /// assert_eq!(result, true);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn le(&self, other: &Rhs) -> bool {\n}\n\n    /// This method tests greater than (for `self` and `other`) and is used by the `>` operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 1.0 > 2.0;\n    /// assert_eq!(result, false);\n    ///\n    /// let result = 2.0 > 2.0;\n    /// assert_eq!(result, false);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn gt(&self, other: &Rhs) -> bool {\n}\n\n    /// This method tests greater than or equal to (for `self` and `other`) and is used by the `>=`\n    /// operator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let result = 2.0 >= 1.0;\n    /// assert_eq!(result, true);\n    ///\n    /// let result = 2.0 >= 2.0;\n    /// assert_eq!(result, true);\n    /// ```\n    #[inline]\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn ge(&self, other: &Rhs) -> bool {\n}\n}\n\n/// Derive macro generating an impl of the trait `PartialOrd`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics)]\npub macro PartialOrd($item:item) {\n    /* compiler built-in */\n}\n\n/// Compares and returns the minimum of two values.\n///\n/// Returns the first argument if the comparison determines them to be equal.\n///\n/// Internally uses an alias to `Ord::min`.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp;\n///\n/// assert_eq!(1, cmp::min(1, 2));\n/// assert_eq!(2, cmp::min(2, 2));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn min<T: Ord>(v1: T, v2: T) -> T {\n}\n\n/// Returns the minimum of two values with respect to the specified comparison function.\n///\n/// Returns the first argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(cmp_min_max_by)]\n///\n/// use std::cmp;\n///\n/// assert_eq!(cmp::min_by(-2, 1, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 1);\n/// assert_eq!(cmp::min_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n/// ```\n#[inline]\n#[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\npub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n}\n\n/// Returns the element that gives the minimum value from the specified function.\n///\n/// Returns the first argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(cmp_min_max_by)]\n///\n/// use std::cmp;\n///\n/// assert_eq!(cmp::min_by_key(-2, 1, |x: &i32| x.abs()), 1);\n/// assert_eq!(cmp::min_by_key(-2, 2, |x: &i32| x.abs()), -2);\n/// ```\n#[inline]\n#[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\npub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n}\n\n/// Compares and returns the maximum of two values.\n///\n/// Returns the second argument if the comparison determines them to be equal.\n///\n/// Internally uses an alias to `Ord::max`.\n///\n/// # Examples\n///\n/// ```\n/// use std::cmp;\n///\n/// assert_eq!(2, cmp::max(1, 2));\n/// assert_eq!(2, cmp::max(2, 2));\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn max<T: Ord>(v1: T, v2: T) -> T {\n}\n\n/// Returns the maximum of two values with respect to the specified comparison function.\n///\n/// Returns the second argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(cmp_min_max_by)]\n///\n/// use std::cmp;\n///\n/// assert_eq!(cmp::max_by(-2, 1, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n/// assert_eq!(cmp::max_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 2);\n/// ```\n#[inline]\n#[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\npub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n}\n\n/// Returns the element that gives the maximum value from the specified function.\n///\n/// Returns the second argument if the comparison determines them to be equal.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(cmp_min_max_by)]\n///\n/// use std::cmp;\n///\n/// assert_eq!(cmp::max_by_key(-2, 1, |x: &i32| x.abs()), -2);\n/// assert_eq!(cmp::max_by_key(-2, 2, |x: &i32| x.abs()), 2);\n/// ```\n#[inline]\n#[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\npub fn max_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n}\n\n// Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types\nmod impls {\n    use crate::cmp::Ordering::{self, Equal, Greater, Less};\n    use crate::hint::unreachable_unchecked;\n\n    macro_rules! partial_eq_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialEq for $t {\n                #[inline]\n                fn eq(&self, other: &$t) -> bool { }\n                #[inline]\n                fn ne(&self, other: &$t) -> bool { }\n            }\n        )*)\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialEq for () {\n        #[inline]\n        fn eq(&self, _other: &()) -> bool {\n}\n        #[inline]\n        fn ne(&self, _other: &()) -> bool {\n}\n    }\n\n    partial_eq_impl! {\n        bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64\n    }\n\n    macro_rules! eq_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Eq for $t {}\n        )*)\n    }\n\n    eq_impl! { () bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n    macro_rules! partial_ord_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialOrd for $t {\n                #[inline]\n                fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n}\n                #[inline]\n                fn lt(&self, other: &$t) -> bool { }\n                #[inline]\n                fn le(&self, other: &$t) -> bool { }\n                #[inline]\n                fn ge(&self, other: &$t) -> bool { }\n                #[inline]\n                fn gt(&self, other: &$t) -> bool { }\n            }\n        )*)\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialOrd for () {\n        #[inline]\n        fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl PartialOrd for bool {\n        #[inline]\n        fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n}\n    }\n\n    partial_ord_impl! { f32 f64 }\n\n    macro_rules! ord_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialOrd for $t {\n                #[inline]\n                fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n}\n                #[inline]\n                fn lt(&self, other: &$t) -> bool { }\n                #[inline]\n                fn le(&self, other: &$t) -> bool { }\n                #[inline]\n                fn ge(&self, other: &$t) -> bool { }\n                #[inline]\n                fn gt(&self, other: &$t) -> bool { }\n            }\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Ord for $t {\n                #[inline]\n                fn cmp(&self, other: &$t) -> Ordering {\n}\n            }\n        )*)\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Ord for () {\n        #[inline]\n        fn cmp(&self, _other: &()) -> Ordering {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Ord for bool {\n        #[inline]\n        fn cmp(&self, other: &bool) -> Ordering {\n}\n    }\n\n    ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl PartialEq for ! {\n}\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl Eq for ! {}}\n}\npub mod convert {\n//! Traits for conversions between types.\n//!\n//! The traits in this module provide a way to convert from one type to another type.\n//! Each trait serves a different purpose:\n//!\n//! - Implement the [`AsRef`] trait for cheap reference-to-reference conversions\n//! - Implement the [`AsMut`] trait for cheap mutable-to-mutable conversions\n//! - Implement the [`From`] trait for consuming value-to-value conversions\n//! - Implement the [`Into`] trait for consuming value-to-value conversions to types\n//!   outside the current crate\n//! - The [`TryFrom`] and [`TryInto`] traits behave like [`From`] and [`Into`],\n//!   but should be implemented when the conversion can fail.\n//!\n//! The traits in this module are often used as trait bounds for generic functions such that to\n//! arguments of multiple types are supported. See the documentation of each trait for examples.\n//!\n//! As a library author, you should always prefer implementing [`From<T>`][`From`] or\n//! [`TryFrom<T>`][`TryFrom`] rather than [`Into<U>`][`Into`] or [`TryInto<U>`][`TryInto`],\n//! as [`From`] and [`TryFrom`] provide greater flexibility and offer\n//! equivalent [`Into`] or [`TryInto`] implementations for free, thanks to a\n//! blanket implementation in the standard library. Only implement [`Into`] or [`TryInto`]\n//! when a conversion to a type outside the current crate is required.\n//!\n//! # Generic Implementations\n//!\n//! - [`AsRef`] and [`AsMut`] auto-dereference if the inner type is a reference\n//! - [`From`]`<U> for T` implies [`Into`]`<T> for U`\n//! - [`TryFrom`]`<U> for T` implies [`TryInto`]`<T> for U`\n//! - [`From`] and [`Into`] are reflexive, which means that all types can\n//!   `into` themselves and `from` themselves\n//!\n//! See each trait for usage examples.\n//!\n//! [`Into`]: trait.Into.html\n//! [`From`]: trait.From.html\n//! [`TryFrom`]: trait.TryFrom.html\n//! [`TryInto`]: trait.TryInto.html\n//! [`AsRef`]: trait.AsRef.html\n//! [`AsMut`]: trait.AsMut.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::fmt;\n\nmod num {\nuse super::{From, TryFrom};\nuse crate::num::TryFromIntError;\n\nmod private {\n    /// This trait being unreachable from outside the crate\n    /// prevents other implementations of the `FloatToInt` trait,\n    /// which allows potentially adding more trait methods after the trait is `#[stable]`.\n    #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n    pub trait Sealed {}}\n\n/// Supporting trait for inherent methods of `f32` and `f64` such as `round_unchecked_to`.\n/// Typically doesn’t need to be used directly.\n#[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\npub trait FloatToInt<Int>: private::Sealed + Sized {\n}\n\nmacro_rules! impl_float_to_int {\n    ( $Float: ident => $( $Int: ident )+ ) => {\n        #[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\n        impl private::Sealed for $Float {}}\n}\n\nimpl_float_to_int!(f32 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\nimpl_float_to_int!(f64 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n\n// Conversion traits for primitive integer and float types\n// Conversions T -> T are covered by a blanket impl and therefore excluded\n// Some conversions from and to usize/isize are not implemented due to portability concerns\nmacro_rules! impl_from {\n    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n        #[$attr]\n        #[doc = $doc]\n        impl From<$Small> for $Large {\n            #[inline]\n            fn from(small: $Small) -> Self {\n}\n        }\n    };\n    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n        impl_from!($Small,\n                   $Large,\n                   #[$attr],\n                   concat!(\"Converts `\",\n                           stringify!($Small),\n                           \"` to `\",\n                           stringify!($Large),\n                           \"` losslessly.\"));\n    }\n}\n\nmacro_rules! impl_from_bool {\n    ($target: ty, #[$attr:meta]) => {\n        impl_from!(bool, $target, #[$attr], concat!(\"Converts a `bool` to a `\",\n            stringify!($target), \"`. The resulting value is `0` for `false` and `1` for `true`\nvalues.\n\n# Examples\n\n```\nassert_eq!(\", stringify!($target), \"::from(true), 1);\nassert_eq!(\", stringify!($target), \"::from(false), 0);\n```\"));\n    };\n}\n\n// Bool -> Any\nimpl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\nimpl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n\n// Unsigned -> Unsigned\nimpl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n\n// Signed -> Signed\nimpl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n\n// Unsigned -> Signed\nimpl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\nimpl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\nimpl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n\n// The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n// which imply that pointer-sized integers must be at least 16 bits:\n// https://port70.net/~nsz/c/c99/n1256.html#7.18.2.4\nimpl_from! { u16, usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\nimpl_from! { u8, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\nimpl_from! { i16, isize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")] }\n\n// RISC-V defines the possibility of a 128-bit address space (RV128).\n\n// CHERI proposes 256-bit “capabilities”. Unclear if this would be relevant to usize/isize.\n// https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\n// http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\n\n// Note: integers can only be represented with full precision in a float if\n// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n// Lossy float conversions are not implemented at this time.\n\n// Signed -> Float\nimpl_from! { i8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { i32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n\n// Unsigned -> Float\nimpl_from! { u8, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u8, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u16, f32, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u16, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\nimpl_from! { u32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n\n// Float -> Float\nimpl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\")] }\n\n// no possible bounds violation\nmacro_rules! try_from_unbounded {\n    ($source:ty, $($target:ty),*) => {$(\n        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n        impl TryFrom<$source> for $target {\n            type Error = TryFromIntError;\n\n            /// Try to create the target number type from a source\n            /// number type. This returns an error if the source value\n            /// is outside of the range of the target type.\n            #[inline]\n            fn try_from(value: $source) -> Result<Self, Self::Error> {\n}\n        }\n    )*}\n}\n\n// only negative bounds\nmacro_rules! try_from_lower_bounded {\n    ($source:ty, $($target:ty),*) => {$(\n        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n        impl TryFrom<$source> for $target {\n            type Error = TryFromIntError;\n\n            /// Try to create the target number type from a source\n            /// number type. This returns an error if the source value\n            /// is outside of the range of the target type.\n            #[inline]\n            fn try_from(u: $source) -> Result<Self, Self::Error> {\n}\n        }\n    )*}\n}\n\n// unsigned to signed (only positive bound)\nmacro_rules! try_from_upper_bounded {\n    ($source:ty, $($target:ty),*) => {$(\n        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n        impl TryFrom<$source> for $target {\n            type Error = TryFromIntError;\n\n            /// Try to create the target number type from a source\n            /// number type. This returns an error if the source value\n            /// is outside of the range of the target type.\n            #[inline]\n            fn try_from(u: $source) -> Result<Self, Self::Error> {\n}\n        }\n    )*}\n}\n\n// all other cases\nmacro_rules! try_from_both_bounded {\n    ($source:ty, $($target:ty),*) => {$(\n        #[stable(feature = \"try_from\", since = \"1.34.0\")]\n        impl TryFrom<$source> for $target {\n            type Error = TryFromIntError;\n\n            /// Try to create the target number type from a source\n            /// number type. This returns an error if the source value\n            /// is outside of the range of the target type.\n            #[inline]\n            fn try_from(u: $source) -> Result<Self, Self::Error> {\n}\n        }\n    )*}\n}\n\nmacro_rules! rev {\n    ($mac:ident, $source:ty, $($target:ty),*) => {$(\n        $mac!($target, $source);\n    )*}\n}\n\n// intra-sign conversions\ntry_from_upper_bounded!(u16, u8);\ntry_from_upper_bounded!(u32, u16, u8);\ntry_from_upper_bounded!(u64, u32, u16, u8);\ntry_from_upper_bounded!(u128, u64, u32, u16, u8);\n\ntry_from_both_bounded!(i16, i8);\ntry_from_both_bounded!(i32, i16, i8);\ntry_from_both_bounded!(i64, i32, i16, i8);\ntry_from_both_bounded!(i128, i64, i32, i16, i8);\n\n// unsigned-to-signed\ntry_from_upper_bounded!(u8, i8);\ntry_from_upper_bounded!(u16, i8, i16);\ntry_from_upper_bounded!(u32, i8, i16, i32);\ntry_from_upper_bounded!(u64, i8, i16, i32, i64);\ntry_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n\n// signed-to-unsigned\ntry_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\ntry_from_lower_bounded!(i16, u16, u32, u64, u128);\ntry_from_lower_bounded!(i32, u32, u64, u128);\ntry_from_lower_bounded!(i64, u64, u128);\ntry_from_lower_bounded!(i128, u128);\ntry_from_both_bounded!(i16, u8);\ntry_from_both_bounded!(i32, u16, u8);\ntry_from_both_bounded!(i64, u32, u16, u8);\ntry_from_both_bounded!(i128, u64, u32, u16, u8);\n\n// usize/isize\ntry_from_upper_bounded!(usize, isize);\ntry_from_lower_bounded!(isize, usize);\n\n#[cfg(target_pointer_width = \"16\")]\nmod ptr_try_from_impls {\n    use super::TryFromIntError;\n    use crate::convert::TryFrom;\n\n    try_from_upper_bounded!(usize, u8);\n    try_from_unbounded!(usize, u16, u32, u64, u128);\n    try_from_upper_bounded!(usize, i8, i16);\n    try_from_unbounded!(usize, i32, i64, i128);\n\n    try_from_both_bounded!(isize, u8);\n    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n    try_from_both_bounded!(isize, i8);\n    try_from_unbounded!(isize, i16, i32, i64, i128);\n\n    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n    rev!(try_from_lower_bounded, usize, i8, i16);\n    rev!(try_from_both_bounded, usize, i32, i64, i128);\n\n    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n    rev!(try_from_both_bounded, isize, i32, i64, i128);\n}\n\n#[cfg(target_pointer_width = \"32\")]\nmod ptr_try_from_impls {\n    use super::TryFromIntError;\n    use crate::convert::TryFrom;\n\n    try_from_upper_bounded!(usize, u8, u16);\n    try_from_unbounded!(usize, u32, u64, u128);\n    try_from_upper_bounded!(usize, i8, i16, i32);\n    try_from_unbounded!(usize, i64, i128);\n\n    try_from_both_bounded!(isize, u8, u16);\n    try_from_lower_bounded!(isize, u32, u64, u128);\n    try_from_both_bounded!(isize, i8, i16);\n    try_from_unbounded!(isize, i32, i64, i128);\n\n    rev!(try_from_unbounded, usize, u32);\n    rev!(try_from_upper_bounded, usize, u64, u128);\n    rev!(try_from_lower_bounded, usize, i8, i16, i32);\n    rev!(try_from_both_bounded, usize, i64, i128);\n\n    rev!(try_from_unbounded, isize, u16);\n    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n    rev!(try_from_unbounded, isize, i32);\n    rev!(try_from_both_bounded, isize, i64, i128);\n}\n\n#[cfg(target_pointer_width = \"64\")]\nmod ptr_try_from_impls {\n    use super::TryFromIntError;\n    use crate::convert::TryFrom;\n\n    try_from_upper_bounded!(usize, u8, u16, u32);\n    try_from_unbounded!(usize, u64, u128);\n    try_from_upper_bounded!(usize, i8, i16, i32, i64);\n    try_from_unbounded!(usize, i128);\n\n    try_from_both_bounded!(isize, u8, u16, u32);\n    try_from_lower_bounded!(isize, u64, u128);\n    try_from_both_bounded!(isize, i8, i16, i32);\n    try_from_unbounded!(isize, i64, i128);\n\n    rev!(try_from_unbounded, usize, u32, u64);\n    rev!(try_from_upper_bounded, usize, u128);\n    rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n    rev!(try_from_both_bounded, usize, i128);\n\n    rev!(try_from_unbounded, isize, u16, u32);\n    rev!(try_from_upper_bounded, isize, u64, u128);\n    rev!(try_from_unbounded, isize, i32, i64);\n    rev!(try_from_both_bounded, isize, i128);\n}\n\n// Conversion traits for non-zero integer types\nuse crate::num::NonZeroI128;\nuse crate::num::NonZeroI16;\nuse crate::num::NonZeroI32;\nuse crate::num::NonZeroI64;\nuse crate::num::NonZeroI8;\nuse crate::num::NonZeroIsize;\nuse crate::num::NonZeroU128;\nuse crate::num::NonZeroU16;\nuse crate::num::NonZeroU32;\nuse crate::num::NonZeroU64;\nuse crate::num::NonZeroU8;\nuse crate::num::NonZeroUsize;\n\nmacro_rules! nzint_impl_from {\n    ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n        #[$attr]\n        #[doc = $doc]\n        impl From<$Small> for $Large {\n            #[inline]\n            fn from(small: $Small) -> Self {\n}\n        }\n    };\n    ($Small: ty, $Large: ty, #[$attr:meta]) => {\n        nzint_impl_from!($Small,\n                   $Large,\n                   #[$attr],\n                   concat!(\"Converts `\",\n                           stringify!($Small),\n                           \"` to `\",\n                           stringify!($Large),\n                           \"` losslessly.\"));\n    }\n}\n\n// Non-zero Unsigned -> Non-zero Unsigned\nnzint_impl_from! { NonZeroU8, NonZeroU16, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroU32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroU64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroUsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroU32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroU64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroUsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU32, NonZeroU64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU32, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU64, NonZeroU128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n\n// Non-zero Signed -> Non-zero Signed\nnzint_impl_from! { NonZeroI8, NonZeroI16, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI8, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI8, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI8, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI8, NonZeroIsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI16, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI16, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI16, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI16, NonZeroIsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI32, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI32, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroI64, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n\n// NonZero UnSigned -> Non-zero Signed\nnzint_impl_from! { NonZeroU8, NonZeroI16, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU8, NonZeroIsize, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroI32, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU16, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU32, NonZeroI64, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU32, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\nnzint_impl_from! { NonZeroU64, NonZeroI128, #[stable(feature = \"nz_int_conv\", since = \"1.41.0\")] }\n}\n\n#[unstable(feature = \"convert_float_to_int\", issue = \"67057\")]\npub use num::FloatToInt;\n\n/// The identity function.\n///\n/// Two things are important to note about this function:\n///\n/// - It is not always equivalent to a closure like `|x| x`, since the\n///   closure may coerce `x` into a different type.\n///\n/// - It moves the input `x` passed to the function.\n///\n/// While it might seem strange to have a function that just returns back the\n/// input, there are some interesting uses.\n///\n/// # Examples\n///\n/// Using `identity` to do nothing in a sequence of other, interesting,\n/// functions:\n///\n/// ```rust\n/// use std::convert::identity;\n///\n/// fn manipulation(x: u32) -> u32 {\n///     // Let's pretend that adding one is an interesting function.\n///     x + 1\n/// }\n///\n/// let _arr = &[identity, manipulation];\n/// ```\n///\n/// Using `identity` as a \"do nothing\" base case in a conditional:\n///\n/// ```rust\n/// use std::convert::identity;\n///\n/// # let condition = true;\n/// #\n/// # fn manipulation(x: u32) -> u32 { x + 1 }\n/// #\n/// let do_stuff = if condition { manipulation } else { identity };\n///\n/// // Do more interesting stuff...\n///\n/// let _results = do_stuff(42);\n/// ```\n///\n/// Using `identity` to keep the `Some` variants of an iterator of `Option<T>`:\n///\n/// ```rust\n/// use std::convert::identity;\n///\n/// let iter = vec![Some(1), None, Some(3)].into_iter();\n/// let filtered = iter.filter_map(identity).collect::<Vec<_>>();\n/// assert_eq!(vec![1, 3], filtered);\n/// ```\n#[stable(feature = \"convert_id\", since = \"1.33.0\")]\n#[rustc_const_stable(feature = \"const_identity\", since = \"1.33.0\")]\n#[inline]\npub const fn identity<T>(x: T) -> T {\n}\n\n/// Used to do a cheap reference-to-reference conversion.\n///\n/// This trait is similar to [`AsMut`] which is used for converting between mutable references.\n/// If you need to do a costly conversion it is better to implement [`From`] with type\n/// `&T` or write a custom function.\n///\n/// `AsRef` has the same signature as [`Borrow`], but [`Borrow`] is different in few aspects:\n///\n/// - Unlike `AsRef`, [`Borrow`] has a blanket impl for any `T`, and can be used to accept either\n///   a reference or a value.\n/// - [`Borrow`] also requires that [`Hash`], [`Eq`] and [`Ord`] for borrowed value are\n///   equivalent to those of the owned value. For this reason, if you want to\n///   borrow only a single field of a struct you can implement `AsRef`, but not [`Borrow`].\n///\n/// **Note: This trait must not fail**. If the conversion can fail, use a\n/// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n///\n/// # Generic Implementations\n///\n/// - `AsRef` auto-dereferences if the inner type is a reference or a mutable\n///   reference (e.g.: `foo.as_ref()` will work the same if `foo` has type\n///   `&mut Foo` or `&&mut Foo`)\n///\n/// # Examples\n///\n/// By using trait bounds we can accept arguments of different types as long as they can be\n/// converted to the specified type `T`.\n///\n/// For example: By creating a generic function that takes an `AsRef<str>` we express that we\n/// want to accept all references that can be converted to [`&str`] as an argument.\n/// Since both [`String`] and [`&str`] implement `AsRef<str>` we can accept both as input argument.\n///\n/// [`Option<T>`]: ../../std/option/enum.Option.html\n/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n/// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n/// [`Hash`]: ../../std/hash/trait.Hash.html\n/// [`Eq`]: ../../std/cmp/trait.Eq.html\n/// [`Ord`]: ../../std/cmp/trait.Ord.html\n/// [`&str`]: ../../std/primitive.str.html\n/// [`String`]: ../../std/string/struct.String.html\n///\n/// ```\n/// fn is_hello<T: AsRef<str>>(s: T) {\n///    assert_eq!(\"hello\", s.as_ref());\n/// }\n///\n/// let s = \"hello\";\n/// is_hello(s);\n///\n/// let s = \"hello\".to_string();\n/// is_hello(s);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait AsRef<T: ?Sized> {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn as_ref(&self) -> &T;\n}\n\n/// Used to do a cheap mutable-to-mutable reference conversion.\n///\n/// This trait is similar to [`AsRef`] but used for converting between mutable\n/// references. If you need to do a costly conversion it is better to\n/// implement [`From`] with type `&mut T` or write a custom function.\n///\n/// **Note: This trait must not fail**. If the conversion can fail, use a\n/// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n///\n/// [`Option<T>`]: ../../std/option/enum.Option.html\n/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n///\n/// # Generic Implementations\n///\n/// - `AsMut` auto-dereferences if the inner type is a mutable reference\n///   (e.g.: `foo.as_mut()` will work the same if `foo` has type `&mut Foo`\n///   or `&mut &mut Foo`)\n///\n/// # Examples\n///\n/// Using `AsMut` as trait bound for a generic function we can accept all mutable references\n/// that can be converted to type `&mut T`. Because [`Box<T>`] implements `AsMut<T>` we can\n/// write a function `add_one` that takes all arguments that can be converted to `&mut u64`.\n/// Because [`Box<T>`] implements `AsMut<T>`, `add_one` accepts arguments of type\n/// `&mut Box<u64>` as well:\n///\n/// ```\n/// fn add_one<T: AsMut<u64>>(num: &mut T) {\n///     *num.as_mut() += 1;\n/// }\n///\n/// let mut boxed_num = Box::new(0);\n/// add_one(&mut boxed_num);\n/// assert_eq!(*boxed_num, 1);\n/// ```\n///\n/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait AsMut<T: ?Sized> {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn as_mut(&mut self) -> &mut T;\n}\n\n/// A value-to-value conversion that consumes the input value. The\n/// opposite of [`From`].\n///\n/// One should avoid implementing [`Into`] and implement [`From`] instead.\n/// Implementing [`From`] automatically provides one with an implementation of [`Into`]\n/// thanks to the blanket implementation in the standard library.\n///\n/// Prefer using [`Into`] over [`From`] when specifying trait bounds on a generic function\n/// to ensure that types that only implement [`Into`] can be used as well.\n///\n/// **Note: This trait must not fail**. If the conversion can fail, use [`TryInto`].\n///\n/// # Generic Implementations\n///\n/// - [`From`]`<T> for U` implies `Into<U> for T`\n/// - [`Into`] is reflexive, which means that `Into<T> for T` is implemented\n///\n/// # Implementing [`Into`] for conversions to external types in old versions of Rust\n///\n/// Prior to Rust 1.40, if the destination type was not part of the current crate\n/// then you couldn't implement [`From`] directly.\n/// For example, take this code:\n///\n/// ```\n/// struct Wrapper<T>(Vec<T>);\n/// impl<T> From<Wrapper<T>> for Vec<T> {\n///     fn from(w: Wrapper<T>) -> Vec<T> {\n///         w.0\n///     }\n/// }\n/// ```\n/// This will fail to compile in older versions of the language because Rust's orphaning rules\n/// used to be a little bit more strict. To bypass this, you could implement [`Into`] directly:\n///\n/// ```\n/// struct Wrapper<T>(Vec<T>);\n/// impl<T> Into<Vec<T>> for Wrapper<T> {\n///     fn into(self) -> Vec<T> {\n///         self.0\n///     }\n/// }\n/// ```\n///\n/// It is important to understand that [`Into`] does not provide a [`From`] implementation\n/// (as [`From`] does with [`Into`]). Therefore, you should always try to implement [`From`]\n/// and then fall back to [`Into`] if [`From`] can't be implemented.\n///\n/// # Examples\n///\n/// [`String`] implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>`:\n///\n/// In order to express that we want a generic function to take all arguments that can be\n/// converted to a specified type `T`, we can use a trait bound of [`Into`]`<T>`.\n/// For example: The function `is_hello` takes all arguments that can be converted into a\n/// [`Vec`]`<`[`u8`]`>`.\n///\n/// ```\n/// fn is_hello<T: Into<Vec<u8>>>(s: T) {\n///    let bytes = b\"hello\".to_vec();\n///    assert_eq!(bytes, s.into());\n/// }\n///\n/// let s = \"hello\".to_string();\n/// is_hello(s);\n/// ```\n///\n/// [`TryInto`]: trait.TryInto.html\n/// [`Option<T>`]: ../../std/option/enum.Option.html\n/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [`From`]: trait.From.html\n/// [`Into`]: trait.Into.html\n/// [`Vec`]: ../../std/vec/struct.Vec.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Into<T>: Sized {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn into(self) -> T;\n}\n\n/// Used to do value-to-value conversions while consuming the input value. It is the reciprocal of\n/// [`Into`].\n///\n/// One should always prefer implementing `From` over [`Into`]\n/// because implementing `From` automatically provides one with an implementation of [`Into`]\n/// thanks to the blanket implementation in the standard library.\n///\n/// Only implement [`Into`] if a conversion to a type outside the current crate is required.\n/// `From` cannot do these type of conversions because of Rust's orphaning rules.\n/// See [`Into`] for more details.\n///\n/// Prefer using [`Into`] over using `From` when specifying trait bounds on a generic function.\n/// This way, types that directly implement [`Into`] can be used as arguments as well.\n///\n/// The `From` is also very useful when performing error handling. When constructing a function\n/// that is capable of failing, the return type will generally be of the form `Result<T, E>`.\n/// The `From` trait simplifies error handling by allowing a function to return a single error type\n/// that encapsulate multiple error types. See the \"Examples\" section and [the book][book] for more\n/// details.\n///\n/// **Note: This trait must not fail**. If the conversion can fail, use [`TryFrom`].\n///\n/// # Generic Implementations\n///\n/// - `From<T> for U` implies [`Into`]`<U> for T`\n/// - `From` is reflexive, which means that `From<T> for T` is implemented\n///\n/// # Examples\n///\n/// [`String`] implements `From<&str>`:\n///\n/// An explicit conversion from a `&str` to a String is done as follows:\n///\n/// ```\n/// let string = \"hello\".to_string();\n/// let other_string = String::from(\"hello\");\n///\n/// assert_eq!(string, other_string);\n/// ```\n///\n/// While performing error handling it is often useful to implement `From` for your own error type.\n/// By converting underlying error types to our own custom error type that encapsulates the\n/// underlying error type, we can return a single error type without losing information on the\n/// underlying cause. The '?' operator automatically converts the underlying error type to our\n/// custom error type by calling `Into<CliError>::into` which is automatically provided when\n/// implementing `From`. The compiler then infers which implementation of `Into` should be used.\n///\n/// ```\n/// use std::fs;\n/// use std::io;\n/// use std::num;\n///\n/// enum CliError {\n///     IoError(io::Error),\n///     ParseError(num::ParseIntError),\n/// }\n///\n/// impl From<io::Error> for CliError {\n///     fn from(error: io::Error) -> Self {\n///         CliError::IoError(error)\n///     }\n/// }\n///\n/// impl From<num::ParseIntError> for CliError {\n///     fn from(error: num::ParseIntError) -> Self {\n///         CliError::ParseError(error)\n///     }\n/// }\n///\n/// fn open_and_parse_file(file_name: &str) -> Result<i32, CliError> {\n///     let mut contents = fs::read_to_string(&file_name)?;\n///     let num: i32 = contents.trim().parse()?;\n///     Ok(num)\n/// }\n/// ```\n///\n/// [`TryFrom`]: trait.TryFrom.html\n/// [`Option<T>`]: ../../std/option/enum.Option.html\n/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [`Into`]: trait.Into.html\n/// [`from`]: trait.From.html#tymethod.from\n/// [book]: ../../book/ch09-00-error-handling.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(on(\n    all(_Self = \"&str\", T = \"std::string::String\"),\n    note = \"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\",\n))]\npub trait From<T>: Sized {\n    /// Performs the conversion.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn from(_: T) -> Self;\n}\n\n/// An attempted conversion that consumes `self`, which may or may not be\n/// expensive.\n///\n/// Library authors should usually not directly implement this trait,\n/// but should prefer implementing the [`TryFrom`] trait, which offers\n/// greater flexibility and provides an equivalent `TryInto`\n/// implementation for free, thanks to a blanket implementation in the\n/// standard library. For more information on this, see the\n/// documentation for [`Into`].\n///\n/// # Implementing `TryInto`\n///\n/// This suffers the same restrictions and reasoning as implementing\n/// [`Into`], see there for details.\n///\n/// [`TryFrom`]: trait.TryFrom.html\n/// [`Into`]: trait.Into.html\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\npub trait TryInto<T>: Sized {\n    /// The type returned in the event of a conversion error.\n    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n    type Error;\n\n    /// Performs the conversion.\n    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n    fn try_into(self) -> Result<T, Self::Error>;\n}\n\n/// Simple and safe type conversions that may fail in a controlled\n/// way under some circumstances. It is the reciprocal of [`TryInto`].\n///\n/// This is useful when you are doing a type conversion that may\n/// trivially succeed but may also need special handling.\n/// For example, there is no way to convert an [`i64`] into an [`i32`]\n/// using the [`From`] trait, because an [`i64`] may contain a value\n/// that an [`i32`] cannot represent and so the conversion would lose data.\n/// This might be handled by truncating the [`i64`] to an [`i32`] (essentially\n/// giving the [`i64`]'s value modulo [`i32::MAX`]) or by simply returning\n/// [`i32::MAX`], or by some other method.  The [`From`] trait is intended\n/// for perfect conversions, so the `TryFrom` trait informs the\n/// programmer when a type conversion could go bad and lets them\n/// decide how to handle it.\n///\n/// # Generic Implementations\n///\n/// - `TryFrom<T> for U` implies [`TryInto`]`<U> for T`\n/// - [`try_from`] is reflexive, which means that `TryFrom<T> for T`\n/// is implemented and cannot fail -- the associated `Error` type for\n/// calling `T::try_from()` on a value of type `T` is [`Infallible`].\n/// When the [`!`] type is stabilized [`Infallible`] and [`!`] will be\n/// equivalent.\n///\n/// `TryFrom<T>` can be implemented as follows:\n///\n/// ```\n/// use std::convert::TryFrom;\n///\n/// struct GreaterThanZero(i32);\n///\n/// impl TryFrom<i32> for GreaterThanZero {\n///     type Error = &'static str;\n///\n///     fn try_from(value: i32) -> Result<Self, Self::Error> {\n///         if value <= 0 {\n///             Err(\"GreaterThanZero only accepts value superior than zero!\")\n///         } else {\n///             Ok(GreaterThanZero(value))\n///         }\n///     }\n/// }\n/// ```\n///\n/// # Examples\n///\n/// As described, [`i32`] implements `TryFrom<`[`i64`]`>`:\n///\n/// ```\n/// use std::convert::TryFrom;\n///\n/// let big_number = 1_000_000_000_000i64;\n/// // Silently truncates `big_number`, requires detecting\n/// // and handling the truncation after the fact.\n/// let smaller_number = big_number as i32;\n/// assert_eq!(smaller_number, -727379968);\n///\n/// // Returns an error because `big_number` is too big to\n/// // fit in an `i32`.\n/// let try_smaller_number = i32::try_from(big_number);\n/// assert!(try_smaller_number.is_err());\n///\n/// // Returns `Ok(3)`.\n/// let try_successful_smaller_number = i32::try_from(3);\n/// assert!(try_successful_smaller_number.is_ok());\n/// ```\n///\n/// [`try_from`]: trait.TryFrom.html#tymethod.try_from\n/// [`TryInto`]: trait.TryInto.html\n/// [`i32::MAX`]: ../../std/i32/constant.MAX.html\n/// [`!`]: ../../std/primitive.never.html\n/// [`Infallible`]: enum.Infallible.html\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\npub trait TryFrom<T>: Sized {\n    /// The type returned in the event of a conversion error.\n    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n    type Error;\n\n    /// Performs the conversion.\n    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n    fn try_from(value: T) -> Result<Self, Self::Error>;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// GENERIC IMPLS\n////////////////////////////////////////////////////////////////////////////////\n\n// As lifts over &\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized, U: ?Sized> AsRef<U> for &T\nwhere\n    T: AsRef<U>,\n{\n    fn as_ref(&self) -> &U {\n}\n}\n\n// As lifts over &mut\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T\nwhere\n    T: AsRef<U>,\n{\n    fn as_ref(&self) -> &U {\n}\n}\n\n// FIXME (#45742): replace the above impls for &/&mut with the following more general one:\n// // As lifts over Deref\n// impl<D: ?Sized + Deref<Target: AsRef<U>>, U: ?Sized> AsRef<U> for D {\n//     fn as_ref(&self) -> &U {\n//         self.deref().as_ref()\n//     }\n// }\n\n// AsMut lifts over &mut\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T\nwhere\n    T: AsMut<U>,\n{\n    fn as_mut(&mut self) -> &mut U {\n}\n}\n\n// FIXME (#45742): replace the above impl for &mut with the following more general one:\n// // AsMut lifts over DerefMut\n// impl<D: ?Sized + Deref<Target: AsMut<U>>, U: ?Sized> AsMut<U> for D {\n//     fn as_mut(&mut self) -> &mut U {\n//         self.deref_mut().as_mut()\n//     }\n// }\n\n// From implies Into\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, U> Into<U> for T\nwhere\n    U: From<T>,\n{\n    fn into(self) -> U {\n}\n}\n\n// From (and thus Into) is reflexive\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> From<T> for T {\n    fn from(t: T) -> T {\n}\n}\n\n/// **Stability note:** This impl does not yet exist, but we are\n/// \"reserving space\" to add it in the future. See\n/// [rust-lang/rust#64715][#64715] for details.\n///\n/// [#64715]: https://github.com/rust-lang/rust/issues/64715\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n#[allow(unused_attributes)] // FIXME(#58633): do a principled fix instead.\n#[rustc_reservation_impl = \"permitting this impl would forbid us from adding \\\n                            `impl<T> From<!> for T` later; see rust-lang/rust#64715 for details\"]\nimpl<T> From<!> for T {\n    fn from(t: !) -> T {\n}\n}\n\n// TryFrom implies TryInto\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl<T, U> TryInto<U> for T\nwhere\n    U: TryFrom<T>,\n{\n    type Error = U::Error;\n\n    fn try_into(self) -> Result<U, U::Error> {\n}\n}\n\n// Infallible conversions are semantically equivalent to fallible conversions\n// with an uninhabited error type.\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl<T, U> TryFrom<U> for T\nwhere\n    U: Into<T>,\n{\n    type Error = Infallible;\n\n    fn try_from(value: U) -> Result<Self, Self::Error> {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// CONCRETE IMPLS\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsRef<[T]> for [T] {\n    fn as_ref(&self) -> &[T] {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsMut<[T]> for [T] {\n    fn as_mut(&mut self) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<str> for str {\n    #[inline]\n    fn as_ref(&self) -> &str {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// THE NO-ERROR ERROR TYPE\n////////////////////////////////////////////////////////////////////////////////\n\n/// The error type for errors that can never happen.\n///\n/// Since this enum has no variant, a value of this type can never actually exist.\n/// This can be useful for generic APIs that use [`Result`] and parameterize the error type,\n/// to indicate that the result is always [`Ok`].\n///\n/// For example, the [`TryFrom`] trait (conversion that returns a [`Result`])\n/// has a blanket implementation for all types where a reverse [`Into`] implementation exists.\n///\n/// ```ignore (illustrates std code, duplicating the impl in a doctest would be an error)\n/// impl<T, U> TryFrom<U> for T where U: Into<T> {\n///     type Error = Infallible;\n///\n///     fn try_from(value: U) -> Result<Self, Infallible> {\n///         Ok(U::into(value))  // Never returns `Err`\n///     }\n/// }\n/// ```\n///\n/// # Future compatibility\n///\n/// This enum has the same role as [the `!` “never” type][never],\n/// which is unstable in this version of Rust.\n/// When `!` is stabilized, we plan to make `Infallible` a type alias to it:\n///\n/// ```ignore (illustrates future std change)\n/// pub type Infallible = !;\n/// ```\n///\n/// … and eventually deprecate `Infallible`.\n///\n///\n/// However there is one case where `!` syntax can be used\n/// before `!` is stabilized as a full-fleged type: in the position of a function’s return type.\n/// Specifically, it is possible implementations for two different function pointer types:\n///\n/// ```\n/// trait MyTrait {}\n/// impl MyTrait for fn() -> ! {}\n/// impl MyTrait for fn() -> std::convert::Infallible {}\n/// ```\n///\n/// With `Infallible` being an enum, this code is valid.\n/// However when `Infallible` becomes an alias for the never type,\n/// the two `impl`s will start to overlap\n/// and therefore will be disallowed by the language’s trait coherence rules.\n///\n/// [`Ok`]: ../result/enum.Result.html#variant.Ok\n/// [`Result`]: ../result/enum.Result.html\n/// [`TryFrom`]: trait.TryFrom.html\n/// [`Into`]: trait.Into.html\n/// [never]: ../../std/primitive.never.html\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n#[derive(Copy)]\npub enum Infallible {}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl Clone for Infallible {\n    fn clone(&self) -> Infallible {\n}\n}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl fmt::Debug for Infallible {\n    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl fmt::Display for Infallible {\n    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl PartialEq for Infallible {\n    fn eq(&self, _: &Infallible) -> bool {\n}\n}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl Eq for Infallible {}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl PartialOrd for Infallible {\n    fn partial_cmp(&self, _other: &Self) -> Option<crate::cmp::Ordering> {\n}\n}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl Ord for Infallible {\n    fn cmp(&self, _other: &Self) -> crate::cmp::Ordering {\n}\n}\n\n#[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\nimpl From<!> for Infallible {\n    fn from(x: !) -> Self {\n}\n}\n}\n#[cfg(not(test))] // See #65860\npub mod default {\n//! The `Default` trait for types which may have meaningful default values.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n/// A trait for giving a type a useful default value.\n///\n/// Sometimes, you want to fall back to some kind of default value, and\n/// don't particularly care what it is. This comes up often with `struct`s\n/// that define a set of options:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// struct SomeOptions {\n///     foo: i32,\n///     bar: f32,\n/// }\n/// ```\n///\n/// How can we define some default values? You can use `Default`:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// #[derive(Default)]\n/// struct SomeOptions {\n///     foo: i32,\n///     bar: f32,\n/// }\n///\n/// fn main() {\n///     let options: SomeOptions = Default::default();\n/// }\n/// ```\n///\n/// Now, you get all of the default values. Rust implements `Default` for various primitives types.\n///\n/// If you want to override a particular option, but still retain the other defaults:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// # #[derive(Default)]\n/// # struct SomeOptions {\n/// #     foo: i32,\n/// #     bar: f32,\n/// # }\n/// fn main() {\n///     let options = SomeOptions { foo: 42, ..Default::default() };\n/// }\n/// ```\n///\n/// ## Derivable\n///\n/// This trait can be used with `#[derive]` if all of the type's fields implement\n/// `Default`. When `derive`d, it will use the default value for each field's type.\n///\n/// ## How can I implement `Default`?\n///\n/// Provides an implementation for the `default()` method that returns the value of\n/// your type that should be the default:\n///\n/// ```\n/// # #![allow(dead_code)]\n/// enum Kind {\n///     A,\n///     B,\n///     C,\n/// }\n///\n/// impl Default for Kind {\n///     fn default() -> Self { Kind::A }\n/// }\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// # #[allow(dead_code)]\n/// #[derive(Default)]\n/// struct SomeOptions {\n///     foo: i32,\n///     bar: f32,\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Default: Sized {\n    /// Returns the \"default value\" for a type.\n    ///\n    /// Default values are often some kind of initial value, identity value, or anything else that\n    /// may make sense as a default.\n    ///\n    /// # Examples\n    ///\n    /// Using built-in default values:\n    ///\n    /// ```\n    /// let i: i8 = Default::default();\n    /// let (x, y): (Option<String>, f64) = Default::default();\n    /// let (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default();\n    /// ```\n    ///\n    /// Making your own:\n    ///\n    /// ```\n    /// # #[allow(dead_code)]\n    /// enum Kind {\n    ///     A,\n    ///     B,\n    ///     C,\n    /// }\n    ///\n    /// impl Default for Kind {\n    ///     fn default() -> Self { Kind::A }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn default() -> Self;\n}\n\n/// Derive macro generating an impl of the trait `Default`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics)]\npub macro Default($item:item) {\n    /* compiler built-in */\n}\n\nmacro_rules! default_impl {\n    ($t:ty, $v:expr, $doc:tt) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Default for $t {\n            #[inline]\n            #[doc = $doc]\n            fn default() -> $t { }\n        }\n    }\n}\n\ndefault_impl! { (), (), \"Returns the default value of `()`\" }\ndefault_impl! { bool, false, \"Returns the default value of `false`\" }\ndefault_impl! { char, '\\x00', \"Returns the default value of `\\\\x00`\" }\n\ndefault_impl! { usize, 0, \"Returns the default value of `0`\" }\ndefault_impl! { u8, 0, \"Returns the default value of `0`\" }\ndefault_impl! { u16, 0, \"Returns the default value of `0`\" }\ndefault_impl! { u32, 0, \"Returns the default value of `0`\" }\ndefault_impl! { u64, 0, \"Returns the default value of `0`\" }\ndefault_impl! { u128, 0, \"Returns the default value of `0`\" }\n\ndefault_impl! { isize, 0, \"Returns the default value of `0`\" }\ndefault_impl! { i8, 0, \"Returns the default value of `0`\" }\ndefault_impl! { i16, 0, \"Returns the default value of `0`\" }\ndefault_impl! { i32, 0, \"Returns the default value of `0`\" }\ndefault_impl! { i64, 0, \"Returns the default value of `0`\" }\ndefault_impl! { i128, 0, \"Returns the default value of `0`\" }\n\ndefault_impl! { f32, 0.0f32, \"Returns the default value of `0.0`\" }\ndefault_impl! { f64, 0.0f64, \"Returns the default value of `0.0`\" }\n}\n#[cfg(not(test))] // See #65860\npub mod marker {\n//! Primitive traits and types representing basic properties of types.\n//!\n//! Rust types can be classified in various useful ways according to\n//! their intrinsic properties. These classifications are represented\n//! as traits.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::cell::UnsafeCell;\nuse crate::cmp;\nuse crate::hash::Hash;\nuse crate::hash::Hasher;\n\n/// Types that can be transferred across thread boundaries.\n///\n/// This trait is automatically implemented when the compiler determines it's\n/// appropriate.\n///\n/// An example of a non-`Send` type is the reference-counting pointer\n/// [`rc::Rc`][`Rc`]. If two threads attempt to clone [`Rc`]s that point to the same\n/// reference-counted value, they might try to update the reference count at the\n/// same time, which is [undefined behavior][ub] because [`Rc`] doesn't use atomic\n/// operations. Its cousin [`sync::Arc`][arc] does use atomic operations (incurring\n/// some overhead) and thus is `Send`.\n///\n/// See [the Nomicon](../../nomicon/send-and-sync.html) for more details.\n///\n/// [`Rc`]: ../../std/rc/struct.Rc.html\n/// [arc]: ../../std/sync/struct.Arc.html\n/// [ub]: ../../reference/behavior-considered-undefined.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[cfg_attr(not(test), rustc_diagnostic_item = \"send_trait\")]\n#[rustc_on_unimplemented(\n    message = \"`{Self}` cannot be sent between threads safely\",\n    label = \"`{Self}` cannot be sent between threads safely\"\n)]\npub unsafe auto trait Send {\n    // empty.\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !Send for *const T {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !Send for *mut T {}\n\n/// Types with a constant size known at compile time.\n///\n/// All type parameters have an implicit bound of `Sized`. The special syntax\n/// `?Sized` can be used to remove this bound if it's not appropriate.\n///\n/// ```\n/// # #![allow(dead_code)]\n/// struct Foo<T>(T);\n/// struct Bar<T: ?Sized>(T);\n///\n/// // struct FooUse(Foo<[i32]>); // error: Sized is not implemented for [i32]\n/// struct BarUse(Bar<[i32]>); // OK\n/// ```\n///\n/// The one exception is the implicit `Self` type of a trait. A trait does not\n/// have an implicit `Sized` bound as this is incompatible with [trait object]s\n/// where, by definition, the trait needs to work with all possible implementors,\n/// and thus could be any size.\n///\n/// Although Rust will let you bind `Sized` to a trait, you won't\n/// be able to use it to form a trait object later:\n///\n/// ```\n/// # #![allow(unused_variables)]\n/// trait Foo { }\n/// trait Bar: Sized { }\n///\n/// struct Impl;\n/// impl Foo for Impl { }\n/// impl Bar for Impl { }\n///\n/// let x: &dyn Foo = &Impl;    // OK\n/// // let y: &dyn Bar = &Impl; // error: the trait `Bar` cannot\n///                             // be made into an object\n/// ```\n///\n/// [trait object]: ../../book/ch17-02-trait-objects.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[lang = \"sized\"]\n#[rustc_on_unimplemented(\n    on(parent_trait = \"std::path::Path\", label = \"borrow the `Path` instead\"),\n    message = \"the size for values of type `{Self}` cannot be known at compilation time\",\n    label = \"doesn't have a size known at compile-time\",\n    note = \"to learn more, visit <https://doc.rust-lang.org/book/\\\n          ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\"\n)]\n#[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\npub trait Sized {\n    // Empty.\n}\n\n/// Types that can be \"unsized\" to a dynamically-sized type.\n///\n/// For example, the sized array type `[i8; 2]` implements `Unsize<[i8]>` and\n/// `Unsize<dyn fmt::Debug>`.\n///\n/// All implementations of `Unsize` are provided automatically by the compiler.\n///\n/// `Unsize` is implemented for:\n///\n/// - `[T; N]` is `Unsize<[T]>`\n/// - `T` is `Unsize<dyn Trait>` when `T: Trait`\n/// - `Foo<..., T, ...>` is `Unsize<Foo<..., U, ...>>` if:\n///   - `T: Unsize<U>`\n///   - Foo is a struct\n///   - Only the last field of `Foo` has a type involving `T`\n///   - `T` is not part of the type of any other fields\n///   - `Bar<T>: Unsize<Bar<U>>`, if the last field of `Foo` has type `Bar<T>`\n///\n/// `Unsize` is used along with [`ops::CoerceUnsized`][coerceunsized] to allow\n/// \"user-defined\" containers such as [`rc::Rc`][rc] to contain dynamically-sized\n/// types. See the [DST coercion RFC][RFC982] and [the nomicon entry on coercion][nomicon-coerce]\n/// for more details.\n///\n/// [coerceunsized]: ../ops/trait.CoerceUnsized.html\n/// [rc]: ../../std/rc/struct.Rc.html\n/// [RFC982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n/// [nomicon-coerce]: ../../nomicon/coercions.html\n#[unstable(feature = \"unsize\", issue = \"27732\")]\n#[lang = \"unsize\"]\npub trait Unsize<T: ?Sized> {\n}\n\n/// Required trait for constants used in pattern matches.\n///\n/// Any type that derives `PartialEq` automatically implements this trait,\n/// *regardless* of whether its type-parameters implement `Eq`.\n///\n/// If a `const` item contains some type that does not implement this trait,\n/// then that type either (1.) does not implement `PartialEq` (which means the\n/// constant will not provide that comparison method, which code generation\n/// assumes is available), or (2.) it implements *its own* version of\n/// `PartialEq` (which we assume does not conform to a structural-equality\n/// comparison).\n///\n/// In either of the two scenarios above, we reject usage of such a constant in\n/// a pattern match.\n///\n/// See also the [structural match RFC][RFC1445], and [issue 63438] which\n/// motivated migrating from attribute-based design to this trait.\n///\n/// [RFC1445]: https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md\n/// [issue 63438]: https://github.com/rust-lang/rust/issues/63438\n#[unstable(feature = \"structural_match\", issue = \"31434\")]\n#[rustc_on_unimplemented(message = \"the type `{S}` does not `#[derive(PartialEq)]`\")]\n#[lang = \"structural_peq\"]\npub trait StructuralPartialEq {\n    // Empty.\n}\n\n/// Required trait for constants used in pattern matches.\n///\n/// Any type that derives `Eq` automatically implements this trait, *regardless*\n/// of whether its type-parameters implement `Eq`.\n///\n/// This is a hack to workaround a limitation in our type-system.\n///\n/// Background:\n///\n/// We want to require that types of consts used in pattern matches\n/// have the attribute `#[derive(PartialEq, Eq)]`.\n///\n/// In a more ideal world, we could check that requirement by just checking that\n/// the given type implements both (1.) the `StructuralPartialEq` trait *and*\n/// (2.) the `Eq` trait. However, you can have ADTs that *do* `derive(PartialEq, Eq)`,\n/// and be a case that we want the compiler to accept, and yet the constant's\n/// type fails to implement `Eq`.\n///\n/// Namely, a case like this:\n///\n/// ```rust\n/// #[derive(PartialEq, Eq)]\n/// struct Wrap<X>(X);\n/// fn higher_order(_: &()) { }\n/// const CFN: Wrap<fn(&())> = Wrap(higher_order);\n/// fn main() {\n///     match CFN {\n///         CFN => {}\n///         _ => {}\n///     }\n/// }\n/// ```\n///\n/// (The problem in the above code is that `Wrap<fn(&())>` does not implement\n/// `PartialEq`, nor `Eq`, because `for<'a> fn(&'a _)` does not implement those\n/// traits.)\n///\n/// Therefore, we cannot rely on naive check for `StructuralPartialEq` and\n/// mere `Eq`.\n///\n/// As a hack to work around this, we use two separate traits injected by each\n/// of the two derives (`#[derive(PartialEq)]` and `#[derive(Eq)]`) and check\n/// that both of them are present as part of structural-match checking.\n#[unstable(feature = \"structural_match\", issue = \"31434\")]\n#[rustc_on_unimplemented(message = \"the type `{S}` does not `#[derive(Eq)]`\")]\n#[lang = \"structural_teq\"]\npub trait StructuralEq {\n    // Empty.\n}\n\n/// Types whose values can be duplicated simply by copying bits.\n///\n/// By default, variable bindings have 'move semantics.' In other\n/// words:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Foo;\n///\n/// let x = Foo;\n///\n/// let y = x;\n///\n/// // `x` has moved into `y`, and so cannot be used\n///\n/// // println!(\"{:?}\", x); // error: use of moved value\n/// ```\n///\n/// However, if a type implements `Copy`, it instead has 'copy semantics':\n///\n/// ```\n/// // We can derive a `Copy` implementation. `Clone` is also required, as it's\n/// // a supertrait of `Copy`.\n/// #[derive(Debug, Copy, Clone)]\n/// struct Foo;\n///\n/// let x = Foo;\n///\n/// let y = x;\n///\n/// // `y` is a copy of `x`\n///\n/// println!(\"{:?}\", x); // A-OK!\n/// ```\n///\n/// It's important to note that in these two examples, the only difference is whether you\n/// are allowed to access `x` after the assignment. Under the hood, both a copy and a move\n/// can result in bits being copied in memory, although this is sometimes optimized away.\n///\n/// ## How can I implement `Copy`?\n///\n/// There are two ways to implement `Copy` on your type. The simplest is to use `derive`:\n///\n/// ```\n/// #[derive(Copy, Clone)]\n/// struct MyStruct;\n/// ```\n///\n/// You can also implement `Copy` and `Clone` manually:\n///\n/// ```\n/// struct MyStruct;\n///\n/// impl Copy for MyStruct { }\n///\n/// impl Clone for MyStruct {\n///     fn clone(&self) -> MyStruct {\n///         *self\n///     }\n/// }\n/// ```\n///\n/// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n/// bound on type parameters, which isn't always desired.\n///\n/// ## What's the difference between `Copy` and `Clone`?\n///\n/// Copies happen implicitly, for example as part of an assignment `y = x`. The behavior of\n/// `Copy` is not overloadable; it is always a simple bit-wise copy.\n///\n/// Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`] can\n/// provide any type-specific behavior necessary to duplicate values safely. For example,\n/// the implementation of [`Clone`] for [`String`] needs to copy the pointed-to string\n/// buffer in the heap. A simple bitwise copy of [`String`] values would merely copy the\n/// pointer, leading to a double free down the line. For this reason, [`String`] is [`Clone`]\n/// but not `Copy`.\n///\n/// [`Clone`] is a supertrait of `Copy`, so everything which is `Copy` must also implement\n/// [`Clone`]. If a type is `Copy` then its [`Clone`] implementation only needs to return `*self`\n/// (see the example above).\n///\n/// ## When can my type be `Copy`?\n///\n/// A type can implement `Copy` if all of its components implement `Copy`. For example, this\n/// struct can be `Copy`:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// struct Point {\n///    x: i32,\n///    y: i32,\n/// }\n/// ```\n///\n/// A struct can be `Copy`, and [`i32`] is `Copy`, therefore `Point` is eligible to be `Copy`.\n/// By contrast, consider\n///\n/// ```\n/// # #![allow(dead_code)]\n/// # struct Point;\n/// struct PointList {\n///     points: Vec<Point>,\n/// }\n/// ```\n///\n/// The struct `PointList` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we\n/// attempt to derive a `Copy` implementation, we'll get an error:\n///\n/// ```text\n/// the trait `Copy` may not be implemented for this type; field `points` does not implement `Copy`\n/// ```\n///\n/// ## When *can't* my type be `Copy`?\n///\n/// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n/// mutable reference. Copying [`String`] would duplicate responsibility for managing the\n/// [`String`]'s buffer, leading to a double free.\n///\n/// Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\n/// managing some resource besides its own [`size_of::<T>`] bytes.\n///\n/// If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get\n/// the error [E0204].\n///\n/// [E0204]: ../../error-index.html#E0204\n///\n/// ## When *should* my type be `Copy`?\n///\n/// Generally speaking, if your type _can_ implement `Copy`, it should. Keep in mind, though,\n/// that implementing `Copy` is part of the public API of your type. If the type might become\n/// non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to\n/// avoid a breaking API change.\n///\n/// ## Additional implementors\n///\n/// In addition to the [implementors listed below][impls],\n/// the following types also implement `Copy`:\n///\n/// * Function item types (i.e., the distinct types defined for each function)\n/// * Function pointer types (e.g., `fn() -> i32`)\n/// * Array types, for all sizes, if the item type also implements `Copy` (e.g., `[i32; 123456]`)\n/// * Tuple types, if each component also implements `Copy` (e.g., `()`, `(i32, bool)`)\n/// * Closure types, if they capture no value from the environment\n///   or if all such captured values implement `Copy` themselves.\n///   Note that variables captured by shared reference always implement `Copy`\n///   (even if the referent doesn't),\n///   while variables captured by mutable reference never implement `Copy`.\n///\n/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [`Drop`]: ../../std/ops/trait.Drop.html\n/// [`size_of::<T>`]: ../../std/mem/fn.size_of.html\n/// [`Clone`]: ../clone/trait.Clone.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [`i32`]: ../../std/primitive.i32.html\n/// [impls]: #implementors\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[lang = \"copy\"]\npub trait Copy: Clone {\n    // Empty.\n}\n\n/// Derive macro generating an impl of the trait `Copy`.\n#[rustc_builtin_macro]\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\npub macro Copy($item:item) {\n    /* compiler built-in */\n}\n\n/// Types for which it is safe to share references between threads.\n///\n/// This trait is automatically implemented when the compiler determines\n/// it's appropriate.\n///\n/// The precise definition is: a type `T` is `Sync` if and only if `&T` is\n/// [`Send`][send]. In other words, if there is no possibility of\n/// [undefined behavior][ub] (including data races) when passing\n/// `&T` references between threads.\n///\n/// As one would expect, primitive types like [`u8`][u8] and [`f64`][f64]\n/// are all `Sync`, and so are simple aggregate types containing them,\n/// like tuples, structs and enums. More examples of basic `Sync`\n/// types include \"immutable\" types like `&T`, and those with simple\n/// inherited mutability, such as [`Box<T>`][box], [`Vec<T>`][vec] and\n/// most other collection types. (Generic parameters need to be `Sync`\n/// for their container to be `Sync`.)\n///\n/// A somewhat surprising consequence of the definition is that `&mut T`\n/// is `Sync` (if `T` is `Sync`) even though it seems like that might\n/// provide unsynchronized mutation. The trick is that a mutable\n/// reference behind a shared reference (that is, `& &mut T`)\n/// becomes read-only, as if it were a `& &T`. Hence there is no risk\n/// of a data race.\n///\n/// Types that are not `Sync` are those that have \"interior\n/// mutability\" in a non-thread-safe form, such as [`cell::Cell`][cell]\n/// and [`cell::RefCell`][refcell]. These types allow for mutation of\n/// their contents even through an immutable, shared reference. For\n/// example the `set` method on [`Cell<T>`][cell] takes `&self`, so it requires\n/// only a shared reference [`&Cell<T>`][cell]. The method performs no\n/// synchronization, thus [`Cell`][cell] cannot be `Sync`.\n///\n/// Another example of a non-`Sync` type is the reference-counting\n/// pointer [`rc::Rc`][rc]. Given any reference [`&Rc<T>`][rc], you can clone\n/// a new [`Rc<T>`][rc], modifying the reference counts in a non-atomic way.\n///\n/// For cases when one does need thread-safe interior mutability,\n/// Rust provides [atomic data types], as well as explicit locking via\n/// [`sync::Mutex`][mutex] and [`sync::RwLock`][rwlock]. These types\n/// ensure that any mutation cannot cause data races, hence the types\n/// are `Sync`. Likewise, [`sync::Arc`][arc] provides a thread-safe\n/// analogue of [`Rc`][rc].\n///\n/// Any types with interior mutability must also use the\n/// [`cell::UnsafeCell`][unsafecell] wrapper around the value(s) which\n/// can be mutated through a shared reference. Failing to doing this is\n/// [undefined behavior][ub]. For example, [`transmute`][transmute]-ing\n/// from `&T` to `&mut T` is invalid.\n///\n/// See [the Nomicon](../../nomicon/send-and-sync.html) for more\n/// details about `Sync`.\n///\n/// [send]: trait.Send.html\n/// [u8]: ../../std/primitive.u8.html\n/// [f64]: ../../std/primitive.f64.html\n/// [box]: ../../std/boxed/struct.Box.html\n/// [vec]: ../../std/vec/struct.Vec.html\n/// [cell]: ../cell/struct.Cell.html\n/// [refcell]: ../cell/struct.RefCell.html\n/// [rc]: ../../std/rc/struct.Rc.html\n/// [arc]: ../../std/sync/struct.Arc.html\n/// [atomic data types]: ../sync/atomic/index.html\n/// [mutex]: ../../std/sync/struct.Mutex.html\n/// [rwlock]: ../../std/sync/struct.RwLock.html\n/// [unsafecell]: ../cell/struct.UnsafeCell.html\n/// [ub]: ../../reference/behavior-considered-undefined.html\n/// [transmute]: ../../std/mem/fn.transmute.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[cfg_attr(not(test), rustc_diagnostic_item = \"sync_trait\")]\n#[lang = \"sync\"]\n#[rustc_on_unimplemented(\n    message = \"`{Self}` cannot be shared between threads safely\",\n    label = \"`{Self}` cannot be shared between threads safely\"\n)]\npub unsafe auto trait Sync {\n    // FIXME(estebank): once support to add notes in `rustc_on_unimplemented`\n    // lands in beta, and it has been extended to check whether a closure is\n    // anywhere in the requirement chain, extend it as such (#48534):\n    // ```\n    // on(\n    //     closure,\n    //     note=\"`{Self}` cannot be shared safely, consider marking the closure `move`\"\n    // ),\n    // ```\n\n    // Empty\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !Sync for *const T {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !Sync for *mut T {}\n\nmacro_rules! impls {\n    ($t: ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized> Hash for $t<T> {\n            #[inline]\n            fn hash<H: Hasher>(&self, _: &mut H) {}}\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized> cmp::PartialEq for $t<T> {\n            fn eq(&self, _other: &$t<T>) -> bool {\n}\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized> cmp::Eq for $t<T> {}\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized> cmp::PartialOrd for $t<T> {\n            fn partial_cmp(&self, _other: &$t<T>) -> Option<cmp::Ordering> {\n}\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized> cmp::Ord for $t<T> {\n            fn cmp(&self, _other: &$t<T>) -> cmp::Ordering {\n}\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized> Copy for $t<T> {}\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized> Clone for $t<T> {\n            fn clone(&self) -> Self {\n}\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized> Default for $t<T> {\n            fn default() -> Self {\n}\n        }\n\n        #[unstable(feature = \"structural_match\", issue = \"31434\")]\n        impl<T: ?Sized> StructuralPartialEq for $t<T> {}};\n}\n\n/// Zero-sized type used to mark things that \"act like\" they own a `T`.\n///\n/// Adding a `PhantomData<T>` field to your type tells the compiler that your\n/// type acts as though it stores a value of type `T`, even though it doesn't\n/// really. This information is used when computing certain safety properties.\n///\n/// For a more in-depth explanation of how to use `PhantomData<T>`, please see\n/// [the Nomicon](../../nomicon/phantom-data.html).\n///\n/// # A ghastly note 👻👻👻\n///\n/// Though they both have scary names, `PhantomData` and 'phantom types' are\n/// related, but not identical. A phantom type parameter is simply a type\n/// parameter which is never used. In Rust, this often causes the compiler to\n/// complain, and the solution is to add a \"dummy\" use by way of `PhantomData`.\n///\n/// # Examples\n///\n/// ## Unused lifetime parameters\n///\n/// Perhaps the most common use case for `PhantomData` is a struct that has an\n/// unused lifetime parameter, typically as part of some unsafe code. For\n/// example, here is a struct `Slice` that has two pointers of type `*const T`,\n/// presumably pointing into an array somewhere:\n///\n/// ```compile_fail,E0392\n/// struct Slice<'a, T> {\n///     start: *const T,\n///     end: *const T,\n/// }\n/// ```\n///\n/// The intention is that the underlying data is only valid for the\n/// lifetime `'a`, so `Slice` should not outlive `'a`. However, this\n/// intent is not expressed in the code, since there are no uses of\n/// the lifetime `'a` and hence it is not clear what data it applies\n/// to. We can correct this by telling the compiler to act *as if* the\n/// `Slice` struct contained a reference `&'a T`:\n///\n/// ```\n/// use std::marker::PhantomData;\n///\n/// # #[allow(dead_code)]\n/// struct Slice<'a, T: 'a> {\n///     start: *const T,\n///     end: *const T,\n///     phantom: PhantomData<&'a T>,\n/// }\n/// ```\n///\n/// This also in turn requires the annotation `T: 'a`, indicating\n/// that any references in `T` are valid over the lifetime `'a`.\n///\n/// When initializing a `Slice` you simply provide the value\n/// `PhantomData` for the field `phantom`:\n///\n/// ```\n/// # #![allow(dead_code)]\n/// # use std::marker::PhantomData;\n/// # struct Slice<'a, T: 'a> {\n/// #     start: *const T,\n/// #     end: *const T,\n/// #     phantom: PhantomData<&'a T>,\n/// # }\n/// fn borrow_vec<T>(vec: &Vec<T>) -> Slice<'_, T> {\n///     let ptr = vec.as_ptr();\n///     Slice {\n///         start: ptr,\n///         end: unsafe { ptr.add(vec.len()) },\n///         phantom: PhantomData,\n///     }\n/// }\n/// ```\n///\n/// ## Unused type parameters\n///\n/// It sometimes happens that you have unused type parameters which\n/// indicate what type of data a struct is \"tied\" to, even though that\n/// data is not actually found in the struct itself. Here is an\n/// example where this arises with [FFI]. The foreign interface uses\n/// handles of type `*mut ()` to refer to Rust values of different\n/// types. We track the Rust type using a phantom type parameter on\n/// the struct `ExternalResource` which wraps a handle.\n///\n/// [FFI]: ../../book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code\n///\n/// ```\n/// # #![allow(dead_code)]\n/// # trait ResType { }\n/// # struct ParamType;\n/// # mod foreign_lib {\n/// #     pub fn new(_: usize) -> *mut () { 42 as *mut () }\n/// #     pub fn do_stuff(_: *mut (), _: usize) {}\n/// # }\n/// # fn convert_params(_: ParamType) -> usize { 42 }\n/// use std::marker::PhantomData;\n/// use std::mem;\n///\n/// struct ExternalResource<R> {\n///    resource_handle: *mut (),\n///    resource_type: PhantomData<R>,\n/// }\n///\n/// impl<R: ResType> ExternalResource<R> {\n///     fn new() -> ExternalResource<R> {\n///         let size_of_res = mem::size_of::<R>();\n///         ExternalResource {\n///             resource_handle: foreign_lib::new(size_of_res),\n///             resource_type: PhantomData,\n///         }\n///     }\n///\n///     fn do_stuff(&self, param: ParamType) {\n///         let foreign_params = convert_params(param);\n///         foreign_lib::do_stuff(self.resource_handle, foreign_params);\n///     }\n/// }\n/// ```\n///\n/// ## Ownership and the drop check\n///\n/// Adding a field of type `PhantomData<T>` indicates that your\n/// type owns data of type `T`. This in turn implies that when your\n/// type is dropped, it may drop one or more instances of the type\n/// `T`. This has bearing on the Rust compiler's [drop check]\n/// analysis.\n///\n/// If your struct does not in fact *own* the data of type `T`, it is\n/// better to use a reference type, like `PhantomData<&'a T>`\n/// (ideally) or `PhantomData<*const T>` (if no lifetime applies), so\n/// as not to indicate ownership.\n///\n/// [drop check]: ../../nomicon/dropck.html\n#[lang = \"phantom_data\"]\n#[structural_match]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct PhantomData<T: ?Sized>;\n\nimpls! { PhantomData }\n\nmod impls {\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    unsafe impl<T: Sync + ?Sized> Send for &T {}\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    unsafe impl<T: Send + ?Sized> Send for &mut T {}\n}\n\n/// Compiler-internal trait used to determine whether a type contains\n/// any `UnsafeCell` internally, but not through an indirection.\n/// This affects, for example, whether a `static` of that type is\n/// placed in read-only static memory or writable static memory.\n#[lang = \"freeze\"]\npub(crate) unsafe auto trait Freeze {}\n\nimpl<T: ?Sized> !Freeze for UnsafeCell<T> {}\nunsafe impl<T: ?Sized> Freeze for PhantomData<T> {}\nunsafe impl<T: ?Sized> Freeze for *const T {}\nunsafe impl<T: ?Sized> Freeze for *mut T {}\nunsafe impl<T: ?Sized> Freeze for &T {}\nunsafe impl<T: ?Sized> Freeze for &mut T {}\n\n/// Types that can be safely moved after being pinned.\n///\n/// Since Rust itself has no notion of immovable types, and considers moves\n/// (e.g., through assignment or [`mem::replace`]) to always be safe,\n/// this trait cannot prevent types from moving by itself.\n///\n/// Instead it is used to prevent moves through the type system,\n/// by controlling the behavior of pointers `P` wrapped in the [`Pin<P>`] wrapper,\n/// which \"pin\" the type in place by not allowing it to be moved out of them.\n/// See the [`pin module`] documentation for more information on pinning.\n///\n/// Implementing this trait lifts the restrictions of pinning off a type,\n/// which then allows it to move out with functions such as [`mem::replace`].\n///\n/// `Unpin` has no consequence at all for non-pinned data. In particular,\n/// [`mem::replace`] happily moves `!Unpin` data (it works for any `&mut T`, not\n/// just when `T: Unpin`). However, you cannot use\n/// [`mem::replace`] on data wrapped inside a [`Pin<P>`] because you cannot get the\n/// `&mut T` you need for that, and *that* is what makes this system work.\n///\n/// So this, for example, can only be done on types implementing `Unpin`:\n///\n/// ```rust\n/// use std::mem;\n/// use std::pin::Pin;\n///\n/// let mut string = \"this\".to_string();\n/// let mut pinned_string = Pin::new(&mut string);\n///\n/// // We need a mutable reference to call `mem::replace`.\n/// // We can obtain such a reference by (implicitly) invoking `Pin::deref_mut`,\n/// // but that is only possible because `String` implements `Unpin`.\n/// mem::replace(&mut *pinned_string, \"other\".to_string());\n/// ```\n///\n/// This trait is automatically implemented for almost every type.\n///\n/// [`mem::replace`]: ../../std/mem/fn.replace.html\n/// [`Pin<P>`]: ../pin/struct.Pin.html\n/// [`pin module`]: ../../std/pin/index.html\n#[stable(feature = \"pin\", since = \"1.33.0\")]\n#[lang = \"unpin\"]\npub auto trait Unpin {}\n\n/// A marker type which does not implement `Unpin`.\n///\n/// If a type contains a `PhantomPinned`, it will not implement `Unpin` by default.\n#[stable(feature = \"pin\", since = \"1.33.0\")]\n#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct PhantomPinned;\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl !Unpin for PhantomPinned {}\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<'a, T: ?Sized + 'a> Unpin for &'a T {}\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<'a, T: ?Sized + 'a> Unpin for &'a mut T {}\n\n#[stable(feature = \"pin_raw\", since = \"1.38.0\")]\nimpl<T: ?Sized> Unpin for *const T {}\n\n#[stable(feature = \"pin_raw\", since = \"1.38.0\")]\nimpl<T: ?Sized> Unpin for *mut T {}\n\n/// Implementations of `Copy` for primitive types.\n///\n/// Implementations that cannot be described in Rust\n/// are implemented in `SelectionContext::copy_clone_conditions()` in librustc.\nmod copy_impls {\n\n    use super::Copy;\n\n    macro_rules! impl_copy {\n        ($($t:ty)*) => {\n            $(\n                #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                impl Copy for $t {}\n            )*\n        }\n    }\n\n    impl_copy! {\n        usize u8 u16 u32 u64 u128\n        isize i8 i16 i32 i64 i128\n        f32 f64\n        bool char\n    }\n\n    #[unstable(feature = \"never_type\", issue = \"35121\")]\n    impl Copy for ! {}}\n}\npub mod ops {\n//! Overloadable operators.\n//!\n//! Implementing these traits allows you to overload certain operators.\n//!\n//! Some of these traits are imported by the prelude, so they are available in\n//! every Rust program. Only operators backed by traits can be overloaded. For\n//! example, the addition operator (`+`) can be overloaded through the [`Add`]\n//! trait, but since the assignment operator (`=`) has no backing trait, there\n//! is no way of overloading its semantics. Additionally, this module does not\n//! provide any mechanism to create new operators. If traitless overloading or\n//! custom operators are required, you should look toward macros or compiler\n//! plugins to extend Rust's syntax.\n//!\n//! Implementations of operator traits should be unsurprising in their\n//! respective contexts, keeping in mind their usual meanings and\n//! [operator precedence]. For example, when implementing [`Mul`], the operation\n//! should have some resemblance to multiplication (and share expected\n//! properties like associativity).\n//!\n//! Note that the `&&` and `||` operators short-circuit, i.e., they only\n//! evaluate their second operand if it contributes to the result. Since this\n//! behavior is not enforceable by traits, `&&` and `||` are not supported as\n//! overloadable operators.\n//!\n//! Many of the operators take their operands by value. In non-generic\n//! contexts involving built-in types, this is usually not a problem.\n//! However, using these operators in generic code, requires some\n//! attention if values have to be reused as opposed to letting the operators\n//! consume them. One option is to occasionally use [`clone`].\n//! Another option is to rely on the types involved providing additional\n//! operator implementations for references. For example, for a user-defined\n//! type `T` which is supposed to support addition, it is probably a good\n//! idea to have both `T` and `&T` implement the traits [`Add<T>`][`Add`] and\n//! [`Add<&T>`][`Add`] so that generic code can be written without unnecessary\n//! cloning.\n//!\n//! # Examples\n//!\n//! This example creates a `Point` struct that implements [`Add`] and [`Sub`],\n//! and then demonstrates adding and subtracting two `Point`s.\n//!\n//! ```rust\n//! use std::ops::{Add, Sub};\n//!\n//! #[derive(Debug, PartialEq)]\n//! struct Point {\n//!     x: i32,\n//!     y: i32,\n//! }\n//!\n//! impl Add for Point {\n//!     type Output = Point;\n//!\n//!     fn add(self, other: Point) -> Point {\n//!         Point {x: self.x + other.x, y: self.y + other.y}\n//!     }\n//! }\n//!\n//! impl Sub for Point {\n//!     type Output = Point;\n//!\n//!     fn sub(self, other: Point) -> Point {\n//!         Point {x: self.x - other.x, y: self.y - other.y}\n//!     }\n//! }\n//!\n//! assert_eq!(Point {x: 3, y: 3}, Point {x: 1, y: 0} + Point {x: 2, y: 3});\n//! assert_eq!(Point {x: -1, y: -3}, Point {x: 1, y: 0} - Point {x: 2, y: 3});\n//! ```\n//!\n//! See the documentation for each trait for an example implementation.\n//!\n//! The [`Fn`], [`FnMut`], and [`FnOnce`] traits are implemented by types that can be\n//! invoked like functions. Note that [`Fn`] takes `&self`, [`FnMut`] takes `&mut\n//! self` and [`FnOnce`] takes `self`. These correspond to the three kinds of\n//! methods that can be invoked on an instance: call-by-reference,\n//! call-by-mutable-reference, and call-by-value. The most common use of these\n//! traits is to act as bounds to higher-level functions that take functions or\n//! closures as arguments.\n//!\n//! Taking a [`Fn`] as a parameter:\n//!\n//! ```rust\n//! fn call_with_one<F>(func: F) -> usize\n//!     where F: Fn(usize) -> usize\n//! {\n//!     func(1)\n//! }\n//!\n//! let double = |x| x * 2;\n//! assert_eq!(call_with_one(double), 2);\n//! ```\n//!\n//! Taking a [`FnMut`] as a parameter:\n//!\n//! ```rust\n//! fn do_twice<F>(mut func: F)\n//!     where F: FnMut()\n//! {\n//!     func();\n//!     func();\n//! }\n//!\n//! let mut x: usize = 1;\n//! {\n//!     let add_two_to_x = || x += 2;\n//!     do_twice(add_two_to_x);\n//! }\n//!\n//! assert_eq!(x, 5);\n//! ```\n//!\n//! Taking a [`FnOnce`] as a parameter:\n//!\n//! ```rust\n//! fn consume_with_relish<F>(func: F)\n//!     where F: FnOnce() -> String\n//! {\n//!     // `func` consumes its captured variables, so it cannot be run more\n//!     // than once\n//!     println!(\"Consumed: {}\", func());\n//!\n//!     println!(\"Delicious!\");\n//!\n//!     // Attempting to invoke `func()` again will throw a `use of moved\n//!     // value` error for `func`\n//! }\n//!\n//! let x = String::from(\"x\");\n//! let consume_and_return_x = move || x;\n//! consume_with_relish(consume_and_return_x);\n//!\n//! // `consume_and_return_x` can no longer be invoked at this point\n//! ```\n//!\n//! [`Fn`]: trait.Fn.html\n//! [`FnMut`]: trait.FnMut.html\n//! [`FnOnce`]: trait.FnOnce.html\n//! [`Add`]: trait.Add.html\n//! [`Sub`]: trait.Sub.html\n//! [`Mul`]: trait.Mul.html\n//! [`clone`]: ../clone/trait.Clone.html#tymethod.clone\n//! [operator precedence]: ../../reference/expressions.html#expression-precedence\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nmod arith {\n/// The addition operator `+`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory. For\n/// example, [`std::time::SystemTime`] implements `Add<Duration>`, which permits\n/// operations of the form `SystemTime = SystemTime + Duration`.\n///\n/// [`std::time::SystemTime`]: ../../std/time/struct.SystemTime.html\n///\n/// # Examples\n///\n/// ## `Add`able points\n///\n/// ```\n/// use std::ops::Add;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl Add for Point {\n///     type Output = Self;\n///\n///     fn add(self, other: Self) -> Self {\n///         Self {\n///             x: self.x + other.x,\n///             y: self.y + other.y,\n///         }\n///     }\n/// }\n///\n/// assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n///            Point { x: 3, y: 3 });\n/// ```\n///\n/// ## Implementing `Add` with generics\n///\n/// Here is an example of the same `Point` struct implementing the `Add` trait\n/// using generics.\n///\n/// ```\n/// use std::ops::Add;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Point<T> {\n///     x: T,\n///     y: T,\n/// }\n///\n/// // Notice that the implementation uses the associated type `Output`.\n/// impl<T: Add<Output = T>> Add for Point<T> {\n///     type Output = Self;\n///\n///     fn add(self, other: Self) -> Self::Output {\n///         Self {\n///             x: self.x + other.x,\n///             y: self.y + other.y,\n///         }\n///     }\n/// }\n///\n/// assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n///            Point { x: 3, y: 3 });\n/// ```\n#[lang = \"add\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    on(all(_Self = \"{integer}\", Rhs = \"{float}\"), message = \"cannot add a float to an integer\",),\n    on(all(_Self = \"{float}\", Rhs = \"{integer}\"), message = \"cannot add an integer to a float\",),\n    message = \"cannot add `{Rhs}` to `{Self}`\",\n    label = \"no implementation for `{Self} + {Rhs}`\"\n)]\n#[doc(alias = \"+\")]\npub trait Add<Rhs = Self> {\n    /// The resulting type after applying the `+` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `+` operation.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn add(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! add_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Add for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn add(self, other: $t) -> $t { }\n        }\n\n        forward_ref_binop! { impl Add, add for $t, $t }\n    )*)\n}\n\nadd_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The subtraction operator `-`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory. For\n/// example, [`std::time::SystemTime`] implements `Sub<Duration>`, which permits\n/// operations of the form `SystemTime = SystemTime - Duration`.\n///\n/// [`std::time::SystemTime`]: ../../std/time/struct.SystemTime.html\n///\n/// # Examples\n///\n/// ## `Sub`tractable points\n///\n/// ```\n/// use std::ops::Sub;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl Sub for Point {\n///     type Output = Point;\n///\n///     fn sub(self, other: Point) -> Point {\n///         Point {\n///             x: self.x - other.x,\n///             y: self.y - other.y,\n///         }\n///     }\n/// }\n///\n/// assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n///            Point { x: 1, y: 0 });\n/// ```\n///\n/// ## Implementing `Sub` with generics\n///\n/// Here is an example of the same `Point` struct implementing the `Sub` trait\n/// using generics.\n///\n/// ```\n/// use std::ops::Sub;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Point<T> {\n///     x: T,\n///     y: T,\n/// }\n///\n/// // Notice that the implementation uses the associated type `Output`.\n/// impl<T: Sub<Output = T>> Sub for Point<T> {\n///     type Output = Self;\n///\n///     fn sub(self, other: Self) -> Self::Output {\n///         Point {\n///             x: self.x - other.x,\n///             y: self.y - other.y,\n///         }\n///     }\n/// }\n///\n/// assert_eq!(Point { x: 2, y: 3 } - Point { x: 1, y: 0 },\n///            Point { x: 1, y: 3 });\n/// ```\n#[lang = \"sub\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot subtract `{Rhs}` from `{Self}`\",\n    label = \"no implementation for `{Self} - {Rhs}`\"\n)]\n#[doc(alias = \"-\")]\npub trait Sub<Rhs = Self> {\n    /// The resulting type after applying the `-` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `-` operation.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn sub(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! sub_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Sub for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn sub(self, other: $t) -> $t { }\n        }\n\n        forward_ref_binop! { impl Sub, sub for $t, $t }\n    )*)\n}\n\nsub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The multiplication operator `*`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory.\n///\n/// # Examples\n///\n/// ## `Mul`tipliable rational numbers\n///\n/// ```\n/// use std::ops::Mul;\n///\n/// // By the fundamental theorem of arithmetic, rational numbers in lowest\n/// // terms are unique. So, by keeping `Rational`s in reduced form, we can\n/// // derive `Eq` and `PartialEq`.\n/// #[derive(Debug, Eq, PartialEq)]\n/// struct Rational {\n///     numerator: usize,\n///     denominator: usize,\n/// }\n///\n/// impl Rational {\n///     fn new(numerator: usize, denominator: usize) -> Self {\n///         if denominator == 0 {\n///             panic!(\"Zero is an invalid denominator!\");\n///         }\n///\n///         // Reduce to lowest terms by dividing by the greatest common\n///         // divisor.\n///         let gcd = gcd(numerator, denominator);\n///         Rational {\n///             numerator: numerator / gcd,\n///             denominator: denominator / gcd,\n///         }\n///     }\n/// }\n///\n/// impl Mul for Rational {\n///     // The multiplication of rational numbers is a closed operation.\n///     type Output = Self;\n///\n///     fn mul(self, rhs: Self) -> Self {\n///         let numerator = self.numerator * rhs.numerator;\n///         let denominator = self.denominator * rhs.denominator;\n///         Rational::new(numerator, denominator)\n///     }\n/// }\n///\n/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n/// // divisor.\n/// fn gcd(x: usize, y: usize) -> usize {\n///     let mut x = x;\n///     let mut y = y;\n///     while y != 0 {\n///         let t = y;\n///         y = x % y;\n///         x = t;\n///     }\n///     x\n/// }\n///\n/// assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n/// assert_eq!(Rational::new(2, 3) * Rational::new(3, 4),\n///            Rational::new(1, 2));\n/// ```\n///\n/// ## Multiplying vectors by scalars as in linear algebra\n///\n/// ```\n/// use std::ops::Mul;\n///\n/// struct Scalar { value: usize }\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Vector { value: Vec<usize> }\n///\n/// impl Mul<Scalar> for Vector {\n///     type Output = Self;\n///\n///     fn mul(self, rhs: Scalar) -> Self::Output {\n///         Vector { value: self.value.iter().map(|v| v * rhs.value).collect() }\n///     }\n/// }\n///\n/// let vector = Vector { value: vec![2, 4, 6] };\n/// let scalar = Scalar { value: 3 };\n/// assert_eq!(vector * scalar, Vector { value: vec![6, 12, 18] });\n/// ```\n#[lang = \"mul\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot multiply `{Rhs}` to `{Self}`\",\n    label = \"no implementation for `{Self} * {Rhs}`\"\n)]\n#[doc(alias = \"*\")]\npub trait Mul<Rhs = Self> {\n    /// The resulting type after applying the `*` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `*` operation.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn mul(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! mul_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Mul for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn mul(self, other: $t) -> $t { }\n        }\n\n        forward_ref_binop! { impl Mul, mul for $t, $t }\n    )*)\n}\n\nmul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The division operator `/`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory.\n///\n/// # Examples\n///\n/// ## `Div`idable rational numbers\n///\n/// ```\n/// use std::ops::Div;\n///\n/// // By the fundamental theorem of arithmetic, rational numbers in lowest\n/// // terms are unique. So, by keeping `Rational`s in reduced form, we can\n/// // derive `Eq` and `PartialEq`.\n/// #[derive(Debug, Eq, PartialEq)]\n/// struct Rational {\n///     numerator: usize,\n///     denominator: usize,\n/// }\n///\n/// impl Rational {\n///     fn new(numerator: usize, denominator: usize) -> Self {\n///         if denominator == 0 {\n///             panic!(\"Zero is an invalid denominator!\");\n///         }\n///\n///         // Reduce to lowest terms by dividing by the greatest common\n///         // divisor.\n///         let gcd = gcd(numerator, denominator);\n///         Rational {\n///             numerator: numerator / gcd,\n///             denominator: denominator / gcd,\n///         }\n///     }\n/// }\n///\n/// impl Div for Rational {\n///     // The division of rational numbers is a closed operation.\n///     type Output = Self;\n///\n///     fn div(self, rhs: Self) -> Self::Output {\n///         if rhs.numerator == 0 {\n///             panic!(\"Cannot divide by zero-valued `Rational`!\");\n///         }\n///\n///         let numerator = self.numerator * rhs.denominator;\n///         let denominator = self.denominator * rhs.numerator;\n///         Rational::new(numerator, denominator)\n///     }\n/// }\n///\n/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n/// // divisor.\n/// fn gcd(x: usize, y: usize) -> usize {\n///     let mut x = x;\n///     let mut y = y;\n///     while y != 0 {\n///         let t = y;\n///         y = x % y;\n///         x = t;\n///     }\n///     x\n/// }\n///\n/// assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n/// assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n///            Rational::new(2, 3));\n/// ```\n///\n/// ## Dividing vectors by scalars as in linear algebra\n///\n/// ```\n/// use std::ops::Div;\n///\n/// struct Scalar { value: f32 }\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Vector { value: Vec<f32> }\n///\n/// impl Div<Scalar> for Vector {\n///     type Output = Self;\n///\n///     fn div(self, rhs: Scalar) -> Self::Output {\n///         Vector { value: self.value.iter().map(|v| v / rhs.value).collect() }\n///     }\n/// }\n///\n/// let scalar = Scalar { value: 2f32 };\n/// let vector = Vector { value: vec![2f32, 4f32, 6f32] };\n/// assert_eq!(vector / scalar, Vector { value: vec![1f32, 2f32, 3f32] });\n/// ```\n#[lang = \"div\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot divide `{Self}` by `{Rhs}`\",\n    label = \"no implementation for `{Self} / {Rhs}`\"\n)]\n#[doc(alias = \"/\")]\npub trait Div<Rhs = Self> {\n    /// The resulting type after applying the `/` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `/` operation.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn div(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! div_impl_integer {\n    ($($t:ty)*) => ($(\n        /// This operation rounds towards zero, truncating any\n        /// fractional part of the exact result.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Div for $t {\n            type Output = $t;\n\n            #[inline]\n            fn div(self, other: $t) -> $t { }\n        }\n\n        forward_ref_binop! { impl Div, div for $t, $t }\n    )*)\n}\n\ndiv_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\nmacro_rules! div_impl_float {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Div for $t {\n            type Output = $t;\n\n            #[inline]\n            fn div(self, other: $t) -> $t { }\n        }\n\n        forward_ref_binop! { impl Div, div for $t, $t }\n    )*)\n}\n\ndiv_impl_float! { f32 f64 }\n\n/// The remainder operator `%`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory.\n///\n/// # Examples\n///\n/// This example implements `Rem` on a `SplitSlice` object. After `Rem` is\n/// implemented, one can use the `%` operator to find out what the remaining\n/// elements of the slice would be after splitting it into equal slices of a\n/// given length.\n///\n/// ```\n/// use std::ops::Rem;\n///\n/// #[derive(PartialEq, Debug)]\n/// struct SplitSlice<'a, T: 'a> {\n///     slice: &'a [T],\n/// }\n///\n/// impl<'a, T> Rem<usize> for SplitSlice<'a, T> {\n///     type Output = Self;\n///\n///     fn rem(self, modulus: usize) -> Self::Output {\n///         let len = self.slice.len();\n///         let rem = len % modulus;\n///         let start = len - rem;\n///         SplitSlice {slice: &self.slice[start..]}\n///     }\n/// }\n///\n/// // If we were to divide &[0, 1, 2, 3, 4, 5, 6, 7] into slices of size 3,\n/// // the remainder would be &[6, 7].\n/// assert_eq!(SplitSlice { slice: &[0, 1, 2, 3, 4, 5, 6, 7] } % 3,\n///            SplitSlice { slice: &[6, 7] });\n/// ```\n#[lang = \"rem\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot mod `{Self}` by `{Rhs}`\",\n    label = \"no implementation for `{Self} % {Rhs}`\"\n)]\n#[doc(alias = \"%\")]\npub trait Rem<Rhs = Self> {\n    /// The resulting type after applying the `%` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `%` operation.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn rem(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! rem_impl_integer {\n    ($($t:ty)*) => ($(\n        /// This operation satisfies `n % d == n - (n / d) * d`. The\n        /// result has the same sign as the left operand.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Rem for $t {\n            type Output = $t;\n\n            #[inline]\n            fn rem(self, other: $t) -> $t { }\n        }\n\n        forward_ref_binop! { impl Rem, rem for $t, $t }\n    )*)\n}\n\nrem_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\nmacro_rules! rem_impl_float {\n    ($($t:ty)*) => ($(\n\n        /// The remainder from the division of two floats.\n        ///\n        /// The remainder has the same sign as the dividend and is computed as:\n        /// `x - (x / y).trunc() * y`.\n        ///\n        /// # Examples\n        /// ```\n        /// let x: f32 = 50.50;\n        /// let y: f32 = 8.125;\n        /// let remainder = x - (x / y).trunc() * y;\n        ///\n        /// // The answer to both operations is 1.75\n        /// assert_eq!(x % y, remainder);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Rem for $t {\n            type Output = $t;\n\n            #[inline]\n            fn rem(self, other: $t) -> $t { }\n        }\n\n        forward_ref_binop! { impl Rem, rem for $t, $t }\n    )*)\n}\n\nrem_impl_float! { f32 f64 }\n\n/// The unary negation operator `-`.\n///\n/// # Examples\n///\n/// An implementation of `Neg` for `Sign`, which allows the use of `-` to\n/// negate its value.\n///\n/// ```\n/// use std::ops::Neg;\n///\n/// #[derive(Debug, PartialEq)]\n/// enum Sign {\n///     Negative,\n///     Zero,\n///     Positive,\n/// }\n///\n/// impl Neg for Sign {\n///     type Output = Sign;\n///\n///     fn neg(self) -> Self::Output {\n///         match self {\n///             Sign::Negative => Sign::Positive,\n///             Sign::Zero => Sign::Zero,\n///             Sign::Positive => Sign::Negative,\n///         }\n///     }\n/// }\n///\n/// // A negative positive is a negative.\n/// assert_eq!(-Sign::Positive, Sign::Negative);\n/// // A double negative is a positive.\n/// assert_eq!(-Sign::Negative, Sign::Positive);\n/// // Zero is its own negation.\n/// assert_eq!(-Sign::Zero, Sign::Zero);\n/// ```\n#[lang = \"neg\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(alias = \"-\")]\npub trait Neg {\n    /// The resulting type after applying the `-` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the unary `-` operation.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn neg(self) -> Self::Output;\n}\n\nmacro_rules! neg_impl_core {\n    ($id:ident => $body:expr, $($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Neg for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn neg(self) -> $t { }\n        }\n\n        forward_ref_unop! { impl Neg, neg for $t }\n    )*)\n}\n\nmacro_rules! neg_impl_numeric {\n    ($($t:ty)*) => { neg_impl_core!{ x => -x, $($t)*} }\n}\n\n#[allow(unused_macros)]\nmacro_rules! neg_impl_unsigned {\n    ($($t:ty)*) => {\n        neg_impl_core!{ x => {\n            !x.wrapping_add(1)\n        }, $($t)*} }\n}\n\n// neg_impl_unsigned! { usize u8 u16 u32 u64 }\nneg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The addition assignment operator `+=`.\n///\n/// # Examples\n///\n/// This example creates a `Point` struct that implements the `AddAssign`\n/// trait, and then demonstrates add-assigning to a mutable `Point`.\n///\n/// ```\n/// use std::ops::AddAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl AddAssign for Point {\n///     fn add_assign(&mut self, other: Self) {\n///         *self = Self {\n///             x: self.x + other.x,\n///             y: self.y + other.y,\n///         };\n///     }\n/// }\n///\n/// let mut point = Point { x: 1, y: 0 };\n/// point += Point { x: 2, y: 3 };\n/// assert_eq!(point, Point { x: 3, y: 3 });\n/// ```\n#[lang = \"add_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot add-assign `{Rhs}` to `{Self}`\",\n    label = \"no implementation for `{Self} += {Rhs}`\"\n)]\n#[doc(alias = \"+\")]\n#[doc(alias = \"+=\")]\npub trait AddAssign<Rhs = Self> {\n    /// Performs the `+=` operation.\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn add_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! add_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl AddAssign for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn add_assign(&mut self, other: $t) { }\n        }\n\n        forward_ref_op_assign! { impl AddAssign, add_assign for $t, $t }\n    )+)\n}\n\nadd_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The subtraction assignment operator `-=`.\n///\n/// # Examples\n///\n/// This example creates a `Point` struct that implements the `SubAssign`\n/// trait, and then demonstrates sub-assigning to a mutable `Point`.\n///\n/// ```\n/// use std::ops::SubAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl SubAssign for Point {\n///     fn sub_assign(&mut self, other: Self) {\n///         *self = Self {\n///             x: self.x - other.x,\n///             y: self.y - other.y,\n///         };\n///     }\n/// }\n///\n/// let mut point = Point { x: 3, y: 3 };\n/// point -= Point { x: 2, y: 3 };\n/// assert_eq!(point, Point {x: 1, y: 0});\n/// ```\n#[lang = \"sub_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot subtract-assign `{Rhs}` from `{Self}`\",\n    label = \"no implementation for `{Self} -= {Rhs}`\"\n)]\n#[doc(alias = \"-\")]\n#[doc(alias = \"-=\")]\npub trait SubAssign<Rhs = Self> {\n    /// Performs the `-=` operation.\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn sub_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! sub_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl SubAssign for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn sub_assign(&mut self, other: $t) { }\n        }\n\n        forward_ref_op_assign! { impl SubAssign, sub_assign for $t, $t }\n    )+)\n}\n\nsub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The multiplication assignment operator `*=`.\n///\n/// # Examples\n///\n/// ```\n/// use std::ops::MulAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Frequency { hertz: f64 }\n///\n/// impl MulAssign<f64> for Frequency {\n///     fn mul_assign(&mut self, rhs: f64) {\n///         self.hertz *= rhs;\n///     }\n/// }\n///\n/// let mut frequency = Frequency { hertz: 50.0 };\n/// frequency *= 4.0;\n/// assert_eq!(Frequency { hertz: 200.0 }, frequency);\n/// ```\n#[lang = \"mul_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot multiply-assign `{Rhs}` to `{Self}`\",\n    label = \"no implementation for `{Self} *= {Rhs}`\"\n)]\n#[doc(alias = \"*\")]\n#[doc(alias = \"*=\")]\npub trait MulAssign<Rhs = Self> {\n    /// Performs the `*=` operation.\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn mul_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! mul_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl MulAssign for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn mul_assign(&mut self, other: $t) { }\n        }\n\n        forward_ref_op_assign! { impl MulAssign, mul_assign for $t, $t }\n    )+)\n}\n\nmul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The division assignment operator `/=`.\n///\n/// # Examples\n///\n/// ```\n/// use std::ops::DivAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Frequency { hertz: f64 }\n///\n/// impl DivAssign<f64> for Frequency {\n///     fn div_assign(&mut self, rhs: f64) {\n///         self.hertz /= rhs;\n///     }\n/// }\n///\n/// let mut frequency = Frequency { hertz: 200.0 };\n/// frequency /= 4.0;\n/// assert_eq!(Frequency { hertz: 50.0 }, frequency);\n/// ```\n#[lang = \"div_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot divide-assign `{Self}` by `{Rhs}`\",\n    label = \"no implementation for `{Self} /= {Rhs}`\"\n)]\n#[doc(alias = \"/\")]\n#[doc(alias = \"/=\")]\npub trait DivAssign<Rhs = Self> {\n    /// Performs the `/=` operation.\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn div_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! div_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl DivAssign for $t {\n            #[inline]\n            fn div_assign(&mut self, other: $t) { }\n        }\n\n        forward_ref_op_assign! { impl DivAssign, div_assign for $t, $t }\n    )+)\n}\n\ndiv_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n\n/// The remainder assignment operator `%=`.\n///\n/// # Examples\n///\n/// ```\n/// use std::ops::RemAssign;\n///\n/// struct CookieJar { cookies: u32 }\n///\n/// impl RemAssign<u32> for CookieJar {\n///     fn rem_assign(&mut self, piles: u32) {\n///         self.cookies %= piles;\n///     }\n/// }\n///\n/// let mut jar = CookieJar { cookies: 31 };\n/// let piles = 4;\n///\n/// println!(\"Splitting up {} cookies into {} even piles!\", jar.cookies, piles);\n///\n/// jar %= piles;\n///\n/// println!(\"{} cookies remain in the cookie jar!\", jar.cookies);\n/// ```\n#[lang = \"rem_assign\"]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"cannot mod-assign `{Self}` by `{Rhs}``\",\n    label = \"no implementation for `{Self} %= {Rhs}`\"\n)]\n#[doc(alias = \"%\")]\n#[doc(alias = \"%=\")]\npub trait RemAssign<Rhs = Self> {\n    /// Performs the `%=` operation.\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn rem_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! rem_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl RemAssign for $t {\n            #[inline]\n            fn rem_assign(&mut self, other: $t) { }\n        }\n\n        forward_ref_op_assign! { impl RemAssign, rem_assign for $t, $t }\n    )+)\n}\n\nrem_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n}\nmod bit {\n/// The unary logical negation operator `!`.\n///\n/// # Examples\n///\n/// An implementation of `Not` for `Answer`, which enables the use of `!` to\n/// invert its value.\n///\n/// ```\n/// use std::ops::Not;\n///\n/// #[derive(Debug, PartialEq)]\n/// enum Answer {\n///     Yes,\n///     No,\n/// }\n///\n/// impl Not for Answer {\n///     type Output = Answer;\n///\n///     fn not(self) -> Self::Output {\n///         match self {\n///             Answer::Yes => Answer::No,\n///             Answer::No => Answer::Yes\n///         }\n///     }\n/// }\n///\n/// assert_eq!(!Answer::Yes, Answer::No);\n/// assert_eq!(!Answer::No, Answer::Yes);\n/// ```\n#[lang = \"not\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Not {\n    /// The resulting type after applying the `!` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the unary `!` operation.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn not(self) -> Self::Output;\n}\n\nmacro_rules! not_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Not for $t {\n            type Output = $t;\n\n            #[inline]\n            fn not(self) -> $t { }\n        }\n\n        forward_ref_unop! { impl Not, not for $t }\n    )*)\n}\n\nnot_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The bitwise AND operator `&`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory.\n///\n/// # Examples\n///\n/// An implementation of `BitAnd` for a wrapper around `bool`.\n///\n/// ```\n/// use std::ops::BitAnd;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Scalar(bool);\n///\n/// impl BitAnd for Scalar {\n///     type Output = Self;\n///\n///     // rhs is the \"right-hand side\" of the expression `a & b`\n///     fn bitand(self, rhs: Self) -> Self::Output {\n///         Scalar(self.0 & rhs.0)\n///     }\n/// }\n///\n/// assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n/// assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n/// assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n/// assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n/// ```\n///\n/// An implementation of `BitAnd` for a wrapper around `Vec<bool>`.\n///\n/// ```\n/// use std::ops::BitAnd;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct BooleanVector(Vec<bool>);\n///\n/// impl BitAnd for BooleanVector {\n///     type Output = Self;\n///\n///     fn bitand(self, BooleanVector(rhs): Self) -> Self::Output {\n///         let BooleanVector(lhs) = self;\n///         assert_eq!(lhs.len(), rhs.len());\n///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x && *y).collect())\n///     }\n/// }\n///\n/// let bv1 = BooleanVector(vec![true, true, false, false]);\n/// let bv2 = BooleanVector(vec![true, false, true, false]);\n/// let expected = BooleanVector(vec![true, false, false, false]);\n/// assert_eq!(bv1 & bv2, expected);\n/// ```\n#[lang = \"bitand\"]\n#[doc(alias = \"&\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} & {Rhs}`\",\n    label = \"no implementation for `{Self} & {Rhs}`\"\n)]\npub trait BitAnd<Rhs = Self> {\n    /// The resulting type after applying the `&` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `&` operation.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn bitand(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! bitand_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl BitAnd for $t {\n            type Output = $t;\n\n            #[inline]\n            fn bitand(self, rhs: $t) -> $t { }\n        }\n\n        forward_ref_binop! { impl BitAnd, bitand for $t, $t }\n    )*)\n}\n\nbitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The bitwise OR operator `|`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory.\n///\n/// # Examples\n///\n/// An implementation of `BitOr` for a wrapper around `bool`.\n///\n/// ```\n/// use std::ops::BitOr;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Scalar(bool);\n///\n/// impl BitOr for Scalar {\n///     type Output = Self;\n///\n///     // rhs is the \"right-hand side\" of the expression `a | b`\n///     fn bitor(self, rhs: Self) -> Self {\n///         Scalar(self.0 | rhs.0)\n///     }\n/// }\n///\n/// assert_eq!(Scalar(true) | Scalar(true), Scalar(true));\n/// assert_eq!(Scalar(true) | Scalar(false), Scalar(true));\n/// assert_eq!(Scalar(false) | Scalar(true), Scalar(true));\n/// assert_eq!(Scalar(false) | Scalar(false), Scalar(false));\n/// ```\n///\n/// An implementation of `BitOr` for a wrapper around `Vec<bool>`.\n///\n/// ```\n/// use std::ops::BitOr;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct BooleanVector(Vec<bool>);\n///\n/// impl BitOr for BooleanVector {\n///     type Output = Self;\n///\n///     fn bitor(self, BooleanVector(rhs): Self) -> Self::Output {\n///         let BooleanVector(lhs) = self;\n///         assert_eq!(lhs.len(), rhs.len());\n///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x || *y).collect())\n///     }\n/// }\n///\n/// let bv1 = BooleanVector(vec![true, true, false, false]);\n/// let bv2 = BooleanVector(vec![true, false, true, false]);\n/// let expected = BooleanVector(vec![true, true, true, false]);\n/// assert_eq!(bv1 | bv2, expected);\n/// ```\n#[lang = \"bitor\"]\n#[doc(alias = \"|\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} | {Rhs}`\",\n    label = \"no implementation for `{Self} | {Rhs}`\"\n)]\npub trait BitOr<Rhs = Self> {\n    /// The resulting type after applying the `|` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `|` operation.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn bitor(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! bitor_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl BitOr for $t {\n            type Output = $t;\n\n            #[inline]\n            fn bitor(self, rhs: $t) -> $t { }\n        }\n\n        forward_ref_binop! { impl BitOr, bitor for $t, $t }\n    )*)\n}\n\nbitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The bitwise XOR operator `^`.\n///\n/// Note that `Rhs` is `Self` by default, but this is not mandatory.\n///\n/// # Examples\n///\n/// An implementation of `BitXor` that lifts `^` to a wrapper around `bool`.\n///\n/// ```\n/// use std::ops::BitXor;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Scalar(bool);\n///\n/// impl BitXor for Scalar {\n///     type Output = Self;\n///\n///     // rhs is the \"right-hand side\" of the expression `a ^ b`\n///     fn bitxor(self, rhs: Self) -> Self::Output {\n///         Scalar(self.0 ^ rhs.0)\n///     }\n/// }\n///\n/// assert_eq!(Scalar(true) ^ Scalar(true), Scalar(false));\n/// assert_eq!(Scalar(true) ^ Scalar(false), Scalar(true));\n/// assert_eq!(Scalar(false) ^ Scalar(true), Scalar(true));\n/// assert_eq!(Scalar(false) ^ Scalar(false), Scalar(false));\n/// ```\n///\n/// An implementation of `BitXor` trait for a wrapper around `Vec<bool>`.\n///\n/// ```\n/// use std::ops::BitXor;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct BooleanVector(Vec<bool>);\n///\n/// impl BitXor for BooleanVector {\n///     type Output = Self;\n///\n///     fn bitxor(self, BooleanVector(rhs): Self) -> Self::Output {\n///         let BooleanVector(lhs) = self;\n///         assert_eq!(lhs.len(), rhs.len());\n///         BooleanVector(lhs.iter()\n///                          .zip(rhs.iter())\n///                          .map(|(x, y)| (*x || *y) && !(*x && *y))\n///                          .collect())\n///     }\n/// }\n///\n/// let bv1 = BooleanVector(vec![true, true, false, false]);\n/// let bv2 = BooleanVector(vec![true, false, true, false]);\n/// let expected = BooleanVector(vec![false, true, true, false]);\n/// assert_eq!(bv1 ^ bv2, expected);\n/// ```\n#[lang = \"bitxor\"]\n#[doc(alias = \"^\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} ^ {Rhs}`\",\n    label = \"no implementation for `{Self} ^ {Rhs}`\"\n)]\npub trait BitXor<Rhs = Self> {\n    /// The resulting type after applying the `^` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `^` operation.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn bitxor(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! bitxor_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl BitXor for $t {\n            type Output = $t;\n\n            #[inline]\n            fn bitxor(self, other: $t) -> $t { }\n        }\n\n        forward_ref_binop! { impl BitXor, bitxor for $t, $t }\n    )*)\n}\n\nbitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The left shift operator `<<`. Note that because this trait is implemented\n/// for all integer types with multiple right-hand-side types, Rust's type\n/// checker has special handling for `_ << _`, setting the result type for\n/// integer operations to the type of the left-hand-side operand. This means\n/// that though `a << b` and `a.shl(b)` are one and the same from an evaluation\n/// standpoint, they are different when it comes to type inference.\n///\n/// # Examples\n///\n/// An implementation of `Shl` that lifts the `<<` operation on integers to a\n/// wrapper around `usize`.\n///\n/// ```\n/// use std::ops::Shl;\n///\n/// #[derive(PartialEq, Debug)]\n/// struct Scalar(usize);\n///\n/// impl Shl<Scalar> for Scalar {\n///     type Output = Self;\n///\n///     fn shl(self, Scalar(rhs): Self) -> Scalar {\n///         let Scalar(lhs) = self;\n///         Scalar(lhs << rhs)\n///     }\n/// }\n///\n/// assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n/// ```\n///\n/// An implementation of `Shl` that spins a vector leftward by a given amount.\n///\n/// ```\n/// use std::ops::Shl;\n///\n/// #[derive(PartialEq, Debug)]\n/// struct SpinVector<T: Clone> {\n///     vec: Vec<T>,\n/// }\n///\n/// impl<T: Clone> Shl<usize> for SpinVector<T> {\n///     type Output = Self;\n///\n///     fn shl(self, rhs: usize) -> Self::Output {\n///         // Rotate the vector by `rhs` places.\n///         let (a, b) = self.vec.split_at(rhs);\n///         let mut spun_vector: Vec<T> = vec![];\n///         spun_vector.extend_from_slice(b);\n///         spun_vector.extend_from_slice(a);\n///         SpinVector { vec: spun_vector }\n///     }\n/// }\n///\n/// assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n///            SpinVector { vec: vec![2, 3, 4, 0, 1] });\n/// ```\n#[lang = \"shl\"]\n#[doc(alias = \"<<\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} << {Rhs}`\",\n    label = \"no implementation for `{Self} << {Rhs}`\"\n)]\npub trait Shl<Rhs = Self> {\n    /// The resulting type after applying the `<<` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `<<` operation.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn shl(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! shl_impl {\n    ($t:ty, $f:ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Shl<$f> for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn shl(self, other: $f) -> $t {\n}\n        }\n\n        forward_ref_binop! { impl Shl, shl for $t, $f }\n    };\n}\n\nmacro_rules! shl_impl_all {\n    ($($t:ty)*) => ($(\n        shl_impl! { $t, u8 }\n        shl_impl! { $t, u16 }\n        shl_impl! { $t, u32 }\n        shl_impl! { $t, u64 }\n        shl_impl! { $t, u128 }\n        shl_impl! { $t, usize }\n\n        shl_impl! { $t, i8 }\n        shl_impl! { $t, i16 }\n        shl_impl! { $t, i32 }\n        shl_impl! { $t, i64 }\n        shl_impl! { $t, i128 }\n        shl_impl! { $t, isize }\n    )*)\n}\n\nshl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n\n/// The right shift operator `>>`. Note that because this trait is implemented\n/// for all integer types with multiple right-hand-side types, Rust's type\n/// checker has special handling for `_ >> _`, setting the result type for\n/// integer operations to the type of the left-hand-side operand. This means\n/// that though `a >> b` and `a.shr(b)` are one and the same from an evaluation\n/// standpoint, they are different when it comes to type inference.\n///\n/// # Examples\n///\n/// An implementation of `Shr` that lifts the `>>` operation on integers to a\n/// wrapper around `usize`.\n///\n/// ```\n/// use std::ops::Shr;\n///\n/// #[derive(PartialEq, Debug)]\n/// struct Scalar(usize);\n///\n/// impl Shr<Scalar> for Scalar {\n///     type Output = Self;\n///\n///     fn shr(self, Scalar(rhs): Self) -> Scalar {\n///         let Scalar(lhs) = self;\n///         Scalar(lhs >> rhs)\n///     }\n/// }\n///\n/// assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n/// ```\n///\n/// An implementation of `Shr` that spins a vector rightward by a given amount.\n///\n/// ```\n/// use std::ops::Shr;\n///\n/// #[derive(PartialEq, Debug)]\n/// struct SpinVector<T: Clone> {\n///     vec: Vec<T>,\n/// }\n///\n/// impl<T: Clone> Shr<usize> for SpinVector<T> {\n///     type Output = Self;\n///\n///     fn shr(self, rhs: usize) -> Self::Output {\n///         // Rotate the vector by `rhs` places.\n///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n///         let mut spun_vector: Vec<T> = vec![];\n///         spun_vector.extend_from_slice(b);\n///         spun_vector.extend_from_slice(a);\n///         SpinVector { vec: spun_vector }\n///     }\n/// }\n///\n/// assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n///            SpinVector { vec: vec![3, 4, 0, 1, 2] });\n/// ```\n#[lang = \"shr\"]\n#[doc(alias = \">>\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} >> {Rhs}`\",\n    label = \"no implementation for `{Self} >> {Rhs}`\"\n)]\npub trait Shr<Rhs = Self> {\n    /// The resulting type after applying the `>>` operator.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output;\n\n    /// Performs the `>>` operation.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn shr(self, rhs: Rhs) -> Self::Output;\n}\n\nmacro_rules! shr_impl {\n    ($t:ty, $f:ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Shr<$f> for $t {\n            type Output = $t;\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn shr(self, other: $f) -> $t {\n}\n        }\n\n        forward_ref_binop! { impl Shr, shr for $t, $f }\n    };\n}\n\nmacro_rules! shr_impl_all {\n    ($($t:ty)*) => ($(\n        shr_impl! { $t, u8 }\n        shr_impl! { $t, u16 }\n        shr_impl! { $t, u32 }\n        shr_impl! { $t, u64 }\n        shr_impl! { $t, u128 }\n        shr_impl! { $t, usize }\n\n        shr_impl! { $t, i8 }\n        shr_impl! { $t, i16 }\n        shr_impl! { $t, i32 }\n        shr_impl! { $t, i64 }\n        shr_impl! { $t, i128 }\n        shr_impl! { $t, isize }\n    )*)\n}\n\nshr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n\n/// The bitwise AND assignment operator `&=`.\n///\n/// # Examples\n///\n/// An implementation of `BitAndAssign` that lifts the `&=` operator to a\n/// wrapper around `bool`.\n///\n/// ```\n/// use std::ops::BitAndAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Scalar(bool);\n///\n/// impl BitAndAssign for Scalar {\n///     // rhs is the \"right-hand side\" of the expression `a &= b`\n///     fn bitand_assign(&mut self, rhs: Self) {\n///         *self = Scalar(self.0 & rhs.0)\n///     }\n/// }\n///\n/// let mut scalar = Scalar(true);\n/// scalar &= Scalar(true);\n/// assert_eq!(scalar, Scalar(true));\n///\n/// let mut scalar = Scalar(true);\n/// scalar &= Scalar(false);\n/// assert_eq!(scalar, Scalar(false));\n///\n/// let mut scalar = Scalar(false);\n/// scalar &= Scalar(true);\n/// assert_eq!(scalar, Scalar(false));\n///\n/// let mut scalar = Scalar(false);\n/// scalar &= Scalar(false);\n/// assert_eq!(scalar, Scalar(false));\n/// ```\n///\n/// Here, the `BitAndAssign` trait is implemented for a wrapper around\n/// `Vec<bool>`.\n///\n/// ```\n/// use std::ops::BitAndAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct BooleanVector(Vec<bool>);\n///\n/// impl BitAndAssign for BooleanVector {\n///     // `rhs` is the \"right-hand side\" of the expression `a &= b`.\n///     fn bitand_assign(&mut self, rhs: Self) {\n///         assert_eq!(self.0.len(), rhs.0.len());\n///         *self = BooleanVector(self.0\n///                                   .iter()\n///                                   .zip(rhs.0.iter())\n///                                   .map(|(x, y)| *x && *y)\n///                                   .collect());\n///     }\n/// }\n///\n/// let mut bv = BooleanVector(vec![true, true, false, false]);\n/// bv &= BooleanVector(vec![true, false, true, false]);\n/// let expected = BooleanVector(vec![true, false, false, false]);\n/// assert_eq!(bv, expected);\n/// ```\n#[lang = \"bitand_assign\"]\n#[doc(alias = \"&=\")]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} &= {Rhs}`\",\n    label = \"no implementation for `{Self} &= {Rhs}`\"\n)]\npub trait BitAndAssign<Rhs = Self> {\n    /// Performs the `&=` operation.\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn bitand_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! bitand_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl BitAndAssign for $t {\n            #[inline]\n            fn bitand_assign(&mut self, other: $t) { }\n        }\n\n        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for $t, $t }\n    )+)\n}\n\nbitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The bitwise OR assignment operator `|=`.\n///\n/// # Examples\n///\n/// ```\n/// use std::ops::BitOrAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct PersonalPreferences {\n///     likes_cats: bool,\n///     likes_dogs: bool,\n/// }\n///\n/// impl BitOrAssign for PersonalPreferences {\n///     fn bitor_assign(&mut self, rhs: Self) {\n///         self.likes_cats |= rhs.likes_cats;\n///         self.likes_dogs |= rhs.likes_dogs;\n///     }\n/// }\n///\n/// let mut prefs = PersonalPreferences { likes_cats: true, likes_dogs: false };\n/// prefs |= PersonalPreferences { likes_cats: false, likes_dogs: true };\n/// assert_eq!(prefs, PersonalPreferences { likes_cats: true, likes_dogs: true });\n/// ```\n#[lang = \"bitor_assign\"]\n#[doc(alias = \"|=\")]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} |= {Rhs}`\",\n    label = \"no implementation for `{Self} |= {Rhs}`\"\n)]\npub trait BitOrAssign<Rhs = Self> {\n    /// Performs the `|=` operation.\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn bitor_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! bitor_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl BitOrAssign for $t {\n            #[inline]\n            fn bitor_assign(&mut self, other: $t) { }\n        }\n\n        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for $t, $t }\n    )+)\n}\n\nbitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The bitwise XOR assignment operator `^=`.\n///\n/// # Examples\n///\n/// ```\n/// use std::ops::BitXorAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Personality {\n///     has_soul: bool,\n///     likes_knitting: bool,\n/// }\n///\n/// impl BitXorAssign for Personality {\n///     fn bitxor_assign(&mut self, rhs: Self) {\n///         self.has_soul ^= rhs.has_soul;\n///         self.likes_knitting ^= rhs.likes_knitting;\n///     }\n/// }\n///\n/// let mut personality = Personality { has_soul: false, likes_knitting: true };\n/// personality ^= Personality { has_soul: true, likes_knitting: true };\n/// assert_eq!(personality, Personality { has_soul: true, likes_knitting: false});\n/// ```\n#[lang = \"bitxor_assign\"]\n#[doc(alias = \"^=\")]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} ^= {Rhs}`\",\n    label = \"no implementation for `{Self} ^= {Rhs}`\"\n)]\npub trait BitXorAssign<Rhs = Self> {\n    /// Performs the `^=` operation.\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn bitxor_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! bitxor_assign_impl {\n    ($($t:ty)+) => ($(\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl BitXorAssign for $t {\n            #[inline]\n            fn bitxor_assign(&mut self, other: $t) { }\n        }\n\n        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for $t, $t }\n    )+)\n}\n\nbitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n\n/// The left shift assignment operator `<<=`.\n///\n/// # Examples\n///\n/// An implementation of `ShlAssign` for a wrapper around `usize`.\n///\n/// ```\n/// use std::ops::ShlAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Scalar(usize);\n///\n/// impl ShlAssign<usize> for Scalar {\n///     fn shl_assign(&mut self, rhs: usize) {\n///         self.0 <<= rhs;\n///     }\n/// }\n///\n/// let mut scalar = Scalar(4);\n/// scalar <<= 2;\n/// assert_eq!(scalar, Scalar(16));\n/// ```\n#[lang = \"shl_assign\"]\n#[doc(alias = \"<<=\")]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} <<= {Rhs}`\",\n    label = \"no implementation for `{Self} <<= {Rhs}`\"\n)]\npub trait ShlAssign<Rhs = Self> {\n    /// Performs the `<<=` operation.\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn shl_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! shl_assign_impl {\n    ($t:ty, $f:ty) => {\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl ShlAssign<$f> for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn shl_assign(&mut self, other: $f) {\n}\n        }\n\n        forward_ref_op_assign! { impl ShlAssign, shl_assign for $t, $f }\n    };\n}\n\nmacro_rules! shl_assign_impl_all {\n    ($($t:ty)*) => ($(\n        shl_assign_impl! { $t, u8 }\n        shl_assign_impl! { $t, u16 }\n        shl_assign_impl! { $t, u32 }\n        shl_assign_impl! { $t, u64 }\n        shl_assign_impl! { $t, u128 }\n        shl_assign_impl! { $t, usize }\n\n        shl_assign_impl! { $t, i8 }\n        shl_assign_impl! { $t, i16 }\n        shl_assign_impl! { $t, i32 }\n        shl_assign_impl! { $t, i64 }\n        shl_assign_impl! { $t, i128 }\n        shl_assign_impl! { $t, isize }\n    )*)\n}\n\nshl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n\n/// The right shift assignment operator `>>=`.\n///\n/// # Examples\n///\n/// An implementation of `ShrAssign` for a wrapper around `usize`.\n///\n/// ```\n/// use std::ops::ShrAssign;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Scalar(usize);\n///\n/// impl ShrAssign<usize> for Scalar {\n///     fn shr_assign(&mut self, rhs: usize) {\n///         self.0 >>= rhs;\n///     }\n/// }\n///\n/// let mut scalar = Scalar(16);\n/// scalar >>= 2;\n/// assert_eq!(scalar, Scalar(4));\n/// ```\n#[lang = \"shr_assign\"]\n#[doc(alias = \">>=\")]\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n#[rustc_on_unimplemented(\n    message = \"no implementation for `{Self} >>= {Rhs}`\",\n    label = \"no implementation for `{Self} >>= {Rhs}`\"\n)]\npub trait ShrAssign<Rhs = Self> {\n    /// Performs the `>>=` operation.\n    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n    fn shr_assign(&mut self, rhs: Rhs);\n}\n\nmacro_rules! shr_assign_impl {\n    ($t:ty, $f:ty) => {\n        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n        impl ShrAssign<$f> for $t {\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn shr_assign(&mut self, other: $f) {\n}\n        }\n\n        forward_ref_op_assign! { impl ShrAssign, shr_assign for $t, $f }\n    };\n}\n\nmacro_rules! shr_assign_impl_all {\n    ($($t:ty)*) => ($(\n        shr_assign_impl! { $t, u8 }\n        shr_assign_impl! { $t, u16 }\n        shr_assign_impl! { $t, u32 }\n        shr_assign_impl! { $t, u64 }\n        shr_assign_impl! { $t, u128 }\n        shr_assign_impl! { $t, usize }\n\n        shr_assign_impl! { $t, i8 }\n        shr_assign_impl! { $t, i16 }\n        shr_assign_impl! { $t, i32 }\n        shr_assign_impl! { $t, i64 }\n        shr_assign_impl! { $t, i128 }\n        shr_assign_impl! { $t, isize }\n    )*)\n}\n\nshr_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n}\nmod deref {\n/// Used for immutable dereferencing operations, like `*v`.\n///\n/// In addition to being used for explicit dereferencing operations with the\n/// (unary) `*` operator in immutable contexts, `Deref` is also used implicitly\n/// by the compiler in many circumstances. This mechanism is called\n/// ['`Deref` coercion'][more]. In mutable contexts, [`DerefMut`] is used.\n///\n/// Implementing `Deref` for smart pointers makes accessing the data behind them\n/// convenient, which is why they implement `Deref`. On the other hand, the\n/// rules regarding `Deref` and [`DerefMut`] were designed specifically to\n/// accommodate smart pointers. Because of this, **`Deref` should only be\n/// implemented for smart pointers** to avoid confusion.\n///\n/// For similar reasons, **this trait should never fail**. Failure during\n/// dereferencing can be extremely confusing when `Deref` is invoked implicitly.\n///\n/// # More on `Deref` coercion\n///\n/// If `T` implements `Deref<Target = U>`, and `x` is a value of type `T`, then:\n///\n/// * In immutable contexts, `*x` on non-pointer types is equivalent to\n///   `*Deref::deref(&x)`.\n/// * Values of type `&T` are coerced to values of type `&U`\n/// * `T` implicitly implements all the (immutable) methods of the type `U`.\n///\n/// For more details, visit [the chapter in *The Rust Programming Language*][book]\n/// as well as the reference sections on [the dereference operator][ref-deref-op],\n/// [method resolution] and [type coercions].\n///\n/// [book]: ../../book/ch15-02-deref.html\n/// [`DerefMut`]: trait.DerefMut.html\n/// [more]: #more-on-deref-coercion\n/// [ref-deref-op]: ../../reference/expressions/operator-expr.html#the-dereference-operator\n/// [method resolution]: ../../reference/expressions/method-call-expr.html\n/// [type coercions]: ../../reference/type-coercions.html\n///\n/// # Examples\n///\n/// A struct with a single field which is accessible by dereferencing the\n/// struct.\n///\n/// ```\n/// use std::ops::Deref;\n///\n/// struct DerefExample<T> {\n///     value: T\n/// }\n///\n/// impl<T> Deref for DerefExample<T> {\n///     type Target = T;\n///\n///     fn deref(&self) -> &Self::Target {\n///         &self.value\n///     }\n/// }\n///\n/// let x = DerefExample { value: 'a' };\n/// assert_eq!('a', *x);\n/// ```\n#[lang = \"deref\"]\n#[doc(alias = \"*\")]\n#[doc(alias = \"&*\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Deref {\n    /// The resulting type after dereferencing.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Target: ?Sized;\n\n    /// Dereferences the value.\n    #[must_use]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn deref(&self) -> &Self::Target;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Deref for &T {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Deref for &mut T {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n}\n}\n\n/// Used for mutable dereferencing operations, like in `*v = 1;`.\n///\n/// In addition to being used for explicit dereferencing operations with the\n/// (unary) `*` operator in mutable contexts, `DerefMut` is also used implicitly\n/// by the compiler in many circumstances. This mechanism is called\n/// ['`Deref` coercion'][more]. In immutable contexts, [`Deref`] is used.\n///\n/// Implementing `DerefMut` for smart pointers makes mutating the data behind\n/// them convenient, which is why they implement `DerefMut`. On the other hand,\n/// the rules regarding [`Deref`] and `DerefMut` were designed specifically to\n/// accommodate smart pointers. Because of this, **`DerefMut` should only be\n/// implemented for smart pointers** to avoid confusion.\n///\n/// For similar reasons, **this trait should never fail**. Failure during\n/// dereferencing can be extremely confusing when `DerefMut` is invoked\n/// implicitly.\n///\n/// # More on `Deref` coercion\n///\n/// If `T` implements `DerefMut<Target = U>`, and `x` is a value of type `T`,\n/// then:\n///\n/// * In mutable contexts, `*x` on non-pointer types is equivalent to\n///   `*DerefMut::deref_mut(&mut x)`.\n/// * Values of type `&mut T` are coerced to values of type `&mut U`\n/// * `T` implicitly implements all the (mutable) methods of the type `U`.\n///\n/// For more details, visit [the chapter in *The Rust Programming Language*][book]\n/// as well as the reference sections on [the dereference operator][ref-deref-op],\n/// [method resolution] and [type coercions].\n///\n/// [book]: ../../book/ch15-02-deref.html\n/// [`Deref`]: trait.Deref.html\n/// [more]: #more-on-deref-coercion\n/// [ref-deref-op]: ../../reference/expressions/operator-expr.html#the-dereference-operator\n/// [method resolution]: ../../reference/expressions/method-call-expr.html\n/// [type coercions]: ../../reference/type-coercions.html\n///\n/// # Examples\n///\n/// A struct with a single field which is modifiable by dereferencing the\n/// struct.\n///\n/// ```\n/// use std::ops::{Deref, DerefMut};\n///\n/// struct DerefMutExample<T> {\n///     value: T\n/// }\n///\n/// impl<T> Deref for DerefMutExample<T> {\n///     type Target = T;\n///\n///     fn deref(&self) -> &Self::Target {\n///         &self.value\n///     }\n/// }\n///\n/// impl<T> DerefMut for DerefMutExample<T> {\n///     fn deref_mut(&mut self) -> &mut Self::Target {\n///         &mut self.value\n///     }\n/// }\n///\n/// let mut x = DerefMutExample { value: 'a' };\n/// *x = 'b';\n/// assert_eq!('b', *x);\n/// ```\n#[lang = \"deref_mut\"]\n#[doc(alias = \"*\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait DerefMut: Deref {\n    /// Mutably dereferences the value.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn deref_mut(&mut self) -> &mut Self::Target;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> DerefMut for &mut T {\n    fn deref_mut(&mut self) -> &mut T {\n}\n}\n\n/// Indicates that a struct can be used as a method receiver, without the\n/// `arbitrary_self_types` feature. This is implemented by stdlib pointer types like `Box<T>`,\n/// `Rc<T>`, `&T`, and `Pin<P>`.\n#[lang = \"receiver\"]\n#[unstable(feature = \"receiver_trait\", issue = \"none\")]\n#[doc(hidden)]\npub trait Receiver {\n}\n\n#[unstable(feature = \"receiver_trait\", issue = \"none\")]\nimpl<T: ?Sized> Receiver for &T {}}\nmod drop {\n/// Used to run some code when a value goes out of scope.\n/// This is sometimes called a 'destructor'.\n///\n/// When a value goes out of scope, it will have its `drop` method called if\n/// its type implements `Drop`. Then, any fields the value contains will also\n/// be dropped recursively.\n///\n/// Because of this recursive dropping, you do not need to implement this trait\n/// unless your type needs its own destructor logic.\n///\n/// Refer to [the chapter on `Drop` in *The Rust Programming Language*][book]\n/// for some more elaboration.\n///\n/// [book]: ../../book/ch15-03-drop.html\n///\n/// # Examples\n///\n/// ## Implementing `Drop`\n///\n/// The `drop` method is called when `_x` goes out of scope, and therefore\n/// `main` prints `Dropping!`.\n///\n/// ```\n/// struct HasDrop;\n///\n/// impl Drop for HasDrop {\n///     fn drop(&mut self) {\n///         println!(\"Dropping!\");\n///     }\n/// }\n///\n/// fn main() {\n///     let _x = HasDrop;\n/// }\n/// ```\n///\n/// ## Dropping is done recursively\n///\n/// When `outer` goes out of scope, the `drop` method will be called first for\n/// `Outer`, then for `Inner`. Therefore, `main` prints `Dropping Outer!` and\n/// then `Dropping Inner!`.\n///\n/// ```\n/// struct Inner;\n/// struct Outer(Inner);\n///\n/// impl Drop for Inner {\n///     fn drop(&mut self) {\n///         println!(\"Dropping Inner!\");\n///     }\n/// }\n///\n/// impl Drop for Outer {\n///     fn drop(&mut self) {\n///         println!(\"Dropping Outer!\");\n///     }\n/// }\n///\n/// fn main() {\n///     let _x = Outer(Inner);\n/// }\n/// ```\n///\n/// ## Variables are dropped in reverse order of declaration\n///\n/// `_first` is declared first and `_second` is declared second, so `main` will\n/// print `Declared second!` and then `Declared first!`.\n///\n/// ```\n/// struct PrintOnDrop(&'static str);\n///\n/// impl Drop for PrintOnDrop {\n///     fn drop(&mut self) {\n///         println!(\"{}\", self.0);\n///     }\n/// }\n///\n/// fn main() {\n///     let _first = PrintOnDrop(\"Declared first!\");\n///     let _second = PrintOnDrop(\"Declared second!\");\n/// }\n/// ```\n#[lang = \"drop\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Drop {\n    /// Executes the destructor for this type.\n    ///\n    /// This method is called implicitly when the value goes out of scope,\n    /// and cannot be called explicitly (this is compiler error [E0040]).\n    /// However, the [`std::mem::drop`] function in the prelude can be\n    /// used to call the argument's `Drop` implementation.\n    ///\n    /// When this method has been called, `self` has not yet been deallocated.\n    /// That only happens after the method is over.\n    /// If this wasn't the case, `self` would be a dangling reference.\n    ///\n    /// # Panics\n    ///\n    /// Given that a [`panic!`] will call `drop` as it unwinds, any [`panic!`]\n    /// in a `drop` implementation will likely abort.\n    ///\n    /// Note that even if this panics, the value is considered to be dropped;\n    /// you must not cause `drop` to be called again. This is normally automatically\n    /// handled by the compiler, but when using unsafe code, can sometimes occur\n    /// unintentionally, particularly when using [`std::ptr::drop_in_place`].\n    ///\n    /// [E0040]: ../../error-index.html#E0040\n    /// [`panic!`]: ../macro.panic.html\n    /// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n    /// [`std::ptr::drop_in_place`]: ../../std/ptr/fn.drop_in_place.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn drop(&mut self);\n}\n}\nmod function {\n/// The version of the call operator that takes an immutable receiver.\n///\n/// Instances of `Fn` can be called repeatedly without mutating state.\n///\n/// *This trait (`Fn`) is not to be confused with [function pointers]\n/// (`fn`).*\n///\n/// `Fn` is implemented automatically by closures which only take immutable\n/// references to captured variables or don't capture anything at all, as well\n/// as (safe) [function pointers] (with some caveats, see their documentation\n/// for more details). Additionally, for any type `F` that implements `Fn`, `&F`\n/// implements `Fn`, too.\n///\n/// Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\n/// instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`]\n/// is expected.\n///\n/// Use `Fn` as a bound when you want to accept a parameter of function-like\n/// type and need to call it repeatedly and without mutating state (e.g., when\n/// calling it concurrently). If you do not need such strict requirements, use\n/// [`FnMut`] or [`FnOnce`] as bounds.\n///\n/// See the [chapter on closures in *The Rust Programming Language*][book] for\n/// some more information on this topic.\n///\n/// Also of note is the special syntax for `Fn` traits (e.g.\n/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n///\n/// [book]: ../../book/ch13-01-closures.html\n/// [`FnMut`]: trait.FnMut.html\n/// [`FnOnce`]: trait.FnOnce.html\n/// [function pointers]: ../../std/primitive.fn.html\n/// [nomicon]: ../../nomicon/hrtb.html\n///\n/// # Examples\n///\n/// ## Calling a closure\n///\n/// ```\n/// let square = |x| x * x;\n/// assert_eq!(square(5), 25);\n/// ```\n///\n/// ## Using a `Fn` parameter\n///\n/// ```\n/// fn call_with_one<F>(func: F) -> usize\n///     where F: Fn(usize) -> usize {\n///     func(1)\n/// }\n///\n/// let double = |x| x * 2;\n/// assert_eq!(call_with_one(double), 2);\n/// ```\n#[lang = \"fn\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[rustc_on_unimplemented(\n    on(\n        Args = \"()\",\n        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n    ),\n    message = \"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n    label = \"expected an `Fn<{Args}>` closure, found `{Self}`\"\n)]\n#[fundamental] // so that regex can rely that `&str: !FnMut`\n#[must_use = \"closures are lazy and do nothing unless called\"]\npub trait Fn<Args>: FnMut<Args> {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n}\n\n/// The version of the call operator that takes a mutable receiver.\n///\n/// Instances of `FnMut` can be called repeatedly and may mutate state.\n///\n/// `FnMut` is implemented automatically by closures which take mutable\n/// references to captured variables, as well as all types that implement\n/// [`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of\n/// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\n/// implements `FnMut`, too.\n///\n/// Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be\n/// used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of\n/// `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.\n///\n/// Use `FnMut` as a bound when you want to accept a parameter of function-like\n/// type and need to call it repeatedly, while allowing it to mutate state.\n/// If you don't want the parameter to mutate state, use [`Fn`] as a\n/// bound; if you don't need to call it repeatedly, use [`FnOnce`].\n///\n/// See the [chapter on closures in *The Rust Programming Language*][book] for\n/// some more information on this topic.\n///\n/// Also of note is the special syntax for `Fn` traits (e.g.\n/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n///\n/// [book]: ../../book/ch13-01-closures.html\n/// [`Fn`]: trait.Fn.html\n/// [`FnOnce`]: trait.FnOnce.html\n/// [function pointers]: ../../std/primitive.fn.html\n/// [nomicon]: ../../nomicon/hrtb.html\n///\n/// # Examples\n///\n/// ## Calling a mutably capturing closure\n///\n/// ```\n/// let mut x = 5;\n/// {\n///     let mut square_x = || x *= x;\n///     square_x();\n/// }\n/// assert_eq!(x, 25);\n/// ```\n///\n/// ## Using a `FnMut` parameter\n///\n/// ```\n/// fn do_twice<F>(mut func: F)\n///     where F: FnMut()\n/// {\n///     func();\n///     func();\n/// }\n///\n/// let mut x: usize = 1;\n/// {\n///     let add_two_to_x = || x += 2;\n///     do_twice(add_two_to_x);\n/// }\n///\n/// assert_eq!(x, 5);\n/// ```\n#[lang = \"fn_mut\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[rustc_on_unimplemented(\n    on(\n        Args = \"()\",\n        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n    ),\n    message = \"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n    label = \"expected an `FnMut<{Args}>` closure, found `{Self}`\"\n)]\n#[fundamental] // so that regex can rely that `&str: !FnMut`\n#[must_use = \"closures are lazy and do nothing unless called\"]\npub trait FnMut<Args>: FnOnce<Args> {\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n}\n\n/// The version of the call operator that takes a by-value receiver.\n///\n/// Instances of `FnOnce` can be called, but might not be callable multiple\n/// times. Because of this, if the only thing known about a type is that it\n/// implements `FnOnce`, it can only be called once.\n///\n/// `FnOnce` is implemented automatically by closure that might consume captured\n/// variables, as well as all types that implement [`FnMut`], e.g., (safe)\n/// [function pointers] (since `FnOnce` is a supertrait of [`FnMut`]).\n///\n/// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n/// [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n///\n/// Use `FnOnce` as a bound when you want to accept a parameter of function-like\n/// type and only need to call it once. If you need to call the parameter\n/// repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate\n/// state, use [`Fn`].\n///\n/// See the [chapter on closures in *The Rust Programming Language*][book] for\n/// some more information on this topic.\n///\n/// Also of note is the special syntax for `Fn` traits (e.g.\n/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n///\n/// [book]: ../../book/ch13-01-closures.html\n/// [`Fn`]: trait.Fn.html\n/// [`FnMut`]: trait.FnMut.html\n/// [function pointers]: ../../std/primitive.fn.html\n/// [nomicon]: ../../nomicon/hrtb.html\n///\n/// # Examples\n///\n/// ## Using a `FnOnce` parameter\n///\n/// ```\n/// fn consume_with_relish<F>(func: F)\n///     where F: FnOnce() -> String\n/// {\n///     // `func` consumes its captured variables, so it cannot be run more\n///     // than once.\n///     println!(\"Consumed: {}\", func());\n///\n///     println!(\"Delicious!\");\n///\n///     // Attempting to invoke `func()` again will throw a `use of moved\n///     // value` error for `func`.\n/// }\n///\n/// let x = String::from(\"x\");\n/// let consume_and_return_x = move || x;\n/// consume_with_relish(consume_and_return_x);\n///\n/// // `consume_and_return_x` can no longer be invoked at this point\n/// ```\n#[lang = \"fn_once\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_paren_sugar]\n#[rustc_on_unimplemented(\n    on(\n        Args = \"()\",\n        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"\n    ),\n    message = \"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n    label = \"expected an `FnOnce<{Args}>` closure, found `{Self}`\"\n)]\n#[fundamental] // so that regex can rely that `&str: !FnMut`\n#[must_use = \"closures are lazy and do nothing unless called\"]\npub trait FnOnce<Args> {\n    /// The returned type after the call operator is used.\n    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n    type Output;\n\n    /// Performs the call operation.\n    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n}\n\nmod impls {\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A, F: ?Sized> Fn<A> for &F\n    where\n        F: Fn<A>,\n    {\n        extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A, F: ?Sized> FnMut<A> for &F\n    where\n        F: Fn<A>,\n    {\n        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A, F: ?Sized> FnOnce<A> for &F\n    where\n        F: Fn<A>,\n    {\n        type Output = F::Output;\n\n        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A, F: ?Sized> FnMut<A> for &mut F\n    where\n        F: FnMut<A>,\n    {\n        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<A, F: ?Sized> FnOnce<A> for &mut F\n    where\n        F: FnMut<A>,\n    {\n        type Output = F::Output;\n        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n}\n    }\n}\n}\nmod generator {\nuse crate::marker::Unpin;\nuse crate::pin::Pin;\n\n/// The result of a generator resumption.\n///\n/// This enum is returned from the `Generator::resume` method and indicates the\n/// possible return values of a generator. Currently this corresponds to either\n/// a suspension point (`Yielded`) or a termination point (`Complete`).\n#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n#[lang = \"generator_state\"]\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\npub enum GeneratorState<Y, R> {\n}\n\n/// The trait implemented by builtin generator types.\n///\n/// Generators, also commonly referred to as coroutines, are currently an\n/// experimental language feature in Rust. Added in [RFC 2033] generators are\n/// currently intended to primarily provide a building block for async/await\n/// syntax but will likely extend to also providing an ergonomic definition for\n/// iterators and other primitives.\n///\n/// The syntax and semantics for generators is unstable and will require a\n/// further RFC for stabilization. At this time, though, the syntax is\n/// closure-like:\n///\n/// ```rust\n/// #![feature(generators, generator_trait)]\n///\n/// use std::ops::{Generator, GeneratorState};\n/// use std::pin::Pin;\n///\n/// fn main() {\n///     let mut generator = || {\n///         yield 1;\n///         return \"foo\"\n///     };\n///\n///     match Pin::new(&mut generator).resume() {\n///         GeneratorState::Yielded(1) => {}\n///         _ => panic!(\"unexpected return from resume\"),\n///     }\n///     match Pin::new(&mut generator).resume() {\n///         GeneratorState::Complete(\"foo\") => {}\n///         _ => panic!(\"unexpected return from resume\"),\n///     }\n/// }\n/// ```\n///\n/// More documentation of generators can be found in the unstable book.\n///\n/// [RFC 2033]: https://github.com/rust-lang/rfcs/pull/2033\n#[lang = \"generator\"]\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n#[fundamental]\npub trait Generator {\n}\n\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\nimpl<G: ?Sized + Generator> Generator for Pin<&mut G> {\n}\n\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\nimpl<G: ?Sized + Generator + Unpin> Generator for &mut G {\n}\n}\nmod index {\n/// Used for indexing operations (`container[index]`) in immutable contexts.\n///\n/// `container[index]` is actually syntactic sugar for `*container.index(index)`,\n/// but only when used as an immutable value. If a mutable value is requested,\n/// [`IndexMut`] is used instead. This allows nice things such as\n/// `let value = v[index]` if the type of `value` implements [`Copy`].\n///\n/// [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n/// [`Copy`]: ../../std/marker/trait.Copy.html\n///\n/// # Examples\n///\n/// The following example implements `Index` on a read-only `NucleotideCount`\n/// container, enabling individual counts to be retrieved with index syntax.\n///\n/// ```\n/// use std::ops::Index;\n///\n/// enum Nucleotide {\n///     A,\n///     C,\n///     G,\n///     T,\n/// }\n///\n/// struct NucleotideCount {\n///     a: usize,\n///     c: usize,\n///     g: usize,\n///     t: usize,\n/// }\n///\n/// impl Index<Nucleotide> for NucleotideCount {\n///     type Output = usize;\n///\n///     fn index(&self, nucleotide: Nucleotide) -> &Self::Output {\n///         match nucleotide {\n///             Nucleotide::A => &self.a,\n///             Nucleotide::C => &self.c,\n///             Nucleotide::G => &self.g,\n///             Nucleotide::T => &self.t,\n///         }\n///     }\n/// }\n///\n/// let nucleotide_count = NucleotideCount {a: 14, c: 9, g: 10, t: 12};\n/// assert_eq!(nucleotide_count[Nucleotide::A], 14);\n/// assert_eq!(nucleotide_count[Nucleotide::C], 9);\n/// assert_eq!(nucleotide_count[Nucleotide::G], 10);\n/// assert_eq!(nucleotide_count[Nucleotide::T], 12);\n/// ```\n#[lang = \"index\"]\n#[rustc_on_unimplemented(\n    message = \"the type `{Self}` cannot be indexed by `{Idx}`\",\n    label = \"`{Self}` cannot be indexed by `{Idx}`\"\n)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(alias = \"]\")]\n#[doc(alias = \"[\")]\n#[doc(alias = \"[]\")]\npub trait Index<Idx: ?Sized> {\n    /// The returned type after indexing.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Output: ?Sized;\n\n    /// Performs the indexing (`container[index]`) operation.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn index(&self, index: Idx) -> &Self::Output;\n}\n\n/// Used for indexing operations (`container[index]`) in mutable contexts.\n///\n/// `container[index]` is actually syntactic sugar for\n/// `*container.index_mut(index)`, but only when used as a mutable value. If\n/// an immutable value is requested, the [`Index`] trait is used instead. This\n/// allows nice things such as `v[index] = value`.\n///\n/// [`Index`]: ../../std/ops/trait.Index.html\n///\n/// # Examples\n///\n/// A very simple implementation of a `Balance` struct that has two sides, where\n/// each can be indexed mutably and immutably.\n///\n/// ```\n/// use std::ops::{Index,IndexMut};\n///\n/// #[derive(Debug)]\n/// enum Side {\n///     Left,\n///     Right,\n/// }\n///\n/// #[derive(Debug, PartialEq)]\n/// enum Weight {\n///     Kilogram(f32),\n///     Pound(f32),\n/// }\n///\n/// struct Balance {\n///     pub left: Weight,\n///     pub right: Weight,\n/// }\n///\n/// impl Index<Side> for Balance {\n///     type Output = Weight;\n///\n///     fn index(&self, index: Side) -> &Self::Output {\n///         println!(\"Accessing {:?}-side of balance immutably\", index);\n///         match index {\n///             Side::Left => &self.left,\n///             Side::Right => &self.right,\n///         }\n///     }\n/// }\n///\n/// impl IndexMut<Side> for Balance {\n///     fn index_mut(&mut self, index: Side) -> &mut Self::Output {\n///         println!(\"Accessing {:?}-side of balance mutably\", index);\n///         match index {\n///             Side::Left => &mut self.left,\n///             Side::Right => &mut self.right,\n///         }\n///     }\n/// }\n///\n/// let mut balance = Balance {\n///     right: Weight::Kilogram(2.5),\n///     left: Weight::Pound(1.5),\n/// };\n///\n/// // In this case, `balance[Side::Right]` is sugar for\n/// // `*balance.index(Side::Right)`, since we are only *reading*\n/// // `balance[Side::Right]`, not writing it.\n/// assert_eq!(balance[Side::Right], Weight::Kilogram(2.5));\n///\n/// // However, in this case `balance[Side::Left]` is sugar for\n/// // `*balance.index_mut(Side::Left)`, since we are writing\n/// // `balance[Side::Left]`.\n/// balance[Side::Left] = Weight::Kilogram(3.0);\n/// ```\n#[lang = \"index_mut\"]\n#[rustc_on_unimplemented(\n    on(\n        _Self = \"&str\",\n        note = \"you can use `.chars().nth()` or `.bytes().nth()`\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n    ),\n    on(\n        _Self = \"str\",\n        note = \"you can use `.chars().nth()` or `.bytes().nth()`\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n    ),\n    on(\n        _Self = \"std::string::String\",\n        note = \"you can use `.chars().nth()` or `.bytes().nth()`\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n    ),\n    message = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\",\n    label = \"`{Self}` cannot be mutably indexed by `{Idx}`\"\n)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(alias = \"[\")]\n#[doc(alias = \"]\")]\n#[doc(alias = \"[]\")]\npub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n    /// Performs the mutable indexing (`container[index]`) operation.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n}\n}\nmod range {\nuse crate::fmt;\nuse crate::hash::{Hash, Hasher};\n\n/// An unbounded range (`..`).\n///\n/// `RangeFull` is primarily used as a [slicing index], its shorthand is `..`.\n/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n///\n/// # Examples\n///\n/// The `..` syntax is a `RangeFull`:\n///\n/// ```\n/// assert_eq!((..), std::ops::RangeFull);\n/// ```\n///\n/// It does not have an [`IntoIterator`] implementation, so you can't use it in\n/// a `for` loop directly. This won't compile:\n///\n/// ```compile_fail,E0277\n/// for i in .. {\n///    // ...\n/// }\n/// ```\n///\n/// Used as a [slicing index], `RangeFull` produces the full array as a slice.\n///\n/// ```\n/// let arr = [0, 1, 2, 3, 4];\n/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);  // RangeFull\n/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n/// assert_eq!(arr[1.. 3], [  1,2    ]);\n/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n/// ```\n///\n/// [`IntoIterator`]: ../iter/trait.Iterator.html\n/// [`Iterator`]: ../iter/trait.IntoIterator.html\n/// [slicing index]: ../slice/trait.SliceIndex.html\n#[doc(alias = \"..\")]\n#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RangeFull;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for RangeFull {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A (half-open) range bounded inclusively below and exclusively above\n/// (`start..end`).\n///\n/// The `Range` `start..end` contains all values with `x >= start` and\n/// `x < end`. It is empty unless `start < end`.\n///\n/// # Examples\n///\n/// ```\n/// assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n/// assert_eq!(3 + 4 + 5, (3..6).sum());\n///\n/// let arr = [0, 1, 2, 3, 4];\n/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n/// assert_eq!(arr[1.. 3], [  1,2    ]);  // Range\n/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n/// ```\n#[doc(alias = \"..\")]\n#[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Range<Idx> {\n    /// The lower bound of the range (inclusive).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub start: Idx,\n    /// The upper bound of the range (exclusive).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub end: Idx,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<Idx: PartialOrd<Idx>> Range<Idx> {\n    /// Returns `true` if `item` is contained in the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// assert!(!(3..5).contains(&2));\n    /// assert!( (3..5).contains(&3));\n    /// assert!( (3..5).contains(&4));\n    /// assert!(!(3..5).contains(&5));\n    ///\n    /// assert!(!(3..3).contains(&3));\n    /// assert!(!(3..2).contains(&3));\n    ///\n    /// assert!( (0.0..1.0).contains(&0.5));\n    /// assert!(!(0.0..1.0).contains(&f32::NAN));\n    /// assert!(!(0.0..f32::NAN).contains(&0.5));\n    /// assert!(!(f32::NAN..1.0).contains(&0.5));\n    /// ```\n    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n    pub fn contains<U>(&self, item: &U) -> bool\n    where\n        Idx: PartialOrd<U>,\n        U: ?Sized + PartialOrd<Idx>,\n    {\n}\n\n    /// Returns `true` if the range contains no items.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(range_is_empty)]\n    ///\n    /// assert!(!(3..5).is_empty());\n    /// assert!( (3..3).is_empty());\n    /// assert!( (3..2).is_empty());\n    /// ```\n    ///\n    /// The range is empty if either side is incomparable:\n    ///\n    /// ```\n    /// #![feature(range_is_empty)]\n    ///\n    /// use std::f32::NAN;\n    /// assert!(!(3.0..5.0).is_empty());\n    /// assert!( (3.0..NAN).is_empty());\n    /// assert!( (NAN..5.0).is_empty());\n    /// ```\n    #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n    pub fn is_empty(&self) -> bool {\n}\n}\n\n/// A range only bounded inclusively below (`start..`).\n///\n/// The `RangeFrom` `start..` contains all values with `x >= start`.\n///\n/// *Note*: Currently, no overflow checking is done for the [`Iterator`]\n/// implementation; if you use an integer range and the integer overflows, it\n/// might panic in debug mode or create an endless loop in release mode. **This\n/// overflow behavior might change in the future.**\n///\n/// # Examples\n///\n/// ```\n/// assert_eq!((2..), std::ops::RangeFrom { start: 2 });\n/// assert_eq!(2 + 3 + 4, (2..).take(3).sum());\n///\n/// let arr = [0, 1, 2, 3, 4];\n/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n/// assert_eq!(arr[1..  ], [  1,2,3,4]);  // RangeFrom\n/// assert_eq!(arr[1.. 3], [  1,2    ]);\n/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n/// ```\n///\n/// [`Iterator`]: ../iter/trait.IntoIterator.html\n#[doc(alias = \"..\")]\n#[derive(Clone, PartialEq, Eq, Hash)] // not Copy -- see #27186\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RangeFrom<Idx> {\n    /// The lower bound of the range (inclusive).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub start: Idx,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n    /// Returns `true` if `item` is contained in the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// assert!(!(3..).contains(&2));\n    /// assert!( (3..).contains(&3));\n    /// assert!( (3..).contains(&1_000_000_000));\n    ///\n    /// assert!( (0.0..).contains(&0.5));\n    /// assert!(!(0.0..).contains(&f32::NAN));\n    /// assert!(!(f32::NAN..).contains(&0.5));\n    /// ```\n    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n    pub fn contains<U>(&self, item: &U) -> bool\n    where\n        Idx: PartialOrd<U>,\n        U: ?Sized + PartialOrd<Idx>,\n    {\n}\n}\n\n/// A range only bounded exclusively above (`..end`).\n///\n/// The `RangeTo` `..end` contains all values with `x < end`.\n/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n///\n/// # Examples\n///\n/// The `..end` syntax is a `RangeTo`:\n///\n/// ```\n/// assert_eq!((..5), std::ops::RangeTo { end: 5 });\n/// ```\n///\n/// It does not have an [`IntoIterator`] implementation, so you can't use it in\n/// a `for` loop directly. This won't compile:\n///\n/// ```compile_fail,E0277\n/// // error[E0277]: the trait bound `std::ops::RangeTo<{integer}>:\n/// // std::iter::Iterator` is not satisfied\n/// for i in ..5 {\n///     // ...\n/// }\n/// ```\n///\n/// When used as a [slicing index], `RangeTo` produces a slice of all array\n/// elements before the index indicated by `end`.\n///\n/// ```\n/// let arr = [0, 1, 2, 3, 4];\n/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n/// assert_eq!(arr[ .. 3], [0,1,2    ]);  // RangeTo\n/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n/// assert_eq!(arr[1.. 3], [  1,2    ]);\n/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n/// ```\n///\n/// [`IntoIterator`]: ../iter/trait.Iterator.html\n/// [`Iterator`]: ../iter/trait.IntoIterator.html\n/// [slicing index]: ../slice/trait.SliceIndex.html\n#[doc(alias = \"..\")]\n#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RangeTo<Idx> {\n    /// The upper bound of the range (exclusive).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub end: Idx,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n    /// Returns `true` if `item` is contained in the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// assert!( (..5).contains(&-1_000_000_000));\n    /// assert!( (..5).contains(&4));\n    /// assert!(!(..5).contains(&5));\n    ///\n    /// assert!( (..1.0).contains(&0.5));\n    /// assert!(!(..1.0).contains(&f32::NAN));\n    /// assert!(!(..f32::NAN).contains(&0.5));\n    /// ```\n    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n    pub fn contains<U>(&self, item: &U) -> bool\n    where\n        Idx: PartialOrd<U>,\n        U: ?Sized + PartialOrd<Idx>,\n    {\n}\n}\n\n/// A range bounded inclusively below and above (`start..=end`).\n///\n/// The `RangeInclusive` `start..=end` contains all values with `x >= start`\n/// and `x <= end`. It is empty unless `start <= end`.\n///\n/// This iterator is [fused], but the specific values of `start` and `end` after\n/// iteration has finished are **unspecified** other than that [`.is_empty()`]\n/// will return `true` once no more values will be produced.\n///\n/// [fused]: ../iter/trait.FusedIterator.html\n/// [`.is_empty()`]: #method.is_empty\n///\n/// # Examples\n///\n/// ```\n/// assert_eq!((3..=5), std::ops::RangeInclusive::new(3, 5));\n/// assert_eq!(3 + 4 + 5, (3..=5).sum());\n///\n/// let arr = [0, 1, 2, 3, 4];\n/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n/// assert_eq!(arr[1.. 3], [  1,2    ]);\n/// assert_eq!(arr[1..=3], [  1,2,3  ]);  // RangeInclusive\n/// ```\n#[doc(alias = \"..=\")]\n#[derive(Clone)] // not Copy -- see #27186\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\npub struct RangeInclusive<Idx> {\n    // Note that the fields here are not public to allow changing the\n    // representation in the future; in particular, while we could plausibly\n    // expose start/end, modifying them without changing (future/current)\n    // private fields may lead to incorrect behavior, so we don't want to\n    // support that mode.\n    pub(crate) start: Idx,\n    pub(crate) end: Idx,\n    pub(crate) is_empty: Option<bool>,\n    // This field is:\n    //  - `None` when next() or next_back() was never called\n    //  - `Some(false)` when `start <= end` assuming no overflow\n    //  - `Some(true)` otherwise\n    // The field cannot be a simple `bool` because the `..=` constructor can\n    // accept non-PartialOrd types, also we want the constructor to be const.\n}\n\ntrait RangeInclusiveEquality: Sized {\n    fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool;\n}\n\nimpl<T> RangeInclusiveEquality for T {\n    #[inline]\n    default fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n}\n}\n\nimpl<T: PartialOrd> RangeInclusiveEquality for T {\n    #[inline]\n    fn canonicalized_is_empty(range: &RangeInclusive<Self>) -> bool {\n}\n}\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n    #[inline]\n    fn eq(&self, other: &Self) -> bool {\n}\n}\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: Eq> Eq for RangeInclusive<Idx> {}\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: Hash> Hash for RangeInclusive<Idx> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n}\n}\n\nimpl<Idx> RangeInclusive<Idx> {\n    /// Creates a new inclusive range. Equivalent to writing `start..=end`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ops::RangeInclusive;\n    ///\n    /// assert_eq!(3..=5, RangeInclusive::new(3, 5));\n    /// ```\n    #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n    #[inline]\n    #[rustc_promotable]\n    #[rustc_const_stable(feature = \"const_range_new\", since = \"1.32.0\")]\n    pub const fn new(start: Idx, end: Idx) -> Self {\n}\n\n    /// Returns the lower bound of the range (inclusive).\n    ///\n    /// When using an inclusive range for iteration, the values of `start()` and\n    /// [`end()`] are unspecified after the iteration ended. To determine\n    /// whether the inclusive range is empty, use the [`is_empty()`] method\n    /// instead of comparing `start() > end()`.\n    ///\n    /// Note: the value returned by this method is unspecified after the range\n    /// has been iterated to exhaustion.\n    ///\n    /// [`end()`]: #method.end\n    /// [`is_empty()`]: #method.is_empty\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!((3..=5).start(), &3);\n    /// ```\n    #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n    #[rustc_const_stable(feature = \"const_inclusive_range_methods\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn start(&self) -> &Idx {\n}\n\n    /// Returns the upper bound of the range (inclusive).\n    ///\n    /// When using an inclusive range for iteration, the values of [`start()`]\n    /// and `end()` are unspecified after the iteration ended. To determine\n    /// whether the inclusive range is empty, use the [`is_empty()`] method\n    /// instead of comparing `start() > end()`.\n    ///\n    /// Note: the value returned by this method is unspecified after the range\n    /// has been iterated to exhaustion.\n    ///\n    /// [`start()`]: #method.start\n    /// [`is_empty()`]: #method.is_empty\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!((3..=5).end(), &5);\n    /// ```\n    #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n    #[rustc_const_stable(feature = \"const_inclusive_range_methods\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn end(&self) -> &Idx {\n}\n\n    /// Destructures the `RangeInclusive` into (lower bound, upper (inclusive) bound).\n    ///\n    /// Note: the value returned by this method is unspecified after the range\n    /// has been iterated to exhaustion.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!((3..=5).into_inner(), (3, 5));\n    /// ```\n    #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n    #[inline]\n    pub fn into_inner(self) -> (Idx, Idx) {\n}\n}\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n    /// Returns `true` if `item` is contained in the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// assert!(!(3..=5).contains(&2));\n    /// assert!( (3..=5).contains(&3));\n    /// assert!( (3..=5).contains(&4));\n    /// assert!( (3..=5).contains(&5));\n    /// assert!(!(3..=5).contains(&6));\n    ///\n    /// assert!( (3..=3).contains(&3));\n    /// assert!(!(3..=2).contains(&3));\n    ///\n    /// assert!( (0.0..=1.0).contains(&1.0));\n    /// assert!(!(0.0..=1.0).contains(&f32::NAN));\n    /// assert!(!(0.0..=f32::NAN).contains(&0.0));\n    /// assert!(!(f32::NAN..=1.0).contains(&1.0));\n    /// ```\n    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n    pub fn contains<U>(&self, item: &U) -> bool\n    where\n        Idx: PartialOrd<U>,\n        U: ?Sized + PartialOrd<Idx>,\n    {\n}\n\n    /// Returns `true` if the range contains no items.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(range_is_empty)]\n    ///\n    /// assert!(!(3..=5).is_empty());\n    /// assert!(!(3..=3).is_empty());\n    /// assert!( (3..=2).is_empty());\n    /// ```\n    ///\n    /// The range is empty if either side is incomparable:\n    ///\n    /// ```\n    /// #![feature(range_is_empty)]\n    ///\n    /// use std::f32::NAN;\n    /// assert!(!(3.0..=5.0).is_empty());\n    /// assert!( (3.0..=NAN).is_empty());\n    /// assert!( (NAN..=5.0).is_empty());\n    /// ```\n    ///\n    /// This method returns `true` after iteration has finished:\n    ///\n    /// ```\n    /// #![feature(range_is_empty)]\n    ///\n    /// let mut r = 3..=5;\n    /// for _ in r.by_ref() {}\n    /// // Precise field values are unspecified here\n    /// assert!(r.is_empty());\n    /// ```\n    #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n}\n\n    // If this range's `is_empty` is field is unknown (`None`), update it to be a concrete value.\n    #[inline]\n    pub(crate) fn compute_is_empty(&mut self) {\n}\n}\n\n/// A range only bounded inclusively above (`..=end`).\n///\n/// The `RangeToInclusive` `..=end` contains all values with `x <= end`.\n/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n///\n/// # Examples\n///\n/// The `..=end` syntax is a `RangeToInclusive`:\n///\n/// ```\n/// assert_eq!((..=5), std::ops::RangeToInclusive{ end: 5 });\n/// ```\n///\n/// It does not have an [`IntoIterator`] implementation, so you can't use it in a\n/// `for` loop directly. This won't compile:\n///\n/// ```compile_fail,E0277\n/// // error[E0277]: the trait bound `std::ops::RangeToInclusive<{integer}>:\n/// // std::iter::Iterator` is not satisfied\n/// for i in ..=5 {\n///     // ...\n/// }\n/// ```\n///\n/// When used as a [slicing index], `RangeToInclusive` produces a slice of all\n/// array elements up to and including the index indicated by `end`.\n///\n/// ```\n/// let arr = [0, 1, 2, 3, 4];\n/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);  // RangeToInclusive\n/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n/// assert_eq!(arr[1.. 3], [  1,2    ]);\n/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n/// ```\n///\n/// [`IntoIterator`]: ../iter/trait.Iterator.html\n/// [`Iterator`]: ../iter/trait.IntoIterator.html\n/// [slicing index]: ../slice/trait.SliceIndex.html\n#[doc(alias = \"..=\")]\n#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\npub struct RangeToInclusive<Idx> {\n    /// The upper bound of the range (inclusive)\n    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n    pub end: Idx,\n}\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n    /// Returns `true` if `item` is contained in the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// assert!( (..=5).contains(&-1_000_000_000));\n    /// assert!( (..=5).contains(&5));\n    /// assert!(!(..=5).contains(&6));\n    ///\n    /// assert!( (..=1.0).contains(&1.0));\n    /// assert!(!(..=1.0).contains(&f32::NAN));\n    /// assert!(!(..=f32::NAN).contains(&0.5));\n    /// ```\n    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n    pub fn contains<U>(&self, item: &U) -> bool\n    where\n        Idx: PartialOrd<U>,\n        U: ?Sized + PartialOrd<Idx>,\n    {\n}\n}\n\n// RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n// because underflow would be possible with (..0).into()\n\n/// An endpoint of a range of keys.\n///\n/// # Examples\n///\n/// `Bound`s are range endpoints:\n///\n/// ```\n/// use std::ops::Bound::*;\n/// use std::ops::RangeBounds;\n///\n/// assert_eq!((..100).start_bound(), Unbounded);\n/// assert_eq!((1..12).start_bound(), Included(&1));\n/// assert_eq!((1..12).end_bound(), Excluded(&12));\n/// ```\n///\n/// Using a tuple of `Bound`s as an argument to [`BTreeMap::range`].\n/// Note that in most cases, it's better to use range syntax (`1..5`) instead.\n///\n/// ```\n/// use std::collections::BTreeMap;\n/// use std::ops::Bound::{Excluded, Included, Unbounded};\n///\n/// let mut map = BTreeMap::new();\n/// map.insert(3, \"a\");\n/// map.insert(5, \"b\");\n/// map.insert(8, \"c\");\n///\n/// for (key, value) in map.range((Excluded(3), Included(8))) {\n///     println!(\"{}: {}\", key, value);\n/// }\n///\n/// assert_eq!(Some((&3, &\"a\")), map.range((Unbounded, Included(5))).next());\n/// ```\n///\n/// [`BTreeMap::range`]: ../../std/collections/btree_map/struct.BTreeMap.html#method.range\n#[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]\npub enum Bound<T> {\n    /// An inclusive bound.\n    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n    Included(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n    /// An exclusive bound.\n    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n    Excluded(#[stable(feature = \"collections_bound\", since = \"1.17.0\")] T),\n    /// An infinite endpoint. Indicates that there is no bound in this direction.\n    #[stable(feature = \"collections_bound\", since = \"1.17.0\")]\n    Unbounded,\n}\n\nimpl<T: Clone> Bound<&T> {\n    /// Map a `Bound<&T>` to a `Bound<T>` by cloning the contents of the bound.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(bound_cloned)]\n    /// use std::ops::Bound::*;\n    /// use std::ops::RangeBounds;\n    ///\n    /// assert_eq!((1..12).start_bound(), Included(&1));\n    /// assert_eq!((1..12).start_bound().cloned(), Included(1));\n    /// ```\n    #[unstable(feature = \"bound_cloned\", issue = \"61356\")]\n    pub fn cloned(self) -> Bound<T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n/// `RangeBounds` is implemented by Rust's built-in range types, produced\n/// by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`.\npub trait RangeBounds<T: ?Sized> {\n    /// Start index bound.\n    ///\n    /// Returns the start value as a `Bound`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # fn main() {\n    /// use std::ops::Bound::*;\n    /// use std::ops::RangeBounds;\n    ///\n    /// assert_eq!((..10).start_bound(), Unbounded);\n    /// assert_eq!((3..10).start_bound(), Included(&3));\n    /// # }\n    /// ```\n    #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n    fn start_bound(&self) -> Bound<&T>;\n\n    /// End index bound.\n    ///\n    /// Returns the end value as a `Bound`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # fn main() {\n    /// use std::ops::Bound::*;\n    /// use std::ops::RangeBounds;\n    ///\n    /// assert_eq!((3..).end_bound(), Unbounded);\n    /// assert_eq!((3..10).end_bound(), Excluded(&10));\n    /// # }\n    /// ```\n    #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n    fn end_bound(&self) -> Bound<&T>;\n\n    /// Returns `true` if `item` is contained in the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::f32;\n    ///\n    /// assert!( (3..5).contains(&4));\n    /// assert!(!(3..5).contains(&2));\n    ///\n    /// assert!( (0.0..1.0).contains(&0.5));\n    /// assert!(!(0.0..1.0).contains(&f32::NAN));\n    /// assert!(!(0.0..f32::NAN).contains(&0.5));\n    /// assert!(!(f32::NAN..1.0).contains(&0.5));\n    #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n    fn contains<U>(&self, item: &U) -> bool\n    where\n        T: PartialOrd<U>,\n        U: ?Sized + PartialOrd<T>,\n    {\n        (match self.start_bound() {\n            Included(ref start) => *start <= item,\n            Excluded(ref start) => *start < item,\n            Unbounded => true,\n        }) && (match self.end_bound() {\n            Included(ref end) => item <= *end,\n            Excluded(ref end) => item < *end,\n            Unbounded => true,\n        })\n    }\n}\n\nuse self::Bound::{Excluded, Included, Unbounded};\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T: ?Sized> RangeBounds<T> for RangeFull {\n    fn start_bound(&self) -> Bound<&T> {\n}\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeFrom<T> {\n    fn start_bound(&self) -> Bound<&T> {\n}\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeTo<T> {\n    fn start_bound(&self) -> Bound<&T> {\n}\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for Range<T> {\n    fn start_bound(&self) -> Bound<&T> {\n}\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeInclusive<T> {\n    fn start_bound(&self) -> Bound<&T> {\n}\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeToInclusive<T> {\n    fn start_bound(&self) -> Bound<&T> {\n}\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n    fn start_bound(&self) -> Bound<&T> {\n}\n\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n    fn start_bound(&self) -> Bound<&T> {\n}\n\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeFrom<&T> {\n    fn start_bound(&self) -> Bound<&T> {\n}\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeTo<&T> {\n    fn start_bound(&self) -> Bound<&T> {\n}\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for Range<&T> {\n    fn start_bound(&self) -> Bound<&T> {\n}\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeInclusive<&T> {\n    fn start_bound(&self) -> Bound<&T> {\n}\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n\n#[stable(feature = \"collections_range\", since = \"1.28.0\")]\nimpl<T> RangeBounds<T> for RangeToInclusive<&T> {\n    fn start_bound(&self) -> Bound<&T> {\n}\n    fn end_bound(&self) -> Bound<&T> {\n}\n}\n}\nmod try {\n/// A trait for customizing the behavior of the `?` operator.\n///\n/// A type implementing `Try` is one that has a canonical way to view it\n/// in terms of a success/failure dichotomy. This trait allows both\n/// extracting those success or failure values from an existing instance and\n/// creating a new instance from a success or failure value.\n#[unstable(feature = \"try_trait\", issue = \"42327\")]\n#[rustc_on_unimplemented(\n    on(\n        all(\n            any(from_method = \"from_error\", from_method = \"from_ok\"),\n            from_desugaring = \"QuestionMark\"\n        ),\n        message = \"the `?` operator can only be used in {I} \\\n                    that returns `Result` or `Option` \\\n                    (or another type that implements `{Try}`)\",\n        label = \"cannot use the `?` operator in {ItemContext} that returns `{Self}`\",\n        enclosing_scope = \"this function should return `Result` or `Option` to accept `?`\"\n    ),\n    on(\n        all(from_method = \"into_result\", from_desugaring = \"QuestionMark\"),\n        message = \"the `?` operator can only be applied to values \\\n                    that implement `{Try}`\",\n        label = \"the `?` operator cannot be applied to type `{Self}`\"\n    )\n)]\n#[doc(alias = \"?\")]\npub trait Try {\n    /// The type of this value when viewed as successful.\n    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n    type Ok;\n    /// The type of this value when viewed as failed.\n    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n    type Error;\n\n    /// Applies the \"?\" operator. A return of `Ok(t)` means that the\n    /// execution should continue normally, and the result of `?` is the\n    /// value `t`. A return of `Err(e)` means that execution should branch\n    /// to the innermost enclosing `catch`, or return from the function.\n    ///\n    /// If an `Err(e)` result is returned, the value `e` will be \"wrapped\"\n    /// in the return type of the enclosing scope (which must itself implement\n    /// `Try`). Specifically, the value `X::from_error(From::from(e))`\n    /// is returned, where `X` is the return type of the enclosing function.\n    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n    fn into_result(self) -> Result<Self::Ok, Self::Error>;\n\n    /// Wrap an error value to construct the composite result. For example,\n    /// `Result::Err(x)` and `Result::from_error(x)` are equivalent.\n    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n    fn from_error(v: Self::Error) -> Self;\n\n    /// Wrap an OK value to construct the composite result. For example,\n    /// `Result::Ok(x)` and `Result::from_ok(x)` are equivalent.\n    #[unstable(feature = \"try_trait\", issue = \"42327\")]\n    fn from_ok(v: Self::Ok) -> Self;\n}\n}\nmod unsize {\nuse crate::marker::Unsize;\n\n/// Trait that indicates that this is a pointer or a wrapper for one,\n/// where unsizing can be performed on the pointee.\n///\n/// See the [DST coercion RFC][dst-coerce] and [the nomicon entry on coercion][nomicon-coerce]\n/// for more details.\n///\n/// For builtin pointer types, pointers to `T` will coerce to pointers to `U` if `T: Unsize<U>`\n/// by converting from a thin pointer to a fat pointer.\n///\n/// For custom types, the coercion here works by coercing `Foo<T>` to `Foo<U>`\n/// provided an impl of `CoerceUnsized<Foo<U>> for Foo<T>` exists.\n/// Such an impl can only be written if `Foo<T>` has only a single non-phantomdata\n/// field involving `T`. If the type of that field is `Bar<T>`, an implementation\n/// of `CoerceUnsized<Bar<U>> for Bar<T>` must exist. The coercion will work by\n/// coercing the `Bar<T>` field into `Bar<U>` and filling in the rest of the fields\n/// from `Foo<T>` to create a `Foo<U>`. This will effectively drill down to a pointer\n/// field and coerce that.\n///\n/// Generally, for smart pointers you will implement\n/// `CoerceUnsized<Ptr<U>> for Ptr<T> where T: Unsize<U>, U: ?Sized`, with an\n/// optional `?Sized` bound on `T` itself. For wrapper types that directly embed `T`\n/// like `Cell<T>` and `RefCell<T>`, you\n/// can directly implement `CoerceUnsized<Wrap<U>> for Wrap<T> where T: CoerceUnsized<U>`.\n/// This will let coercions of types like `Cell<Box<T>>` work.\n///\n/// [`Unsize`][unsize] is used to mark types which can be coerced to DSTs if behind\n/// pointers. It is implemented automatically by the compiler.\n///\n/// [dst-coerce]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n/// [unsize]: ../marker/trait.Unsize.html\n/// [nomicon-coerce]: ../../nomicon/coercions.html\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n#[lang = \"coerce_unsized\"]\npub trait CoerceUnsized<T: ?Sized> {\n}\n\n// &mut T -> &mut U\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::arith::{Add, Div, Mul, Neg, Rem, Sub};\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\npub use self::arith::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::bit::{BitAnd, BitOr, BitXor, Not, Shl, Shr};\n#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\npub use self::bit::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::deref::{Deref, DerefMut};\n\n#[unstable(feature = \"receiver_trait\", issue = \"none\")]\npub use self::deref::Receiver;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::drop::Drop;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::function::{Fn, FnMut, FnOnce};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::index::{Index, IndexMut};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\npub use self::range::{Bound, RangeBounds, RangeInclusive, RangeToInclusive};\n\n#[unstable(feature = \"try_trait\", issue = \"42327\")]\npub use self::r#try::Try;\n\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\npub use self::generator::{Generator, GeneratorState};\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\npub use self::unsize::CoerceUnsized;\n\n#[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\npub use self::unsize::DispatchFromDyn;\n}\n\n/* Core types and methods on primitives */\n\npub mod any {\n//! This module implements the `Any` trait, which enables dynamic typing\n//! of any `'static` type through runtime reflection.\n//!\n//! `Any` itself can be used to get a `TypeId`, and has more features when used\n//! as a trait object. As `&dyn Any` (a borrowed trait object), it has the `is`\n//! and `downcast_ref` methods, to test if the contained value is of a given type,\n//! and to get a reference to the inner value as a type. As `&mut dyn Any`, there\n//! is also the `downcast_mut` method, for getting a mutable reference to the\n//! inner value. `Box<dyn Any>` adds the `downcast` method, which attempts to\n//! convert to a `Box<T>`. See the [`Box`] documentation for the full details.\n//!\n//! Note that `&dyn Any` is limited to testing whether a value is of a specified\n//! concrete type, and cannot be used to test whether a type implements a trait.\n//!\n//! [`Box`]: ../../std/boxed/struct.Box.html\n//!\n//! # Examples\n//!\n//! Consider a situation where we want to log out a value passed to a function.\n//! We know the value we're working on implements Debug, but we don't know its\n//! concrete type. We want to give special treatment to certain types: in this\n//! case printing out the length of String values prior to their value.\n//! We don't know the concrete type of our value at compile time, so we need to\n//! use runtime reflection instead.\n//!\n//! ```rust\n//! use std::fmt::Debug;\n//! use std::any::Any;\n//!\n//! // Logger function for any type that implements Debug.\n//! fn log<T: Any + Debug>(value: &T) {\n//!     let value_any = value as &dyn Any;\n//!\n//!     // Try to convert our value to a `String`. If successful, we want to\n//!     // output the String`'s length as well as its value. If not, it's a\n//!     // different type: just print it out unadorned.\n//!     match value_any.downcast_ref::<String>() {\n//!         Some(as_string) => {\n//!             println!(\"String ({}): {}\", as_string.len(), as_string);\n//!         }\n//!         None => {\n//!             println!(\"{:?}\", value);\n//!         }\n//!     }\n//! }\n//!\n//! // This function wants to log its parameter out prior to doing work with it.\n//! fn do_work<T: Any + Debug>(value: &T) {\n//!     log(value);\n//!     // ...do some other work\n//! }\n//!\n//! fn main() {\n//!     let my_string = \"Hello World\".to_string();\n//!     do_work(&my_string);\n//!\n//!     let my_i8: i8 = 100;\n//!     do_work(&my_i8);\n//! }\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::fmt;\nuse crate::intrinsics;\n\n///////////////////////////////////////////////////////////////////////////////\n// Any trait\n///////////////////////////////////////////////////////////////////////////////\n\n/// A trait to emulate dynamic typing.\n///\n/// Most types implement `Any`. However, any type which contains a non-`'static` reference does not.\n/// See the [module-level documentation][mod] for more details.\n///\n/// [mod]: index.html\n// This trait is not unsafe, though we rely on the specifics of it's sole impl's\n// `type_id` function in unsafe code (e.g., `downcast`). Normally, that would be\n// a problem, but because the only impl of `Any` is a blanket implementation, no\n// other code can implement `Any`.\n//\n// We could plausibly make this trait unsafe -- it would not cause breakage,\n// since we control all the implementations -- but we choose not to as that's\n// both not really necessary and may confuse users about the distinction of\n// unsafe traits and unsafe methods (i.e., `type_id` would still be safe to call,\n// but we would likely want to indicate as such in documentation).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Any: 'static {\n    /// Gets the `TypeId` of `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::{Any, TypeId};\n    ///\n    /// fn is_string(s: &dyn Any) -> bool {\n    ///     TypeId::of::<String>() == s.type_id()\n    /// }\n    ///\n    /// assert_eq!(is_string(&0), false);\n    /// assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n    /// ```\n    #[stable(feature = \"get_type_id\", since = \"1.34.0\")]\n    fn type_id(&self) -> TypeId;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: 'static + ?Sized> Any for T {\n    fn type_id(&self) -> TypeId {\n}\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Extension methods for Any trait objects.\n///////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for dyn Any {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n// Ensure that the result of e.g., joining a thread can be printed and\n// hence used with `unwrap`. May eventually no longer be needed if\n// dispatch works with upcasting.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for dyn Any + Send {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\nimpl fmt::Debug for dyn Any + Send + Sync {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl dyn Any {\n    /// Returns `true` if the boxed type is the same as `T`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn is_string(s: &dyn Any) {\n    ///     if s.is::<String>() {\n    ///         println!(\"It's a string!\");\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// is_string(&0);\n    /// is_string(&\"cookie monster\".to_string());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is<T: Any>(&self) -> bool {\n}\n\n    /// Returns some reference to the boxed value if it is of type `T`, or\n    /// `None` if it isn't.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(s: &dyn Any) {\n    ///     if let Some(string) = s.downcast_ref::<String>() {\n    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// print_if_string(&0);\n    /// print_if_string(&\"cookie monster\".to_string());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n}\n\n    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n    /// `None` if it isn't.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn modify_if_u32(s: &mut dyn Any) {\n    ///     if let Some(num) = s.downcast_mut::<u32>() {\n    ///         *num = 42;\n    ///     }\n    /// }\n    ///\n    /// let mut x = 10u32;\n    /// let mut s = \"starlord\".to_string();\n    ///\n    /// modify_if_u32(&mut x);\n    /// modify_if_u32(&mut s);\n    ///\n    /// assert_eq!(x, 42);\n    /// assert_eq!(&s, \"starlord\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n}\n}\n\nimpl dyn Any + Send {\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn is_string(s: &(dyn Any + Send)) {\n    ///     if s.is::<String>() {\n    ///         println!(\"It's a string!\");\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// is_string(&0);\n    /// is_string(&\"cookie monster\".to_string());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is<T: Any>(&self) -> bool {\n}\n\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(s: &(dyn Any + Send)) {\n    ///     if let Some(string) = s.downcast_ref::<String>() {\n    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// print_if_string(&0);\n    /// print_if_string(&\"cookie monster\".to_string());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n}\n\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn modify_if_u32(s: &mut (dyn Any + Send)) {\n    ///     if let Some(num) = s.downcast_mut::<u32>() {\n    ///         *num = 42;\n    ///     }\n    /// }\n    ///\n    /// let mut x = 10u32;\n    /// let mut s = \"starlord\".to_string();\n    ///\n    /// modify_if_u32(&mut x);\n    /// modify_if_u32(&mut s);\n    ///\n    /// assert_eq!(x, 42);\n    /// assert_eq!(&s, \"starlord\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n}\n}\n\nimpl dyn Any + Send + Sync {\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn is_string(s: &(dyn Any + Send + Sync)) {\n    ///     if s.is::<String>() {\n    ///         println!(\"It's a string!\");\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// is_string(&0);\n    /// is_string(&\"cookie monster\".to_string());\n    /// ```\n    #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n    #[inline]\n    pub fn is<T: Any>(&self) -> bool {\n}\n\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(s: &(dyn Any + Send + Sync)) {\n    ///     if let Some(string) = s.downcast_ref::<String>() {\n    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n    ///     } else {\n    ///         println!(\"Not a string...\");\n    ///     }\n    /// }\n    ///\n    /// print_if_string(&0);\n    /// print_if_string(&\"cookie monster\".to_string());\n    /// ```\n    #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n    #[inline]\n    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n}\n\n    /// Forwards to the method defined on the type `Any`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn modify_if_u32(s: &mut (dyn Any + Send + Sync)) {\n    ///     if let Some(num) = s.downcast_mut::<u32>() {\n    ///         *num = 42;\n    ///     }\n    /// }\n    ///\n    /// let mut x = 10u32;\n    /// let mut s = \"starlord\".to_string();\n    ///\n    /// modify_if_u32(&mut x);\n    /// modify_if_u32(&mut s);\n    ///\n    /// assert_eq!(x, 42);\n    /// assert_eq!(&s, \"starlord\");\n    /// ```\n    #[stable(feature = \"any_send_sync_methods\", since = \"1.28.0\")]\n    #[inline]\n    pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n}\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// TypeID and its methods\n///////////////////////////////////////////////////////////////////////////////\n\n/// A `TypeId` represents a globally unique identifier for a type.\n///\n/// Each `TypeId` is an opaque object which does not allow inspection of what's\n/// inside but does allow basic operations such as cloning, comparison,\n/// printing, and showing.\n///\n/// A `TypeId` is currently only available for types which ascribe to `'static`,\n/// but this limitation may be removed in the future.\n///\n/// While `TypeId` implements `Hash`, `PartialOrd`, and `Ord`, it is worth\n/// noting that the hashes and ordering will vary between Rust releases. Beware\n/// of relying on them inside of your code!\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct TypeId {\n    t: u64,\n}\n\nimpl TypeId {\n    /// Returns the `TypeId` of the type this generic function has been\n    /// instantiated with.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::{Any, TypeId};\n    ///\n    /// fn is_string<T: ?Sized + Any>(_s: &T) -> bool {\n    ///     TypeId::of::<String>() == TypeId::of::<T>()\n    /// }\n    ///\n    /// assert_eq!(is_string(&0), false);\n    /// assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_unstable(feature = \"const_type_id\", issue = \"41875\")]\n    pub const fn of<T: ?Sized + 'static>() -> TypeId {\n}\n}\n\n/// Returns the name of a type as a string slice.\n///\n/// # Note\n///\n/// This is intended for diagnostic use. The exact contents and format of the\n/// string are not specified, other than being a best-effort description of the\n/// type. For example, `type_name::<Option<String>>()` could return the\n/// `\"Option<String>\"` or `\"std::option::Option<std::string::String>\"`, but not\n/// `\"foobar\"`. In addition, the output may change between versions of the\n/// compiler.\n///\n/// The type name should not be considered a unique identifier of a type;\n/// multiple types may share the same type name.\n///\n/// The current implementation uses the same infrastructure as compiler\n/// diagnostics and debuginfo, but this is not guaranteed.\n///\n/// # Examples\n///\n/// ```rust\n/// assert_eq!(\n///     std::any::type_name::<Option<String>>(),\n///     \"core::option::Option<alloc::string::String>\",\n/// );\n/// ```\n#[stable(feature = \"type_name\", since = \"1.38.0\")]\n#[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\npub const fn type_name<T: ?Sized>() -> &'static str {\n}\n\n/// Returns the name of the type of the pointed-to value as a string slice.\n/// This is the same as `type_name::<T>()`, but can be used where the type of a\n/// variable is not easily available.\n///\n/// # Note\n///\n/// This is intended for diagnostic use. The exact contents and format of the\n/// string are not specified, other than being a best-effort description of the\n/// type. For example, `type_name_of_val::<Option<String>>(None)` could return\n/// `\"Option<String>\"` or `\"std::option::Option<std::string::String>\"`, but not\n/// `\"foobar\"`. In addition, the output may change between versions of the\n/// compiler.\n///\n/// This function does not resolve trait objects,\n/// meaning that `type_name_of_val(&7u32 as &dyn Debug)`\n/// may return `\"dyn Debug\"`, but not `\"u32\"`.\n///\n/// The type name should not be considered a unique identifier of a type;\n/// multiple types may share the same type name.\n///\n/// The current implementation uses the same infrastructure as compiler\n/// diagnostics and debuginfo, but this is not guaranteed.\n///\n/// # Examples\n///\n/// Prints the default integer and float types.\n///\n/// ```rust\n/// #![feature(type_name_of_val)]\n/// use std::any::type_name_of_val;\n///\n/// let x = 1;\n/// println!(\"{}\", type_name_of_val(&x));\n/// let y = 1.0;\n/// println!(\"{}\", type_name_of_val(&y));\n/// ```\n#[unstable(feature = \"type_name_of_val\", issue = \"66359\")]\n#[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\npub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n}\n}\n#[cfg(not(test))] // See #65860\npub mod array {\n//! Implementations of things like `Eq` for fixed-length arrays\n//! up to a certain length. Eventually, we should be able to generalize\n//! to all lengths.\n//!\n//! *[See also the array primitive type](../../std/primitive.array.html).*\n\n#![stable(feature = \"core_array\", since = \"1.36.0\")]\n\nuse crate::borrow::{Borrow, BorrowMut};\nuse crate::cmp::Ordering;\nuse crate::convert::{Infallible, TryFrom};\nuse crate::fmt;\nuse crate::hash::{self, Hash};\nuse crate::marker::Unsize;\nuse crate::slice::{Iter, IterMut};\n\nmod iter {\n//! Defines the `IntoIter` owned iterator for arrays.\n\nuse super::LengthAtMost32;\nuse crate::{\n    fmt,\n    iter::{ExactSizeIterator, FusedIterator, TrustedLen},\n    mem::{self, MaybeUninit},\n    ops::Range,\n    ptr,\n};\n\n/// A by-value [array] iterator.\n///\n/// [array]: ../../std/primitive.array.html\n#[unstable(feature = \"array_value_iter\", issue = \"65798\")]\npub struct IntoIter<T, const N: usize>\nwhere\n    [T; N]: LengthAtMost32,\n{\n}\n\nimpl<T, const N: usize> IntoIter<T, { N }>\nwhere\n    [T; N]: LengthAtMost32,\n{\n    /// Creates a new iterator over the given `array`.\n    ///\n    /// *Note*: this method might never get stabilized and/or removed in the\n    /// future as there will likely be another, preferred way of obtaining this\n    /// iterator (either via `IntoIterator` for arrays or via another way).\n    #[unstable(feature = \"array_value_iter\", issue = \"65798\")]\n    pub fn new(array: [T; N]) -> Self {\n}\n\n    /// Returns an immutable slice of all elements that have not been yielded\n    /// yet.\n    fn as_slice(&self) -> &[T] {\n}\n\n    /// Returns a mutable slice of all elements that have not been yielded yet.\n    fn as_mut_slice(&mut self) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T, const N: usize> Iterator for IntoIter<T, { N }>\nwhere\n    [T; N]: LengthAtMost32,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<Self::Item> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    fn count(self) -> usize {\n}\n\n    fn last(mut self) -> Option<Self::Item> {\n}\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T, const N: usize> DoubleEndedIterator for IntoIter<T, { N }>\nwhere\n    [T; N]: LengthAtMost32,\n{\n    fn next_back(&mut self) -> Option<Self::Item> {\n}\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T, const N: usize> Drop for IntoIter<T, { N }>\nwhere\n    [T; N]: LengthAtMost32,\n{\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T, const N: usize> ExactSizeIterator for IntoIter<T, { N }>\nwhere\n    [T; N]: LengthAtMost32,\n{\n    fn len(&self) -> usize {\n}\n    fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T, const N: usize> FusedIterator for IntoIter<T, { N }> where [T; N]: LengthAtMost32 {}\n\n// The iterator indeed reports the correct length. The number of \"alive\"\n// elements (that will still be yielded) is the length of the range `alive`.\n// This range is decremented in length in either `next` or `next_back`. It is\n// always decremented by 1 in those methods, but only if `Some(_)` is returned.\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nunsafe impl<T, const N: usize> TrustedLen for IntoIter<T, { N }> where [T; N]: LengthAtMost32 {}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T: Clone, const N: usize> Clone for IntoIter<T, { N }>\nwhere\n    [T; N]: LengthAtMost32,\n{\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\nimpl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, { N }>\nwhere\n    [T; N]: LengthAtMost32,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n}\n\n#[unstable(feature = \"array_value_iter\", issue = \"65798\")]\npub use iter::IntoIter;\n\n/// Utility trait implemented only on arrays of fixed size\n///\n/// This trait can be used to implement other traits on fixed-size arrays\n/// without causing much metadata bloat.\n///\n/// The trait is marked unsafe in order to restrict implementors to fixed-size\n/// arrays. User of this trait can assume that implementors have the exact\n/// layout in memory of a fixed size array (for example, for unsafe\n/// initialization).\n///\n/// Note that the traits [`AsRef`] and [`AsMut`] provide similar methods for types that\n/// may not be fixed-size arrays. Implementors should prefer those traits\n/// instead.\n///\n/// [`AsRef`]: ../convert/trait.AsRef.html\n/// [`AsMut`]: ../convert/trait.AsMut.html\n#[unstable(feature = \"fixed_size_array\", issue = \"27778\")]\npub unsafe trait FixedSizeArray<T> {\n    /// Converts the array to immutable slice\n    #[unstable(feature = \"fixed_size_array\", issue = \"27778\")]\n    fn as_slice(&self) -> &[T];\n    /// Converts the array to mutable slice\n    #[unstable(feature = \"fixed_size_array\", issue = \"27778\")]\n    fn as_mut_slice(&mut self) -> &mut [T];\n}\n\n#[unstable(feature = \"fixed_size_array\", issue = \"27778\")]\nunsafe impl<T, A: Unsize<[T]>> FixedSizeArray<T> for A {\n    #[inline]\n    fn as_slice(&self) -> &[T] {\n}\n    #[inline]\n    fn as_mut_slice(&mut self) -> &mut [T] {\n}\n}\n\n/// The error type returned when a conversion from a slice to an array fails.\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\n#[derive(Debug, Copy, Clone)]\npub struct TryFromSliceError(());\n\n#[stable(feature = \"core_array\", since = \"1.36.0\")]\nimpl fmt::Display for TryFromSliceError {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl TryFromSliceError {\n    #[unstable(\n        feature = \"array_error_internals\",\n        reason = \"available through Error trait and this method should not \\\n                     be exposed publicly\",\n        issue = \"none\"\n    )]\n    #[inline]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n}\n}\n\n#[stable(feature = \"try_from_slice_error\", since = \"1.36.0\")]\nimpl From<Infallible> for TryFromSliceError {\n    fn from(x: Infallible) -> TryFromSliceError {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, const N: usize> AsRef<[T]> for [T; N]\nwhere\n    [T; N]: LengthAtMost32,\n{\n    #[inline]\n    fn as_ref(&self) -> &[T] {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, const N: usize> AsMut<[T]> for [T; N]\nwhere\n    [T; N]: LengthAtMost32,\n{\n    #[inline]\n    fn as_mut(&mut self) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"array_borrow\", since = \"1.4.0\")]\nimpl<T, const N: usize> Borrow<[T]> for [T; N]\nwhere\n    [T; N]: LengthAtMost32,\n{\n    fn borrow(&self) -> &[T] {\n}\n}\n\n#[stable(feature = \"array_borrow\", since = \"1.4.0\")]\nimpl<T, const N: usize> BorrowMut<[T]> for [T; N]\nwhere\n    [T; N]: LengthAtMost32,\n{\n    fn borrow_mut(&mut self) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl<T, const N: usize> TryFrom<&[T]> for [T; N]\nwhere\n    T: Copy,\n    [T; N]: LengthAtMost32,\n{\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &[T]) -> Result<[T; N], TryFromSliceError> {\n}\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N]\nwhere\n    [T; N]: LengthAtMost32,\n{\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &[T]) -> Result<&[T; N], TryFromSliceError> {\n}\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N]\nwhere\n    [T; N]: LengthAtMost32,\n{\n    type Error = TryFromSliceError;\n\n    fn try_from(slice: &mut [T]) -> Result<&mut [T; N], TryFromSliceError> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Hash, const N: usize> Hash for [T; N]\nwhere\n    [T; N]: LengthAtMost32,\n{\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug, const N: usize> fmt::Debug for [T; N]\nwhere\n    [T; N]: LengthAtMost32,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, const N: usize> IntoIterator for &'a [T; N]\nwhere\n    [T; N]: LengthAtMost32,\n{\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, const N: usize> IntoIterator for &'a mut [T; N]\nwhere\n    [T; N]: LengthAtMost32,\n{\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B, const N: usize> PartialEq<[B; N]> for [A; N]\nwhere\n    A: PartialEq<B>,\n    [A; N]: LengthAtMost32,\n    [B; N]: LengthAtMost32,\n{\n    #[inline]\n    fn eq(&self, other: &[B; N]) -> bool {\n}\n    #[inline]\n    fn ne(&self, other: &[B; N]) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B, const N: usize> PartialEq<[B]> for [A; N]\nwhere\n    A: PartialEq<B>,\n    [A; N]: LengthAtMost32,\n{\n    #[inline]\n    fn eq(&self, other: &[B]) -> bool {\n}\n    #[inline]\n    fn ne(&self, other: &[B]) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B, const N: usize> PartialEq<[A; N]> for [B]\nwhere\n    B: PartialEq<A>,\n    [A; N]: LengthAtMost32,\n{\n    #[inline]\n    fn eq(&self, other: &[A; N]) -> bool {\n}\n    #[inline]\n    fn ne(&self, other: &[A; N]) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'b, A, B, const N: usize> PartialEq<&'b [B]> for [A; N]\nwhere\n    A: PartialEq<B>,\n    [A; N]: LengthAtMost32,\n{\n    #[inline]\n    fn eq(&self, other: &&'b [B]) -> bool {\n}\n    #[inline]\n    fn ne(&self, other: &&'b [B]) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'b, A, B, const N: usize> PartialEq<[A; N]> for &'b [B]\nwhere\n    B: PartialEq<A>,\n    [A; N]: LengthAtMost32,\n{\n    #[inline]\n    fn eq(&self, other: &[A; N]) -> bool {\n}\n    #[inline]\n    fn ne(&self, other: &[A; N]) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'b, A, B, const N: usize> PartialEq<&'b mut [B]> for [A; N]\nwhere\n    A: PartialEq<B>,\n    [A; N]: LengthAtMost32,\n{\n    #[inline]\n    fn eq(&self, other: &&'b mut [B]) -> bool {\n}\n    #[inline]\n    fn ne(&self, other: &&'b mut [B]) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'b, A, B, const N: usize> PartialEq<[A; N]> for &'b mut [B]\nwhere\n    B: PartialEq<A>,\n    [A; N]: LengthAtMost32,\n{\n    #[inline]\n    fn eq(&self, other: &[A; N]) -> bool {\n}\n    #[inline]\n    fn ne(&self, other: &[A; N]) -> bool {\n}\n}\n\n// NOTE: some less important impls are omitted to reduce code bloat\n// __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n// __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Eq, const N: usize> Eq for [T; N] where [T; N]: LengthAtMost32 {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: PartialOrd, const N: usize> PartialOrd for [T; N]\nwhere\n    [T; N]: LengthAtMost32,\n{\n    #[inline]\n    fn partial_cmp(&self, other: &[T; N]) -> Option<Ordering> {\n}\n    #[inline]\n    fn lt(&self, other: &[T; N]) -> bool {\n}\n    #[inline]\n    fn le(&self, other: &[T; N]) -> bool {\n}\n    #[inline]\n    fn ge(&self, other: &[T; N]) -> bool {\n}\n    #[inline]\n    fn gt(&self, other: &[T; N]) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord, const N: usize> Ord for [T; N]\nwhere\n    [T; N]: LengthAtMost32,\n{\n    #[inline]\n    fn cmp(&self, other: &[T; N]) -> Ordering {\n}\n}\n\n/// Implemented for lengths where trait impls are allowed on arrays in core/std\n#[rustc_on_unimplemented(message = \"arrays only have std trait implementations for lengths 0..=32\")]\n#[unstable(\n    feature = \"const_generic_impls_guard\",\n    issue = \"none\",\n    reason = \"will never be stable, just a temporary step until const generics are stable\"\n)]\npub trait LengthAtMost32 {}\n\nmacro_rules! array_impls {\n    ($($N:literal)+) => {\n        $(\n            #[unstable(feature = \"const_generic_impls_guard\", issue = \"none\")]\n            impl<T> LengthAtMost32 for [T; $N] {}}\n}\n\narray_impls! {\n     0  1  2  3  4  5  6  7  8  9\n    10 11 12 13 14 15 16 17 18 19\n    20 21 22 23 24 25 26 27 28 29\n    30 31 32\n}\n\n// The Default impls cannot be generated using the array_impls! macro because\n// they require array literals.\n\nmacro_rules! array_impl_default {\n    {$n:expr, $t:ident $($ts:ident)*} => {\n        #[stable(since = \"1.4.0\", feature = \"array_default\")]\n        impl<T> Default for [T; $n] where T: Default {\n            fn default() -> [T; $n] {\n}\n        }\n        array_impl_default!{($n - 1), $($ts)*}\n    };\n    {$n:expr,} => {\n        #[stable(since = \"1.4.0\", feature = \"array_default\")]\n        impl<T> Default for [T; $n] {\n            fn default() -> [T; $n] { }\n        }\n    };\n}\n\narray_impl_default! {32, T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T}\n}\npub mod ascii {\n//! Operations on ASCII strings and characters.\n//!\n//! Most string operations in Rust act on UTF-8 strings. However, at times it\n//! makes more sense to only consider the ASCII character set for a specific\n//! operation.\n//!\n//! The [`escape_default`] function provides an iterator over the bytes of an\n//! escaped version of the character given.\n//!\n//! [`escape_default`]: fn.escape_default.html\n\n#![stable(feature = \"core_ascii\", since = \"1.26.0\")]\n\nuse crate::fmt;\nuse crate::iter::FusedIterator;\nuse crate::ops::Range;\nuse crate::str::from_utf8_unchecked;\n\n/// An iterator over the escaped version of a byte.\n///\n/// This `struct` is created by the [`escape_default`] function. See its\n/// documentation for more.\n///\n/// [`escape_default`]: fn.escape_default.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct EscapeDefault {\n    range: Range<usize>,\n    data: [u8; 4],\n}\n\n/// Returns an iterator that produces an escaped version of a `u8`.\n///\n/// The default is chosen with a bias toward producing literals that are\n/// legal in a variety of languages, including C++11 and similar C-family\n/// languages. The exact rules are:\n///\n/// * Tab is escaped as `\\t`.\n/// * Carriage return is escaped as `\\r`.\n/// * Line feed is escaped as `\\n`.\n/// * Single quote is escaped as `\\'`.\n/// * Double quote is escaped as `\\\"`.\n/// * Backslash is escaped as `\\\\`.\n/// * Any character in the 'printable ASCII' range `0x20` .. `0x7e`\n///   inclusive is not escaped.\n/// * Any other chars are given hex escapes of the form '\\xNN'.\n/// * Unicode escapes are never generated by this function.\n///\n/// # Examples\n///\n/// ```\n/// use std::ascii;\n///\n/// let escaped = ascii::escape_default(b'0').next().unwrap();\n/// assert_eq!(b'0', escaped);\n///\n/// let mut escaped = ascii::escape_default(b'\\t');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b't', escaped.next().unwrap());\n///\n/// let mut escaped = ascii::escape_default(b'\\r');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b'r', escaped.next().unwrap());\n///\n/// let mut escaped = ascii::escape_default(b'\\n');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b'n', escaped.next().unwrap());\n///\n/// let mut escaped = ascii::escape_default(b'\\'');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b'\\'', escaped.next().unwrap());\n///\n/// let mut escaped = ascii::escape_default(b'\"');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b'\"', escaped.next().unwrap());\n///\n/// let mut escaped = ascii::escape_default(b'\\\\');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n///\n/// let mut escaped = ascii::escape_default(b'\\x9d');\n///\n/// assert_eq!(b'\\\\', escaped.next().unwrap());\n/// assert_eq!(b'x', escaped.next().unwrap());\n/// assert_eq!(b'9', escaped.next().unwrap());\n/// assert_eq!(b'd', escaped.next().unwrap());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn escape_default(c: u8) -> EscapeDefault {\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for EscapeDefault {\n    type Item = u8;\n    fn next(&mut self) -> Option<u8> {\n}\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n    fn last(mut self) -> Option<u8> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl DoubleEndedIterator for EscapeDefault {\n    fn next_back(&mut self) -> Option<u8> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ExactSizeIterator for EscapeDefault {}\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for EscapeDefault {}\n\n#[stable(feature = \"ascii_escape_display\", since = \"1.39.0\")]\nimpl fmt::Display for EscapeDefault {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for EscapeDefault {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n}\npub mod cell {\n//! Shareable mutable containers.\n//!\n//! Rust memory safety is based on this rule: Given an object `T`, it is only possible to\n//! have one of the following:\n//!\n//! - Having several immutable references (`&T`) to the object (also known as **aliasing**).\n//! - Having one mutable reference (`&mut T`) to the object (also known as **mutability**).\n//!\n//! This is enforced by the Rust compiler. However, there are situations where this rule is not\n//! flexible enough. Sometimes it is required to have multiple references to an object and yet\n//! mutate it.\n//!\n//! Shareable mutable containers exist to permit mutability in a controlled manner, even in the\n//! presence of aliasing. Both `Cell<T>` and `RefCell<T>` allow doing this in a single-threaded\n//! way. However, neither `Cell<T>` nor `RefCell<T>` are thread safe (they do not implement\n//! `Sync`). If you need to do aliasing and mutation between multiple threads it is possible to\n//! use [`Mutex`](../../std/sync/struct.Mutex.html),\n//! [`RwLock`](../../std/sync/struct.RwLock.html) or\n//! [`atomic`](../../core/sync/atomic/index.html) types.\n//!\n//! Values of the `Cell<T>` and `RefCell<T>` types may be mutated through shared references (i.e.\n//! the common `&T` type), whereas most Rust types can only be mutated through unique (`&mut T`)\n//! references. We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast\n//! with typical Rust types that exhibit 'inherited mutability'.\n//!\n//! Cell types come in two flavors: `Cell<T>` and `RefCell<T>`. `Cell<T>` implements interior\n//! mutability by moving values in and out of the `Cell<T>`. To use references instead of values,\n//! one must use the `RefCell<T>` type, acquiring a write lock before mutating. `Cell<T>` provides\n//! methods to retrieve and change the current interior value:\n//!\n//!  - For types that implement `Copy`, the `get` method retrieves the current interior value.\n//!  - For types that implement `Default`, the `take` method replaces the current interior value\n//!    with `Default::default()` and returns the replaced value.\n//!  - For all types, the `replace` method replaces the current interior value and returns the\n//!    replaced value and the `into_inner` method consumes the `Cell<T>` and returns the interior\n//!    value. Additionally, the `set` method replaces the interior value, dropping the replaced\n//!    value.\n//!\n//! `RefCell<T>` uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can\n//! claim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are\n//! tracked 'at runtime', unlike Rust's native reference types which are entirely tracked\n//! statically, at compile time. Because `RefCell<T>` borrows are dynamic it is possible to attempt\n//! to borrow a value that is already mutably borrowed; when this happens it results in thread\n//! panic.\n//!\n//! # When to choose interior mutability\n//!\n//! The more common inherited mutability, where one must have unique access to mutate a value, is\n//! one of the key language elements that enables Rust to reason strongly about pointer aliasing,\n//! statically preventing crash bugs. Because of that, inherited mutability is preferred, and\n//! interior mutability is something of a last resort. Since cell types enable mutation where it\n//! would otherwise be disallowed though, there are occasions when interior mutability might be\n//! appropriate, or even *must* be used, e.g.\n//!\n//! * Introducing mutability 'inside' of something immutable\n//! * Implementation details of logically-immutable methods.\n//! * Mutating implementations of `Clone`.\n//!\n//! ## Introducing mutability 'inside' of something immutable\n//!\n//! Many shared smart pointer types, including `Rc<T>` and `Arc<T>`, provide containers that can be\n//! cloned and shared between multiple parties. Because the contained values may be\n//! multiply-aliased, they can only be borrowed with `&`, not `&mut`. Without cells it would be\n//! impossible to mutate data inside of these smart pointers at all.\n//!\n//! It's very common then to put a `RefCell<T>` inside shared pointer types to reintroduce\n//! mutability:\n//!\n//! ```\n//! use std::cell::{RefCell, RefMut};\n//! use std::collections::HashMap;\n//! use std::rc::Rc;\n//!\n//! fn main() {\n//!     let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));\n//!     // Create a new block to limit the scope of the dynamic borrow\n//!     {\n//!         let mut map: RefMut<_> = shared_map.borrow_mut();\n//!         map.insert(\"africa\", 92388);\n//!         map.insert(\"kyoto\", 11837);\n//!         map.insert(\"piccadilly\", 11826);\n//!         map.insert(\"marbles\", 38);\n//!     }\n//!\n//!     // Note that if we had not let the previous borrow of the cache fall out\n//!     // of scope then the subsequent borrow would cause a dynamic thread panic.\n//!     // This is the major hazard of using `RefCell`.\n//!     let total: i32 = shared_map.borrow().values().sum();\n//!     println!(\"{}\", total);\n//! }\n//! ```\n//!\n//! Note that this example uses `Rc<T>` and not `Arc<T>`. `RefCell<T>`s are for single-threaded\n//! scenarios. Consider using `RwLock<T>` or `Mutex<T>` if you need shared mutability in a\n//! multi-threaded situation.\n//!\n//! ## Implementation details of logically-immutable methods\n//!\n//! Occasionally it may be desirable not to expose in an API that there is mutation happening\n//! \"under the hood\". This may be because logically the operation is immutable, but e.g., caching\n//! forces the implementation to perform mutation; or because you must employ mutation to implement\n//! a trait method that was originally defined to take `&self`.\n//!\n//! ```\n//! # #![allow(dead_code)]\n//! use std::cell::RefCell;\n//!\n//! struct Graph {\n//!     edges: Vec<(i32, i32)>,\n//!     span_tree_cache: RefCell<Option<Vec<(i32, i32)>>>\n//! }\n//!\n//! impl Graph {\n//!     fn minimum_spanning_tree(&self) -> Vec<(i32, i32)> {\n//!         self.span_tree_cache.borrow_mut()\n//!             .get_or_insert_with(|| self.calc_span_tree())\n//!             .clone()\n//!     }\n//!\n//!     fn calc_span_tree(&self) -> Vec<(i32, i32)> {\n//!         // Expensive computation goes here\n//!         vec![]\n//!     }\n//! }\n//! ```\n//!\n//! ## Mutating implementations of `Clone`\n//!\n//! This is simply a special - but common - case of the previous: hiding mutability for operations\n//! that appear to be immutable. The `clone` method is expected to not change the source value, and\n//! is declared to take `&self`, not `&mut self`. Therefore, any mutation that happens in the\n//! `clone` method must use cell types. For example, `Rc<T>` maintains its reference counts within a\n//! `Cell<T>`.\n//!\n//! ```\n//! #![feature(core_intrinsics)]\n//! use std::cell::Cell;\n//! use std::ptr::NonNull;\n//! use std::intrinsics::abort;\n//! use std::marker::PhantomData;\n//!\n//! struct Rc<T: ?Sized> {\n//!     ptr: NonNull<RcBox<T>>,\n//!     phantom: PhantomData<RcBox<T>>,\n//! }\n//!\n//! struct RcBox<T: ?Sized> {\n//!     strong: Cell<usize>,\n//!     refcount: Cell<usize>,\n//!     value: T,\n//! }\n//!\n//! impl<T: ?Sized> Clone for Rc<T> {\n//!     fn clone(&self) -> Rc<T> {\n//!         self.inc_strong();\n//!         Rc {\n//!             ptr: self.ptr,\n//!             phantom: PhantomData,\n//!         }\n//!     }\n//! }\n//!\n//! trait RcBoxPtr<T: ?Sized> {\n//!\n//!     fn inner(&self) -> &RcBox<T>;\n//!\n//!     fn strong(&self) -> usize {\n//!         self.inner().strong.get()\n//!     }\n//!\n//!     fn inc_strong(&self) {\n//!         self.inner()\n//!             .strong\n//!             .set(self.strong()\n//!                      .checked_add(1)\n//!                      .unwrap_or_else(|| unsafe { abort() }));\n//!     }\n//! }\n//!\n//! impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n//!    fn inner(&self) -> &RcBox<T> {\n//!        unsafe {\n//!            self.ptr.as_ref()\n//!        }\n//!    }\n//! }\n//! ```\n//!\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::cmp::Ordering;\nuse crate::fmt::{self, Debug, Display};\nuse crate::marker::Unsize;\nuse crate::mem;\nuse crate::ops::{CoerceUnsized, Deref, DerefMut};\nuse crate::ptr;\n\n/// A mutable memory location.\n///\n/// # Examples\n///\n/// In this example, you can see that `Cell<T>` enables mutation inside an\n/// immutable struct. In other words, it enables \"interior mutability\".\n///\n/// ```\n/// use std::cell::Cell;\n///\n/// struct SomeStruct {\n///     regular_field: u8,\n///     special_field: Cell<u8>,\n/// }\n///\n/// let my_struct = SomeStruct {\n///     regular_field: 0,\n///     special_field: Cell::new(1),\n/// };\n///\n/// let new_value = 100;\n///\n/// // ERROR: `my_struct` is immutable\n/// // my_struct.regular_field = new_value;\n///\n/// // WORKS: although `my_struct` is immutable, `special_field` is a `Cell`,\n/// // which can always be mutated\n/// my_struct.special_field.set(new_value);\n/// assert_eq!(my_struct.special_field.get(), new_value);\n/// ```\n///\n/// See the [module-level documentation](index.html) for more.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[repr(transparent)]\npub struct Cell<T: ?Sized> {\n    value: UnsafeCell<T>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: ?Sized> Send for Cell<T> where T: Send {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !Sync for Cell<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Copy> Clone for Cell<T> {\n    #[inline]\n    fn clone(&self) -> Cell<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Default> Default for Cell<T> {\n    /// Creates a `Cell<T>`, with the `Default` value for T.\n    #[inline]\n    fn default() -> Cell<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: PartialEq + Copy> PartialEq for Cell<T> {\n    #[inline]\n    fn eq(&self, other: &Cell<T>) -> bool {\n}\n}\n\n#[stable(feature = \"cell_eq\", since = \"1.2.0\")]\nimpl<T: Eq + Copy> Eq for Cell<T> {}\n\n#[stable(feature = \"cell_ord\", since = \"1.10.0\")]\nimpl<T: PartialOrd + Copy> PartialOrd for Cell<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Cell<T>) -> Option<Ordering> {\n}\n\n    #[inline]\n    fn lt(&self, other: &Cell<T>) -> bool {\n}\n\n    #[inline]\n    fn le(&self, other: &Cell<T>) -> bool {\n}\n\n    #[inline]\n    fn gt(&self, other: &Cell<T>) -> bool {\n}\n\n    #[inline]\n    fn ge(&self, other: &Cell<T>) -> bool {\n}\n}\n\n#[stable(feature = \"cell_ord\", since = \"1.10.0\")]\nimpl<T: Ord + Copy> Ord for Cell<T> {\n    #[inline]\n    fn cmp(&self, other: &Cell<T>) -> Ordering {\n}\n}\n\n#[stable(feature = \"cell_from\", since = \"1.12.0\")]\nimpl<T> From<T> for Cell<T> {\n    fn from(t: T) -> Cell<T> {\n}\n}\n\nimpl<T> Cell<T> {\n    /// Creates a new `Cell` containing the given value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_cell_new\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn new(value: T) -> Cell<T> {\n}\n\n    /// Sets the contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    ///\n    /// c.set(10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn set(&self, val: T) {\n}\n\n    /// Swaps the values of two Cells.\n    /// Difference with `std::mem::swap` is that this function doesn't require `&mut` reference.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c1 = Cell::new(5i32);\n    /// let c2 = Cell::new(10i32);\n    /// c1.swap(&c2);\n    /// assert_eq!(10, c1.get());\n    /// assert_eq!(5, c2.get());\n    /// ```\n    #[inline]\n    #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n    pub fn swap(&self, other: &Self) {\n}\n\n    /// Replaces the contained value, and returns it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let cell = Cell::new(5);\n    /// assert_eq!(cell.get(), 5);\n    /// assert_eq!(cell.replace(10), 5);\n    /// assert_eq!(cell.get(), 10);\n    /// ```\n    #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n    pub fn replace(&self, val: T) -> T {\n}\n\n    /// Unwraps the value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    /// let five = c.into_inner();\n    ///\n    /// assert_eq!(five, 5);\n    /// ```\n    #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n    pub fn into_inner(self) -> T {\n}\n}\n\nimpl<T: Copy> Cell<T> {\n    /// Returns a copy of the contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    ///\n    /// let five = c.get();\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get(&self) -> T {\n}\n\n    /// Updates the contained value using a function and returns the new value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(cell_update)]\n    ///\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    /// let new = c.update(|x| x + 1);\n    ///\n    /// assert_eq!(new, 6);\n    /// assert_eq!(c.get(), 6);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"cell_update\", issue = \"50186\")]\n    pub fn update<F>(&self, f: F) -> T\n    where\n        F: FnOnce(T) -> T,\n    {\n}\n}\n\nimpl<T: ?Sized> Cell<T> {\n    /// Returns a raw pointer to the underlying data in this cell.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    ///\n    /// let ptr = c.as_ptr();\n    /// ```\n    #[inline]\n    #[stable(feature = \"cell_as_ptr\", since = \"1.12.0\")]\n    #[rustc_const_stable(feature = \"const_cell_as_ptr\", since = \"1.32.0\")]\n    pub const fn as_ptr(&self) -> *mut T {\n}\n\n    /// Returns a mutable reference to the underlying data.\n    ///\n    /// This call borrows `Cell` mutably (at compile-time) which guarantees\n    /// that we possess the only reference.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let mut c = Cell::new(5);\n    /// *c.get_mut() += 1;\n    ///\n    /// assert_eq!(c.get(), 6);\n    /// ```\n    #[inline]\n    #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n    pub fn get_mut(&mut self) -> &mut T {\n}\n\n    /// Returns a `&Cell<T>` from a `&mut T`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let slice: &mut [i32] = &mut [1, 2, 3];\n    /// let cell_slice: &Cell<[i32]> = Cell::from_mut(slice);\n    /// let slice_cell: &[Cell<i32>] = cell_slice.as_slice_of_cells();\n    ///\n    /// assert_eq!(slice_cell.len(), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"as_cell\", since = \"1.37.0\")]\n    pub fn from_mut(t: &mut T) -> &Cell<T> {\n}\n}\n\nimpl<T: Default> Cell<T> {\n    /// Takes the value of the cell, leaving `Default::default()` in its place.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::cell::Cell;\n    ///\n    /// let c = Cell::new(5);\n    /// let five = c.take();\n    ///\n    /// assert_eq!(five, 5);\n    /// assert_eq!(c.into_inner(), 0);\n    /// ```\n    #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n    pub fn take(&self) -> T {\n}\n}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: CoerceUnsized<U>, U> CoerceUnsized<Cell<U>> for Cell<T> {}}\npub mod char {\n//! A character type.\n//!\n//! The `char` type represents a single character. More specifically, since\n//! 'character' isn't a well-defined concept in Unicode, `char` is a '[Unicode\n//! scalar value]', which is similar to, but not the same as, a '[Unicode code\n//! point]'.\n//!\n//! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n//! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n//!\n//! This module exists for technical reasons, the primary documentation for\n//! `char` is directly on [the `char` primitive type](../../std/primitive.char.html)\n//! itself.\n//!\n//! This module is the home of the iterator implementations for the iterators\n//! implemented on `char`, as well as some useful constants and conversion\n//! functions that convert various types to `char`.\n\n#![allow(non_snake_case)]\n#![stable(feature = \"core_char\", since = \"1.2.0\")]\n\nmod convert {\n//! Character conversions.\n\nuse crate::convert::TryFrom;\nuse crate::fmt;\nuse crate::mem::transmute;\nuse crate::str::FromStr;\n\nuse super::MAX;\n\n/// Converts a `u32` to a `char`.\n///\n/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n/// `as`:\n///\n/// ```\n/// let c = '💯';\n/// let i = c as u32;\n///\n/// assert_eq!(128175, i);\n/// ```\n///\n/// However, the reverse is not true: not all valid [`u32`]s are valid\n/// [`char`]s. `from_u32()` will return `None` if the input is not a valid value\n/// for a [`char`].\n///\n/// [`char`]: ../../std/primitive.char.html\n/// [`u32`]: ../../std/primitive.u32.html\n///\n/// For an unsafe version of this function which ignores these checks, see\n/// [`from_u32_unchecked`].\n///\n/// [`from_u32_unchecked`]: fn.from_u32_unchecked.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::char;\n///\n/// let c = char::from_u32(0x2764);\n///\n/// assert_eq!(Some('❤'), c);\n/// ```\n///\n/// Returning `None` when the input is not a valid [`char`]:\n///\n/// ```\n/// use std::char;\n///\n/// let c = char::from_u32(0x110000);\n///\n/// assert_eq!(None, c);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn from_u32(i: u32) -> Option<char> {\n}\n\n/// Converts a `u32` to a `char`, ignoring validity.\n///\n/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n/// `as`:\n///\n/// ```\n/// let c = '💯';\n/// let i = c as u32;\n///\n/// assert_eq!(128175, i);\n/// ```\n///\n/// However, the reverse is not true: not all valid [`u32`]s are valid\n/// [`char`]s. `from_u32_unchecked()` will ignore this, and blindly cast to\n/// [`char`], possibly creating an invalid one.\n///\n/// [`char`]: ../../std/primitive.char.html\n/// [`u32`]: ../../std/primitive.u32.html\n///\n/// # Safety\n///\n/// This function is unsafe, as it may construct invalid `char` values.\n///\n/// For a safe version of this function, see the [`from_u32`] function.\n///\n/// [`from_u32`]: fn.from_u32.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::char;\n///\n/// let c = unsafe { char::from_u32_unchecked(0x2764) };\n///\n/// assert_eq!('❤', c);\n/// ```\n#[inline]\n#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\npub unsafe fn from_u32_unchecked(i: u32) -> char {\n}\n\n#[stable(feature = \"char_convert\", since = \"1.13.0\")]\nimpl From<char> for u32 {\n    /// Converts a [`char`] into a [`u32`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::mem;\n    ///\n    /// let c = 'c';\n    /// let u = u32::from(c);\n    /// assert!(4 == mem::size_of_val(&u))\n    /// ```\n    #[inline]\n    fn from(c: char) -> Self {\n}\n}\n\n/// Maps a byte in 0x00..=0xFF to a `char` whose code point has the same value, in U+0000..=U+00FF.\n///\n/// Unicode is designed such that this effectively decodes bytes\n/// with the character encoding that IANA calls ISO-8859-1.\n/// This encoding is compatible with ASCII.\n///\n/// Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen),\n/// which leaves some \"blanks\", byte values that are not assigned to any character.\n/// ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.\n///\n/// Note that this is *also* different from Windows-1252 a.k.a. code page 1252,\n/// which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks\n/// to punctuation and various Latin characters.\n///\n/// To confuse things further, [on the Web](https://encoding.spec.whatwg.org/)\n/// `ascii`, `iso-8859-1`, and `windows-1252` are all aliases\n/// for a superset of Windows-1252 that fills the remaining blanks with corresponding\n/// C0 and C1 control codes.\n#[stable(feature = \"char_convert\", since = \"1.13.0\")]\nimpl From<u8> for char {\n    /// Converts a [`u8`] into a [`char`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::mem;\n    ///\n    /// let u = 32 as u8;\n    /// let c = char::from(u);\n    /// assert!(4 == mem::size_of_val(&c))\n    /// ```\n    #[inline]\n    fn from(i: u8) -> Self {\n}\n}\n\n/// An error which can be returned when parsing a char.\n#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ParseCharError {\n    kind: CharErrorKind,\n}\n\nimpl ParseCharError {\n    #[unstable(\n        feature = \"char_error_internals\",\n        reason = \"this method should not be available publicly\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    pub fn __description(&self) -> &str {\n}\n}\n\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\nenum CharErrorKind {\n    EmptyString,\n    TooManyChars,\n}\n\n#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\nimpl fmt::Display for ParseCharError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\nimpl FromStr for char {\n    type Err = ParseCharError;\n\n    #[inline]\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n}\n}\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl TryFrom<u32> for char {\n    type Error = CharTryFromError;\n\n    #[inline]\n    fn try_from(i: u32) -> Result<Self, Self::Error> {\n}\n}\n\n/// The error type returned when a conversion from u32 to char fails.\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\npub struct CharTryFromError(());\n\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\nimpl fmt::Display for CharTryFromError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// Converts a digit in the given radix to a `char`.\n///\n/// A 'radix' here is sometimes also called a 'base'. A radix of two\n/// indicates a binary number, a radix of ten, decimal, and a radix of\n/// sixteen, hexadecimal, to give some common values. Arbitrary\n/// radices are supported.\n///\n/// `from_digit()` will return `None` if the input is not a digit in\n/// the given radix.\n///\n/// # Panics\n///\n/// Panics if given a radix larger than 36.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::char;\n///\n/// let c = char::from_digit(4, 10);\n///\n/// assert_eq!(Some('4'), c);\n///\n/// // Decimal 11 is a single digit in base 16\n/// let c = char::from_digit(11, 16);\n///\n/// assert_eq!(Some('b'), c);\n/// ```\n///\n/// Returning `None` when the input is not a digit:\n///\n/// ```\n/// use std::char;\n///\n/// let c = char::from_digit(20, 10);\n///\n/// assert_eq!(None, c);\n/// ```\n///\n/// Passing a large radix, causing a panic:\n///\n/// ```\n/// use std::thread;\n/// use std::char;\n///\n/// let result = thread::spawn(|| {\n///     // this panics\n///     let c = char::from_digit(1, 37);\n/// }).join();\n///\n/// assert!(result.is_err());\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn from_digit(num: u32, radix: u32) -> Option<char> {\n}\n}\nmod decode {\n//! UTF-8 and UTF-16 decoding iterators\n\nuse crate::fmt;\n\nuse super::from_u32_unchecked;\n\n/// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n#[derive(Clone, Debug)]\npub struct DecodeUtf16<I>\nwhere\n    I: Iterator<Item = u16>,\n{\n    iter: I,\n    buf: Option<u16>,\n}\n\n/// An error that can be returned when decoding UTF-16 code points.\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n#[derive(Debug, Clone, Eq, PartialEq)]\npub struct DecodeUtf16Error {\n    code: u16,\n}\n\n/// Creates an iterator over the UTF-16 encoded code points in `iter`,\n/// returning unpaired surrogates as `Err`s.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::char::decode_utf16;\n///\n/// // 𝄞mus<invalid>ic<invalid>\n/// let v = [\n///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n/// ];\n///\n/// assert_eq!(\n///     decode_utf16(v.iter().cloned())\n///         .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n///         .collect::<Vec<_>>(),\n///     vec![\n///         Ok('𝄞'),\n///         Ok('m'), Ok('u'), Ok('s'),\n///         Err(0xDD1E),\n///         Ok('i'), Ok('c'),\n///         Err(0xD834)\n///     ]\n/// );\n/// ```\n///\n/// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n///\n/// ```\n/// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n///\n/// // 𝄞mus<invalid>ic<invalid>\n/// let v = [\n///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n/// ];\n///\n/// assert_eq!(\n///     decode_utf16(v.iter().cloned())\n///        .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n///        .collect::<String>(),\n///     \"𝄞mus�ic�\"\n/// );\n/// ```\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n#[inline]\npub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n}\n\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\nimpl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n    type Item = Result<char, DecodeUtf16Error>;\n\n    fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\nimpl DecodeUtf16Error {\n    /// Returns the unpaired surrogate which caused this error.\n    #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n    pub fn unpaired_surrogate(&self) -> u16 {\n}\n}\n\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\nimpl fmt::Display for DecodeUtf16Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n}\nmod methods {\n//! impl char {}\n\nuse crate::slice;\nuse crate::str::from_utf8_unchecked_mut;\nuse crate::unicode::printable::is_printable;\nuse crate::unicode::{self, conversions};\n\nuse super::*;\n\n#[lang = \"char\"]\nimpl char {\n    /// Checks if a `char` is a digit in the given radix.\n    ///\n    /// A 'radix' here is sometimes also called a 'base'. A radix of two\n    /// indicates a binary number, a radix of ten, decimal, and a radix of\n    /// sixteen, hexadecimal, to give some common values. Arbitrary\n    /// radices are supported.\n    ///\n    /// Compared to `is_numeric()`, this function only recognizes the characters\n    /// `0-9`, `a-z` and `A-Z`.\n    ///\n    /// 'Digit' is defined to be only the following characters:\n    ///\n    /// * `0-9`\n    /// * `a-z`\n    /// * `A-Z`\n    ///\n    /// For a more comprehensive understanding of 'digit', see [`is_numeric`][is_numeric].\n    ///\n    /// [is_numeric]: #method.is_numeric\n    ///\n    /// # Panics\n    ///\n    /// Panics if given a radix larger than 36.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!('1'.is_digit(10));\n    /// assert!('f'.is_digit(16));\n    /// assert!(!'f'.is_digit(10));\n    /// ```\n    ///\n    /// Passing a large radix, causing a panic:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let result = thread::spawn(|| {\n    ///     // this panics\n    ///     '1'.is_digit(37);\n    /// }).join();\n    ///\n    /// assert!(result.is_err());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_digit(self, radix: u32) -> bool {\n}\n\n    /// Converts a `char` to a digit in the given radix.\n    ///\n    /// A 'radix' here is sometimes also called a 'base'. A radix of two\n    /// indicates a binary number, a radix of ten, decimal, and a radix of\n    /// sixteen, hexadecimal, to give some common values. Arbitrary\n    /// radices are supported.\n    ///\n    /// 'Digit' is defined to be only the following characters:\n    ///\n    /// * `0-9`\n    /// * `a-z`\n    /// * `A-Z`\n    ///\n    /// # Errors\n    ///\n    /// Returns `None` if the `char` does not refer to a digit in the given radix.\n    ///\n    /// # Panics\n    ///\n    /// Panics if given a radix larger than 36.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert_eq!('1'.to_digit(10), Some(1));\n    /// assert_eq!('f'.to_digit(16), Some(15));\n    /// ```\n    ///\n    /// Passing a non-digit results in failure:\n    ///\n    /// ```\n    /// assert_eq!('f'.to_digit(10), None);\n    /// assert_eq!('z'.to_digit(16), None);\n    /// ```\n    ///\n    /// Passing a large radix, causing a panic:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let result = thread::spawn(|| {\n    ///     '1'.to_digit(37);\n    /// }).join();\n    ///\n    /// assert!(result.is_err());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_digit(self, radix: u32) -> Option<u32> {\n}\n\n    /// Returns an iterator that yields the hexadecimal Unicode escape of a\n    /// character as `char`s.\n    ///\n    /// This will escape characters with the Rust syntax of the form\n    /// `\\u{NNNNNN}` where `NNNNNN` is a hexadecimal representation.\n    ///\n    /// # Examples\n    ///\n    /// As an iterator:\n    ///\n    /// ```\n    /// for c in '❤'.escape_unicode() {\n    ///     print!(\"{}\", c);\n    /// }\n    /// println!();\n    /// ```\n    ///\n    /// Using `println!` directly:\n    ///\n    /// ```\n    /// println!(\"{}\", '❤'.escape_unicode());\n    /// ```\n    ///\n    /// Both are equivalent to:\n    ///\n    /// ```\n    /// println!(\"\\\\u{{2764}}\");\n    /// ```\n    ///\n    /// Using `to_string`:\n    ///\n    /// ```\n    /// assert_eq!('❤'.escape_unicode().to_string(), \"\\\\u{2764}\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn escape_unicode(self) -> EscapeUnicode {\n}\n\n    /// An extended version of `escape_debug` that optionally permits escaping\n    /// Extended Grapheme codepoints. This allows us to format characters like\n    /// nonspacing marks better when they're at the start of a string.\n    #[inline]\n    pub(crate) fn escape_debug_ext(self, escape_grapheme_extended: bool) -> EscapeDebug {\n}\n\n    /// Returns an iterator that yields the literal escape code of a character\n    /// as `char`s.\n    ///\n    /// This will escape the characters similar to the `Debug` implementations\n    /// of `str` or `char`.\n    ///\n    /// # Examples\n    ///\n    /// As an iterator:\n    ///\n    /// ```\n    /// for c in '\\n'.escape_debug() {\n    ///     print!(\"{}\", c);\n    /// }\n    /// println!();\n    /// ```\n    ///\n    /// Using `println!` directly:\n    ///\n    /// ```\n    /// println!(\"{}\", '\\n'.escape_debug());\n    /// ```\n    ///\n    /// Both are equivalent to:\n    ///\n    /// ```\n    /// println!(\"\\\\n\");\n    /// ```\n    ///\n    /// Using `to_string`:\n    ///\n    /// ```\n    /// assert_eq!('\\n'.escape_debug().to_string(), \"\\\\n\");\n    /// ```\n    #[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n    #[inline]\n    pub fn escape_debug(self) -> EscapeDebug {\n}\n\n    /// Returns an iterator that yields the literal escape code of a character\n    /// as `char`s.\n    ///\n    /// The default is chosen with a bias toward producing literals that are\n    /// legal in a variety of languages, including C++11 and similar C-family\n    /// languages. The exact rules are:\n    ///\n    /// * Tab is escaped as `\\t`.\n    /// * Carriage return is escaped as `\\r`.\n    /// * Line feed is escaped as `\\n`.\n    /// * Single quote is escaped as `\\'`.\n    /// * Double quote is escaped as `\\\"`.\n    /// * Backslash is escaped as `\\\\`.\n    /// * Any character in the 'printable ASCII' range `0x20` .. `0x7e`\n    ///   inclusive is not escaped.\n    /// * All other characters are given hexadecimal Unicode escapes; see\n    ///   [`escape_unicode`][escape_unicode].\n    ///\n    /// [escape_unicode]: #method.escape_unicode\n    ///\n    /// # Examples\n    ///\n    /// As an iterator:\n    ///\n    /// ```\n    /// for c in '\"'.escape_default() {\n    ///     print!(\"{}\", c);\n    /// }\n    /// println!();\n    /// ```\n    ///\n    /// Using `println!` directly:\n    ///\n    /// ```\n    /// println!(\"{}\", '\"'.escape_default());\n    /// ```\n    ///\n    ///\n    /// Both are equivalent to:\n    ///\n    /// ```\n    /// println!(\"\\\\\\\"\");\n    /// ```\n    ///\n    /// Using `to_string`:\n    ///\n    /// ```\n    /// assert_eq!('\"'.escape_default().to_string(), \"\\\\\\\"\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn escape_default(self) -> EscapeDefault {\n}\n\n    /// Returns the number of bytes this `char` would need if encoded in UTF-8.\n    ///\n    /// That number of bytes is always between 1 and 4, inclusive.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let len = 'A'.len_utf8();\n    /// assert_eq!(len, 1);\n    ///\n    /// let len = 'ß'.len_utf8();\n    /// assert_eq!(len, 2);\n    ///\n    /// let len = 'ℝ'.len_utf8();\n    /// assert_eq!(len, 3);\n    ///\n    /// let len = '💣'.len_utf8();\n    /// assert_eq!(len, 4);\n    /// ```\n    ///\n    /// The `&str` type guarantees that its contents are UTF-8, and so we can compare the length it\n    /// would take if each code point was represented as a `char` vs in the `&str` itself:\n    ///\n    /// ```\n    /// // as chars\n    /// let eastern = '東';\n    /// let capital = '京';\n    ///\n    /// // both can be represented as three bytes\n    /// assert_eq!(3, eastern.len_utf8());\n    /// assert_eq!(3, capital.len_utf8());\n    ///\n    /// // as a &str, these two are encoded in UTF-8\n    /// let tokyo = \"東京\";\n    ///\n    /// let len = eastern.len_utf8() + capital.len_utf8();\n    ///\n    /// // we can see that they take six bytes total...\n    /// assert_eq!(6, tokyo.len());\n    ///\n    /// // ... just like the &str\n    /// assert_eq!(len, tokyo.len());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn len_utf8(self) -> usize {\n}\n\n    /// Returns the number of 16-bit code units this `char` would need if\n    /// encoded in UTF-16.\n    ///\n    /// See the documentation for [`len_utf8`] for more explanation of this\n    /// concept. This function is a mirror, but for UTF-16 instead of UTF-8.\n    ///\n    /// [`len_utf8`]: #method.len_utf8\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let n = 'ß'.len_utf16();\n    /// assert_eq!(n, 1);\n    ///\n    /// let len = '💣'.len_utf16();\n    /// assert_eq!(len, 2);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn len_utf16(self) -> usize {\n}\n\n    /// Encodes this character as UTF-8 into the provided byte buffer,\n    /// and then returns the subslice of the buffer that contains the encoded character.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the buffer is not large enough.\n    /// A buffer of length four is large enough to encode any `char`.\n    ///\n    /// # Examples\n    ///\n    /// In both of these examples, 'ß' takes two bytes to encode.\n    ///\n    /// ```\n    /// let mut b = [0; 2];\n    ///\n    /// let result = 'ß'.encode_utf8(&mut b);\n    ///\n    /// assert_eq!(result, \"ß\");\n    ///\n    /// assert_eq!(result.len(), 2);\n    /// ```\n    ///\n    /// A buffer that's too small:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let result = thread::spawn(|| {\n    ///     let mut b = [0; 1];\n    ///\n    ///     // this panics\n    ///    'ß'.encode_utf8(&mut b);\n    /// }).join();\n    ///\n    /// assert!(result.is_err());\n    /// ```\n    #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n    #[inline]\n    pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n}\n\n    /// Encodes this character as UTF-16 into the provided `u16` buffer,\n    /// and then returns the subslice of the buffer that contains the encoded character.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the buffer is not large enough.\n    /// A buffer of length 2 is large enough to encode any `char`.\n    ///\n    /// # Examples\n    ///\n    /// In both of these examples, '𝕊' takes two `u16`s to encode.\n    ///\n    /// ```\n    /// let mut b = [0; 2];\n    ///\n    /// let result = '𝕊'.encode_utf16(&mut b);\n    ///\n    /// assert_eq!(result.len(), 2);\n    /// ```\n    ///\n    /// A buffer that's too small:\n    ///\n    /// ```\n    /// use std::thread;\n    ///\n    /// let result = thread::spawn(|| {\n    ///     let mut b = [0; 1];\n    ///\n    ///     // this panics\n    ///     '𝕊'.encode_utf16(&mut b);\n    /// }).join();\n    ///\n    /// assert!(result.is_err());\n    /// ```\n    #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n    #[inline]\n    pub fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n}\n\n    /// Returns `true` if this `char` has the `Alphabetic` property.\n    ///\n    /// `Alphabetic` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n    ///\n    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n    /// [ucd]: https://www.unicode.org/reports/tr44/\n    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!('a'.is_alphabetic());\n    /// assert!('京'.is_alphabetic());\n    ///\n    /// let c = '💝';\n    /// // love is many things, but it is not alphabetic\n    /// assert!(!c.is_alphabetic());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_alphabetic(self) -> bool {\n}\n\n    /// Returns `true` if this `char` has the `Lowercase` property.\n    ///\n    /// `Lowercase` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n    ///\n    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n    /// [ucd]: https://www.unicode.org/reports/tr44/\n    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!('a'.is_lowercase());\n    /// assert!('δ'.is_lowercase());\n    /// assert!(!'A'.is_lowercase());\n    /// assert!(!'Δ'.is_lowercase());\n    ///\n    /// // The various Chinese scripts do not have case, and so:\n    /// assert!(!'中'.is_lowercase());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_lowercase(self) -> bool {\n}\n\n    /// Returns `true` if this `char` has the `Uppercase` property.\n    ///\n    /// `Uppercase` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n    ///\n    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n    /// [ucd]: https://www.unicode.org/reports/tr44/\n    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!(!'a'.is_uppercase());\n    /// assert!(!'δ'.is_uppercase());\n    /// assert!('A'.is_uppercase());\n    /// assert!('Δ'.is_uppercase());\n    ///\n    /// // The various Chinese scripts do not have case, and so:\n    /// assert!(!'中'.is_uppercase());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_uppercase(self) -> bool {\n}\n\n    /// Returns `true` if this `char` has the `White_Space` property.\n    ///\n    /// `White_Space` is specified in the [Unicode Character Database][ucd] [`PropList.txt`].\n    ///\n    /// [ucd]: https://www.unicode.org/reports/tr44/\n    /// [`PropList.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!(' '.is_whitespace());\n    ///\n    /// // a non-breaking space\n    /// assert!('\\u{A0}'.is_whitespace());\n    ///\n    /// assert!(!'越'.is_whitespace());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_whitespace(self) -> bool {\n}\n\n    /// Returns `true` if this `char` satisfies either [`is_alphabetic()`] or [`is_numeric()`].\n    ///\n    /// [`is_alphabetic()`]: #method.is_alphabetic\n    /// [`is_numeric()`]: #method.is_numeric\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!('٣'.is_alphanumeric());\n    /// assert!('7'.is_alphanumeric());\n    /// assert!('৬'.is_alphanumeric());\n    /// assert!('¾'.is_alphanumeric());\n    /// assert!('①'.is_alphanumeric());\n    /// assert!('K'.is_alphanumeric());\n    /// assert!('و'.is_alphanumeric());\n    /// assert!('藏'.is_alphanumeric());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_alphanumeric(self) -> bool {\n}\n\n    /// Returns `true` if this `char` has the general category for control codes.\n    ///\n    /// Control codes (code points with the general category of `Cc`) are described in Chapter 4\n    /// (Character Properties) of the [Unicode Standard] and specified in the [Unicode Character\n    /// Database][ucd] [`UnicodeData.txt`].\n    ///\n    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n    /// [ucd]: https://www.unicode.org/reports/tr44/\n    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // U+009C, STRING TERMINATOR\n    /// assert!(''.is_control());\n    /// assert!(!'q'.is_control());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_control(self) -> bool {\n}\n\n    /// Returns `true` if this `char` has the `Grapheme_Extend` property.\n    ///\n    /// `Grapheme_Extend` is described in [Unicode Standard Annex #29 (Unicode Text\n    /// Segmentation)][uax29] and specified in the [Unicode Character Database][ucd]\n    /// [`DerivedCoreProperties.txt`].\n    ///\n    /// [uax29]: https://www.unicode.org/reports/tr29/\n    /// [ucd]: https://www.unicode.org/reports/tr44/\n    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n    #[inline]\n    pub(crate) fn is_grapheme_extended(self) -> bool {\n}\n\n    /// Returns `true` if this `char` has one of the general categories for numbers.\n    ///\n    /// The general categories for numbers (`Nd` for decimal digits, `Nl` for letter-like numeric\n    /// characters, and `No` for other numeric characters) are specified in the [Unicode Character\n    /// Database][ucd] [`UnicodeData.txt`].\n    ///\n    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n    /// [ucd]: https://www.unicode.org/reports/tr44/\n    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert!('٣'.is_numeric());\n    /// assert!('7'.is_numeric());\n    /// assert!('৬'.is_numeric());\n    /// assert!('¾'.is_numeric());\n    /// assert!('①'.is_numeric());\n    /// assert!(!'K'.is_numeric());\n    /// assert!(!'و'.is_numeric());\n    /// assert!(!'藏'.is_numeric());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn is_numeric(self) -> bool {\n}\n\n    /// Returns an iterator that yields the lowercase mapping of this `char` as one or more\n    /// `char`s.\n    ///\n    /// If this `char` does not have a lowercase mapping, the iterator yields the same `char`.\n    ///\n    /// If this `char` has a one-to-one lowercase mapping given by the [Unicode Character\n    /// Database][ucd] [`UnicodeData.txt`], the iterator yields that `char`.\n    ///\n    /// [ucd]: https://www.unicode.org/reports/tr44/\n    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n    ///\n    /// If this `char` requires special considerations (e.g. multiple `char`s) the iterator yields\n    /// the `char`(s) given by [`SpecialCasing.txt`].\n    ///\n    /// [`SpecialCasing.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n    ///\n    /// This operation performs an unconditional mapping without tailoring. That is, the conversion\n    /// is independent of context and language.\n    ///\n    /// In the [Unicode Standard], Chapter 4 (Character Properties) discusses case mapping in\n    /// general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.\n    ///\n    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n    ///\n    /// # Examples\n    ///\n    /// As an iterator:\n    ///\n    /// ```\n    /// for c in 'İ'.to_lowercase() {\n    ///     print!(\"{}\", c);\n    /// }\n    /// println!();\n    /// ```\n    ///\n    /// Using `println!` directly:\n    ///\n    /// ```\n    /// println!(\"{}\", 'İ'.to_lowercase());\n    /// ```\n    ///\n    /// Both are equivalent to:\n    ///\n    /// ```\n    /// println!(\"i\\u{307}\");\n    /// ```\n    ///\n    /// Using `to_string`:\n    ///\n    /// ```\n    /// assert_eq!('C'.to_lowercase().to_string(), \"c\");\n    ///\n    /// // Sometimes the result is more than one character:\n    /// assert_eq!('İ'.to_lowercase().to_string(), \"i\\u{307}\");\n    ///\n    /// // Characters that do not have both uppercase and lowercase\n    /// // convert into themselves.\n    /// assert_eq!('山'.to_lowercase().to_string(), \"山\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_lowercase(self) -> ToLowercase {\n}\n\n    /// Returns an iterator that yields the uppercase mapping of this `char` as one or more\n    /// `char`s.\n    ///\n    /// If this `char` does not have a uppercase mapping, the iterator yields the same `char`.\n    ///\n    /// If this `char` has a one-to-one uppercase mapping given by the [Unicode Character\n    /// Database][ucd] [`UnicodeData.txt`], the iterator yields that `char`.\n    ///\n    /// [ucd]: https://www.unicode.org/reports/tr44/\n    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n    ///\n    /// If this `char` requires special considerations (e.g. multiple `char`s) the iterator yields\n    /// the `char`(s) given by [`SpecialCasing.txt`].\n    ///\n    /// [`SpecialCasing.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n    ///\n    /// This operation performs an unconditional mapping without tailoring. That is, the conversion\n    /// is independent of context and language.\n    ///\n    /// In the [Unicode Standard], Chapter 4 (Character Properties) discusses case mapping in\n    /// general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.\n    ///\n    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n    ///\n    /// # Examples\n    ///\n    /// As an iterator:\n    ///\n    /// ```\n    /// for c in 'ß'.to_uppercase() {\n    ///     print!(\"{}\", c);\n    /// }\n    /// println!();\n    /// ```\n    ///\n    /// Using `println!` directly:\n    ///\n    /// ```\n    /// println!(\"{}\", 'ß'.to_uppercase());\n    /// ```\n    ///\n    /// Both are equivalent to:\n    ///\n    /// ```\n    /// println!(\"SS\");\n    /// ```\n    ///\n    /// Using `to_string`:\n    ///\n    /// ```\n    /// assert_eq!('c'.to_uppercase().to_string(), \"C\");\n    ///\n    /// // Sometimes the result is more than one character:\n    /// assert_eq!('ß'.to_uppercase().to_string(), \"SS\");\n    ///\n    /// // Characters that do not have both uppercase and lowercase\n    /// // convert into themselves.\n    /// assert_eq!('山'.to_uppercase().to_string(), \"山\");\n    /// ```\n    ///\n    /// # Note on locale\n    ///\n    /// In Turkish, the equivalent of 'i' in Latin has five forms instead of two:\n    ///\n    /// * 'Dotless': I / ı, sometimes written ï\n    /// * 'Dotted': İ / i\n    ///\n    /// Note that the lowercase dotted 'i' is the same as the Latin. Therefore:\n    ///\n    /// ```\n    /// let upper_i = 'i'.to_uppercase().to_string();\n    /// ```\n    ///\n    /// The value of `upper_i` here relies on the language of the text: if we're\n    /// in `en-US`, it should be `\"I\"`, but if we're in `tr_TR`, it should\n    /// be `\"İ\"`. `to_uppercase()` does not take this into account, and so:\n    ///\n    /// ```\n    /// let upper_i = 'i'.to_uppercase().to_string();\n    ///\n    /// assert_eq!(upper_i, \"I\");\n    /// ```\n    ///\n    /// holds across languages.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_uppercase(self) -> ToUppercase {\n}\n\n    /// Checks if the value is within the ASCII range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let ascii = 'a';\n    /// let non_ascii = '❤';\n    ///\n    /// assert!(ascii.is_ascii());\n    /// assert!(!non_ascii.is_ascii());\n    /// ```\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[rustc_const_stable(feature = \"const_ascii_methods_on_intrinsics\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn is_ascii(&self) -> bool {\n}\n\n    /// Makes a copy of the value in its ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n    ///\n    /// To uppercase ASCII characters in addition to non-ASCII characters, use\n    /// [`to_uppercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let ascii = 'a';\n    /// let non_ascii = '❤';\n    ///\n    /// assert_eq!('A', ascii.to_ascii_uppercase());\n    /// assert_eq!('❤', non_ascii.to_ascii_uppercase());\n    /// ```\n    ///\n    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n    /// [`to_uppercase`]: #method.to_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_uppercase(&self) -> char {\n}\n\n    /// Makes a copy of the value in its ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n    ///\n    /// To lowercase ASCII characters in addition to non-ASCII characters, use\n    /// [`to_lowercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let ascii = 'A';\n    /// let non_ascii = '❤';\n    ///\n    /// assert_eq!('a', ascii.to_ascii_lowercase());\n    /// assert_eq!('❤', non_ascii.to_ascii_lowercase());\n    /// ```\n    ///\n    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n    /// [`to_lowercase`]: #method.to_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_lowercase(&self) -> char {\n}\n\n    /// Checks that two values are an ASCII case-insensitive match.\n    ///\n    /// Equivalent to `to_ascii_lowercase(a) == to_ascii_lowercase(b)`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let upper_a = 'A';\n    /// let lower_a = 'a';\n    /// let lower_z = 'z';\n    ///\n    /// assert!(upper_a.eq_ignore_ascii_case(&lower_a));\n    /// assert!(upper_a.eq_ignore_ascii_case(&upper_a));\n    /// assert!(!upper_a.eq_ignore_ascii_case(&lower_z));\n    /// ```\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn eq_ignore_ascii_case(&self, other: &char) -> bool {\n}\n\n    /// Converts this type to its ASCII upper case equivalent in-place.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new uppercased value without modifying the existing one, use\n    /// [`to_ascii_uppercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut ascii = 'a';\n    ///\n    /// ascii.make_ascii_uppercase();\n    ///\n    /// assert_eq!('A', ascii);\n    /// ```\n    ///\n    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n}\n\n    /// Converts this type to its ASCII lower case equivalent in-place.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new lowercased value without modifying the existing one, use\n    /// [`to_ascii_lowercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut ascii = 'A';\n    ///\n    /// ascii.make_ascii_lowercase();\n    ///\n    /// assert_eq!('a', ascii);\n    /// ```\n    ///\n    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n}\n\n    /// Checks if the value is an ASCII alphabetic character:\n    ///\n    /// - U+0041 'A' ..= U+005A 'Z', or\n    /// - U+0061 'a' ..= U+007A 'z'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 'A';\n    /// let uppercase_g = 'G';\n    /// let a = 'a';\n    /// let g = 'g';\n    /// let zero = '0';\n    /// let percent = '%';\n    /// let space = ' ';\n    /// let lf = '\\n';\n    /// let esc: char = 0x1b_u8.into();\n    ///\n    /// assert!(uppercase_a.is_ascii_alphabetic());\n    /// assert!(uppercase_g.is_ascii_alphabetic());\n    /// assert!(a.is_ascii_alphabetic());\n    /// assert!(g.is_ascii_alphabetic());\n    /// assert!(!zero.is_ascii_alphabetic());\n    /// assert!(!percent.is_ascii_alphabetic());\n    /// assert!(!space.is_ascii_alphabetic());\n    /// assert!(!lf.is_ascii_alphabetic());\n    /// assert!(!esc.is_ascii_alphabetic());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_alphabetic(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII uppercase character:\n    /// U+0041 'A' ..= U+005A 'Z'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 'A';\n    /// let uppercase_g = 'G';\n    /// let a = 'a';\n    /// let g = 'g';\n    /// let zero = '0';\n    /// let percent = '%';\n    /// let space = ' ';\n    /// let lf = '\\n';\n    /// let esc: char = 0x1b_u8.into();\n    ///\n    /// assert!(uppercase_a.is_ascii_uppercase());\n    /// assert!(uppercase_g.is_ascii_uppercase());\n    /// assert!(!a.is_ascii_uppercase());\n    /// assert!(!g.is_ascii_uppercase());\n    /// assert!(!zero.is_ascii_uppercase());\n    /// assert!(!percent.is_ascii_uppercase());\n    /// assert!(!space.is_ascii_uppercase());\n    /// assert!(!lf.is_ascii_uppercase());\n    /// assert!(!esc.is_ascii_uppercase());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_uppercase(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII lowercase character:\n    /// U+0061 'a' ..= U+007A 'z'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 'A';\n    /// let uppercase_g = 'G';\n    /// let a = 'a';\n    /// let g = 'g';\n    /// let zero = '0';\n    /// let percent = '%';\n    /// let space = ' ';\n    /// let lf = '\\n';\n    /// let esc: char = 0x1b_u8.into();\n    ///\n    /// assert!(!uppercase_a.is_ascii_lowercase());\n    /// assert!(!uppercase_g.is_ascii_lowercase());\n    /// assert!(a.is_ascii_lowercase());\n    /// assert!(g.is_ascii_lowercase());\n    /// assert!(!zero.is_ascii_lowercase());\n    /// assert!(!percent.is_ascii_lowercase());\n    /// assert!(!space.is_ascii_lowercase());\n    /// assert!(!lf.is_ascii_lowercase());\n    /// assert!(!esc.is_ascii_lowercase());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_lowercase(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII alphanumeric character:\n    ///\n    /// - U+0041 'A' ..= U+005A 'Z', or\n    /// - U+0061 'a' ..= U+007A 'z', or\n    /// - U+0030 '0' ..= U+0039 '9'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 'A';\n    /// let uppercase_g = 'G';\n    /// let a = 'a';\n    /// let g = 'g';\n    /// let zero = '0';\n    /// let percent = '%';\n    /// let space = ' ';\n    /// let lf = '\\n';\n    /// let esc: char = 0x1b_u8.into();\n    ///\n    /// assert!(uppercase_a.is_ascii_alphanumeric());\n    /// assert!(uppercase_g.is_ascii_alphanumeric());\n    /// assert!(a.is_ascii_alphanumeric());\n    /// assert!(g.is_ascii_alphanumeric());\n    /// assert!(zero.is_ascii_alphanumeric());\n    /// assert!(!percent.is_ascii_alphanumeric());\n    /// assert!(!space.is_ascii_alphanumeric());\n    /// assert!(!lf.is_ascii_alphanumeric());\n    /// assert!(!esc.is_ascii_alphanumeric());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_alphanumeric(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII decimal digit:\n    /// U+0030 '0' ..= U+0039 '9'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 'A';\n    /// let uppercase_g = 'G';\n    /// let a = 'a';\n    /// let g = 'g';\n    /// let zero = '0';\n    /// let percent = '%';\n    /// let space = ' ';\n    /// let lf = '\\n';\n    /// let esc: char = 0x1b_u8.into();\n    ///\n    /// assert!(!uppercase_a.is_ascii_digit());\n    /// assert!(!uppercase_g.is_ascii_digit());\n    /// assert!(!a.is_ascii_digit());\n    /// assert!(!g.is_ascii_digit());\n    /// assert!(zero.is_ascii_digit());\n    /// assert!(!percent.is_ascii_digit());\n    /// assert!(!space.is_ascii_digit());\n    /// assert!(!lf.is_ascii_digit());\n    /// assert!(!esc.is_ascii_digit());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_digit(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII hexadecimal digit:\n    ///\n    /// - U+0030 '0' ..= U+0039 '9', or\n    /// - U+0041 'A' ..= U+0046 'F', or\n    /// - U+0061 'a' ..= U+0066 'f'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 'A';\n    /// let uppercase_g = 'G';\n    /// let a = 'a';\n    /// let g = 'g';\n    /// let zero = '0';\n    /// let percent = '%';\n    /// let space = ' ';\n    /// let lf = '\\n';\n    /// let esc: char = 0x1b_u8.into();\n    ///\n    /// assert!(uppercase_a.is_ascii_hexdigit());\n    /// assert!(!uppercase_g.is_ascii_hexdigit());\n    /// assert!(a.is_ascii_hexdigit());\n    /// assert!(!g.is_ascii_hexdigit());\n    /// assert!(zero.is_ascii_hexdigit());\n    /// assert!(!percent.is_ascii_hexdigit());\n    /// assert!(!space.is_ascii_hexdigit());\n    /// assert!(!lf.is_ascii_hexdigit());\n    /// assert!(!esc.is_ascii_hexdigit());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_hexdigit(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII punctuation character:\n    ///\n    /// - U+0021 ..= U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n    /// - U+003A ..= U+0040 `: ; < = > ? @`, or\n    /// - U+005B ..= U+0060 ``[ \\ ] ^ _ ` ``, or\n    /// - U+007B ..= U+007E `{ | } ~`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 'A';\n    /// let uppercase_g = 'G';\n    /// let a = 'a';\n    /// let g = 'g';\n    /// let zero = '0';\n    /// let percent = '%';\n    /// let space = ' ';\n    /// let lf = '\\n';\n    /// let esc: char = 0x1b_u8.into();\n    ///\n    /// assert!(!uppercase_a.is_ascii_punctuation());\n    /// assert!(!uppercase_g.is_ascii_punctuation());\n    /// assert!(!a.is_ascii_punctuation());\n    /// assert!(!g.is_ascii_punctuation());\n    /// assert!(!zero.is_ascii_punctuation());\n    /// assert!(percent.is_ascii_punctuation());\n    /// assert!(!space.is_ascii_punctuation());\n    /// assert!(!lf.is_ascii_punctuation());\n    /// assert!(!esc.is_ascii_punctuation());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_punctuation(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII graphic character:\n    /// U+0021 '!' ..= U+007E '~'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 'A';\n    /// let uppercase_g = 'G';\n    /// let a = 'a';\n    /// let g = 'g';\n    /// let zero = '0';\n    /// let percent = '%';\n    /// let space = ' ';\n    /// let lf = '\\n';\n    /// let esc: char = 0x1b_u8.into();\n    ///\n    /// assert!(uppercase_a.is_ascii_graphic());\n    /// assert!(uppercase_g.is_ascii_graphic());\n    /// assert!(a.is_ascii_graphic());\n    /// assert!(g.is_ascii_graphic());\n    /// assert!(zero.is_ascii_graphic());\n    /// assert!(percent.is_ascii_graphic());\n    /// assert!(!space.is_ascii_graphic());\n    /// assert!(!lf.is_ascii_graphic());\n    /// assert!(!esc.is_ascii_graphic());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_graphic(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII whitespace character:\n    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n    ///\n    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n    /// whitespace][infra-aw]. There are several other definitions in\n    /// wide use. For instance, [the POSIX locale][pct] includes\n    /// U+000B VERTICAL TAB as well as all the above characters,\n    /// but—from the very same specification—[the default rule for\n    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n    ///\n    /// If you are writing a program that will process an existing\n    /// file format, check what that format's definition of whitespace is\n    /// before using this function.\n    ///\n    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 'A';\n    /// let uppercase_g = 'G';\n    /// let a = 'a';\n    /// let g = 'g';\n    /// let zero = '0';\n    /// let percent = '%';\n    /// let space = ' ';\n    /// let lf = '\\n';\n    /// let esc: char = 0x1b_u8.into();\n    ///\n    /// assert!(!uppercase_a.is_ascii_whitespace());\n    /// assert!(!uppercase_g.is_ascii_whitespace());\n    /// assert!(!a.is_ascii_whitespace());\n    /// assert!(!g.is_ascii_whitespace());\n    /// assert!(!zero.is_ascii_whitespace());\n    /// assert!(!percent.is_ascii_whitespace());\n    /// assert!(space.is_ascii_whitespace());\n    /// assert!(lf.is_ascii_whitespace());\n    /// assert!(!esc.is_ascii_whitespace());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_whitespace(&self) -> bool {\n}\n\n    /// Checks if the value is an ASCII control character:\n    /// U+0000 NUL ..= U+001F UNIT SEPARATOR, or U+007F DELETE.\n    /// Note that most ASCII whitespace characters are control\n    /// characters, but SPACE is not.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let uppercase_a = 'A';\n    /// let uppercase_g = 'G';\n    /// let a = 'a';\n    /// let g = 'g';\n    /// let zero = '0';\n    /// let percent = '%';\n    /// let space = ' ';\n    /// let lf = '\\n';\n    /// let esc: char = 0x1b_u8.into();\n    ///\n    /// assert!(!uppercase_a.is_ascii_control());\n    /// assert!(!uppercase_g.is_ascii_control());\n    /// assert!(!a.is_ascii_control());\n    /// assert!(!g.is_ascii_control());\n    /// assert!(!zero.is_ascii_control());\n    /// assert!(!percent.is_ascii_control());\n    /// assert!(!space.is_ascii_control());\n    /// assert!(lf.is_ascii_control());\n    /// assert!(esc.is_ascii_control());\n    /// ```\n    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n    #[inline]\n    pub fn is_ascii_control(&self) -> bool {\n}\n}\n}\n\n// stable re-exports\n#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\npub use self::convert::from_u32_unchecked;\n#[stable(feature = \"try_from\", since = \"1.34.0\")]\npub use self::convert::CharTryFromError;\n#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\npub use self::convert::ParseCharError;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::convert::{from_digit, from_u32};\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\npub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n\n// unstable re-exports\n#[unstable(feature = \"unicode_version\", issue = \"49726\")]\npub use crate::unicode::version::UnicodeVersion;\n#[unstable(feature = \"unicode_version\", issue = \"49726\")]\npub use crate::unicode::UNICODE_VERSION;\n\nuse crate::fmt::{self, Write};\nuse crate::iter::FusedIterator;\n\n// UTF-8 ranges and tags for encoding characters\nconst TAG_CONT: u8 = 0b1000_0000;\nconst TAG_TWO_B: u8 = 0b1100_0000;\nconst TAG_THREE_B: u8 = 0b1110_0000;\nconst TAG_FOUR_B: u8 = 0b1111_0000;\nconst MAX_ONE_B: u32 = 0x80;\nconst MAX_TWO_B: u32 = 0x800;\nconst MAX_THREE_B: u32 = 0x10000;\n\n/*\n    Lu  Uppercase_Letter        an uppercase letter\n    Ll  Lowercase_Letter        a lowercase letter\n    Lt  Titlecase_Letter        a digraphic character, with first part uppercase\n    Lm  Modifier_Letter         a modifier letter\n    Lo  Other_Letter            other letters, including syllables and ideographs\n    Mn  Nonspacing_Mark         a nonspacing combining mark (zero advance width)\n    Mc  Spacing_Mark            a spacing combining mark (positive advance width)\n    Me  Enclosing_Mark          an enclosing combining mark\n    Nd  Decimal_Number          a decimal digit\n    Nl  Letter_Number           a letterlike numeric character\n    No  Other_Number            a numeric character of other type\n    Pc  Connector_Punctuation   a connecting punctuation mark, like a tie\n    Pd  Dash_Punctuation        a dash or hyphen punctuation mark\n    Ps  Open_Punctuation        an opening punctuation mark (of a pair)\n    Pe  Close_Punctuation       a closing punctuation mark (of a pair)\n    Pi  Initial_Punctuation     an initial quotation mark\n    Pf  Final_Punctuation       a final quotation mark\n    Po  Other_Punctuation       a punctuation mark of other type\n    Sm  Math_Symbol             a symbol of primarily mathematical use\n    Sc  Currency_Symbol         a currency sign\n    Sk  Modifier_Symbol         a non-letterlike modifier symbol\n    So  Other_Symbol            a symbol of other type\n    Zs  Space_Separator         a space character (of various non-zero widths)\n    Zl  Line_Separator          U+2028 LINE SEPARATOR only\n    Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only\n    Cc  Control                 a C0 or C1 control code\n    Cf  Format                  a format control character\n    Cs  Surrogate               a surrogate code point\n    Co  Private_Use             a private-use character\n    Cn  Unassigned              a reserved unassigned code point or a noncharacter\n*/\n\n/// The highest valid code point a `char` can have.\n///\n/// A [`char`] is a [Unicode Scalar Value], which means that it is a [Code\n/// Point], but only ones within a certain range. `MAX` is the highest valid\n/// code point that's a valid [Unicode Scalar Value].\n///\n/// [`char`]: ../../std/primitive.char.html\n/// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n/// [Code Point]: http://www.unicode.org/glossary/#code_point\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub const MAX: char = '\\u{10ffff}';\n\n/// `U+FFFD REPLACEMENT CHARACTER` (�) is used in Unicode to represent a\n/// decoding error.\n///\n/// It can occur, for example, when giving ill-formed UTF-8 bytes to\n/// [`String::from_utf8_lossy`](../../std/string/struct.String.html#method.from_utf8_lossy).\n#[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\npub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';\n\n/// Returns an iterator that yields the hexadecimal Unicode escape of a\n/// character, as `char`s.\n///\n/// This `struct` is created by the [`escape_unicode`] method on [`char`]. See\n/// its documentation for more.\n///\n/// [`escape_unicode`]: ../../std/primitive.char.html#method.escape_unicode\n/// [`char`]: ../../std/primitive.char.html\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct EscapeUnicode {\n    c: char,\n    state: EscapeUnicodeState,\n\n    // The index of the next hex digit to be printed (0 if none),\n    // i.e., the number of remaining hex digits to be printed;\n    // increasing from the least significant digit: 0x543210\n    hex_digit_idx: usize,\n}\n\n// The enum values are ordered so that their representation is the\n// same as the remaining length (besides the hexadecimal digits). This\n// likely makes `len()` a single load from memory) and inline-worth.\n#[derive(Clone, Debug)]\nenum EscapeUnicodeState {\n    Done,\n    RightBrace,\n    Value,\n    LeftBrace,\n    Type,\n    Backslash,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for EscapeUnicode {\n    type Item = char;\n\n    fn next(&mut self) -> Option<char> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn count(self) -> usize {\n}\n\n    fn last(self) -> Option<char> {\n}\n}\n\n#[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\nimpl ExactSizeIterator for EscapeUnicode {\n    #[inline]\n    fn len(&self) -> usize {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for EscapeUnicode {}\n\n#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\nimpl fmt::Display for EscapeUnicode {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// An iterator that yields the literal escape code of a `char`.\n///\n/// This `struct` is created by the [`escape_default`] method on [`char`]. See\n/// its documentation for more.\n///\n/// [`escape_default`]: ../../std/primitive.char.html#method.escape_default\n/// [`char`]: ../../std/primitive.char.html\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct EscapeDefault {\n    state: EscapeDefaultState,\n}\n\n#[derive(Clone, Debug)]\nenum EscapeDefaultState {\n    Done,\n    Char(char),\n    Backslash(char),\n    Unicode(EscapeUnicode),\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for EscapeDefault {\n    type Item = char;\n\n    fn next(&mut self) -> Option<char> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn count(self) -> usize {\n}\n\n    fn nth(&mut self, n: usize) -> Option<char> {\n}\n\n    fn last(self) -> Option<char> {\n}\n}\n\n#[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\nimpl ExactSizeIterator for EscapeDefault {\n    fn len(&self) -> usize {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for EscapeDefault {}\n\n#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\nimpl fmt::Display for EscapeDefault {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// An iterator that yields the literal escape code of a `char`.\n///\n/// This `struct` is created by the [`escape_debug`] method on [`char`]. See its\n/// documentation for more.\n///\n/// [`escape_debug`]: ../../std/primitive.char.html#method.escape_debug\n/// [`char`]: ../../std/primitive.char.html\n#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\n#[derive(Clone, Debug)]\npub struct EscapeDebug(EscapeDefault);\n\n#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\nimpl Iterator for EscapeDebug {\n    type Item = char;\n    fn next(&mut self) -> Option<char> {\n}\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\nimpl ExactSizeIterator for EscapeDebug {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for EscapeDebug {}\n\n#[stable(feature = \"char_escape_debug\", since = \"1.20.0\")]\nimpl fmt::Display for EscapeDebug {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// Returns an iterator that yields the lowercase equivalent of a `char`.\n///\n/// This `struct` is created by the [`to_lowercase`] method on [`char`]. See\n/// its documentation for more.\n///\n/// [`to_lowercase`]: ../../std/primitive.char.html#method.to_lowercase\n/// [`char`]: ../../std/primitive.char.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug, Clone)]\npub struct ToLowercase(CaseMappingIter);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for ToLowercase {\n    type Item = char;\n    fn next(&mut self) -> Option<char> {\n}\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for ToLowercase {}\n\n#[stable(feature = \"exact_size_case_mapping_iter\", since = \"1.35.0\")]\nimpl ExactSizeIterator for ToLowercase {}\n\n/// Returns an iterator that yields the uppercase equivalent of a `char`.\n///\n/// This `struct` is created by the [`to_uppercase`] method on [`char`]. See\n/// its documentation for more.\n///\n/// [`to_uppercase`]: ../../std/primitive.char.html#method.to_uppercase\n/// [`char`]: ../../std/primitive.char.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug, Clone)]\npub struct ToUppercase(CaseMappingIter);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for ToUppercase {\n    type Item = char;\n    fn next(&mut self) -> Option<char> {\n}\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for ToUppercase {}\n\n#[stable(feature = \"exact_size_case_mapping_iter\", since = \"1.35.0\")]\nimpl ExactSizeIterator for ToUppercase {}\n\n#[derive(Debug, Clone)]\nenum CaseMappingIter {\n    Three(char, char, char),\n    Two(char, char),\n    One(char),\n    Zero,\n}\n\nimpl CaseMappingIter {\n    fn new(chars: [char; 3]) -> CaseMappingIter {\n}\n}\n\nimpl Iterator for CaseMappingIter {\n    type Item = char;\n    fn next(&mut self) -> Option<char> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\nimpl fmt::Display for CaseMappingIter {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\nimpl fmt::Display for ToLowercase {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"char_struct_display\", since = \"1.16.0\")]\nimpl fmt::Display for ToUppercase {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n}\npub mod ffi {\n#![stable(feature = \"\", since = \"1.30.0\")]\n#![allow(non_camel_case_types)]\n\n//! Utilities related to FFI bindings.\n\nuse crate::fmt;\nuse crate::marker::PhantomData;\nuse crate::ops::{Deref, DerefMut};\n\n/// Equivalent to C's `void` type when used as a [pointer].\n///\n/// In essence, `*const c_void` is equivalent to C's `const void*`\n/// and `*mut c_void` is equivalent to C's `void*`. That said, this is\n/// *not* the same as C's `void` return type, which is Rust's `()` type.\n///\n/// To model pointers to opaque types in FFI, until `extern type` is\n/// stabilized, it is recommended to use a newtype wrapper around an empty\n/// byte array. See the [Nomicon] for details.\n///\n/// One could use `std::os::raw::c_void` if they want to support old Rust\n/// compiler down to 1.1.0. After Rust 1.30.0, it was re-exported by\n/// this definition. For more information, please read [RFC 2521].\n///\n/// [pointer]: ../../std/primitive.pointer.html\n/// [Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs\n/// [RFC 2521]: https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md\n// N.B., for LLVM to recognize the void pointer type and by extension\n//     functions like malloc(), we need to have it represented as i8* in\n//     LLVM bitcode. The enum used here ensures this and prevents misuse\n//     of the \"raw\" type by only having private variants. We need two\n//     variants, because the compiler complains about the repr attribute\n//     otherwise and we need at least one variant as otherwise the enum\n//     would be uninhabited and at least dereferencing such pointers would\n//     be UB.\n#[repr(u8)]\n#[stable(feature = \"core_c_void\", since = \"1.30.0\")]\npub enum c_void {\n    #[unstable(\n        feature = \"c_void_variant\",\n        reason = \"temporary implementation detail\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    __variant1,\n    #[unstable(\n        feature = \"c_void_variant\",\n        reason = \"temporary implementation detail\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    __variant2,\n}\n\n#[stable(feature = \"std_debug\", since = \"1.16.0\")]\nimpl fmt::Debug for c_void {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// Basic implementation of a `va_list`.\n// The name is WIP, using `VaListImpl` for now.\n#[cfg(any(\n    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n    all(target_arch = \"aarch64\", target_os = \"ios\"),\n    target_arch = \"wasm32\",\n    target_arch = \"asmjs\",\n    windows\n))]\n#[repr(transparent)]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\n#[lang = \"va_list\"]\npub struct VaListImpl<'f> {\n    ptr: *mut c_void,\n\n    // Invariant over `'f`, so each `VaListImpl<'f>` object is tied to\n    // the region of the function it's defined in\n    _marker: PhantomData<&'f mut &'f c_void>,\n}\n\n#[cfg(any(\n    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n    all(target_arch = \"aarch64\", target_os = \"ios\"),\n    target_arch = \"wasm32\",\n    target_arch = \"asmjs\",\n    windows\n))]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'f> fmt::Debug for VaListImpl<'f> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// AArch64 ABI implementation of a `va_list`. See the\n/// [AArch64 Procedure Call Standard] for more details.\n///\n/// [AArch64 Procedure Call Standard]:\n/// http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf\n#[cfg(all(target_arch = \"aarch64\", not(target_os = \"ios\"), not(windows)))]\n#[repr(C)]\n#[derive(Debug)]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\n#[lang = \"va_list\"]\npub struct VaListImpl<'f> {\n    stack: *mut c_void,\n    gr_top: *mut c_void,\n    vr_top: *mut c_void,\n    gr_offs: i32,\n    vr_offs: i32,\n    _marker: PhantomData<&'f mut &'f c_void>,\n}\n\n/// PowerPC ABI implementation of a `va_list`.\n#[cfg(all(target_arch = \"powerpc\", not(windows)))]\n#[repr(C)]\n#[derive(Debug)]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\n#[lang = \"va_list\"]\npub struct VaListImpl<'f> {\n    gpr: u8,\n    fpr: u8,\n    reserved: u16,\n    overflow_arg_area: *mut c_void,\n    reg_save_area: *mut c_void,\n    _marker: PhantomData<&'f mut &'f c_void>,\n}\n\n/// x86_64 ABI implementation of a `va_list`.\n#[cfg(all(target_arch = \"x86_64\", not(windows)))]\n#[repr(C)]\n#[derive(Debug)]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\n#[lang = \"va_list\"]\npub struct VaListImpl<'f> {\n    gp_offset: i32,\n    fp_offset: i32,\n    overflow_arg_area: *mut c_void,\n    reg_save_area: *mut c_void,\n    _marker: PhantomData<&'f mut &'f c_void>,\n}\n\n/// A wrapper for a `va_list`\n#[repr(transparent)]\n#[derive(Debug)]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\npub struct VaList<'a, 'f: 'a> {\n    #[cfg(any(\n        all(\n            not(target_arch = \"aarch64\"),\n            not(target_arch = \"powerpc\"),\n            not(target_arch = \"x86_64\")\n        ),\n        all(target_arch = \"aarch64\", target_os = \"ios\"),\n        target_arch = \"wasm32\",\n        target_arch = \"asmjs\",\n        windows\n    ))]\n    inner: VaListImpl<'f>,\n\n    #[cfg(all(\n        any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n        any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n        not(target_arch = \"wasm32\"),\n        not(target_arch = \"asmjs\"),\n        not(windows)\n    ))]\n    inner: &'a mut VaListImpl<'f>,\n\n    _marker: PhantomData<&'a mut VaListImpl<'f>>,\n}\n\n#[cfg(any(\n    all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"), not(target_arch = \"x86_64\")),\n    all(target_arch = \"aarch64\", target_os = \"ios\"),\n    target_arch = \"wasm32\",\n    target_arch = \"asmjs\",\n    windows\n))]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'f> VaListImpl<'f> {\n    /// Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n    #[inline]\n    pub fn as_va_list<'a>(&'a mut self) -> VaList<'a, 'f> {\n}\n}\n\n#[cfg(all(\n    any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n    any(not(target_arch = \"aarch64\"), not(target_os = \"ios\")),\n    not(target_arch = \"wasm32\"),\n    not(target_arch = \"asmjs\"),\n    not(windows)\n))]\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'f> VaListImpl<'f> {\n    /// Convert a `VaListImpl` into a `VaList` that is binary-compatible with C's `va_list`.\n    #[inline]\n    pub fn as_va_list<'a>(&'a mut self) -> VaList<'a, 'f> {\n}\n}\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'a, 'f: 'a> Deref for VaList<'a, 'f> {\n    type Target = VaListImpl<'f>;\n\n    #[inline]\n    fn deref(&self) -> &VaListImpl<'f> {\n}\n}\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'a, 'f: 'a> DerefMut for VaList<'a, 'f> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut VaListImpl<'f> {\n}\n}\n\n// The VaArgSafe trait needs to be used in public interfaces, however, the trait\n// itself must not be allowed to be used outside this module. Allowing users to\n// implement the trait for a new type (thereby allowing the va_arg intrinsic to\n// be used on a new type) is likely to cause undefined behavior.\n//\n// FIXME(dlrobertson): In order to use the VaArgSafe trait in a public interface\n// but also ensure it cannot be used elsewhere, the trait needs to be public\n// within a private module. Once RFC 2145 has been implemented look into\n// improving this.\nmod sealed_trait {\n    /// Trait which whitelists the allowed types to be used with [VaList::arg]\n    ///\n    /// [VaList::va_arg]: struct.VaList.html#method.arg\n    #[unstable(\n        feature = \"c_variadic\",\n        reason = \"the `c_variadic` feature has not been properly tested on \\\n                  all supported platforms\",\n        issue = \"44930\"\n    )]\n    pub trait VaArgSafe {}\n}\n\nmacro_rules! impl_va_arg_safe {\n    ($($t:ty),+) => {\n        $(\n            #[unstable(feature = \"c_variadic\",\n                       reason = \"the `c_variadic` feature has not been properly tested on \\\n                                 all supported platforms\",\n                       issue = \"44930\")]\n            impl sealed_trait::VaArgSafe for $t {}}\n}\n\nimpl_va_arg_safe! {i8, i16, i32, i64, usize}\nimpl_va_arg_safe! {u8, u16, u32, u64, isize}\nimpl_va_arg_safe! {f64}\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<T> sealed_trait::VaArgSafe for *mut T {}\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<T> sealed_trait::VaArgSafe for *const T {}\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'f> VaListImpl<'f> {\n    /// Advance to the next arg.\n    #[inline]\n    pub unsafe fn arg<T: sealed_trait::VaArgSafe>(&mut self) -> T {\n}\n\n    /// Copies the `va_list` at the current location.\n    pub unsafe fn with_copy<F, R>(&self, f: F) -> R\n    where\n        F: for<'copy> FnOnce(VaList<'copy, 'f>) -> R,\n    {\n}\n}\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'f> Clone for VaListImpl<'f> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[unstable(\n    feature = \"c_variadic\",\n    reason = \"the `c_variadic` feature has not been properly tested on \\\n              all supported platforms\",\n    issue = \"44930\"\n)]\nimpl<'f> Drop for VaListImpl<'f> {\n    fn drop(&mut self) {\n}\n}\n\nextern \"rust-intrinsic\" {\n    /// Destroy the arglist `ap` after initialization with `va_start` or\n    /// `va_copy`.\n    fn va_end(ap: &mut VaListImpl<'_>);\n\n    /// Copies the current location of arglist `src` to the arglist `dst`.\n    fn va_copy<'f>(dest: *mut VaListImpl<'f>, src: &VaListImpl<'f>);\n\n    /// Loads an argument of type `T` from the `va_list` `ap` and increment the\n    /// argument `ap` points to.\n    fn va_arg<T: sealed_trait::VaArgSafe>(ap: &mut VaListImpl<'_>) -> T;\n}\n}\n#[cfg(not(test))] // See #65860\npub mod iter {\n//! Composable external iteration.\n//!\n//! If you've found yourself with a collection of some kind, and needed to\n//! perform an operation on the elements of said collection, you'll quickly run\n//! into 'iterators'. Iterators are heavily used in idiomatic Rust code, so\n//! it's worth becoming familiar with them.\n//!\n//! Before explaining more, let's talk about how this module is structured:\n//!\n//! # Organization\n//!\n//! This module is largely organized by type:\n//!\n//! * [Traits] are the core portion: these traits define what kind of iterators\n//!   exist and what you can do with them. The methods of these traits are worth\n//!   putting some extra study time into.\n//! * [Functions] provide some helpful ways to create some basic iterators.\n//! * [Structs] are often the return types of the various methods on this\n//!   module's traits. You'll usually want to look at the method that creates\n//!   the `struct`, rather than the `struct` itself. For more detail about why,\n//!   see '[Implementing Iterator](#implementing-iterator)'.\n//!\n//! [Traits]: #traits\n//! [Functions]: #functions\n//! [Structs]: #structs\n//!\n//! That's it! Let's dig into iterators.\n//!\n//! # Iterator\n//!\n//! The heart and soul of this module is the [`Iterator`] trait. The core of\n//! [`Iterator`] looks like this:\n//!\n//! ```\n//! trait Iterator {\n//!     type Item;\n//!     fn next(&mut self) -> Option<Self::Item>;\n//! }\n//! ```\n//!\n//! An iterator has a method, [`next`], which when called, returns an\n//! [`Option`]`<Item>`. [`next`] will return `Some(Item)` as long as there\n//! are elements, and once they've all been exhausted, will return `None` to\n//! indicate that iteration is finished. Individual iterators may choose to\n//! resume iteration, and so calling [`next`] again may or may not eventually\n//! start returning `Some(Item)` again at some point.\n//!\n//! [`Iterator`]'s full definition includes a number of other methods as well,\n//! but they are default methods, built on top of [`next`], and so you get\n//! them for free.\n//!\n//! Iterators are also composable, and it's common to chain them together to do\n//! more complex forms of processing. See the [Adapters](#adapters) section\n//! below for more details.\n//!\n//! [`Iterator`]: trait.Iterator.html\n//! [`next`]: trait.Iterator.html#tymethod.next\n//! [`Option`]: ../../std/option/enum.Option.html\n//!\n//! # The three forms of iteration\n//!\n//! There are three common methods which can create iterators from a collection:\n//!\n//! * `iter()`, which iterates over `&T`.\n//! * `iter_mut()`, which iterates over `&mut T`.\n//! * `into_iter()`, which iterates over `T`.\n//!\n//! Various things in the standard library may implement one or more of the\n//! three, where appropriate.\n//!\n//! # Implementing Iterator\n//!\n//! Creating an iterator of your own involves two steps: creating a `struct` to\n//! hold the iterator's state, and then `impl`ementing [`Iterator`] for that\n//! `struct`. This is why there are so many `struct`s in this module: there is\n//! one for each iterator and iterator adapter.\n//!\n//! Let's make an iterator named `Counter` which counts from `1` to `5`:\n//!\n//! ```\n//! // First, the struct:\n//!\n//! /// An iterator which counts from one to five\n//! struct Counter {\n//!     count: usize,\n//! }\n//!\n//! // we want our count to start at one, so let's add a new() method to help.\n//! // This isn't strictly necessary, but is convenient. Note that we start\n//! // `count` at zero, we'll see why in `next()`'s implementation below.\n//! impl Counter {\n//!     fn new() -> Counter {\n//!         Counter { count: 0 }\n//!     }\n//! }\n//!\n//! // Then, we implement `Iterator` for our `Counter`:\n//!\n//! impl Iterator for Counter {\n//!     // we will be counting with usize\n//!     type Item = usize;\n//!\n//!     // next() is the only required method\n//!     fn next(&mut self) -> Option<Self::Item> {\n//!         // Increment our count. This is why we started at zero.\n//!         self.count += 1;\n//!\n//!         // Check to see if we've finished counting or not.\n//!         if self.count < 6 {\n//!             Some(self.count)\n//!         } else {\n//!             None\n//!         }\n//!     }\n//! }\n//!\n//! // And now we can use it!\n//!\n//! let mut counter = Counter::new();\n//!\n//! assert_eq!(counter.next(), Some(1));\n//! assert_eq!(counter.next(), Some(2));\n//! assert_eq!(counter.next(), Some(3));\n//! assert_eq!(counter.next(), Some(4));\n//! assert_eq!(counter.next(), Some(5));\n//! assert_eq!(counter.next(), None);\n//! ```\n//!\n//! Calling [`next`] this way gets repetitive. Rust has a construct which can\n//! call [`next`] on your iterator, until it reaches `None`. Let's go over that\n//! next.\n//!\n//! Also note that `Iterator` provides a default implementation of methods such as `nth` and `fold`\n//! which call `next` internally. However, it is also possible to write a custom implementation of\n//! methods like `nth` and `fold` if an iterator can compute them more efficiently without calling\n//! `next`.\n//!\n//! # for Loops and IntoIterator\n//!\n//! Rust's `for` loop syntax is actually sugar for iterators. Here's a basic\n//! example of `for`:\n//!\n//! ```\n//! let values = vec![1, 2, 3, 4, 5];\n//!\n//! for x in values {\n//!     println!(\"{}\", x);\n//! }\n//! ```\n//!\n//! This will print the numbers one through five, each on their own line. But\n//! you'll notice something here: we never called anything on our vector to\n//! produce an iterator. What gives?\n//!\n//! There's a trait in the standard library for converting something into an\n//! iterator: [`IntoIterator`]. This trait has one method, [`into_iter`],\n//! which converts the thing implementing [`IntoIterator`] into an iterator.\n//! Let's take a look at that `for` loop again, and what the compiler converts\n//! it into:\n//!\n//! [`IntoIterator`]: trait.IntoIterator.html\n//! [`into_iter`]: trait.IntoIterator.html#tymethod.into_iter\n//!\n//! ```\n//! let values = vec![1, 2, 3, 4, 5];\n//!\n//! for x in values {\n//!     println!(\"{}\", x);\n//! }\n//! ```\n//!\n//! Rust de-sugars this into:\n//!\n//! ```\n//! let values = vec![1, 2, 3, 4, 5];\n//! {\n//!     let result = match IntoIterator::into_iter(values) {\n//!         mut iter => loop {\n//!             let next;\n//!             match iter.next() {\n//!                 Some(val) => next = val,\n//!                 None => break,\n//!             };\n//!             let x = next;\n//!             let () = { println!(\"{}\", x); };\n//!         },\n//!     };\n//!     result\n//! }\n//! ```\n//!\n//! First, we call `into_iter()` on the value. Then, we match on the iterator\n//! that returns, calling [`next`] over and over until we see a `None`. At\n//! that point, we `break` out of the loop, and we're done iterating.\n//!\n//! There's one more subtle bit here: the standard library contains an\n//! interesting implementation of [`IntoIterator`]:\n//!\n//! ```ignore (only-for-syntax-highlight)\n//! impl<I: Iterator> IntoIterator for I\n//! ```\n//!\n//! In other words, all [`Iterator`]s implement [`IntoIterator`], by just\n//! returning themselves. This means two things:\n//!\n//! 1. If you're writing an [`Iterator`], you can use it with a `for` loop.\n//! 2. If you're creating a collection, implementing [`IntoIterator`] for it\n//!    will allow your collection to be used with the `for` loop.\n//!\n//! # Adapters\n//!\n//! Functions which take an [`Iterator`] and return another [`Iterator`] are\n//! often called 'iterator adapters', as they're a form of the 'adapter\n//! pattern'.\n//!\n//! Common iterator adapters include [`map`], [`take`], and [`filter`].\n//! For more, see their documentation.\n//!\n//! If an iterator adapter panics, the iterator will be in an unspecified (but\n//! memory safe) state.  This state is also not guaranteed to stay the same\n//! across versions of Rust, so you should avoid relying on the exact values\n//! returned by an iterator which panicked.\n//!\n//! [`map`]: trait.Iterator.html#method.map\n//! [`take`]: trait.Iterator.html#method.take\n//! [`filter`]: trait.Iterator.html#method.filter\n//!\n//! # Laziness\n//!\n//! Iterators (and iterator [adapters](#adapters)) are *lazy*. This means that\n//! just creating an iterator doesn't _do_ a whole lot. Nothing really happens\n//! until you call [`next`]. This is sometimes a source of confusion when\n//! creating an iterator solely for its side effects. For example, the [`map`]\n//! method calls a closure on each element it iterates over:\n//!\n//! ```\n//! # #![allow(unused_must_use)]\n//! let v = vec![1, 2, 3, 4, 5];\n//! v.iter().map(|x| println!(\"{}\", x));\n//! ```\n//!\n//! This will not print any values, as we only created an iterator, rather than\n//! using it. The compiler will warn us about this kind of behavior:\n//!\n//! ```text\n//! warning: unused result that must be used: iterators are lazy and\n//! do nothing unless consumed\n//! ```\n//!\n//! The idiomatic way to write a [`map`] for its side effects is to use a\n//! `for` loop or call the [`for_each`] method:\n//!\n//! ```\n//! let v = vec![1, 2, 3, 4, 5];\n//!\n//! v.iter().for_each(|x| println!(\"{}\", x));\n//! // or\n//! for x in &v {\n//!     println!(\"{}\", x);\n//! }\n//! ```\n//!\n//! [`map`]: trait.Iterator.html#method.map\n//! [`for_each`]: trait.Iterator.html#method.for_each\n//!\n//! Another common way to evaluate an iterator is to use the [`collect`]\n//! method to produce a new collection.\n//!\n//! [`collect`]: trait.Iterator.html#method.collect\n//!\n//! # Infinity\n//!\n//! Iterators do not have to be finite. As an example, an open-ended range is\n//! an infinite iterator:\n//!\n//! ```\n//! let numbers = 0..;\n//! ```\n//!\n//! It is common to use the [`take`] iterator adapter to turn an infinite\n//! iterator into a finite one:\n//!\n//! ```\n//! let numbers = 0..;\n//! let five_numbers = numbers.take(5);\n//!\n//! for number in five_numbers {\n//!     println!(\"{}\", number);\n//! }\n//! ```\n//!\n//! This will print the numbers `0` through `4`, each on their own line.\n//!\n//! Bear in mind that methods on infinite iterators, even those for which a\n//! result can be determined mathematically in finite time, may not terminate.\n//! Specifically, methods such as [`min`], which in the general case require\n//! traversing every element in the iterator, are likely not to return\n//! successfully for any infinite iterators.\n//!\n//! ```no_run\n//! let ones = std::iter::repeat(1);\n//! let least = ones.min().unwrap(); // Oh no! An infinite loop!\n//! // `ones.min()` causes an infinite loop, so we won't reach this point!\n//! println!(\"The smallest number one is {}.\", least);\n//! ```\n//!\n//! [`take`]: trait.Iterator.html#method.take\n//! [`min`]: trait.Iterator.html#method.min\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::ops::Try;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::traits::Iterator;\n\n#[unstable(\n    feature = \"step_trait\",\n    reason = \"likely to be replaced by finer-grained traits\",\n    issue = \"42168\"\n)]\npub use self::range::Step;\n\n#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\npub use self::sources::{empty, Empty};\n#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\npub use self::sources::{from_fn, FromFn};\n#[stable(feature = \"iter_once\", since = \"1.2.0\")]\npub use self::sources::{once, Once};\n#[unstable(feature = \"iter_once_with\", issue = \"57581\")]\npub use self::sources::{o};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::sources::{repeat, Repeat};\n#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\npub use self::sources::{repeat_with, RepeatWith};\n#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\npub use self::sources::{successors, Successors};\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\npub use self::traits::FusedIterator;\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\npub use self::traits::TrustedLen;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::traits::{DoubleEndedIterator, Extend, FromIterator, IntoIterator};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::traits::{ExactSizeIterator, Product, Sum};\n\n#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\npub use self::adapters::Cloned;\n#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\npub use self::adapters::Copied;\n#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\npub use self::adapters::Flatten;\n#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\npub use self::adapters::StepBy;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::adapters::{Chain, Cycle, Enumerate, Filter, FilterMap, Map, Rev, Zip};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::adapters::{FlatMap, Peekable, Scan, Skip, SkipWhile, Take, TakeWhile};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::adapters::{Fuse, Inspect};\n\npub(crate) use self::adapters::{process_results, TrustedRandomAccess};\n\nmod adapters {\nuse crate::cmp;\nuse crate::fmt;\nuse crate::intrinsics;\nuse crate::ops::{Add, AddAssign, Try};\nuse crate::usize;\n\nuse super::{from_fn, LoopState};\nuse super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedLen};\n\nmod chain {\nuse crate::ops::Try;\nuse crate::usize;\n\nuse super::super::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n\n/// An iterator that links two iterators together, in a chain.\n///\n/// This `struct` is created by the [`chain`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`chain`]: trait.Iterator.html#method.chain\n/// [`Iterator`]: trait.Iterator.html\n#[derive(Clone, Debug)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Chain<A, B> {\n    a: A,\n    b: B,\n    state: ChainState,\n}\nimpl<A, B> Chain<A, B> {\n    pub(in super::super) fn new(a: A, b: B) -> Chain<A, B> {\n}\n}\n\n// The iterator protocol specifies that iteration ends with the return value\n// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n// further calls return. The chain adaptor must account for this since it uses\n// two subiterators.\n//\n//  It uses three states:\n//\n//  - Both: `a` and `b` are remaining\n//  - Front: `a` remaining\n//  - Back: `b` remaining\n//\n//  The fourth state (neither iterator is remaining) only occurs after Chain has\n//  returned None once, so we don't need to store this state.\n#[derive(Clone, Debug)]\nenum ChainState {\n    // both front and back iterator are remaining\n    Both,\n    // only front is remaining\n    Front,\n    // only back is remaining\n    Back,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> Iterator for Chain<A, B>\nwhere\n    A: Iterator,\n    B: Iterator<Item = A::Item>,\n{\n    type Item = A::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<A::Item> {\n}\n\n    #[inline]\n    #[rustc_inherit_overflow_checks]\n    fn count(self) -> usize {\n}\n\n    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n    where\n        Self: Sized,\n        F: FnMut(Acc, Self::Item) -> R,\n        R: Try<Ok = Acc>,\n    {\n}\n\n    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n    where\n        F: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n\n    #[inline]\n    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n}\n\n    #[inline]\n    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n    where\n        P: FnMut(&Self::Item) -> bool,\n    {\n}\n\n    #[inline]\n    fn last(self) -> Option<A::Item> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> DoubleEndedIterator for Chain<A, B>\nwhere\n    A: DoubleEndedIterator,\n    B: DoubleEndedIterator<Item = A::Item>,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<A::Item> {\n}\n\n    #[inline]\n    fn nth_back(&mut self, mut n: usize) -> Option<A::Item> {\n}\n\n    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n    where\n        Self: Sized,\n        F: FnMut(Acc, Self::Item) -> R,\n        R: Try<Ok = Acc>,\n    {\n}\n\n    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n    where\n        F: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n}\n\n// Note: *both* must be fused to handle double-ended iterators.\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<A, B> FusedIterator for Chain<A, B>\nwhere\n    A: FusedIterator,\n    B: FusedIterator<Item = A::Item>,\n{\n}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A, B> TrustedLen for Chain<A, B>\nwhere\n    A: TrustedLen,\n    B: TrustedLen<Item = A::Item>,\n{\n}\n}\nmod flatten {\nuse crate::fmt;\nuse crate::ops::Try;\n\nuse super::super::{DoubleEndedIterator, FusedIterator, Iterator};\nuse super::Map;\n\n/// An iterator that maps each element to an iterator, and yields the elements\n/// of the produced iterators.\n///\n/// This `struct` is created by the [`flat_map`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`flat_map`]: trait.Iterator.html#method.flat_map\n/// [`Iterator`]: trait.Iterator.html\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct FlatMap<I, U: IntoIterator, F> {\n    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>,\n}\nimpl<I: Iterator, U: IntoIterator, F: FnMut(I::Item) -> U> FlatMap<I, U, F> {\n    pub(in super::super) fn new(iter: I, f: F) -> FlatMap<I, U, F> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Clone, U, F: Clone> Clone for FlatMap<I, U, F>\nwhere\n    U: Clone + IntoIterator<IntoIter: Clone>,\n{\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<I: fmt::Debug, U, F> fmt::Debug for FlatMap<I, U, F>\nwhere\n    U: IntoIterator<IntoIter: fmt::Debug>,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\nwhere\n    F: FnMut(I::Item) -> U,\n{\n    type Item = U::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<U::Item> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> R,\n        R: Try<Ok = Acc>,\n    {\n}\n\n    #[inline]\n    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\nwhere\n    F: FnMut(I::Item) -> U,\n    U: IntoIterator<IntoIter: DoubleEndedIterator>,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<U::Item> {\n}\n\n    #[inline]\n    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> R,\n        R: Try<Ok = Acc>,\n    {\n}\n\n    #[inline]\n    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<I, U, F> FusedIterator for FlatMap<I, U, F>\nwhere\n    I: FusedIterator,\n    U: IntoIterator,\n    F: FnMut(I::Item) -> U,\n{\n}\n\n/// An iterator that flattens one level of nesting in an iterator of things\n/// that can be turned into iterators.\n///\n/// This `struct` is created by the [`flatten`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`flatten`]: trait.Iterator.html#method.flatten\n/// [`Iterator`]: trait.Iterator.html\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\npub struct Flatten<I: Iterator<Item: IntoIterator>> {\n    inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n}\n\nimpl<I: Iterator<Item: IntoIterator>> Flatten<I> {\n    pub(in super::super) fn new(iter: I) -> Flatten<I> {\n}\n}\n\n#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\nimpl<I, U> fmt::Debug for Flatten<I>\nwhere\n    I: fmt::Debug + Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n    U: fmt::Debug + Iterator,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\nimpl<I, U> Clone for Flatten<I>\nwhere\n    I: Clone + Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n    U: Clone + Iterator,\n{\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\nimpl<I, U> Iterator for Flatten<I>\nwhere\n    I: Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n    U: Iterator,\n{\n    type Item = U::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<U::Item> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> R,\n        R: Try<Ok = Acc>,\n    {\n}\n\n    #[inline]\n    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n}\n\n#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\nimpl<I, U> DoubleEndedIterator for Flatten<I>\nwhere\n    I: DoubleEndedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n    U: DoubleEndedIterator,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<U::Item> {\n}\n\n    #[inline]\n    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> R,\n        R: Try<Ok = Acc>,\n    {\n}\n\n    #[inline]\n    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n}\n\n#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\nimpl<I, U> FusedIterator for Flatten<I>\nwhere\n    I: FusedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n    U: Iterator,\n{\n}\n\n/// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n/// this type.\n#[derive(Clone, Debug)]\nstruct FlattenCompat<I, U> {\n    iter: I,\n    frontiter: Option<U>,\n    backiter: Option<U>,\n}\nimpl<I, U> FlattenCompat<I, U> {\n    /// Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.\n    fn new(iter: I) -> FlattenCompat<I, U> {\n}\n}\n\nimpl<I, U> Iterator for FlattenCompat<I, U>\nwhere\n    I: Iterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n    U: Iterator,\n{\n    type Item = U::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<U::Item> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> R,\n        R: Try<Ok = Acc>,\n    {\n}\n\n    #[inline]\n    fn fold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n}\n\nimpl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\nwhere\n    I: DoubleEndedIterator<Item: IntoIterator<IntoIter = U, Item = U::Item>>,\n    U: DoubleEndedIterator,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<U::Item> {\n}\n\n    #[inline]\n    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> R,\n        R: Try<Ok = Acc>,\n    {\n}\n\n    #[inline]\n    fn rfold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n    where\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n}\n}\nmod zip {\n// ignore-tidy-undocumented-unsafe\n\nuse crate::cmp;\n\nuse super::super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedLen};\n\n/// An iterator that iterates two other iterators simultaneously.\n///\n/// This `struct` is created by the [`zip`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`zip`]: trait.Iterator.html#method.zip\n/// [`Iterator`]: trait.Iterator.html\n#[derive(Clone, Debug)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Zip<A, B> {\n    a: A,\n    b: B,\n    // index and len are only used by the specialized version of zip\n    index: usize,\n    len: usize,\n}\nimpl<A: Iterator, B: Iterator> Zip<A, B> {\n    pub(in super::super) fn new(a: A, b: B) -> Zip<A, B> {\n}\n    fn super_nth(&mut self, mut n: usize) -> Option<(A::Item, B::Item)> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> Iterator for Zip<A, B>\nwhere\n    A: Iterator,\n    B: Iterator,\n{\n    type Item = (A::Item, B::Item);\n\n    #[inline]\n    fn next(&mut self) -> Option<Self::Item> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> DoubleEndedIterator for Zip<A, B>\nwhere\n    A: DoubleEndedIterator + ExactSizeIterator,\n    B: DoubleEndedIterator + ExactSizeIterator,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<(A::Item, B::Item)> {\n}\n}\n\n// Zip specialization trait\n#[doc(hidden)]\ntrait ZipImpl<A, B> {\n    type Item;\n    fn new(a: A, b: B) -> Self;\n    fn next(&mut self) -> Option<Self::Item>;\n    fn size_hint(&self) -> (usize, Option<usize>);\n    fn nth(&mut self, n: usize) -> Option<Self::Item>;\n    fn next_back(&mut self) -> Option<Self::Item>\n    where\n        A: DoubleEndedIterator + ExactSizeIterator,\n        B: DoubleEndedIterator + ExactSizeIterator;\n}\n\n// General Zip impl\n#[doc(hidden)]\nimpl<A, B> ZipImpl<A, B> for Zip<A, B>\nwhere\n    A: Iterator,\n    B: Iterator,\n{\n    type Item = (A::Item, B::Item);\n    default fn new(a: A, b: B) -> Self {\n}\n\n    #[inline]\n    default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n}\n\n    #[inline]\n    default fn nth(&mut self, n: usize) -> Option<Self::Item> {\n}\n\n    #[inline]\n    default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n    where\n        A: DoubleEndedIterator + ExactSizeIterator,\n        B: DoubleEndedIterator + ExactSizeIterator,\n    {\n}\n\n    #[inline]\n    default fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[doc(hidden)]\nimpl<A, B> ZipImpl<A, B> for Zip<A, B>\nwhere\n    A: TrustedRandomAccess,\n    B: TrustedRandomAccess,\n{\n    fn new(a: A, b: B) -> Self {\n}\n\n    #[inline]\n    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n}\n\n    #[inline]\n    fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n    where\n        A: DoubleEndedIterator + ExactSizeIterator,\n        B: DoubleEndedIterator + ExactSizeIterator,\n    {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A, B> ExactSizeIterator for Zip<A, B>\nwhere\n    A: ExactSizeIterator,\n    B: ExactSizeIterator,\n{\n}\n\n#[doc(hidden)]\nunsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\nwhere\n    A: TrustedRandomAccess,\n    B: TrustedRandomAccess,\n{\n    unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n}\n\n    fn may_have_side_effect() -> bool {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<A, B> FusedIterator for Zip<A, B>\nwhere\n    A: FusedIterator,\n    B: FusedIterator,\n{\n}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A, B> TrustedLen for Zip<A, B>\nwhere\n    A: TrustedLen,\n    B: TrustedLen,\n{\n}\n\n/// An iterator whose items are random-accessible efficiently\n///\n/// # Safety\n///\n/// The iterator's .len() and size_hint() must be exact.\n/// `.len()` must be cheap to call.\n///\n/// .get_unchecked() must return distinct mutable references for distinct\n/// indices (if applicable), and must return a valid reference if index is in\n/// 0..self.len().\npub(crate) unsafe trait TrustedRandomAccess: ExactSizeIterator {\n    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n    /// Returns `true` if getting an iterator element may have\n    /// side effects. Remember to take inner iterators into account.\n    fn may_have_side_effect() -> bool;\n}\n}\n\npub use self::chain::Chain;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::flatten::{FlatMap, Flatten};\npub(crate) use self::zip::TrustedRandomAccess;\npub use self::zip::Zip;\n\n/// A double-ended iterator with the direction inverted.\n///\n/// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n/// documentation for more.\n///\n/// [`rev`]: trait.Iterator.html#method.rev\n/// [`Iterator`]: trait.Iterator.html\n#[derive(Clone, Debug)]\n#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Rev<T> {\n    iter: T,\n}\nimpl<T> Rev<T> {\n    pub(super) fn new(iter: T) -> Rev<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> Iterator for Rev<I>\nwhere\n    I: DoubleEndedIterator,\n{\n    type Item = <I as Iterator>::Item;\n\n    #[inline]\n    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n}\n\n    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> R,\n        R: Try<Ok = B>,\n    {\n}\n\n    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n    where\n        F: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n\n    #[inline]\n    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n    where\n        P: FnMut(&Self::Item) -> bool,\n    {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> DoubleEndedIterator for Rev<I>\nwhere\n    I: DoubleEndedIterator,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n}\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n}\n\n    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> R,\n        R: Try<Ok = B>,\n    {\n}\n\n    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n    where\n        F: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n\n    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n    where\n        P: FnMut(&Self::Item) -> bool,\n    {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I> ExactSizeIterator for Rev<I>\nwhere\n    I: ExactSizeIterator + DoubleEndedIterator,\n{\n    fn len(&self) -> usize {\n}\n\n    fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<I> FusedIterator for Rev<I> where I: FusedIterator + DoubleEndedIterator {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<I> TrustedLen for Rev<I> where I: TrustedLen + DoubleEndedIterator {}}\nmod range {\nuse crate::convert::TryFrom;\nuse crate::mem;\nuse crate::ops::{self, Add, Sub, Try};\nuse crate::usize;\n\nuse super::{FusedIterator, TrustedLen};\n\n/// Objects that can be stepped over in both directions.\n///\n/// The `steps_between` function provides a way to efficiently compare\n/// two `Step` objects.\n#[unstable(\n    feature = \"step_trait\",\n    reason = \"likely to be replaced by finer-grained traits\",\n    issue = \"42168\"\n)]\npub trait Step: Clone + PartialOrd + Sized {\n    /// Returns the number of steps between two step objects. The count is\n    /// inclusive of `start` and exclusive of `end`.\n    ///\n    /// Returns `None` if it is not possible to calculate `steps_between`\n    /// without overflow.\n    fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n\n    /// Replaces this step with `1`, returning a clone of itself.\n    ///\n    /// The output of this method should always be greater than the output of replace_zero.\n    fn replace_one(&mut self) -> Self;\n\n    /// Replaces this step with `0`, returning a clone of itself.\n    ///\n    /// The output of this method should always be less than the output of replace_one.\n    fn replace_zero(&mut self) -> Self;\n\n    /// Adds one to this step, returning the result.\n    fn add_one(&self) -> Self;\n\n    /// Subtracts one to this step, returning the result.\n    fn sub_one(&self) -> Self;\n\n    /// Adds a `usize`, returning `None` on overflow.\n    fn add_usize(&self, n: usize) -> Option<Self>;\n\n    /// Subtracts a `usize`, returning `None` on underflow.\n    fn sub_usize(&self, n: usize) -> Option<Self> {\n        // this default implementation makes the addition of `sub_usize` a non-breaking change\n        let _ = n;\n        unimplemented!()\n    }\n}\n\n// These are still macro-generated because the integer literals resolve to different types.\nmacro_rules! step_identical_methods {\n    () => {\n        #[inline]\n        fn replace_one(&mut self) -> Self {\n}\n\n        #[inline]\n        fn replace_zero(&mut self) -> Self {\n}\n\n        #[inline]\n        fn add_one(&self) -> Self {\n}\n\n        #[inline]\n        fn sub_one(&self) -> Self {\n}\n    }\n}\n\nmacro_rules! step_impl_unsigned {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"step_trait\",\n                   reason = \"likely to be replaced by finer-grained traits\",\n                   issue = \"42168\")]\n        impl Step for $t {\n}\n    )*)\n}\nmacro_rules! step_impl_signed {\n    ($( [$t:ty : $unsigned:ty] )*) => ($(\n        #[unstable(feature = \"step_trait\",\n                   reason = \"likely to be replaced by finer-grained traits\",\n                   issue = \"42168\")]\n        impl Step for $t {\n}\n    )*)\n}\n\nstep_impl_unsigned!(usize u8 u16 u32 u64 u128);\nstep_impl_signed!([isize: usize][i8: u8][i16: u16]);\nstep_impl_signed!([i32: u32][i64: u64][i128: u128]);\n\nmacro_rules! range_exact_iter_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl ExactSizeIterator for ops::Range<$t> { }\n    )*)\n}\n\nmacro_rules! range_incl_exact_iter_impl {\n    ($($t:ty)*) => ($(\n        #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n        impl ExactSizeIterator for ops::RangeInclusive<$t> { }\n    )*)\n}\n\nmacro_rules! range_trusted_len_impl {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl TrustedLen for ops::Range<$t> { }\n    )*)\n}\n\nmacro_rules! range_incl_trusted_len_impl {\n    ($($t:ty)*) => ($(\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl TrustedLen for ops::RangeInclusive<$t> { }\n    )*)\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Step> Iterator for ops::Range<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<A> {\n}\n\n    #[inline]\n    fn last(mut self) -> Option<A> {\n}\n\n    #[inline]\n    fn min(mut self) -> Option<A> {\n}\n\n    #[inline]\n    fn max(mut self) -> Option<A> {\n}\n}\n\n// These macros generate `ExactSizeIterator` impls for various range types.\n// Range<{u,i}64> and RangeInclusive<{u,i}{32,64,size}> are excluded\n// because they cannot guarantee having a length <= usize::MAX, which is\n// required by ExactSizeIterator.\nrange_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\nrange_incl_exact_iter_impl!(u8 u16 i8 i16);\n\n// These macros generate `TrustedLen` impls.\n//\n// They need to guarantee that .size_hint() is either exact, or that\n// the upper bound is None when it does not fit the type limits.\nrange_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 u64 i64 u128 i128);\nrange_incl_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 u64 i64 u128 i128);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Step> DoubleEndedIterator for ops::Range<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A> {\n}\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<A> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<A: Step> FusedIterator for ops::Range<A> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Step> Iterator for ops::RangeFrom<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<A> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<A: Step> FusedIterator for ops::RangeFrom<A> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A: Step> TrustedLen for ops::RangeFrom<A> {}}\nmod sources {\nuse crate::fmt;\nuse crate::marker;\nuse crate::usize;\n\nuse super::{FusedIterator, TrustedLen};\n\n/// An iterator that repeats an element endlessly.\n///\n/// This `struct` is created by the [`repeat`] function. See its documentation for more.\n///\n/// [`repeat`]: fn.repeat.html\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Repeat<A> {\n    element: A,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Clone> Iterator for Repeat<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Clone> DoubleEndedIterator for Repeat<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<A: Clone> FusedIterator for Repeat<A> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A: Clone> TrustedLen for Repeat<A> {}}\nmod traits {\nmod accum {\nuse crate::iter;\nuse crate::num::Wrapping;\nuse crate::ops::{Add, Mul};\n\n/// Trait to represent types that can be created by summing up an iterator.\n///\n/// This trait is used to implement the [`sum`] method on iterators. Types which\n/// implement the trait can be generated by the [`sum`] method. Like\n/// [`FromIterator`] this trait should rarely be called directly and instead\n/// interacted with through [`Iterator::sum`].\n///\n/// [`sum`]: ../../std/iter/trait.Sum.html#tymethod.sum\n/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n/// [`Iterator::sum`]: ../../std/iter/trait.Iterator.html#method.sum\n#[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\npub trait Sum<A = Self>: Sized {\n    /// Method which takes an iterator and generates `Self` from the elements by\n    /// \"summing up\" the items.\n    #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n    fn sum<I: Iterator<Item = A>>(iter: I) -> Self;\n}\n\n/// Trait to represent types that can be created by multiplying elements of an\n/// iterator.\n///\n/// This trait is used to implement the [`product`] method on iterators. Types\n/// which implement the trait can be generated by the [`product`] method. Like\n/// [`FromIterator`] this trait should rarely be called directly and instead\n/// interacted with through [`Iterator::product`].\n///\n/// [`product`]: ../../std/iter/trait.Product.html#tymethod.product\n/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n/// [`Iterator::product`]: ../../std/iter/trait.Iterator.html#method.product\n#[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\npub trait Product<A = Self>: Sized {\n    /// Method which takes an iterator and generates `Self` from the elements by\n    /// multiplying the items.\n    #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n    fn product<I: Iterator<Item = A>>(iter: I) -> Self;\n}\n\n// N.B., explicitly use Add and Mul here to inherit overflow checks\nmacro_rules! integer_sum_product {\n    (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n        #[$attr]\n        impl Sum for $a {\n            fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {\n}\n        }\n\n        #[$attr]\n        impl Product for $a {\n            fn product<I: Iterator<Item=Self>>(iter: I) -> Self {\n}\n        }\n\n        #[$attr]\n        impl<'a> Sum<&'a $a> for $a {\n            fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {\n}\n        }\n\n        #[$attr]\n        impl<'a> Product<&'a $a> for $a {\n            fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {\n}\n        }\n    )*);\n    ($($a:ty)*) => (\n        integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*);\n        integer_sum_product!(@impls Wrapping(0), Wrapping(1),\n                #[stable(feature = \"wrapping_iter_arith\", since = \"1.14.0\")],\n                $(Wrapping<$a>)*);\n    );\n}\n\nmacro_rules! float_sum_product {\n    ($($a:ident)*) => ($(\n        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n        impl Sum for $a {\n            fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {\n}\n        }\n\n        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n        impl Product for $a {\n            fn product<I: Iterator<Item=Self>>(iter: I) -> Self {\n}\n        }\n\n        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n        impl<'a> Sum<&'a $a> for $a {\n            fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {\n}\n        }\n\n        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n        impl<'a> Product<&'a $a> for $a {\n            fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {\n}\n        }\n    )*)\n}\n\ninteger_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\nfloat_sum_product! { f32 f64 }\n\n#[stable(feature = \"iter_arith_traits_result\", since = \"1.16.0\")]\nimpl<T, U, E> Sum<Result<U, E>> for Result<T, E>\nwhere\n    T: Sum<U>,\n{\n    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n    /// the sum of all elements is returned.\n    ///\n    /// # Examples\n    ///\n    /// This sums up every integer in a vector, rejecting the sum if a negative\n    /// element is encountered:\n    ///\n    /// ```\n    /// let v = vec![1, 2];\n    /// let res: Result<i32, &'static str> = v.iter().map(|&x: &i32|\n    ///     if x < 0 { Err(\"Negative element found\") }\n    ///     else { Ok(x) }\n    /// ).sum();\n    /// assert_eq!(res, Ok(3));\n    /// ```\n    fn sum<I>(iter: I) -> Result<T, E>\n    where\n        I: Iterator<Item = Result<U, E>>,\n    {\n}\n}\n\n#[stable(feature = \"iter_arith_traits_result\", since = \"1.16.0\")]\nimpl<T, U, E> Product<Result<U, E>> for Result<T, E>\nwhere\n    T: Product<U>,\n{\n    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n    /// the product of all elements is returned.\n    fn product<I>(iter: I) -> Result<T, E>\n    where\n        I: Iterator<Item = Result<U, E>>,\n    {\n}\n}\n\n#[stable(feature = \"iter_arith_traits_option\", since = \"1.37.0\")]\nimpl<T, U> Sum<Option<U>> for Option<T>\nwhere\n    T: Sum<U>,\n{\n    /// Takes each element in the `Iterator`: if it is a `None`, no further\n    /// elements are taken, and the `None` is returned. Should no `None` occur,\n    /// the sum of all elements is returned.\n    ///\n    /// # Examples\n    ///\n    /// This sums up the position of the character 'a' in a vector of strings,\n    /// if a word did not have the character 'a' the operation returns `None`:\n    ///\n    /// ```\n    /// let words = vec![\"have\", \"a\", \"great\", \"day\"];\n    /// let total: Option<usize> = words.iter().map(|w| w.find('a')).sum();\n    /// assert_eq!(total, Some(5));\n    /// ```\n    fn sum<I>(iter: I) -> Option<T>\n    where\n        I: Iterator<Item = Option<U>>,\n    {\n}\n}\n\n#[stable(feature = \"iter_arith_traits_option\", since = \"1.37.0\")]\nimpl<T, U> Product<Option<U>> for Option<T>\nwhere\n    T: Product<U>,\n{\n    /// Takes each element in the `Iterator`: if it is a `None`, no further\n    /// elements are taken, and the `None` is returned. Should no `None` occur,\n    /// the product of all elements is returned.\n    fn product<I>(iter: I) -> Option<T>\n    where\n        I: Iterator<Item = Option<U>>,\n    {\n}\n}\n}\nmod collect {\n/// Conversion from an `Iterator`.\n///\n/// By implementing `FromIterator` for a type, you define how it will be\n/// created from an iterator. This is common for types which describe a\n/// collection of some kind.\n///\n/// `FromIterator`'s [`from_iter`] is rarely called explicitly, and is instead\n/// used through [`Iterator`]'s [`collect`] method. See [`collect`]'s\n/// documentation for more examples.\n///\n/// [`from_iter`]: #tymethod.from_iter\n/// [`Iterator`]: trait.Iterator.html\n/// [`collect`]: trait.Iterator.html#method.collect\n///\n/// See also: [`IntoIterator`].\n///\n/// [`IntoIterator`]: trait.IntoIterator.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::iter::FromIterator;\n///\n/// let five_fives = std::iter::repeat(5).take(5);\n///\n/// let v = Vec::from_iter(five_fives);\n///\n/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n/// ```\n///\n/// Using [`collect`] to implicitly use `FromIterator`:\n///\n/// ```\n/// let five_fives = std::iter::repeat(5).take(5);\n///\n/// let v: Vec<i32> = five_fives.collect();\n///\n/// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n/// ```\n///\n/// Implementing `FromIterator` for your type:\n///\n/// ```\n/// use std::iter::FromIterator;\n///\n/// // A sample collection, that's just a wrapper over Vec<T>\n/// #[derive(Debug)]\n/// struct MyCollection(Vec<i32>);\n///\n/// // Let's give it some methods so we can create one and add things\n/// // to it.\n/// impl MyCollection {\n///     fn new() -> MyCollection {\n///         MyCollection(Vec::new())\n///     }\n///\n///     fn add(&mut self, elem: i32) {\n///         self.0.push(elem);\n///     }\n/// }\n///\n/// // and we'll implement FromIterator\n/// impl FromIterator<i32> for MyCollection {\n///     fn from_iter<I: IntoIterator<Item=i32>>(iter: I) -> Self {\n///         let mut c = MyCollection::new();\n///\n///         for i in iter {\n///             c.add(i);\n///         }\n///\n///         c\n///     }\n/// }\n///\n/// // Now we can make a new iterator...\n/// let iter = (0..5).into_iter();\n///\n/// // ... and make a MyCollection out of it\n/// let c = MyCollection::from_iter(iter);\n///\n/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n///\n/// // collect works too!\n///\n/// let iter = (0..5).into_iter();\n/// let c: MyCollection = iter.collect();\n///\n/// assert_eq!(c.0, vec![0, 1, 2, 3, 4]);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"a value of type `{Self}` cannot be built from an iterator \\\n               over elements of type `{A}`\",\n    label = \"value of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`\"\n)]\npub trait FromIterator<A>: Sized {\n    /// Creates a value from an iterator.\n    ///\n    /// See the [module-level documentation] for more.\n    ///\n    /// [module-level documentation]: index.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::iter::FromIterator;\n    ///\n    /// let five_fives = std::iter::repeat(5).take(5);\n    ///\n    /// let v = Vec::from_iter(five_fives);\n    ///\n    /// assert_eq!(v, vec![5, 5, 5, 5, 5]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> Self;\n}\n\n/// Conversion into an `Iterator`.\n///\n/// By implementing `IntoIterator` for a type, you define how it will be\n/// converted to an iterator. This is common for types which describe a\n/// collection of some kind.\n///\n/// One benefit of implementing `IntoIterator` is that your type will [work\n/// with Rust's `for` loop syntax](index.html#for-loops-and-intoiterator).\n///\n/// See also: [`FromIterator`].\n///\n/// [`FromIterator`]: trait.FromIterator.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let v = vec![1, 2, 3];\n/// let mut iter = v.into_iter();\n///\n/// assert_eq!(Some(1), iter.next());\n/// assert_eq!(Some(2), iter.next());\n/// assert_eq!(Some(3), iter.next());\n/// assert_eq!(None, iter.next());\n/// ```\n/// Implementing `IntoIterator` for your type:\n///\n/// ```\n/// // A sample collection, that's just a wrapper over Vec<T>\n/// #[derive(Debug)]\n/// struct MyCollection(Vec<i32>);\n///\n/// // Let's give it some methods so we can create one and add things\n/// // to it.\n/// impl MyCollection {\n///     fn new() -> MyCollection {\n///         MyCollection(Vec::new())\n///     }\n///\n///     fn add(&mut self, elem: i32) {\n///         self.0.push(elem);\n///     }\n/// }\n///\n/// // and we'll implement IntoIterator\n/// impl IntoIterator for MyCollection {\n///     type Item = i32;\n///     type IntoIter = std::vec::IntoIter<Self::Item>;\n///\n///     fn into_iter(self) -> Self::IntoIter {\n///         self.0.into_iter()\n///     }\n/// }\n///\n/// // Now we can make a new collection...\n/// let mut c = MyCollection::new();\n///\n/// // ... add some stuff to it ...\n/// c.add(0);\n/// c.add(1);\n/// c.add(2);\n///\n/// // ... and then turn it into an Iterator:\n/// for (i, n) in c.into_iter().enumerate() {\n///     assert_eq!(i as i32, n);\n/// }\n/// ```\n///\n/// It is common to use `IntoIterator` as a trait bound. This allows\n/// the input collection type to change, so long as it is still an\n/// iterator. Additional bounds can be specified by restricting on\n/// `Item`:\n///\n/// ```rust\n/// fn collect_as_strings<T>(collection: T) -> Vec<String>\n/// where\n///     T: IntoIterator,\n///     T::Item: std::fmt::Debug,\n/// {\n///     collection\n///         .into_iter()\n///         .map(|item| format!(\"{:?}\", item))\n///         .collect()\n/// }\n/// ```\n#[rustc_diagnostic_item = \"IntoIterator\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait IntoIterator {\n    /// The type of the elements being iterated over.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Item;\n\n    /// Which kind of iterator are we turning this into?\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type IntoIter: Iterator<Item = Self::Item>;\n\n    /// Creates an iterator from a value.\n    ///\n    /// See the [module-level documentation] for more.\n    ///\n    /// [module-level documentation]: index.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let v = vec![1, 2, 3];\n    /// let mut iter = v.into_iter();\n    ///\n    /// assert_eq!(Some(1), iter.next());\n    /// assert_eq!(Some(2), iter.next());\n    /// assert_eq!(Some(3), iter.next());\n    /// assert_eq!(None, iter.next());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn into_iter(self) -> Self::IntoIter;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator> IntoIterator for I {\n    type Item = I::Item;\n    type IntoIter = I;\n\n    fn into_iter(self) -> I {\n}\n}\n\n/// Extend a collection with the contents of an iterator.\n///\n/// Iterators produce a series of values, and collections can also be thought\n/// of as a series of values. The `Extend` trait bridges this gap, allowing you\n/// to extend a collection by including the contents of that iterator. When\n/// extending a collection with an already existing key, that entry is updated\n/// or, in the case of collections that permit multiple entries with equal\n/// keys, that entry is inserted.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // You can extend a String with some chars:\n/// let mut message = String::from(\"The first three letters are: \");\n///\n/// message.extend(&['a', 'b', 'c']);\n///\n/// assert_eq!(\"abc\", &message[29..32]);\n/// ```\n///\n/// Implementing `Extend`:\n///\n/// ```\n/// // A sample collection, that's just a wrapper over Vec<T>\n/// #[derive(Debug)]\n/// struct MyCollection(Vec<i32>);\n///\n/// // Let's give it some methods so we can create one and add things\n/// // to it.\n/// impl MyCollection {\n///     fn new() -> MyCollection {\n///         MyCollection(Vec::new())\n///     }\n///\n///     fn add(&mut self, elem: i32) {\n///         self.0.push(elem);\n///     }\n/// }\n///\n/// // since MyCollection has a list of i32s, we implement Extend for i32\n/// impl Extend<i32> for MyCollection {\n///\n///     // This is a bit simpler with the concrete type signature: we can call\n///     // extend on anything which can be turned into an Iterator which gives\n///     // us i32s. Because we need i32s to put into MyCollection.\n///     fn extend<T: IntoIterator<Item=i32>>(&mut self, iter: T) {\n///\n///         // The implementation is very straightforward: loop through the\n///         // iterator, and add() each element to ourselves.\n///         for elem in iter {\n///             self.add(elem);\n///         }\n///     }\n/// }\n///\n/// let mut c = MyCollection::new();\n///\n/// c.add(5);\n/// c.add(6);\n/// c.add(7);\n///\n/// // let's extend our collection with three more numbers\n/// c.extend(vec![1, 2, 3]);\n///\n/// // we've added these elements onto the end\n/// assert_eq!(\"MyCollection([5, 6, 7, 1, 2, 3])\", format!(\"{:?}\", c));\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Extend<A> {\n    /// Extends a collection with the contents of an iterator.\n    ///\n    /// As this is the only method for this trait, the [trait-level] docs\n    /// contain more details.\n    ///\n    /// [trait-level]: trait.Extend.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // You can extend a String with some chars:\n    /// let mut message = String::from(\"abc\");\n    ///\n    /// message.extend(['d', 'e', 'f'].iter());\n    ///\n    /// assert_eq!(\"abcdef\", &message);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T);\n}\n\n#[stable(feature = \"extend_for_unit\", since = \"1.28.0\")]\nimpl Extend<()> for () {\n    fn extend<T: IntoIterator<Item = ()>>(&mut self, iter: T) {\n}\n}\n}\nmod double_ended {\nuse crate::iter::LoopState;\nuse crate::ops::Try;\n\n/// An iterator able to yield elements from both ends.\n///\n/// Something that implements `DoubleEndedIterator` has one extra capability\n/// over something that implements [`Iterator`]: the ability to also take\n/// `Item`s from the back, as well as the front.\n///\n/// It is important to note that both back and forth work on the same range,\n/// and do not cross: iteration is over when they meet in the middle.\n///\n/// In a similar fashion to the [`Iterator`] protocol, once a\n/// `DoubleEndedIterator` returns `None` from a `next_back()`, calling it again\n/// may or may not ever return `Some` again. `next()` and `next_back()` are\n/// interchangeable for this purpose.\n///\n/// [`Iterator`]: trait.Iterator.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let numbers = vec![1, 2, 3, 4, 5, 6];\n///\n/// let mut iter = numbers.iter();\n///\n/// assert_eq!(Some(&1), iter.next());\n/// assert_eq!(Some(&6), iter.next_back());\n/// assert_eq!(Some(&5), iter.next_back());\n/// assert_eq!(Some(&2), iter.next());\n/// assert_eq!(Some(&3), iter.next());\n/// assert_eq!(Some(&4), iter.next());\n/// assert_eq!(None, iter.next());\n/// assert_eq!(None, iter.next_back());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait DoubleEndedIterator: Iterator {\n    /// Removes and returns an element from the end of the iterator.\n    ///\n    /// Returns `None` when there are no more elements.\n    ///\n    /// The [trait-level] docs contain more details.\n    ///\n    /// [trait-level]: trait.DoubleEndedIterator.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let numbers = vec![1, 2, 3, 4, 5, 6];\n    ///\n    /// let mut iter = numbers.iter();\n    ///\n    /// assert_eq!(Some(&1), iter.next());\n    /// assert_eq!(Some(&6), iter.next_back());\n    /// assert_eq!(Some(&5), iter.next_back());\n    /// assert_eq!(Some(&2), iter.next());\n    /// assert_eq!(Some(&3), iter.next());\n    /// assert_eq!(Some(&4), iter.next());\n    /// assert_eq!(None, iter.next());\n    /// assert_eq!(None, iter.next_back());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn next_back(&mut self) -> Option<Self::Item>;\n\n    /// Returns the `n`th element from the end of the iterator.\n    ///\n    /// This is essentially the reversed version of [`nth`]. Although like most indexing\n    /// operations, the count starts from zero, so `nth_back(0)` returns the first value from\n    /// the end, `nth_back(1)` the second, and so on.\n    ///\n    /// Note that all elements between the end and the returned element will be\n    /// consumed, including the returned element. This also means that calling\n    /// `nth_back(0)` multiple times on the same iterator will return different\n    /// elements.\n    ///\n    /// `nth_back()` will return [`None`] if `n` is greater than or equal to the length of the\n    /// iterator.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    /// [`nth`]: ../../std/iter/trait.Iterator.html#method.nth\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert_eq!(a.iter().nth_back(2), Some(&1));\n    /// ```\n    ///\n    /// Calling `nth_back()` multiple times doesn't rewind the iterator:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter();\n    ///\n    /// assert_eq!(iter.nth_back(1), Some(&2));\n    /// assert_eq!(iter.nth_back(1), None);\n    /// ```\n    ///\n    /// Returning `None` if there are less than `n + 1` elements:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert_eq!(a.iter().nth_back(10), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"iter_nth_back\", since = \"1.37.0\")]\n    fn nth_back(&mut self, mut n: usize) -> Option<Self::Item> {\n        for x in self.rev() {\n            if n == 0 {\n                return Some(x);\n            }\n            n -= 1;\n        }\n        None\n    }\n\n    /// This is the reverse version of [`try_fold()`]: it takes elements\n    /// starting from the back of the iterator.\n    ///\n    /// [`try_fold()`]: trait.Iterator.html#method.try_fold\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [\"1\", \"2\", \"3\"];\n    /// let sum = a.iter()\n    ///     .map(|&s| s.parse::<i32>())\n    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n    /// assert_eq!(sum, Ok(6));\n    /// ```\n    ///\n    /// Short-circuiting:\n    ///\n    /// ```\n    /// let a = [\"1\", \"rust\", \"3\"];\n    /// let mut it = a.iter();\n    /// let sum = it\n    ///     .by_ref()\n    ///     .map(|&s| s.parse::<i32>())\n    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n    /// assert!(sum.is_err());\n    ///\n    /// // Because it short-circuited, the remaining elements are still\n    /// // available through the iterator.\n    /// assert_eq!(it.next_back(), Some(&\"1\"));\n    /// ```\n    #[inline]\n    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> R,\n        R: Try<Ok = B>,\n    {\n}\n\n    /// An iterator method that reduces the iterator's elements to a single,\n    /// final value, starting from the back.\n    ///\n    /// This is the reverse version of [`fold()`]: it takes elements starting from\n    /// the back of the iterator.\n    ///\n    /// `rfold()` takes two arguments: an initial value, and a closure with two\n    /// arguments: an 'accumulator', and an element. The closure returns the value that\n    /// the accumulator should have for the next iteration.\n    ///\n    /// The initial value is the value the accumulator will have on the first\n    /// call.\n    ///\n    /// After applying this closure to every element of the iterator, `rfold()`\n    /// returns the accumulator.\n    ///\n    /// This operation is sometimes called 'reduce' or 'inject'.\n    ///\n    /// Folding is useful whenever you have a collection of something, and want\n    /// to produce a single value from it.\n    ///\n    /// [`fold()`]: trait.Iterator.html#method.fold\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// // the sum of all of the elements of a\n    /// let sum = a.iter()\n    ///            .rfold(0, |acc, &x| acc + x);\n    ///\n    /// assert_eq!(sum, 6);\n    /// ```\n    ///\n    /// This example builds a string, starting with an initial value\n    /// and continuing with each element from the back until the front:\n    ///\n    /// ```\n    /// let numbers = [1, 2, 3, 4, 5];\n    ///\n    /// let zero = \"0\".to_string();\n    ///\n    /// let result = numbers.iter().rfold(zero, |acc, &x| {\n    ///     format!(\"({} + {})\", x, acc)\n    /// });\n    ///\n    /// assert_eq!(result, \"(1 + (2 + (3 + (4 + (5 + 0)))))\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n    fn rfold<B, F>(mut self, accum: B, f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n}\n\n    /// Searches for an element of an iterator from the back that satisfies a predicate.\n    ///\n    /// `rfind()` takes a closure that returns `true` or `false`. It applies\n    /// this closure to each element of the iterator, starting at the end, and if any\n    /// of them return `true`, then `rfind()` returns [`Some(element)`]. If they all return\n    /// `false`, it returns [`None`].\n    ///\n    /// `rfind()` is short-circuiting; in other words, it will stop processing\n    /// as soon as the closure returns `true`.\n    ///\n    /// Because `rfind()` takes a reference, and many iterators iterate over\n    /// references, this leads to a possibly confusing situation where the\n    /// argument is a double reference. You can see this effect in the\n    /// examples below, with `&&x`.\n    ///\n    /// [`Some(element)`]: ../../std/option/enum.Option.html#variant.Some\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// assert_eq!(a.iter().rfind(|&&x| x == 2), Some(&2));\n    ///\n    /// assert_eq!(a.iter().rfind(|&&x| x == 5), None);\n    /// ```\n    ///\n    /// Stopping at the first `true`:\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    ///\n    /// let mut iter = a.iter();\n    ///\n    /// assert_eq!(iter.rfind(|&&x| x == 2), Some(&2));\n    ///\n    /// // we can still use `iter`, as there are more elements.\n    /// assert_eq!(iter.next_back(), Some(&1));\n    /// ```\n    #[inline]\n    #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n    where\n        Self: Sized,\n        P: FnMut(&Self::Item) -> bool,\n    {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n    fn next_back(&mut self) -> Option<I::Item> {\n}\n    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n}\n}\n}\nmod exact_size {\n/// An iterator that knows its exact length.\n///\n/// Many [`Iterator`]s don't know how many times they will iterate, but some do.\n/// If an iterator knows how many times it can iterate, providing access to\n/// that information can be useful. For example, if you want to iterate\n/// backwards, a good start is to know where the end is.\n///\n/// When implementing an `ExactSizeIterator`, you must also implement\n/// [`Iterator`]. When doing so, the implementation of [`size_hint`] *must*\n/// return the exact size of the iterator.\n///\n/// [`Iterator`]: trait.Iterator.html\n/// [`size_hint`]: trait.Iterator.html#method.size_hint\n///\n/// The [`len`] method has a default implementation, so you usually shouldn't\n/// implement it. However, you may be able to provide a more performant\n/// implementation than the default, so overriding it in this case makes sense.\n///\n/// [`len`]: #method.len\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // a finite range knows exactly how many times it will iterate\n/// let five = 0..5;\n///\n/// assert_eq!(5, five.len());\n/// ```\n///\n/// In the [module level docs][moddocs], we implemented an [`Iterator`],\n/// `Counter`. Let's implement `ExactSizeIterator` for it as well:\n///\n/// [moddocs]: index.html\n///\n/// ```\n/// # struct Counter {\n/// #     count: usize,\n/// # }\n/// # impl Counter {\n/// #     fn new() -> Counter {\n/// #         Counter { count: 0 }\n/// #     }\n/// # }\n/// # impl Iterator for Counter {\n/// #     type Item = usize;\n/// #     fn next(&mut self) -> Option<Self::Item> {\n/// #         self.count += 1;\n/// #         if self.count < 6 {\n/// #             Some(self.count)\n/// #         } else {\n/// #             None\n/// #         }\n/// #     }\n/// # }\n/// impl ExactSizeIterator for Counter {\n///     // We can easily calculate the remaining number of iterations.\n///     fn len(&self) -> usize {\n///         5 - self.count\n///     }\n/// }\n///\n/// // And now we can use it!\n///\n/// let counter = Counter::new();\n///\n/// assert_eq!(5, counter.len());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait ExactSizeIterator: Iterator {\n    /// Returns the exact number of times the iterator will iterate.\n    ///\n    /// This method has a default implementation, so you usually should not\n    /// implement it directly. However, if you can provide a more efficient\n    /// implementation, you can do so. See the [trait-level] docs for an\n    /// example.\n    ///\n    /// This function has the same safety guarantees as the [`size_hint`]\n    /// function.\n    ///\n    /// [trait-level]: trait.ExactSizeIterator.html\n    /// [`size_hint`]: trait.Iterator.html#method.size_hint\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // a finite range knows exactly how many times it will iterate\n    /// let five = 0..5;\n    ///\n    /// assert_eq!(5, five.len());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn len(&self) -> usize {\n}\n\n    /// Returns `true` if the iterator is empty.\n    ///\n    /// This method has a default implementation using `self.len()`, so you\n    /// don't need to implement it yourself.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(exact_size_is_empty)]\n    ///\n    /// let mut one_element = std::iter::once(0);\n    /// assert!(!one_element.is_empty());\n    ///\n    /// assert_eq!(one_element.next(), Some(0));\n    /// assert!(one_element.is_empty());\n    ///\n    /// assert_eq!(one_element.next(), None);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"exact_size_is_empty\", issue = \"35428\")]\n    fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for &mut I {\n    fn len(&self) -> usize {\n}\n    fn is_empty(&self) -> bool {\n}\n}\n}\nmod iterator {\n// ignore-tidy-filelength\n\nuse crate::cmp::{self, Ordering};\nuse crate::ops::{Add, Try};\n\nuse super::super::LoopState;\nuse super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\nuse super::super::{FlatMap, Flatten};\nuse super::super::{FromIterator, Product, Sum, Zip};\nuse super::super::{Inspect, Map, Peekable, Rev, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile};\n\nfn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}}\nmod marker {\n/// An iterator that always continues to yield `None` when exhausted.\n///\n/// Calling next on a fused iterator that has returned `None` once is guaranteed\n/// to return [`None`] again. This trait should be implemented by all iterators\n/// that behave this way because it allows optimizing [`Iterator::fuse`].\n///\n/// Note: In general, you should not use `FusedIterator` in generic bounds if\n/// you need a fused iterator. Instead, you should just call [`Iterator::fuse`]\n/// on the iterator. If the iterator is already fused, the additional [`Fuse`]\n/// wrapper will be a no-op with no performance penalty.\n///\n/// [`None`]: ../../std/option/enum.Option.html#variant.None\n/// [`Iterator::fuse`]: ../../std/iter/trait.Iterator.html#method.fuse\n/// [`Fuse`]: ../../std/iter/struct.Fuse.html\n#[stable(feature = \"fused\", since = \"1.26.0\")]\npub trait FusedIterator: Iterator {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<I: FusedIterator + ?Sized> FusedIterator for &mut I {}\n\n/// An iterator that reports an accurate length using size_hint.\n///\n/// The iterator reports a size hint where it is either exact\n/// (lower bound is equal to upper bound), or the upper bound is [`None`].\n/// The upper bound must only be [`None`] if the actual iterator length is\n/// larger than [`usize::MAX`]. In that case, the lower bound must be\n/// [`usize::MAX`], resulting in a [`.size_hint`] of `(usize::MAX, None)`.\n///\n/// The iterator must produce exactly the number of elements it reported\n/// or diverge before reaching the end.\n///\n/// # Safety\n///\n/// This trait must only be implemented when the contract is upheld.\n/// Consumers of this trait must inspect [`.size_hint`]’s upper bound.\n///\n/// [`None`]: ../../std/option/enum.Option.html#variant.None\n/// [`usize::MAX`]: ../../std/usize/constant.MAX.html\n/// [`.size_hint`]: ../../std/iter/trait.Iterator.html#method.size_hint\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\npub unsafe trait TrustedLen: Iterator {}}\n\npub use self::accum::{Product, Sum};\npub use self::collect::{Extend, FromIterator, IntoIterator};\npub use self::double_ended::DoubleEndedIterator;\npub use self::exact_size::ExactSizeIterator;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::iterator::Iterator;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::marker::{FusedIterator, TrustedLen};\n}\n\n/// Used to make try_fold closures more like normal loops\n#[derive(PartialEq)]\nenum LoopState<C, B> {\n    Continue(C),\n    Break(B),\n}\n\nimpl<C, B> Try for LoopState<C, B> {\n    type Ok = C;\n    type Error = B;\n    #[inline]\n    fn into_result(self) -> Result<Self::Ok, Self::Error> {\n}\n    #[inline]\n    fn from_error(v: Self::Error) -> Self {\n}\n    #[inline]\n    fn from_ok(v: Self::Ok) -> Self {\n}\n}\n\nimpl<C, B> LoopState<C, B> {\n    #[inline]\n    fn break_value(self) -> Option<B> {\n}\n}\n\nimpl<R: Try> LoopState<R::Ok, R> {\n    #[inline]\n    fn from_try(r: R) -> Self {\n}\n    #[inline]\n    fn into_try(self) -> R {\n}\n}\n}\npub mod option {\n//! Optional values.\n//!\n//! Type [`Option`] represents an optional value: every [`Option`]\n//! is either [`Some`] and contains a value, or [`None`], and\n//! does not. [`Option`] types are very common in Rust code, as\n//! they have a number of uses:\n//!\n//! * Initial values\n//! * Return values for functions that are not defined\n//!   over their entire input range (partial functions)\n//! * Return value for otherwise reporting simple errors, where [`None`] is\n//!   returned on error\n//! * Optional struct fields\n//! * Struct fields that can be loaned or \"taken\"\n//! * Optional function arguments\n//! * Nullable pointers\n//! * Swapping things out of difficult situations\n//!\n//! [`Option`]s are commonly paired with pattern matching to query the presence\n//! of a value and take action, always accounting for the [`None`] case.\n//!\n//! ```\n//! fn divide(numerator: f64, denominator: f64) -> Option<f64> {\n//!     if denominator == 0.0 {\n//!         None\n//!     } else {\n//!         Some(numerator / denominator)\n//!     }\n//! }\n//!\n//! // The return value of the function is an option\n//! let result = divide(2.0, 3.0);\n//!\n//! // Pattern match to retrieve the value\n//! match result {\n//!     // The division was valid\n//!     Some(x) => println!(\"Result: {}\", x),\n//!     // The division was invalid\n//!     None    => println!(\"Cannot divide by 0\"),\n//! }\n//! ```\n//!\n//\n// FIXME: Show how `Option` is used in practice, with lots of methods\n//\n//! # Options and pointers (\"nullable\" pointers)\n//!\n//! Rust's pointer types must always point to a valid location; there are\n//! no \"null\" references. Instead, Rust has *optional* pointers, like\n//! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n//!\n//! The following example uses [`Option`] to create an optional box of\n//! [`i32`]. Notice that in order to use the inner [`i32`] value first, the\n//! `check_optional` function needs to use pattern matching to\n//! determine whether the box has a value (i.e., it is [`Some(...)`][`Some`]) or\n//! not ([`None`]).\n//!\n//! ```\n//! let optional = None;\n//! check_optional(optional);\n//!\n//! let optional = Some(Box::new(9000));\n//! check_optional(optional);\n//!\n//! fn check_optional(optional: Option<Box<i32>>) {\n//!     match optional {\n//!         Some(p) => println!(\"has value {}\", p),\n//!         None => println!(\"has no value\"),\n//!     }\n//! }\n//! ```\n//!\n//! This usage of [`Option`] to create safe nullable pointers is so\n//! common that Rust does special optimizations to make the\n//! representation of [`Option`]`<`[`Box<T>`]`>` a single pointer. Optional pointers\n//! in Rust are stored as efficiently as any other pointer type.\n//!\n//! # Examples\n//!\n//! Basic pattern matching on [`Option`]:\n//!\n//! ```\n//! let msg = Some(\"howdy\");\n//!\n//! // Take a reference to the contained string\n//! if let Some(m) = &msg {\n//!     println!(\"{}\", *m);\n//! }\n//!\n//! // Remove the contained string, destroying the Option\n//! let unwrapped_msg = msg.unwrap_or(\"default message\");\n//! ```\n//!\n//! Initialize a result to [`None`] before a loop:\n//!\n//! ```\n//! enum Kingdom { Plant(u32, &'static str), Animal(u32, &'static str) }\n//!\n//! // A list of data to search through.\n//! let all_the_big_things = [\n//!     Kingdom::Plant(250, \"redwood\"),\n//!     Kingdom::Plant(230, \"noble fir\"),\n//!     Kingdom::Plant(229, \"sugar pine\"),\n//!     Kingdom::Animal(25, \"blue whale\"),\n//!     Kingdom::Animal(19, \"fin whale\"),\n//!     Kingdom::Animal(15, \"north pacific right whale\"),\n//! ];\n//!\n//! // We're going to search for the name of the biggest animal,\n//! // but to start with we've just got `None`.\n//! let mut name_of_biggest_animal = None;\n//! let mut size_of_biggest_animal = 0;\n//! for big_thing in &all_the_big_things {\n//!     match *big_thing {\n//!         Kingdom::Animal(size, name) if size > size_of_biggest_animal => {\n//!             // Now we've found the name of some big animal\n//!             size_of_biggest_animal = size;\n//!             name_of_biggest_animal = Some(name);\n//!         }\n//!         Kingdom::Animal(..) | Kingdom::Plant(..) => ()\n//!     }\n//! }\n//!\n//! match name_of_biggest_animal {\n//!     Some(name) => println!(\"the biggest animal is {}\", name),\n//!     None => println!(\"there are no animals :(\"),\n//! }\n//! ```\n//!\n//! [`Option`]: enum.Option.html\n//! [`Some`]: enum.Option.html#variant.Some\n//! [`None`]: enum.Option.html#variant.None\n//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n//! [`i32`]: ../../std/primitive.i32.html\n\n// ignore-tidy-undocumented-unsafe\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::iter::{FromIterator, FusedIterator, TrustedLen};\nuse crate::pin::Pin;\nuse crate::{\n    convert, fmt, hint, mem,\n    ops::{self, Deref, DerefMut},\n};\n\n// Note that this is not a lang item per se, but it has a hidden dependency on\n// `Iterator`, which is one. The compiler assumes that the `next` method of\n// `Iterator` is an enumeration with one type parameter and two variants,\n// which basically means it must be `Option`.\n\n/// The `Option` type. See [the module level documentation](index.html) for more.\n#[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n#[rustc_diagnostic_item = \"option_type\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Option<T> {\n    /// No value\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    None,\n    /// Some value `T`\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Type implementation\n/////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Option<T> {\n    /////////////////////////////////////////////////////////////////////////\n    // Querying the contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns `true` if the option is a [`Some`] value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x: Option<u32> = Some(2);\n    /// assert_eq!(x.is_some(), true);\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.is_some(), false);\n    /// ```\n    ///\n    /// [`Some`]: #variant.Some\n    #[must_use = \"if you intended to assert that this has a value, consider `.unwrap()` instead\"]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_some(&self) -> bool {\n}\n\n    /// Returns `true` if the option is a [`None`] value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x: Option<u32> = Some(2);\n    /// assert_eq!(x.is_none(), false);\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.is_none(), true);\n    /// ```\n    ///\n    /// [`None`]: #variant.None\n    #[must_use = \"if you intended to assert that this doesn't have a value, consider \\\n                  `.and_then(|| panic!(\\\"`Option` had a value when expected `None`\\\"))` instead\"]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_none(&self) -> bool {\n}\n\n    /// Returns `true` if the option is a [`Some`] value containing the given value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(option_result_contains)]\n    ///\n    /// let x: Option<u32> = Some(2);\n    /// assert_eq!(x.contains(&2), true);\n    ///\n    /// let x: Option<u32> = Some(3);\n    /// assert_eq!(x.contains(&2), false);\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.contains(&2), false);\n    /// ```\n    #[must_use]\n    #[inline]\n    #[unstable(feature = \"option_result_contains\", issue = \"62358\")]\n    pub fn contains<U>(&self, x: &U) -> bool\n    where\n        U: PartialEq<T>,\n    {\n}\n\n    /////////////////////////////////////////////////////////////////////////\n    // Adapter for working with references\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Converts from `&Option<T>` to `Option<&T>`.\n    ///\n    /// # Examples\n    ///\n    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n    /// The [`map`] method takes the `self` argument by value, consuming the original,\n    /// so this technique uses `as_ref` to first take an `Option` to a reference\n    /// to the value inside the original.\n    ///\n    /// [`map`]: enum.Option.html#method.map\n    /// [`String`]: ../../std/string/struct.String.html\n    /// [`usize`]: ../../std/primitive.usize.html\n    ///\n    /// ```\n    /// let text: Option<String> = Some(\"Hello, world!\".to_string());\n    /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n    /// // then consume *that* with `map`, leaving `text` on the stack.\n    /// let text_length: Option<usize> = text.as_ref().map(|s| s.len());\n    /// println!(\"still can print text: {:?}\", text);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_ref(&self) -> Option<&T> {\n}\n\n    /// Converts from `&mut Option<T>` to `Option<&mut T>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(2);\n    /// match x.as_mut() {\n    ///     Some(v) => *v = 42,\n    ///     None => {},\n    /// }\n    /// assert_eq!(x, Some(42));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_mut(&mut self) -> Option<&mut T> {\n}\n\n    /// Converts from [`Pin`]`<&Option<T>>` to `Option<`[`Pin`]`<&T>>`.\n    ///\n    /// [`Pin`]: ../pin/struct.Pin.html\n    #[inline]\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    pub fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {\n}\n\n    /// Converts from [`Pin`]`<&mut Option<T>>` to `Option<`[`Pin`]`<&mut T>>`.\n    ///\n    /// [`Pin`]: ../pin/struct.Pin.html\n    #[inline]\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    pub fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {\n}\n\n    /////////////////////////////////////////////////////////////////////////\n    // Getting to contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Unwraps an option, yielding the content of a [`Some`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is a [`None`] with a custom panic message provided by\n    /// `msg`.\n    ///\n    /// [`Some`]: #variant.Some\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"value\");\n    /// assert_eq!(x.expect(\"the world is ending\"), \"value\");\n    /// ```\n    ///\n    /// ```{.should_panic}\n    /// let x: Option<&str> = None;\n    /// x.expect(\"the world is ending\"); // panics with `the world is ending`\n    /// ```\n    #[inline]\n    #[track_caller]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn expect(self, msg: &str) -> T {\n}\n\n    /// Moves the value `v` out of the `Option<T>` if it is [`Some(v)`].\n    ///\n    /// In general, because this function may panic, its use is discouraged.\n    /// Instead, prefer to use pattern matching and handle the [`None`]\n    /// case explicitly.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the self value equals [`None`].\n    ///\n    /// [`Some(v)`]: #variant.Some\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"air\");\n    /// assert_eq!(x.unwrap(), \"air\");\n    /// ```\n    ///\n    /// ```{.should_panic}\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.unwrap(), \"air\"); // fails\n    /// ```\n    #[inline]\n    #[track_caller]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap(self) -> T {\n}\n\n    /// Returns the contained value or a default.\n    ///\n    /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n    /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n    /// which is lazily evaluated.\n    ///\n    /// [`unwrap_or_else`]: #method.unwrap_or_else\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n    /// assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or(self, default: T) -> T {\n}\n\n    /// Returns the contained value or computes it from a closure.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let k = 10;\n    /// assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n    /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n}\n\n    /////////////////////////////////////////////////////////////////////////\n    // Transforming contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n    ///\n    /// # Examples\n    ///\n    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    /// [`usize`]: ../../std/primitive.usize.html\n    ///\n    /// ```\n    /// let maybe_some_string = Some(String::from(\"Hello, World!\"));\n    /// // `Option::map` takes self *by value*, consuming `maybe_some_string`\n    /// let maybe_some_len = maybe_some_string.map(|s| s.len());\n    ///\n    /// assert_eq!(maybe_some_len, Some(13));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n}\n\n    /// Applies a function to the contained value (if any),\n    /// or returns the provided default (if not).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.map_or(42, |v| v.len()), 3);\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.map_or(42, |v| v.len()), 42);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {\n}\n\n    /// Applies a function to the contained value (if any),\n    /// or computes a default (if not).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let k = 21;\n    ///\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3);\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U {\n}\n\n    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n    /// [`Ok(v)`] and [`None`] to [`Err(err)`].\n    ///\n    /// Arguments passed to `ok_or` are eagerly evaluated; if you are passing the\n    /// result of a function call, it is recommended to use [`ok_or_else`], which is\n    /// lazily evaluated.\n    ///\n    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`Err(err)`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`None`]: #variant.None\n    /// [`Some(v)`]: #variant.Some\n    /// [`ok_or_else`]: #method.ok_or_else\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.ok_or(0), Ok(\"foo\"));\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.ok_or(0), Err(0));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ok_or<E>(self, err: E) -> Result<T, E> {\n}\n\n    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n    /// [`Ok(v)`] and [`None`] to [`Err(err())`].\n    ///\n    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`Err(err())`]: ../../std/result/enum.Result.html#variant.Err\n    /// [`None`]: #variant.None\n    /// [`Some(v)`]: #variant.Some\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"foo\");\n    /// assert_eq!(x.ok_or_else(|| 0), Ok(\"foo\"));\n    ///\n    /// let x: Option<&str> = None;\n    /// assert_eq!(x.ok_or_else(|| 0), Err(0));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {\n}\n\n    /////////////////////////////////////////////////////////////////////////\n    // Iterator constructors\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns an iterator over the possibly contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(4);\n    /// assert_eq!(x.iter().next(), Some(&4));\n    ///\n    /// let x: Option<u32> = None;\n    /// assert_eq!(x.iter().next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, T> {\n}\n\n    /// Returns a mutable iterator over the possibly contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(4);\n    /// match x.iter_mut().next() {\n    ///     Some(v) => *v = 42,\n    ///     None => {},\n    /// }\n    /// assert_eq!(x, Some(42));\n    ///\n    /// let mut x: Option<u32> = None;\n    /// assert_eq!(x.iter_mut().next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n}\n\n    /////////////////////////////////////////////////////////////////////////\n    // Boolean operations on the values, eager and lazy\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns [`None`] if the option is [`None`], otherwise returns `optb`.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(2);\n    /// let y: Option<&str> = None;\n    /// assert_eq!(x.and(y), None);\n    ///\n    /// let x: Option<u32> = None;\n    /// let y = Some(\"foo\");\n    /// assert_eq!(x.and(y), None);\n    ///\n    /// let x = Some(2);\n    /// let y = Some(\"foo\");\n    /// assert_eq!(x.and(y), Some(\"foo\"));\n    ///\n    /// let x: Option<u32> = None;\n    /// let y: Option<&str> = None;\n    /// assert_eq!(x.and(y), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n}\n\n    /// Returns [`None`] if the option is [`None`], otherwise calls `f` with the\n    /// wrapped value and returns the result.\n    ///\n    /// Some languages call this operation flatmap.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// fn sq(x: u32) -> Option<u32> { Some(x * x) }\n    /// fn nope(_: u32) -> Option<u32> { None }\n    ///\n    /// assert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\n    /// assert_eq!(Some(2).and_then(sq).and_then(nope), None);\n    /// assert_eq!(Some(2).and_then(nope).and_then(sq), None);\n    /// assert_eq!(None.and_then(sq).and_then(sq), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n}\n\n    /// Returns [`None`] if the option is [`None`], otherwise calls `predicate`\n    /// with the wrapped value and returns:\n    ///\n    /// - [`Some(t)`] if `predicate` returns `true` (where `t` is the wrapped\n    ///   value), and\n    /// - [`None`] if `predicate` returns `false`.\n    ///\n    /// This function works similar to [`Iterator::filter()`]. You can imagine\n    /// the `Option<T>` being an iterator over one or zero elements. `filter()`\n    /// lets you decide which elements to keep.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// fn is_even(n: &i32) -> bool {\n    ///     n % 2 == 0\n    /// }\n    ///\n    /// assert_eq!(None.filter(is_even), None);\n    /// assert_eq!(Some(3).filter(is_even), None);\n    /// assert_eq!(Some(4).filter(is_even), Some(4));\n    /// ```\n    ///\n    /// [`None`]: #variant.None\n    /// [`Some(t)`]: #variant.Some\n    /// [`Iterator::filter()`]: ../../std/iter/trait.Iterator.html#method.filter\n    #[inline]\n    #[stable(feature = \"option_filter\", since = \"1.27.0\")]\n    pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {\n}\n\n    /// Returns the option if it contains a value, otherwise returns `optb`.\n    ///\n    /// Arguments passed to `or` are eagerly evaluated; if you are passing the\n    /// result of a function call, it is recommended to use [`or_else`], which is\n    /// lazily evaluated.\n    ///\n    /// [`or_else`]: #method.or_else\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(2);\n    /// let y = None;\n    /// assert_eq!(x.or(y), Some(2));\n    ///\n    /// let x = None;\n    /// let y = Some(100);\n    /// assert_eq!(x.or(y), Some(100));\n    ///\n    /// let x = Some(2);\n    /// let y = Some(100);\n    /// assert_eq!(x.or(y), Some(2));\n    ///\n    /// let x: Option<u32> = None;\n    /// let y = None;\n    /// assert_eq!(x.or(y), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or(self, optb: Option<T>) -> Option<T> {\n}\n\n    /// Returns the option if it contains a value, otherwise calls `f` and\n    /// returns the result.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// fn nobody() -> Option<&'static str> { None }\n    /// fn vikings() -> Option<&'static str> { Some(\"vikings\") }\n    ///\n    /// assert_eq!(Some(\"barbarians\").or_else(vikings), Some(\"barbarians\"));\n    /// assert_eq!(None.or_else(vikings), Some(\"vikings\"));\n    /// assert_eq!(None.or_else(nobody), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n}\n\n    /// Returns [`Some`] if exactly one of `self`, `optb` is [`Some`], otherwise returns [`None`].\n    ///\n    /// [`Some`]: #variant.Some\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(2);\n    /// let y: Option<u32> = None;\n    /// assert_eq!(x.xor(y), Some(2));\n    ///\n    /// let x: Option<u32> = None;\n    /// let y = Some(2);\n    /// assert_eq!(x.xor(y), Some(2));\n    ///\n    /// let x = Some(2);\n    /// let y = Some(2);\n    /// assert_eq!(x.xor(y), None);\n    ///\n    /// let x: Option<u32> = None;\n    /// let y: Option<u32> = None;\n    /// assert_eq!(x.xor(y), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"option_xor\", since = \"1.37.0\")]\n    pub fn xor(self, optb: Option<T>) -> Option<T> {\n}\n\n    /////////////////////////////////////////////////////////////////////////\n    // Entry-like operations to insert if None and return a reference\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Inserts `v` into the option if it is [`None`], then\n    /// returns a mutable reference to the contained value.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = None;\n    ///\n    /// {\n    ///     let y: &mut u32 = x.get_or_insert(5);\n    ///     assert_eq!(y, &5);\n    ///\n    ///     *y = 7;\n    /// }\n    ///\n    /// assert_eq!(x, Some(7));\n    /// ```\n    #[inline]\n    #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n    pub fn get_or_insert(&mut self, v: T) -> &mut T {\n}\n\n    /// Inserts a value computed from `f` into the option if it is [`None`], then\n    /// returns a mutable reference to the contained value.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = None;\n    ///\n    /// {\n    ///     let y: &mut u32 = x.get_or_insert_with(|| 5);\n    ///     assert_eq!(y, &5);\n    ///\n    ///     *y = 7;\n    /// }\n    ///\n    /// assert_eq!(x, Some(7));\n    /// ```\n    #[inline]\n    #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n    pub fn get_or_insert_with<F: FnOnce() -> T>(&mut self, f: F) -> &mut T {\n}\n\n    /////////////////////////////////////////////////////////////////////////\n    // Misc\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Takes the value out of the option, leaving a [`None`] in its place.\n    ///\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(2);\n    /// let y = x.take();\n    /// assert_eq!(x, None);\n    /// assert_eq!(y, Some(2));\n    ///\n    /// let mut x: Option<u32> = None;\n    /// let y = x.take();\n    /// assert_eq!(x, None);\n    /// assert_eq!(y, None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn take(&mut self) -> Option<T> {\n}\n\n    /// Replaces the actual value in the option by the value given in parameter,\n    /// returning the old value if present,\n    /// leaving a [`Some`] in its place without deinitializing either one.\n    ///\n    /// [`Some`]: #variant.Some\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = Some(2);\n    /// let old = x.replace(5);\n    /// assert_eq!(x, Some(5));\n    /// assert_eq!(old, Some(2));\n    ///\n    /// let mut x = None;\n    /// let old = x.replace(3);\n    /// assert_eq!(x, Some(3));\n    /// assert_eq!(old, None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"option_replace\", since = \"1.31.0\")]\n    pub fn replace(&mut self, value: T) -> Option<T> {\n}\n}\n\nimpl<T: Copy> Option<&T> {\n    /// Maps an `Option<&T>` to an `Option<T>` by copying the contents of the\n    /// option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 12;\n    /// let opt_x = Some(&x);\n    /// assert_eq!(opt_x, Some(&12));\n    /// let copied = opt_x.copied();\n    /// assert_eq!(copied, Some(12));\n    /// ```\n    #[stable(feature = \"copied\", since = \"1.35.0\")]\n    pub fn copied(self) -> Option<T> {\n}\n}\n\nimpl<T: Copy> Option<&mut T> {\n    /// Maps an `Option<&mut T>` to an `Option<T>` by copying the contents of the\n    /// option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = 12;\n    /// let opt_x = Some(&mut x);\n    /// assert_eq!(opt_x, Some(&mut 12));\n    /// let copied = opt_x.copied();\n    /// assert_eq!(copied, Some(12));\n    /// ```\n    #[stable(feature = \"copied\", since = \"1.35.0\")]\n    pub fn copied(self) -> Option<T> {\n}\n}\n\nimpl<T: Clone> Option<&T> {\n    /// Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n    /// option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = 12;\n    /// let opt_x = Some(&x);\n    /// assert_eq!(opt_x, Some(&12));\n    /// let cloned = opt_x.cloned();\n    /// assert_eq!(cloned, Some(12));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn cloned(self) -> Option<T> {\n}\n}\n\nimpl<T: Clone> Option<&mut T> {\n    /// Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the\n    /// option.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x = 12;\n    /// let opt_x = Some(&mut x);\n    /// assert_eq!(opt_x, Some(&mut 12));\n    /// let cloned = opt_x.cloned();\n    /// assert_eq!(cloned, Some(12));\n    /// ```\n    #[stable(since = \"1.26.0\", feature = \"option_ref_mut_cloned\")]\n    pub fn cloned(self) -> Option<T> {\n}\n}\n\nimpl<T: fmt::Debug> Option<T> {\n    /// Unwraps an option, expecting [`None`] and returning nothing.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is a [`Some`], with a panic message including the\n    /// passed message, and the content of the [`Some`].\n    ///\n    /// [`Some`]: #variant.Some\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(option_expect_none)]\n    ///\n    /// use std::collections::HashMap;\n    /// let mut squares = HashMap::new();\n    /// for i in -10..=10 {\n    ///     // This will not panic, since all keys are unique.\n    ///     squares.insert(i, i * i).expect_none(\"duplicate key\");\n    /// }\n    /// ```\n    ///\n    /// ```{.should_panic}\n    /// #![feature(option_expect_none)]\n    ///\n    /// use std::collections::HashMap;\n    /// let mut sqrts = HashMap::new();\n    /// for i in -10..=10 {\n    ///     // This will panic, since both negative and positive `i` will\n    ///     // insert the same `i * i` key, returning the old `Some(i)`.\n    ///     sqrts.insert(i * i, i).expect_none(\"duplicate key\");\n    /// }\n    /// ```\n    #[inline]\n    #[track_caller]\n    #[unstable(feature = \"option_expect_none\", reason = \"newly added\", issue = \"62633\")]\n    pub fn expect_none(self, msg: &str) {\n}\n\n    /// Unwraps an option, expecting [`None`] and returning nothing.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is a [`Some`], with a custom panic message provided\n    /// by the [`Some`]'s value.\n    ///\n    /// [`Some(v)`]: #variant.Some\n    /// [`None`]: #variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(option_unwrap_none)]\n    ///\n    /// use std::collections::HashMap;\n    /// let mut squares = HashMap::new();\n    /// for i in -10..=10 {\n    ///     // This will not panic, since all keys are unique.\n    ///     squares.insert(i, i * i).unwrap_none();\n    /// }\n    /// ```\n    ///\n    /// ```{.should_panic}\n    /// #![feature(option_unwrap_none)]\n    ///\n    /// use std::collections::HashMap;\n    /// let mut sqrts = HashMap::new();\n    /// for i in -10..=10 {\n    ///     // This will panic, since both negative and positive `i` will\n    ///     // insert the same `i * i` key, returning the old `Some(i)`.\n    ///     sqrts.insert(i * i, i).unwrap_none();\n    /// }\n    /// ```\n    #[inline]\n    #[track_caller]\n    #[unstable(feature = \"option_unwrap_none\", reason = \"newly added\", issue = \"62633\")]\n    pub fn unwrap_none(self) {\n}\n}\n\nimpl<T: Default> Option<T> {\n    /// Returns the contained value or a default\n    ///\n    /// Consumes the `self` argument then, if [`Some`], returns the contained\n    /// value, otherwise if [`None`], returns the [default value] for that\n    /// type.\n    ///\n    /// # Examples\n    ///\n    /// Converts a string to an integer, turning poorly-formed strings\n    /// into 0 (the default value for integers). [`parse`] converts\n    /// a string to any other type that implements [`FromStr`], returning\n    /// [`None`] on error.\n    ///\n    /// ```\n    /// let good_year_from_input = \"1909\";\n    /// let bad_year_from_input = \"190blarg\";\n    /// let good_year = good_year_from_input.parse().ok().unwrap_or_default();\n    /// let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n    ///\n    /// assert_eq!(1909, good_year);\n    /// assert_eq!(0, bad_year);\n    /// ```\n    ///\n    /// [`Some`]: #variant.Some\n    /// [`None`]: #variant.None\n    /// [default value]: ../default/trait.Default.html#tymethod.default\n    /// [`parse`]: ../../std/primitive.str.html#method.parse\n    /// [`FromStr`]: ../../std/str/trait.FromStr.html\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or_default(self) -> T {\n}\n}\n\nimpl<T: Deref> Option<T> {\n    /// Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.\n    ///\n    /// Leaves the original Option in-place, creating a new one with a reference\n    /// to the original one, additionally coercing the contents via [`Deref`].\n    ///\n    /// [`Deref`]: ../../std/ops/trait.Deref.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x: Option<String> = Some(\"hey\".to_owned());\n    /// assert_eq!(x.as_deref(), Some(\"hey\"));\n    ///\n    /// let x: Option<String> = None;\n    /// assert_eq!(x.as_deref(), None);\n    /// ```\n    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n    pub fn as_deref(&self) -> Option<&T::Target> {\n}\n}\n\nimpl<T: DerefMut> Option<T> {\n    /// Converts from `Option<T>` (or `&mut Option<T>`) to `Option<&mut T::Target>`.\n    ///\n    /// Leaves the original `Option` in-place, creating a new one containing a mutable reference to\n    /// the inner type's `Deref::Target` type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut x: Option<String> = Some(\"hey\".to_owned());\n    /// assert_eq!(x.as_deref_mut().map(|x| {\n    ///     x.make_ascii_uppercase();\n    ///     x\n    /// }), Some(\"HEY\".to_owned().as_mut_str()));\n    /// ```\n    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n    pub fn as_deref_mut(&mut self) -> Option<&mut T::Target> {\n}\n}\n\nimpl<T, E> Option<Result<T, E>> {\n    /// Transposes an `Option` of a [`Result`] into a [`Result`] of an `Option`.\n    ///\n    /// [`None`] will be mapped to [`Ok`]`(`[`None`]`)`.\n    /// [`Some`]`(`[`Ok`]`(_))` and [`Some`]`(`[`Err`]`(_))` will be mapped to\n    /// [`Ok`]`(`[`Some`]`(_))` and [`Err`]`(_)`.\n    ///\n    /// [`None`]: #variant.None\n    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`Some`]: #variant.Some\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #[derive(Debug, Eq, PartialEq)]\n    /// struct SomeErr;\n    ///\n    /// let x: Result<Option<i32>, SomeErr> = Ok(Some(5));\n    /// let y: Option<Result<i32, SomeErr>> = Some(Ok(5));\n    /// assert_eq!(x, y.transpose());\n    /// ```\n    #[inline]\n    #[stable(feature = \"transpose_result\", since = \"1.33.0\")]\n    pub fn transpose(self) -> Result<Option<T>, E> {\n}\n}\n\n// This is a separate function to reduce the code size of .expect() itself.\n#[inline(never)]\n#[cold]\n#[track_caller]\nfn expect_failed(msg: &str) -> ! {\n}\n\n// This is a separate function to reduce the code size of .expect_none() itself.\n#[inline(never)]\n#[cold]\n#[track_caller]\nfn expect_none_failed(msg: &str, value: &dyn fmt::Debug) -> ! {\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Trait implementations\n/////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> Clone for Option<T> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n\n    #[inline]\n    fn clone_from(&mut self, source: &Self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for Option<T> {\n    /// Returns [`None`][Option::None].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let opt: Option<u32> = Option::default();\n    /// assert!(opt.is_none());\n    /// ```\n    #[inline]\n    fn default() -> Option<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> IntoIterator for Option<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Returns a consuming iterator over the possibly contained value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Some(\"string\");\n    /// let v: Vec<&str> = x.into_iter().collect();\n    /// assert_eq!(v, [\"string\"]);\n    ///\n    /// let x = None;\n    /// let v: Vec<&str> = x.into_iter().collect();\n    /// assert!(v.is_empty());\n    /// ```\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n}\n}\n\n#[stable(since = \"1.4.0\", feature = \"option_iter\")]\nimpl<'a, T> IntoIterator for &'a Option<T> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n}\n}\n\n#[stable(since = \"1.4.0\", feature = \"option_iter\")]\nimpl<'a, T> IntoIterator for &'a mut Option<T> {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n}\n}\n\n#[stable(since = \"1.12.0\", feature = \"option_from\")]\nimpl<T> From<T> for Option<T> {\n    fn from(val: T) -> Option<T> {\n}\n}\n\n#[stable(feature = \"option_ref_from_ref_option\", since = \"1.30.0\")]\nimpl<'a, T> From<&'a Option<T>> for Option<&'a T> {\n    fn from(o: &'a Option<T>) -> Option<&'a T> {\n}\n}\n\n#[stable(feature = \"option_ref_from_ref_option\", since = \"1.30.0\")]\nimpl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T> {\n    fn from(o: &'a mut Option<T>) -> Option<&'a mut T> {\n}\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The Option Iterators\n/////////////////////////////////////////////////////////////////////////////\n\n#[derive(Clone, Debug)]\nstruct Item<A> {\n    opt: Option<A>,\n}\n\nimpl<A> Iterator for Item<A> {\n    type Item = A;\n\n    #[inline]\n    fn next(&mut self) -> Option<A> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\nimpl<A> DoubleEndedIterator for Item<A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<A> {\n}\n}\n\nimpl<A> ExactSizeIterator for Item<A> {}\nimpl<A> FusedIterator for Item<A> {}\nunsafe impl<A> TrustedLen for Item<A> {}\n\n/// An iterator over a reference to the [`Some`] variant of an [`Option`].\n///\n/// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n///\n/// This `struct` is created by the [`Option::iter`] function.\n///\n/// [`Option`]: enum.Option.html\n/// [`Some`]: enum.Option.html#variant.Some\n/// [`Option::iter`]: enum.Option.html#method.iter\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct Iter<'a, A: 'a> {\n    inner: Item<&'a A>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> Iterator for Iter<'a, A> {\n    type Item = &'a A;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a A> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a A> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> ExactSizeIterator for Iter<'_, A> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<A> FusedIterator for Iter<'_, A> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A> TrustedLen for Iter<'_, A> {}}\npub mod panic {\n//! Panic support in the standard library.\n\n#![stable(feature = \"core_panic_info\", since = \"1.41.0\")]\n\nuse crate::any::Any;\nuse crate::fmt;\n\n/// A struct providing information about a panic.\n///\n/// `PanicInfo` structure is passed to a panic hook set by the [`set_hook`]\n/// function.\n///\n/// [`set_hook`]: ../../std/panic/fn.set_hook.html\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|panic_info| {\n///     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n///         println!(\"panic occurred: {:?}\", s);\n///     } else {\n///         println!(\"panic occurred\");\n///     }\n/// }));\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[lang = \"panic_info\"]\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n#[derive(Debug)]\npub struct PanicInfo<'a> {\n    payload: &'a (dyn Any + Send),\n    message: Option<&'a fmt::Arguments<'a>>,\n    location: &'a Location<'a>,\n}\n\nimpl<'a> PanicInfo<'a> {\n    #[unstable(\n        feature = \"panic_internals\",\n        reason = \"internal details of the implementation of the `panic!` \\\n                         and related macros\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    #[inline]\n    pub fn internal_constructor(\n        message: Option<&'a fmt::Arguments<'a>>,\n        location: &'a Location<'a>,\n    ) -> Self {\n}\n\n    #[unstable(\n        feature = \"panic_internals\",\n        reason = \"internal details of the implementation of the `panic!` \\\n                         and related macros\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    #[inline]\n    pub fn set_payload(&mut self, info: &'a (dyn Any + Send)) {\n}\n\n    /// Returns the payload associated with the panic.\n    ///\n    /// This will commonly, but not always, be a `&'static str` or [`String`].\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     println!(\"panic occurred: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn payload(&self) -> &(dyn Any + Send) {\n}\n\n    /// If the `panic!` macro from the `core` crate (not from `std`)\n    /// was used with a formatting string and some additional arguments,\n    /// returns that message ready to be used for example with [`fmt::write`]\n    ///\n    /// [`fmt::write`]: ../fmt/fn.write.html\n    #[unstable(feature = \"panic_info_message\", issue = \"66745\")]\n    pub fn message(&self) -> Option<&fmt::Arguments<'_>> {\n}\n\n    /// Returns information about the location from which the panic originated,\n    /// if available.\n    ///\n    /// This method will currently always return [`Some`], but this may change\n    /// in future versions.\n    ///\n    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occurred in file '{}' at line {}\", location.file(),\n    ///             location.line());\n    ///     } else {\n    ///         println!(\"panic occurred but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn location(&self) -> Option<&Location<'_>> {\n}\n}\n\n#[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]\nimpl fmt::Display for PanicInfo<'_> {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n} else if let Some(payload) = self.payload.downcast_ref::<&'static str>() {\n            write!(formatter, \"'{}', \", payload)?\n        }\n        // NOTE: we cannot use downcast_ref::<String>() here\n        // since String is not available in libcore!\n        // The payload is a String when `std::panic!` is called with multiple arguments,\n        // but in that case the message is also available.\n\n        self.location.fmt(formatter)\n    }\n}\n\n/// A struct containing information about the location of a panic.\n///\n/// This structure is created by the [`location`] method of [`PanicInfo`].\n///\n/// [`location`]: ../../std/panic/struct.PanicInfo.html#method.location\n/// [`PanicInfo`]: ../../std/panic/struct.PanicInfo.html\n///\n/// # Examples\n///\n/// ```should_panic\n/// use std::panic;\n///\n/// panic::set_hook(Box::new(|panic_info| {\n///     if let Some(location) = panic_info.location() {\n///         println!(\"panic occurred in file '{}' at line {}\", location.file(), location.line());\n///     } else {\n///         println!(\"panic occurred but can't get location information...\");\n///     }\n/// }));\n///\n/// panic!(\"Normal panic\");\n/// ```\n#[lang = \"panic_location\"]\n#[derive(Debug)]\n#[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\npub struct Location<'a> {\n    file: &'a str,\n    line: u32,\n    col: u32,\n}\n\nimpl<'a> Location<'a> {\n    /// Returns the source location of the caller of this function. If that function's caller is\n    /// annotated then its call location will be returned, and so on up the stack to the first call\n    /// within a non-tracked function body.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(track_caller)]\n    /// use core::panic::Location;\n    ///\n    /// /// Returns the [`Location`] at which it is called.\n    /// #[track_caller]\n    /// fn get_caller_location() -> &'static Location<'static> {\n    ///     Location::caller()\n    /// }\n    ///\n    /// /// Returns a [`Location`] from within this function's definition.\n    /// fn get_just_one_location() -> &'static Location<'static> {\n    ///     get_caller_location()\n    /// }\n    ///\n    /// let fixed_location = get_just_one_location();\n    /// assert_eq!(fixed_location.file(), file!());\n    /// assert_eq!(fixed_location.line(), 15);\n    /// assert_eq!(fixed_location.column(), 5);\n    ///\n    /// // running the same untracked function in a different location gives us the same result\n    /// let second_fixed_location = get_just_one_location();\n    /// assert_eq!(fixed_location.file(), second_fixed_location.file());\n    /// assert_eq!(fixed_location.line(), second_fixed_location.line());\n    /// assert_eq!(fixed_location.column(), second_fixed_location.column());\n    ///\n    /// let this_location = get_caller_location();\n    /// assert_eq!(this_location.file(), file!());\n    /// assert_eq!(this_location.line(), 29);\n    /// assert_eq!(this_location.column(), 21);\n    ///\n    /// // running the tracked function in a different location produces a different value\n    /// let another_location = get_caller_location();\n    /// assert_eq!(this_location.file(), another_location.file());\n    /// assert_ne!(this_location.line(), another_location.line());\n    /// assert_ne!(this_location.column(), another_location.column());\n    /// ```\n    #[unstable(\n        feature = \"track_caller\",\n        reason = \"uses #[track_caller] which is not yet stable\",\n        issue = \"47809\"\n    )]\n    #[track_caller]\n    pub const fn caller() -> &'static Location<'static> {\n}\n}\n\nimpl<'a> Location<'a> {\n    #![unstable(\n        feature = \"panic_internals\",\n        reason = \"internal details of the implementation of the `panic!` \\\n                          and related macros\",\n        issue = \"none\"\n    )]\n    #[doc(hidden)]\n    pub const fn internal_constructor(file: &'a str, line: u32, col: u32) -> Self {\n}\n\n    /// Returns the name of the source file from which the panic originated.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occurred in file '{}'\", location.file());\n    ///     } else {\n    ///         println!(\"panic occurred but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn file(&self) -> &str {\n}\n\n    /// Returns the line number from which the panic originated.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occurred at line {}\", location.line());\n    ///     } else {\n    ///         println!(\"panic occurred but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n    pub fn line(&self) -> u32 {\n}\n\n    /// Returns the column from which the panic originated.\n    ///\n    /// # Examples\n    ///\n    /// ```should_panic\n    /// use std::panic;\n    ///\n    /// panic::set_hook(Box::new(|panic_info| {\n    ///     if let Some(location) = panic_info.location() {\n    ///         println!(\"panic occurred at column {}\", location.column());\n    ///     } else {\n    ///         println!(\"panic occurred but can't get location information...\");\n    ///     }\n    /// }));\n    ///\n    /// panic!(\"Normal panic\");\n    /// ```\n    #[stable(feature = \"panic_col\", since = \"1.25.0\")]\n    pub fn column(&self) -> u32 {\n}\n}\n\n#[stable(feature = \"panic_hook_display\", since = \"1.26.0\")]\nimpl fmt::Display for Location<'_> {\n    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// An internal trait used by libstd to pass data from libstd to `panic_unwind`\n/// and other panic runtimes. Not intended to be stabilized any time soon, do\n/// not use.\n#[unstable(feature = \"std_internals\", issue = \"none\")]\n#[doc(hidden)]\npub unsafe trait BoxMeUp {\n}\n}\npub mod panicking {\n//! Panic support for libcore\n//!\n//! The core library cannot define panicking, but it does *declare* panicking. This\n//! means that the functions inside of libcore are allowed to panic, but to be\n//! useful an upstream crate must define panicking for libcore to use. The current\n//! interface for panicking is:\n//!\n//! ```\n//! fn panic_impl(pi: &core::panic::PanicInfo<'_>) -> !\n//! # { loop {} }\n//! ```\n//!\n//! This definition allows for panicking with any general message, but it does not\n//! allow for failing with a `Box<Any>` value. (`PanicInfo` just contains a `&(dyn Any + Send)`,\n//! for which we fill in a dummy value in `PanicInfo::internal_constructor`.)\n//! The reason for this is that libcore is not allowed to allocate.\n//!\n//! This module contains a few other panicking functions, but these are just the\n//! necessary lang items for the compiler. All panics are funneled through this\n//! one function. The actual symbol is declared through the `#[panic_handler]` attribute.\n\n// ignore-tidy-undocumented-unsafe\n\n#![allow(dead_code, missing_docs)]\n#![unstable(\n    feature = \"core_panic\",\n    reason = \"internal details of the implementation of the `panic!` \\\n              and related macros\",\n    issue = \"none\"\n)]\n\nuse crate::fmt;\nuse crate::panic::{Location, PanicInfo};\n\n#[cold]\n// never inline unless panic_immediate_abort to avoid code\n// bloat at the call sites as much as possible\n#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n#[track_caller]\n#[lang = \"panic\"] // needed by codegen for panic on overflow and other `Assert` MIR terminators\npub fn panic(expr: &str) -> ! {\n}\n\n#[cold]\n#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n#[lang = \"panic_bounds_check\"] // needed by codegen for panic on OOB array/slice access\nfn panic_bounds_check(location: &Location<'_>, index: usize, len: usize) -> ! {\n}\n\n#[cold]\n#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\npub fn panic_fmt(fmt: fmt::Arguments<'_>, location: &Location<'_>) -> ! {\n}\n}\n#[cfg(not(test))] // See #65860\npub mod pin {\n//! Types that pin data to its location in memory.\n//!\n//! It is sometimes useful to have objects that are guaranteed not to move,\n//! in the sense that their placement in memory does not change, and can thus be relied upon.\n//! A prime example of such a scenario would be building self-referential structs,\n//! as moving an object with pointers to itself will invalidate them, which could cause undefined\n//! behavior.\n//!\n//! A [`Pin<P>`] ensures that the pointee of any pointer type `P` has a stable location in memory,\n//! meaning it cannot be moved elsewhere and its memory cannot be deallocated\n//! until it gets dropped. We say that the pointee is \"pinned\".\n//!\n//! By default, all types in Rust are movable. Rust allows passing all types by-value,\n//! and common smart-pointer types such as [`Box<T>`] and `&mut T` allow replacing and\n//! moving the values they contain: you can move out of a [`Box<T>`], or you can use [`mem::swap`].\n//! [`Pin<P>`] wraps a pointer type `P`, so [`Pin`]`<`[`Box`]`<T>>` functions much like a regular\n//! [`Box<T>`]: when a [`Pin`]`<`[`Box`]`<T>>` gets dropped, so do its contents, and the memory gets\n//! deallocated. Similarly, [`Pin`]`<&mut T>` is a lot like `&mut T`. However, [`Pin<P>`] does\n//! not let clients actually obtain a [`Box<T>`] or `&mut T` to pinned data, which implies that you\n//! cannot use operations such as [`mem::swap`]:\n//!\n//! ```\n//! use std::pin::Pin;\n//! fn swap_pins<T>(x: Pin<&mut T>, y: Pin<&mut T>) {\n//!     // `mem::swap` needs `&mut T`, but we cannot get it.\n//!     // We are stuck, we cannot swap the contents of these references.\n//!     // We could use `Pin::get_unchecked_mut`, but that is unsafe for a reason:\n//!     // we are not allowed to use it for moving things out of the `Pin`.\n//! }\n//! ```\n//!\n//! It is worth reiterating that [`Pin<P>`] does *not* change the fact that a Rust compiler\n//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, [`Pin<P>`]\n//! prevents certain *values* (pointed to by pointers wrapped in [`Pin<P>`]) from being\n//! moved by making it impossible to call methods that require `&mut T` on them\n//! (like [`mem::swap`]).\n//!\n//! [`Pin<P>`] can be used to wrap any pointer type `P`, and as such it interacts with\n//! [`Deref`] and [`DerefMut`]. A [`Pin<P>`] where `P: Deref` should be considered\n//! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a [`Pin`]`<`[`Box`]`<T>>` is\n//! an owned pointer to a pinned `T`, and a [`Pin`]`<`[`Rc`]`<T>>` is a reference-counted\n//! pointer to a pinned `T`.\n//! For correctness, [`Pin<P>`] relies on the implementations of [`Deref`] and\n//! [`DerefMut`] not to move out of their `self` parameter, and only ever to\n//! return a pointer to pinned data when they are called on a pinned pointer.\n//!\n//! # `Unpin`\n//!\n//! Many types are always freely movable, even when pinned, because they do not\n//! rely on having a stable address. This includes all the basic types (like\n//! [`bool`], [`i32`], and references) as well as types consisting solely of these\n//! types. Types that do not care about pinning implement the [`Unpin`]\n//! auto-trait, which cancels the effect of [`Pin<P>`]. For `T: Unpin`,\n//! [`Pin`]`<`[`Box`]`<T>>` and [`Box<T>`] function identically, as do [`Pin`]`<&mut T>` and\n//! `&mut T`.\n//!\n//! Note that pinning and [`Unpin`] only affect the pointed-to type `P::Target`, not the pointer\n//! type `P` itself that got wrapped in [`Pin<P>`]. For example, whether or not [`Box<T>`] is\n//! [`Unpin`] has no effect on the behavior of [`Pin`]`<`[`Box`]`<T>>` (here, `T` is the\n//! pointed-to type).\n//!\n//! # Example: self-referential struct\n//!\n//! ```rust\n//! use std::pin::Pin;\n//! use std::marker::PhantomPinned;\n//! use std::ptr::NonNull;\n//!\n//! // This is a self-referential struct because the slice field points to the data field.\n//! // We cannot inform the compiler about that with a normal reference,\n//! // as this pattern cannot be described with the usual borrowing rules.\n//! // Instead we use a raw pointer, though one which is known not to be null,\n//! // as we know it's pointing at the string.\n//! struct Unmovable {\n//!     data: String,\n//!     slice: NonNull<String>,\n//!     _pin: PhantomPinned,\n//! }\n//!\n//! impl Unmovable {\n//!     // To ensure the data doesn't move when the function returns,\n//!     // we place it in the heap where it will stay for the lifetime of the object,\n//!     // and the only way to access it would be through a pointer to it.\n//!     fn new(data: String) -> Pin<Box<Self>> {\n//!         let res = Unmovable {\n//!             data,\n//!             // we only create the pointer once the data is in place\n//!             // otherwise it will have already moved before we even started\n//!             slice: NonNull::dangling(),\n//!             _pin: PhantomPinned,\n//!         };\n//!         let mut boxed = Box::pin(res);\n//!\n//!         let slice = NonNull::from(&boxed.data);\n//!         // we know this is safe because modifying a field doesn't move the whole struct\n//!         unsafe {\n//!             let mut_ref: Pin<&mut Self> = Pin::as_mut(&mut boxed);\n//!             Pin::get_unchecked_mut(mut_ref).slice = slice;\n//!         }\n//!         boxed\n//!     }\n//! }\n//!\n//! let unmoved = Unmovable::new(\"hello\".to_string());\n//! // The pointer should point to the correct location,\n//! // so long as the struct hasn't moved.\n//! // Meanwhile, we are free to move the pointer around.\n//! # #[allow(unused_mut)]\n//! let mut still_unmoved = unmoved;\n//! assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n//!\n//! // Since our type doesn't implement Unpin, this will fail to compile:\n//! // let mut new_unmoved = Unmovable::new(\"world\".to_string());\n//! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n//! ```\n//!\n//! # Example: intrusive doubly-linked list\n//!\n//! In an intrusive doubly-linked list, the collection does not actually allocate\n//! the memory for the elements itself. Allocation is controlled by the clients,\n//! and elements can live on a stack frame that lives shorter than the collection does.\n//!\n//! To make this work, every element has pointers to its predecessor and successor in\n//! the list. Elements can only be added when they are pinned, because moving the elements\n//! around would invalidate the pointers. Moreover, the [`Drop`] implementation of a linked\n//! list element will patch the pointers of its predecessor and successor to remove itself\n//! from the list.\n//!\n//! Crucially, we have to be able to rely on [`drop`] being called. If an element\n//! could be deallocated or otherwise invalidated without calling [`drop`], the pointers into it\n//! from its neighbouring elements would become invalid, which would break the data structure.\n//!\n//! Therefore, pinning also comes with a [`drop`]-related guarantee.\n//!\n//! # `Drop` guarantee\n//!\n//! The purpose of pinning is to be able to rely on the placement of some data in memory.\n//! To make this work, not just moving the data is restricted; deallocating, repurposing, or\n//! otherwise invalidating the memory used to store the data is restricted, too.\n//! Concretely, for pinned data you have to maintain the invariant\n//! that *its memory will not get invalidated or repurposed from the moment it gets pinned until\n//! when [`drop`] is called*. Memory can be invalidated by deallocation, but also by\n//! replacing a [`Some(v)`] by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n//! off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n//! calling the destructor first.\n//!\n//! This is exactly the kind of guarantee that the intrusive linked list from the previous\n//! section needs to function correctly.\n//!\n//! Notice that this guarantee does *not* mean that memory does not leak! It is still\n//! completely okay not ever to call [`drop`] on a pinned element (e.g., you can still\n//! call [`mem::forget`] on a [`Pin`]`<`[`Box`]`<T>>`). In the example of the doubly-linked\n//! list, that element would just stay in the list. However you may not free or reuse the storage\n//! *without calling [`drop`]*.\n//!\n//! # `Drop` implementation\n//!\n//! If your type uses pinning (such as the two examples above), you have to be careful\n//! when implementing [`Drop`]. The [`drop`] function takes `&mut self`, but this\n//! is called *even if your type was previously pinned*! It is as if the\n//! compiler automatically called [`Pin::get_unchecked_mut`].\n//!\n//! This can never cause a problem in safe code because implementing a type that\n//! relies on pinning requires unsafe code, but be aware that deciding to make\n//! use of pinning in your type (for example by implementing some operation on\n//! [`Pin`]`<&Self>` or [`Pin`]`<&mut Self>`) has consequences for your [`Drop`]\n//! implementation as well: if an element of your type could have been pinned,\n//! you must treat [`Drop`] as implicitly taking [`Pin`]`<&mut Self>`.\n//!\n//! For example, you could implement `Drop` as follows:\n//!\n//! ```rust,no_run\n//! # use std::pin::Pin;\n//! # struct Type { }\n//! impl Drop for Type {\n//!     fn drop(&mut self) {\n//!         // `new_unchecked` is okay because we know this value is never used\n//!         // again after being dropped.\n//!         inner_drop(unsafe { Pin::new_unchecked(self)});\n//!         fn inner_drop(this: Pin<&mut Type>) {\n//!             // Actual drop code goes here.\n//!         }\n//!     }\n//! }\n//! ```\n//!\n//! The function `inner_drop` has the type that [`drop`] *should* have, so this makes sure that\n//! you do not accidentally use `self`/`this` in a way that is in conflict with pinning.\n//!\n//! Moreover, if your type is `#[repr(packed)]`, the compiler will automatically\n//! move fields around to be able to drop them. It might even do\n//! that for fields that happen to be sufficiently aligned. As a consequence, you cannot use\n//! pinning with a `#[repr(packed)]` type.\n//!\n//! # Projections and Structural Pinning\n//!\n//! When working with pinned structs, the question arises how one can access the\n//! fields of that struct in a method that takes just [`Pin`]`<&mut Struct>`.\n//! The usual approach is to write helper methods (so called *projections*)\n//! that turn [`Pin`]`<&mut Struct>` into a reference to the field, but what\n//! type should that reference have? Is it [`Pin`]`<&mut Field>` or `&mut Field`?\n//! The same question arises with the fields of an `enum`, and also when considering\n//! container/wrapper types such as [`Vec<T>`], [`Box<T>`], or [`RefCell<T>`].\n//! (This question applies to both mutable and shared references, we just\n//! use the more common case of mutable references here for illustration.)\n//!\n//! It turns out that it is actually up to the author of the data structure\n//! to decide whether the pinned projection for a particular field turns\n//! [`Pin`]`<&mut Struct>` into [`Pin`]`<&mut Field>` or `&mut Field`. There are some\n//! constraints though, and the most important constraint is *consistency*:\n//! every field can be *either* projected to a pinned reference, *or* have\n//! pinning removed as part of the projection. If both are done for the same field,\n//! that will likely be unsound!\n//!\n//! As the author of a data structure you get to decide for each field whether pinning\n//! \"propagates\" to this field or not. Pinning that propagates is also called \"structural\",\n//! because it follows the structure of the type.\n//! In the following subsections, we describe the considerations that have to be made\n//! for either choice.\n//!\n//! ## Pinning *is not* structural for `field`\n//!\n//! It may seem counter-intuitive that the field of a pinned struct might not be pinned,\n//! but that is actually the easiest choice: if a [`Pin`]`<&mut Field>` is never created,\n//! nothing can go wrong! So, if you decide that some field does not have structural pinning,\n//! all you have to ensure is that you never create a pinned reference to that field.\n//!\n//! Fields without structural pinning may have a projection method that turns\n//! [`Pin`]`<&mut Struct>` into `&mut Field`:\n//!\n//! ```rust,no_run\n//! # use std::pin::Pin;\n//! # type Field = i32;\n//! # struct Struct { field: Field }\n//! impl Struct {\n//!     fn pin_get_field(self: Pin<&mut Self>) -> &mut Field {\n//!         // This is okay because `field` is never considered pinned.\n//!         unsafe { &mut self.get_unchecked_mut().field }\n//!     }\n//! }\n//! ```\n//!\n//! You may also `impl Unpin for Struct` *even if* the type of `field`\n//! is not [`Unpin`]. What that type thinks about pinning is not relevant\n//! when no [`Pin`]`<&mut Field>` is ever created.\n//!\n//! ## Pinning *is* structural for `field`\n//!\n//! The other option is to decide that pinning is \"structural\" for `field`,\n//! meaning that if the struct is pinned then so is the field.\n//!\n//! This allows writing a projection that creates a [`Pin`]`<&mut Field>`, thus\n//! witnessing that the field is pinned:\n//!\n//! ```rust,no_run\n//! # use std::pin::Pin;\n//! # type Field = i32;\n//! # struct Struct { field: Field }\n//! impl Struct {\n//!     fn pin_get_field(self: Pin<&mut Self>) -> Pin<&mut Field> {\n//!         // This is okay because `field` is pinned when `self` is.\n//!         unsafe { self.map_unchecked_mut(|s| &mut s.field) }\n//!     }\n//! }\n//! ```\n//!\n//! However, structural pinning comes with a few extra requirements:\n//!\n//! 1.  The struct must only be [`Unpin`] if all the structural fields are\n//!     [`Unpin`]. This is the default, but [`Unpin`] is a safe trait, so as the author of\n//!     the struct it is your responsibility *not* to add something like\n//!     `impl<T> Unpin for Struct<T>`. (Notice that adding a projection operation\n//!     requires unsafe code, so the fact that [`Unpin`] is a safe trait does not break\n//!     the principle that you only have to worry about any of this if you use `unsafe`.)\n//! 2.  The destructor of the struct must not move structural fields out of its argument. This\n//!     is the exact point that was raised in the [previous section][drop-impl]: `drop` takes\n//!     `&mut self`, but the struct (and hence its fields) might have been pinned before.\n//!     You have to guarantee that you do not move a field inside your [`Drop`] implementation.\n//!     In particular, as explained previously, this means that your struct must *not*\n//!     be `#[repr(packed)]`.\n//!     See that section for how to write [`drop`] in a way that the compiler can help you\n//!     not accidentally break pinning.\n//! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n//!     once your struct is pinned, the memory that contains the\n//!     content is not overwritten or deallocated without calling the content's destructors.\n//!     This can be tricky, as witnessed by [`VecDeque<T>`]: the destructor of [`VecDeque<T>`]\n//!     can fail to call [`drop`] on all elements if one of the destructors panics. This violates\n//!     the [`Drop`] guarantee, because it can lead to elements being deallocated without\n//!     their destructor being called. ([`VecDeque<T>`] has no pinning projections, so this\n//!     does not cause unsoundness.)\n//! 4.  You must not offer any other operations that could lead to data being moved out of\n//!     the structural fields when your type is pinned. For example, if the struct contains an\n//!     [`Option<T>`] and there is a `take`-like operation with type\n//!     `fn(Pin<&mut Struct<T>>) -> Option<T>`,\n//!     that operation can be used to move a `T` out of a pinned `Struct<T>` -- which means\n//!     pinning cannot be structural for the field holding this data.\n//!\n//!     For a more complex example of moving data out of a pinned type, imagine if [`RefCell<T>`]\n//!     had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n//!     Then we could do the following:\n//!     ```compile_fail\n//!     fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>>) {\n//!         { let p = rc.as_mut().get_pin_mut(); } // Here we get pinned access to the `T`.\n//!         let rc_shr: &RefCell<T> = rc.into_ref().get_ref();\n//!         let b = rc_shr.borrow_mut();\n//!         let content = &mut *b; // And here we have `&mut T` to the same data.\n//!     }\n//!     ```\n//!     This is catastrophic, it means we can first pin the content of the [`RefCell<T>`]\n//!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n//!     reference we got later.\n//!\n//! ## Examples\n//!\n//! For a type like [`Vec<T>`], both possibilites (structural pinning or not) make sense.\n//! A [`Vec<T>`] with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n//! pinned references to elements. However, it could *not* allow calling\n//! [`pop`][Vec::pop] on a pinned [`Vec<T>`] because that would move the (structurally pinned)\n//! contents! Nor could it allow [`push`][Vec::push], which might reallocate and thus also move the\n//! contents.\n//!\n//! A [`Vec<T>`] without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n//! are never pinned and the [`Vec<T>`] itself is fine with being moved as well.\n//! At that point pinning just has no effect on the vector at all.\n//!\n//! In the standard library, pointer types generally do not have structural pinning,\n//! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n//! It makes sense to do this for pointer types, because moving the `Box<T>`\n//! does not actually move the `T`: the [`Box<T>`] can be freely movable (aka `Unpin`) even if\n//! the `T` is not. In fact, even [`Pin`]`<`[`Box`]`<T>>` and [`Pin`]`<&mut T>` are always\n//! [`Unpin`] themselves, for the same reason: their contents (the `T`) are pinned, but the\n//! pointers themselves can be moved without moving the pinned data. For both [`Box<T>`] and\n//! [`Pin`]`<`[`Box`]`<T>>`, whether the content is pinned is entirely independent of whether the\n//! pointer is pinned, meaning pinning is *not* structural.\n//!\n//! When implementing a [`Future`] combinator, you will usually need structural pinning\n//! for the nested futures, as you need to get pinned references to them to call [`poll`].\n//! But if your combinator contains any other data that does not need to be pinned,\n//! you can make those fields not structural and hence freely access them with a\n//! mutable reference even when you just have [`Pin`]`<&mut Self>` (such as in your own\n//! [`poll`] implementation).\n//!\n//! [`Pin<P>`]: struct.Pin.html\n//! [`Unpin`]: ../marker/trait.Unpin.html\n//! [`Deref`]: ../ops/trait.Deref.html\n//! [`DerefMut`]: ../ops/trait.DerefMut.html\n//! [`mem::swap`]: ../mem/fn.swap.html\n//! [`mem::forget`]: ../mem/fn.forget.html\n//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n//! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n//! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len\n//! [`Pin`]: struct.Pin.html\n//! [`Box`]: ../../std/boxed/struct.Box.html\n//! [Vec::pop]: ../../std/vec/struct.Vec.html#method.pop\n//! [Vec::push]: ../../std/vec/struct.Vec.html#method.push\n//! [`Rc`]: ../../std/rc/struct.Rc.html\n//! [`RefCell<T>`]: ../../std/cell/struct.RefCell.html\n//! [`Drop`]: ../../std/ops/trait.Drop.html\n//! [`drop`]: ../../std/ops/trait.Drop.html#tymethod.drop\n//! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n//! [`Option<T>`]: ../../std/option/enum.Option.html\n//! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n//! [`RefCell<T>`]: ../cell/struct.RefCell.html\n//! [`None`]: ../option/enum.Option.html#variant.None\n//! [`Some(v)`]: ../option/enum.Option.html#variant.Some\n//! [`ptr::write`]: ../ptr/fn.write.html\n//! [`Future`]: ../future/trait.Future.html\n//! [drop-impl]: #drop-implementation\n//! [drop-guarantee]: #drop-guarantee\n//! [`poll`]: ../../std/future/trait.Future.html#tymethod.poll\n//! [`Pin::get_unchecked_mut`]: struct.Pin.html#method.get_unchecked_mut\n//! [`bool`]: ../../std/primitive.bool.html\n//! [`i32`]: ../../std/primitive.i32.html\n\n#![stable(feature = \"pin\", since = \"1.33.0\")]\n\nuse crate::cmp::{self, PartialEq, PartialOrd};\nuse crate::fmt;\nuse crate::hash::{Hash, Hasher};\nuse crate::marker::{Sized, Unpin};\nuse crate::ops::{CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Receiver};\n\n/// A pinned pointer.\n///\n/// This is a wrapper around a kind of pointer which makes that pointer \"pin\" its\n/// value in place, preventing the value referenced by that pointer from being moved\n/// unless it implements [`Unpin`].\n///\n/// *See the [`pin` module] documentation for an explanation of pinning.*\n///\n/// [`Unpin`]: ../../std/marker/trait.Unpin.html\n/// [`pin` module]: ../../std/pin/index.html\n//\n// Note: the `Clone` derive below causes unsoundness as it's possible to implement\n// `Clone` for mutable references.\n// See <https://internals.rust-lang.org/t/unsoundness-in-pin/11311> for more details.\n#[stable(feature = \"pin\", since = \"1.33.0\")]\n#[lang = \"pin\"]\n#[fundamental]\n#[repr(transparent)]\n#[derive(Copy, Clone)]\npub struct Pin<P> {\n    pointer: P,\n}\n\n// The following implementations aren't derived in order to avoid soundness\n// issues. `&self.pointer` should not be accessible to untrusted trait\n// implementations.\n//\n// See <https://internals.rust-lang.org/t/unsoundness-in-pin/11311/73> for more details.\n\n#[stable(feature = \"pin_trait_impls\", since = \"1.41.0\")]\nimpl<P: Deref, Q: Deref> PartialEq<Pin<Q>> for Pin<P>\nwhere\n    P::Target: PartialEq<Q::Target>,\n{\n    fn eq(&self, other: &Pin<Q>) -> bool {\n}\n\n    fn ne(&self, other: &Pin<Q>) -> bool {\n}\n}\n\n#[stable(feature = \"pin_trait_impls\", since = \"1.41.0\")]\nimpl<P: Deref<Target: Eq>> Eq for Pin<P> {}\n\n#[stable(feature = \"pin_trait_impls\", since = \"1.41.0\")]\nimpl<P: Deref, Q: Deref> PartialOrd<Pin<Q>> for Pin<P>\nwhere\n    P::Target: PartialOrd<Q::Target>,\n{\n    fn partial_cmp(&self, other: &Pin<Q>) -> Option<cmp::Ordering> {\n}\n\n    fn lt(&self, other: &Pin<Q>) -> bool {\n}\n\n    fn le(&self, other: &Pin<Q>) -> bool {\n}\n\n    fn gt(&self, other: &Pin<Q>) -> bool {\n}\n\n    fn ge(&self, other: &Pin<Q>) -> bool {\n}\n}\n\n#[stable(feature = \"pin_trait_impls\", since = \"1.41.0\")]\nimpl<P: Deref<Target: Ord>> Ord for Pin<P> {\n    fn cmp(&self, other: &Self) -> cmp::Ordering {\n}\n}\n\n#[stable(feature = \"pin_trait_impls\", since = \"1.41.0\")]\nimpl<P: Deref<Target: Hash>> Hash for Pin<P> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n}\n}\n\nimpl<P: Deref<Target: Unpin>> Pin<P> {\n    /// Construct a new `Pin<P>` around a pointer to some data of a type that\n    /// implements [`Unpin`].\n    ///\n    /// Unlike `Pin::new_unchecked`, this method is safe because the pointer\n    /// `P` dereferences to an [`Unpin`] type, which cancels the pinning guarantees.\n    ///\n    /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub fn new(pointer: P) -> Pin<P> {\n}\n\n    /// Unwraps this `Pin<P>` returning the underlying pointer.\n    ///\n    /// This requires that the data inside this `Pin` is [`Unpin`] so that we\n    /// can ignore the pinning invariants when unwrapping it.\n    ///\n    /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n    #[stable(feature = \"pin_into_inner\", since = \"1.39.0\")]\n    #[inline(always)]\n    pub fn into_inner(pin: Pin<P>) -> P {\n}\n}\n\nimpl<P: Deref> Pin<P> {\n    /// Construct a new `Pin<P>` around a reference to some data of a type that\n    /// may or may not implement `Unpin`.\n    ///\n    /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used\n    /// instead.\n    ///\n    /// # Safety\n    ///\n    /// This constructor is unsafe because we cannot guarantee that the data\n    /// pointed to by `pointer` is pinned, meaning that the data will not be moved or\n    /// its storage invalidated until it gets dropped. If the constructed `Pin<P>` does\n    /// not guarantee that the data `P` points to is pinned, that is a violation of\n    /// the API contract and may lead to undefined behavior in later (safe) operations.\n    ///\n    /// By using this method, you are making a promise about the `P::Deref` and\n    /// `P::DerefMut` implementations, if they exist. Most importantly, they\n    /// must not move out of their `self` arguments: `Pin::as_mut` and `Pin::as_ref`\n    /// will call `DerefMut::deref_mut` and `Deref::deref` *on the pinned pointer*\n    /// and expect these methods to uphold the pinning invariants.\n    /// Moreover, by calling this method you promise that the reference `P`\n    /// dereferences to will not be moved out of again; in particular, it\n    /// must not be possible to obtain a `&mut P::Target` and then\n    /// move out of that reference (using, for example [`mem::swap`]).\n    ///\n    /// For example, calling `Pin::new_unchecked` on an `&'a mut T` is unsafe because\n    /// while you are able to pin it for the given lifetime `'a`, you have no control\n    /// over whether it is kept pinned once `'a` ends:\n    /// ```\n    /// use std::mem;\n    /// use std::pin::Pin;\n    ///\n    /// fn move_pinned_ref<T>(mut a: T, mut b: T) {\n    ///     unsafe {\n    ///         let p: Pin<&mut T> = Pin::new_unchecked(&mut a);\n    ///         // This should mean the pointee `a` can never move again.\n    ///     }\n    ///     mem::swap(&mut a, &mut b);\n    ///     // The address of `a` changed to `b`'s stack slot, so `a` got moved even\n    ///     // though we have previously pinned it! We have violated the pinning API contract.\n    /// }\n    /// ```\n    /// A value, once pinned, must remain pinned forever (unless its type implements `Unpin`).\n    ///\n    /// Similarily, calling `Pin::new_unchecked` on an `Rc<T>` is unsafe because there could be\n    /// aliases to the same data that are not subject to the pinning restrictions:\n    /// ```\n    /// use std::rc::Rc;\n    /// use std::pin::Pin;\n    ///\n    /// fn move_pinned_rc<T>(mut x: Rc<T>) {\n    ///     let pinned = unsafe { Pin::new_unchecked(x.clone()) };\n    ///     {\n    ///         let p: Pin<&T> = pinned.as_ref();\n    ///         // This should mean the pointee can never move again.\n    ///     }\n    ///     drop(pinned);\n    ///     let content = Rc::get_mut(&mut x).unwrap();\n    ///     // Now, if `x` was the only reference, we have a mutable reference to\n    ///     // data that we pinned above, which we could use to move it as we have\n    ///     // seen in the previous example. We have violated the pinning API contract.\n    ///  }\n    ///  ```\n    ///\n    /// [`mem::swap`]: ../../std/mem/fn.swap.html\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub unsafe fn new_unchecked(pointer: P) -> Pin<P> {\n}\n\n    /// Gets a pinned shared reference from this pinned pointer.\n    ///\n    /// This is a generic method to go from `&Pin<Pointer<T>>` to `Pin<&T>`.\n    /// It is safe because, as part of the contract of `Pin::new_unchecked`,\n    /// the pointee cannot move after `Pin<Pointer<T>>` got created.\n    /// \"Malicious\" implementations of `Pointer::Deref` are likewise\n    /// ruled out by the contract of `Pin::new_unchecked`.\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub fn as_ref(&self) -> Pin<&P::Target> {\n}\n\n    /// Unwraps this `Pin<P>` returning the underlying pointer.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe. You must guarantee that you will continue to\n    /// treat the pointer `P` as pinned after you call this function, so that\n    /// the invariants on the `Pin` type can be upheld. If the code using the\n    /// resulting `P` does not continue to maintain the pinning invariants that\n    /// is a violation of the API contract and may lead to undefined behavior in\n    /// later (safe) operations.\n    ///\n    /// If the underlying data is [`Unpin`], [`Pin::into_inner`] should be used\n    /// instead.\n    ///\n    /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n    /// [`Pin::into_inner`]: #method.into_inner\n    #[stable(feature = \"pin_into_inner\", since = \"1.39.0\")]\n    #[inline(always)]\n    pub unsafe fn into_inner_unchecked(pin: Pin<P>) -> P {\n}\n}\n\nimpl<P: DerefMut> Pin<P> {\n    /// Gets a pinned mutable reference from this pinned pointer.\n    ///\n    /// This is a generic method to go from `&mut Pin<Pointer<T>>` to `Pin<&mut T>`.\n    /// It is safe because, as part of the contract of `Pin::new_unchecked`,\n    /// the pointee cannot move after `Pin<Pointer<T>>` got created.\n    /// \"Malicious\" implementations of `Pointer::DerefMut` are likewise\n    /// ruled out by the contract of `Pin::new_unchecked`.\n    ///\n    /// This method is useful when doing multiple calls to functions that consume the pinned type.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use std::pin::Pin;\n    ///\n    /// # struct Type {}\n    /// impl Type {\n    ///     fn method(self: Pin<&mut Self>) {\n    ///         // do something\n    ///     }\n    ///\n    ///     fn call_method_twice(mut self: Pin<&mut Self>) {\n    ///         // `method` consumes `self`, so reborrow the `Pin<&mut Self>` via `as_mut`.\n    ///         self.as_mut().method();\n    ///         self.as_mut().method();\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub fn as_mut(&mut self) -> Pin<&mut P::Target> {\n}\n\n    /// Assigns a new value to the memory behind the pinned reference.\n    ///\n    /// This overwrites pinned data, but that is okay: its destructor gets\n    /// run before being overwritten, so no pinning guarantee is violated.\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub fn set(&mut self, value: P::Target)\n    where\n        P::Target: Sized,\n    {\n}\n}\n\nimpl<'a, T: ?Sized> Pin<&'a T> {\n    /// Constructs a new pin by mapping the interior value.\n    ///\n    /// For example, if you  wanted to get a `Pin` of a field of something,\n    /// you could use this to get access to that field in one line of code.\n    /// However, there are several gotchas with these \"pinning projections\";\n    /// see the [`pin` module] documentation for further details on that topic.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe. You must guarantee that the data you return\n    /// will not move so long as the argument value does not move (for example,\n    /// because it is one of the fields of that value), and also that you do\n    /// not move out of the argument you receive to the interior function.\n    ///\n    /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U>\n    where\n        U: ?Sized,\n        F: FnOnce(&T) -> &U,\n    {\n}\n\n    /// Gets a shared reference out of a pin.\n    ///\n    /// This is safe because it is not possible to move out of a shared reference.\n    /// It may seem like there is an issue here with interior mutability: in fact,\n    /// it *is* possible to move a `T` out of a `&RefCell<T>`. However, this is\n    /// not a problem as long as there does not also exist a `Pin<&T>` pointing\n    /// to the same data, and `RefCell<T>` does not let you create a pinned reference\n    /// to its contents. See the discussion on [\"pinning projections\"] for further\n    /// details.\n    ///\n    /// Note: `Pin` also implements `Deref` to the target, which can be used\n    /// to access the inner value. However, `Deref` only provides a reference\n    /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n    /// the `Pin` itself. This method allows turning the `Pin` into a reference\n    /// with the same lifetime as the original `Pin`.\n    ///\n    /// [\"pinning projections\"]: ../../std/pin/index.html#projections-and-structural-pinning\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub fn get_ref(self) -> &'a T {\n}\n}\n\nimpl<'a, T: ?Sized> Pin<&'a mut T> {\n    /// Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub fn into_ref(self) -> Pin<&'a T> {\n}\n\n    /// Gets a mutable reference to the data inside of this `Pin`.\n    ///\n    /// This requires that the data inside this `Pin` is `Unpin`.\n    ///\n    /// Note: `Pin` also implements `DerefMut` to the data, which can be used\n    /// to access the inner value. However, `DerefMut` only provides a reference\n    /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n    /// the `Pin` itself. This method allows turning the `Pin` into a reference\n    /// with the same lifetime as the original `Pin`.\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub fn get_mut(self) -> &'a mut T\n    where\n        T: Unpin,\n    {\n}\n\n    /// Gets a mutable reference to the data inside of this `Pin`.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe. You must guarantee that you will never move\n    /// the data out of the mutable reference you receive when you call this\n    /// function, so that the invariants on the `Pin` type can be upheld.\n    ///\n    /// If the underlying data is `Unpin`, `Pin::get_mut` should be used\n    /// instead.\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub unsafe fn get_unchecked_mut(self) -> &'a mut T {\n}\n\n    /// Construct a new pin by mapping the interior value.\n    ///\n    /// For example, if you  wanted to get a `Pin` of a field of something,\n    /// you could use this to get access to that field in one line of code.\n    /// However, there are several gotchas with these \"pinning projections\";\n    /// see the [`pin` module] documentation for further details on that topic.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe. You must guarantee that the data you return\n    /// will not move so long as the argument value does not move (for example,\n    /// because it is one of the fields of that value), and also that you do\n    /// not move out of the argument you receive to the interior function.\n    ///\n    /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U>\n    where\n        U: ?Sized,\n        F: FnOnce(&mut T) -> &mut U,\n    {\n}\n}\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<P: Deref> Deref for Pin<P> {\n    type Target = P::Target;\n    fn deref(&self) -> &P::Target {\n}\n}\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<P: DerefMut<Target: Unpin>> DerefMut for Pin<P> {\n    fn deref_mut(&mut self) -> &mut P::Target {\n}\n}\n\n#[unstable(feature = \"receiver_trait\", issue = \"none\")]\nimpl<P: Receiver> Receiver for Pin<P> {}}\npub mod raw {\n#![allow(missing_docs)]\n#![unstable(feature = \"raw\", issue = \"27751\")]\n\n//! Contains struct definitions for the layout of compiler built-in types.\n//!\n//! They can be used as targets of transmutes in unsafe code for manipulating\n//! the raw representations directly.\n//!\n//! Their definition should always match the ABI defined in `rustc::back::abi`.\n\n/// The representation of a trait object like `&SomeTrait`.\n///\n/// This struct has the same layout as types like `&SomeTrait` and\n/// `Box<dyn AnotherTrait>`.\n///\n/// `TraitObject` is guaranteed to match layouts, but it is not the\n/// type of trait objects (e.g., the fields are not directly accessible\n/// on a `&SomeTrait`) nor does it control that layout (changing the\n/// definition will not change the layout of a `&SomeTrait`). It is\n/// only designed to be used by unsafe code that needs to manipulate\n/// the low-level details.\n///\n/// There is no way to refer to all trait objects generically, so the only\n/// way to create values of this type is with functions like\n/// [`std::mem::transmute`][transmute]. Similarly, the only way to create a true\n/// trait object from a `TraitObject` value is with `transmute`.\n///\n/// [transmute]: ../intrinsics/fn.transmute.html\n///\n/// Synthesizing a trait object with mismatched types—one where the\n/// vtable does not correspond to the type of the value to which the\n/// data pointer points—is highly likely to lead to undefined\n/// behavior.\n///\n/// # Examples\n///\n/// ```\n/// #![feature(raw)]\n///\n/// use std::{mem, raw};\n///\n/// // an example trait\n/// trait Foo {\n///     fn bar(&self) -> i32;\n/// }\n///\n/// impl Foo for i32 {\n///     fn bar(&self) -> i32 {\n///          *self + 1\n///     }\n/// }\n///\n/// let value: i32 = 123;\n///\n/// // let the compiler make a trait object\n/// let object: &dyn Foo = &value;\n///\n/// // look at the raw representation\n/// let raw_object: raw::TraitObject = unsafe { mem::transmute(object) };\n///\n/// // the data pointer is the address of `value`\n/// assert_eq!(raw_object.data as *const i32, &value as *const _);\n///\n/// let other_value: i32 = 456;\n///\n/// // construct a new object, pointing to a different `i32`, being\n/// // careful to use the `i32` vtable from `object`\n/// let synthesized: &dyn Foo = unsafe {\n///      mem::transmute(raw::TraitObject {\n///          data: &other_value as *const _ as *mut (),\n///          vtable: raw_object.vtable,\n///      })\n/// };\n///\n/// // it should work just as if we had constructed a trait object out of\n/// // `other_value` directly\n/// assert_eq!(synthesized.bar(), 457);\n/// ```\n#[repr(C)]\n#[derive(Copy, Clone)]\n#[allow(missing_debug_implementations)]\npub struct TraitObject {\n    pub data: *mut (),\n    pub vtable: *mut (),\n}\n}\npub mod result {\n//! Error handling with the `Result` type.\n//!\n//! [`Result<T, E>`][`Result`] is the type used for returning and propagating\n//! errors. It is an enum with the variants, [`Ok(T)`], representing\n//! success and containing a value, and [`Err(E)`], representing error\n//! and containing an error value.\n//!\n//! ```\n//! # #[allow(dead_code)]\n//! enum Result<T, E> {\n//!    Ok(T),\n//!    Err(E),\n//! }\n//! ```\n//!\n//! Functions return [`Result`] whenever errors are expected and\n//! recoverable. In the `std` crate, [`Result`] is most prominently used\n//! for [I/O](../../std/io/index.html).\n//!\n//! A simple function returning [`Result`] might be\n//! defined and used like so:\n//!\n//! ```\n//! #[derive(Debug)]\n//! enum Version { Version1, Version2 }\n//!\n//! fn parse_version(header: &[u8]) -> Result<Version, &'static str> {\n//!     match header.get(0) {\n//!         None => Err(\"invalid header length\"),\n//!         Some(&1) => Ok(Version::Version1),\n//!         Some(&2) => Ok(Version::Version2),\n//!         Some(_) => Err(\"invalid version\"),\n//!     }\n//! }\n//!\n//! let version = parse_version(&[1, 2, 3, 4]);\n//! match version {\n//!     Ok(v) => println!(\"working with version: {:?}\", v),\n//!     Err(e) => println!(\"error parsing header: {:?}\", e),\n//! }\n//! ```\n//!\n//! Pattern matching on [`Result`]s is clear and straightforward for\n//! simple cases, but [`Result`] comes with some convenience methods\n//! that make working with it more succinct.\n//!\n//! ```\n//! let good_result: Result<i32, i32> = Ok(10);\n//! let bad_result: Result<i32, i32> = Err(10);\n//!\n//! // The `is_ok` and `is_err` methods do what they say.\n//! assert!(good_result.is_ok() && !good_result.is_err());\n//! assert!(bad_result.is_err() && !bad_result.is_ok());\n//!\n//! // `map` consumes the `Result` and produces another.\n//! let good_result: Result<i32, i32> = good_result.map(|i| i + 1);\n//! let bad_result: Result<i32, i32> = bad_result.map(|i| i - 1);\n//!\n//! // Use `and_then` to continue the computation.\n//! let good_result: Result<bool, i32> = good_result.and_then(|i| Ok(i == 11));\n//!\n//! // Use `or_else` to handle the error.\n//! let bad_result: Result<i32, i32> = bad_result.or_else(|i| Ok(i + 20));\n//!\n//! // Consume the result and return the contents with `unwrap`.\n//! let final_awesome_result = good_result.unwrap();\n//! ```\n//!\n//! # Results must be used\n//!\n//! A common problem with using return values to indicate errors is\n//! that it is easy to ignore the return value, thus failing to handle\n//! the error. [`Result`] is annotated with the `#[must_use]` attribute,\n//! which will cause the compiler to issue a warning when a Result\n//! value is ignored. This makes [`Result`] especially useful with\n//! functions that may encounter errors but don't otherwise return a\n//! useful value.\n//!\n//! Consider the [`write_all`] method defined for I/O types\n//! by the [`Write`] trait:\n//!\n//! ```\n//! use std::io;\n//!\n//! trait Write {\n//!     fn write_all(&mut self, bytes: &[u8]) -> Result<(), io::Error>;\n//! }\n//! ```\n//!\n//! *Note: The actual definition of [`Write`] uses [`io::Result`], which\n//! is just a synonym for [`Result`]`<T, `[`io::Error`]`>`.*\n//!\n//! This method doesn't produce a value, but the write may\n//! fail. It's crucial to handle the error case, and *not* write\n//! something like this:\n//!\n//! ```no_run\n//! # #![allow(unused_must_use)] // \\o/\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//!\n//! let mut file = File::create(\"valuable_data.txt\").unwrap();\n//! // If `write_all` errors, then we'll never know, because the return\n//! // value is ignored.\n//! file.write_all(b\"important message\");\n//! ```\n//!\n//! If you *do* write that in Rust, the compiler will give you a\n//! warning (by default, controlled by the `unused_must_use` lint).\n//!\n//! You might instead, if you don't want to handle the error, simply\n//! assert success with [`expect`]. This will panic if the\n//! write fails, providing a marginally useful message indicating why:\n//!\n//! ```{.no_run}\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//!\n//! let mut file = File::create(\"valuable_data.txt\").unwrap();\n//! file.write_all(b\"important message\").expect(\"failed to write message\");\n//! ```\n//!\n//! You might also simply assert success:\n//!\n//! ```{.no_run}\n//! # use std::fs::File;\n//! # use std::io::prelude::*;\n//! # let mut file = File::create(\"valuable_data.txt\").unwrap();\n//! assert!(file.write_all(b\"important message\").is_ok());\n//! ```\n//!\n//! Or propagate the error up the call stack with [`?`]:\n//!\n//! ```\n//! # use std::fs::File;\n//! # use std::io::prelude::*;\n//! # use std::io;\n//! # #[allow(dead_code)]\n//! fn write_message() -> io::Result<()> {\n//!     let mut file = File::create(\"valuable_data.txt\")?;\n//!     file.write_all(b\"important message\")?;\n//!     Ok(())\n//! }\n//! ```\n//!\n//! # The question mark operator, `?`\n//!\n//! When writing code that calls many functions that return the\n//! [`Result`] type, the error handling can be tedious. The question mark\n//! operator, [`?`], hides some of the boilerplate of propagating errors\n//! up the call stack.\n//!\n//! It replaces this:\n//!\n//! ```\n//! # #![allow(dead_code)]\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//! use std::io;\n//!\n//! struct Info {\n//!     name: String,\n//!     age: i32,\n//!     rating: i32,\n//! }\n//!\n//! fn write_info(info: &Info) -> io::Result<()> {\n//!     // Early return on error\n//!     let mut file = match File::create(\"my_best_friends.txt\") {\n//!            Err(e) => return Err(e),\n//!            Ok(f) => f,\n//!     };\n//!     if let Err(e) = file.write_all(format!(\"name: {}\\n\", info.name).as_bytes()) {\n//!         return Err(e)\n//!     }\n//!     if let Err(e) = file.write_all(format!(\"age: {}\\n\", info.age).as_bytes()) {\n//!         return Err(e)\n//!     }\n//!     if let Err(e) = file.write_all(format!(\"rating: {}\\n\", info.rating).as_bytes()) {\n//!         return Err(e)\n//!     }\n//!     Ok(())\n//! }\n//! ```\n//!\n//! With this:\n//!\n//! ```\n//! # #![allow(dead_code)]\n//! use std::fs::File;\n//! use std::io::prelude::*;\n//! use std::io;\n//!\n//! struct Info {\n//!     name: String,\n//!     age: i32,\n//!     rating: i32,\n//! }\n//!\n//! fn write_info(info: &Info) -> io::Result<()> {\n//!     let mut file = File::create(\"my_best_friends.txt\")?;\n//!     // Early return on error\n//!     file.write_all(format!(\"name: {}\\n\", info.name).as_bytes())?;\n//!     file.write_all(format!(\"age: {}\\n\", info.age).as_bytes())?;\n//!     file.write_all(format!(\"rating: {}\\n\", info.rating).as_bytes())?;\n//!     Ok(())\n//! }\n//! ```\n//!\n//! *It's much nicer!*\n//!\n//! Ending the expression with [`?`] will result in the unwrapped\n//! success ([`Ok`]) value, unless the result is [`Err`], in which case\n//! [`Err`] is returned early from the enclosing function.\n//!\n//! [`?`] can only be used in functions that return [`Result`] because of the\n//! early return of [`Err`] that it provides.\n//!\n//! [`expect`]: enum.Result.html#method.expect\n//! [`Write`]: ../../std/io/trait.Write.html\n//! [`write_all`]: ../../std/io/trait.Write.html#method.write_all\n//! [`io::Result`]: ../../std/io/type.Result.html\n//! [`?`]: ../../std/macro.try.html\n//! [`Result`]: enum.Result.html\n//! [`Ok(T)`]: enum.Result.html#variant.Ok\n//! [`Err(E)`]: enum.Result.html#variant.Err\n//! [`io::Error`]: ../../std/io/struct.Error.html\n//! [`Ok`]: enum.Result.html#variant.Ok\n//! [`Err`]: enum.Result.html#variant.Err\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::fmt;\nuse crate::iter::{self, FromIterator, FusedIterator, TrustedLen};\nuse crate::ops::{self, Deref, DerefMut};\n\n/// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n///\n/// See the [`std::result`](index.html) module documentation for details.\n///\n/// [`Ok`]: enum.Result.html#variant.Ok\n/// [`Err`]: enum.Result.html#variant.Err\n#[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n#[must_use = \"this `Result` may be an `Err` variant, which should be handled\"]\n#[rustc_diagnostic_item = \"result_type\"]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Result<T, E> {\n    /// Contains the success value\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Ok(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n\n    /// Contains the error value\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Type implementation\n/////////////////////////////////////////////////////////////////////////////\n\nimpl<T, E> Result<T, E> {\n    /////////////////////////////////////////////////////////////////////////\n    // Querying the contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns `true` if the result is [`Ok`].\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<i32, &str> = Ok(-3);\n    /// assert_eq!(x.is_ok(), true);\n    ///\n    /// let x: Result<i32, &str> = Err(\"Some error message\");\n    /// assert_eq!(x.is_ok(), false);\n    /// ```\n    #[must_use = \"if you intended to assert that this is ok, consider `.unwrap()` instead\"]\n    #[rustc_const_unstable(feature = \"const_result\", issue = \"67520\")]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn is_ok(&self) -> bool {\n}\n\n    /// Returns `true` if the result is [`Err`].\n    ///\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<i32, &str> = Ok(-3);\n    /// assert_eq!(x.is_err(), false);\n    ///\n    /// let x: Result<i32, &str> = Err(\"Some error message\");\n    /// assert_eq!(x.is_err(), true);\n    /// ```\n    #[must_use = \"if you intended to assert that this is err, consider `.unwrap_err()` instead\"]\n    #[rustc_const_unstable(feature = \"const_result\", issue = \"67520\")]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn is_err(&self) -> bool {\n}\n\n    /// Returns `true` if the result is an [`Ok`] value containing the given value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(option_result_contains)]\n    ///\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.contains(&2), true);\n    ///\n    /// let x: Result<u32, &str> = Ok(3);\n    /// assert_eq!(x.contains(&2), false);\n    ///\n    /// let x: Result<u32, &str> = Err(\"Some error message\");\n    /// assert_eq!(x.contains(&2), false);\n    /// ```\n    #[must_use]\n    #[inline]\n    #[unstable(feature = \"option_result_contains\", issue = \"62358\")]\n    pub fn contains<U>(&self, x: &U) -> bool\n    where\n        U: PartialEq<T>,\n    {\n}\n\n    /// Returns `true` if the result is an [`Err`] value containing the given value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(result_contains_err)]\n    ///\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.contains_err(&\"Some error message\"), false);\n    ///\n    /// let x: Result<u32, &str> = Err(\"Some error message\");\n    /// assert_eq!(x.contains_err(&\"Some error message\"), true);\n    ///\n    /// let x: Result<u32, &str> = Err(\"Some other error message\");\n    /// assert_eq!(x.contains_err(&\"Some error message\"), false);\n    /// ```\n    #[must_use]\n    #[inline]\n    #[unstable(feature = \"result_contains_err\", issue = \"62358\")]\n    pub fn contains_err<F>(&self, f: &F) -> bool\n    where\n        F: PartialEq<E>,\n    {\n}\n\n    /////////////////////////////////////////////////////////////////////////\n    // Adapter for each variant\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Converts from `Result<T, E>` to [`Option<T>`].\n    ///\n    /// Converts `self` into an [`Option<T>`], consuming `self`,\n    /// and discarding the error, if any.\n    ///\n    /// [`Option<T>`]: ../../std/option/enum.Option.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.ok(), Some(2));\n    ///\n    /// let x: Result<u32, &str> = Err(\"Nothing here\");\n    /// assert_eq!(x.ok(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ok(self) -> Option<T> {\n}\n\n    /// Converts from `Result<T, E>` to [`Option<E>`].\n    ///\n    /// Converts `self` into an [`Option<E>`], consuming `self`,\n    /// and discarding the success value, if any.\n    ///\n    /// [`Option<E>`]: ../../std/option/enum.Option.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.err(), None);\n    ///\n    /// let x: Result<u32, &str> = Err(\"Nothing here\");\n    /// assert_eq!(x.err(), Some(\"Nothing here\"));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn err(self) -> Option<E> {\n}\n\n    /////////////////////////////////////////////////////////////////////////\n    // Adapter for working with references\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Converts from `&Result<T, E>` to `Result<&T, &E>`.\n    ///\n    /// Produces a new `Result`, containing a reference\n    /// into the original, leaving the original in place.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.as_ref(), Ok(&2));\n    ///\n    /// let x: Result<u32, &str> = Err(\"Error\");\n    /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n    /// ```\n    #[inline]\n    #[rustc_const_unstable(feature = \"const_result\", issue = \"67520\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn as_ref(&self) -> Result<&T, &E> {\n}\n\n    /// Converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn mutate(r: &mut Result<i32, i32>) {\n    ///     match r.as_mut() {\n    ///         Ok(v) => *v = 42,\n    ///         Err(e) => *e = 0,\n    ///     }\n    /// }\n    ///\n    /// let mut x: Result<i32, i32> = Ok(2);\n    /// mutate(&mut x);\n    /// assert_eq!(x.unwrap(), 42);\n    ///\n    /// let mut x: Result<i32, i32> = Err(13);\n    /// mutate(&mut x);\n    /// assert_eq!(x.unwrap_err(), 0);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_mut(&mut self) -> Result<&mut T, &mut E> {\n}\n\n    /////////////////////////////////////////////////////////////////////////\n    // Transforming contained values\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n    /// contained [`Ok`] value, leaving an [`Err`] value untouched.\n    ///\n    /// This function can be used to compose the results of two functions.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Print the numbers on each line of a string multiplied by two.\n    ///\n    /// ```\n    /// let line = \"1\\n2\\n3\\n4\\n\";\n    ///\n    /// for num in line.lines() {\n    ///     match num.parse::<i32>().map(|i| i * 2) {\n    ///         Ok(n) => println!(\"{}\", n),\n    ///         Err(..) => {}\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map<U, F: FnOnce(T) -> U>(self, op: F) -> Result<U, E> {\n}\n\n    /// Applies a function to the contained value (if any),\n    /// or returns the provided default (if not).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x: Result<_, &str> = Ok(\"foo\");\n    /// assert_eq!(x.map_or(42, |v| v.len()), 3);\n    ///\n    /// let x: Result<&str, _> = Err(\"bar\");\n    /// assert_eq!(x.map_or(42, |v| v.len()), 42);\n    /// ```\n    #[inline]\n    #[stable(feature = \"result_map_or\", since = \"1.41.0\")]\n    pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {\n}\n\n    /// Maps a `Result<T, E>` to `U` by applying a function to a\n    /// contained [`Ok`] value, or a fallback function to a\n    /// contained [`Err`] value.\n    ///\n    /// This function can be used to unpack a successful result\n    /// while handling an error.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let k = 21;\n    ///\n    /// let x : Result<_, &str> = Ok(\"foo\");\n    /// assert_eq!(x.map_or_else(|e| k * 2, |v| v.len()), 3);\n    ///\n    /// let x : Result<&str, _> = Err(\"bar\");\n    /// assert_eq!(x.map_or_else(|e| k * 2, |v| v.len()), 42);\n    /// ```\n    #[inline]\n    #[stable(feature = \"result_map_or_else\", since = \"1.41.0\")]\n    pub fn map_or_else<U, D: FnOnce(E) -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U {\n}\n\n    /// Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n    /// contained [`Err`] value, leaving an [`Ok`] value untouched.\n    ///\n    /// This function can be used to pass through a successful result while handling\n    /// an error.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn stringify(x: u32) -> String { format!(\"error code: {}\", x) }\n    ///\n    /// let x: Result<u32, u32> = Ok(2);\n    /// assert_eq!(x.map_err(stringify), Ok(2));\n    ///\n    /// let x: Result<u32, u32> = Err(13);\n    /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn map_err<F, O: FnOnce(E) -> F>(self, op: O) -> Result<T, F> {\n}\n\n    /////////////////////////////////////////////////////////////////////////\n    // Iterator constructors\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns an iterator over the possibly contained value.\n    ///\n    /// The iterator yields one value if the result is [`Result::Ok`], otherwise none.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(7);\n    /// assert_eq!(x.iter().next(), Some(&7));\n    ///\n    /// let x: Result<u32, &str> = Err(\"nothing!\");\n    /// assert_eq!(x.iter().next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, T> {\n}\n\n    /// Returns a mutable iterator over the possibly contained value.\n    ///\n    /// The iterator yields one value if the result is [`Result::Ok`], otherwise none.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut x: Result<u32, &str> = Ok(7);\n    /// match x.iter_mut().next() {\n    ///     Some(v) => *v = 40,\n    ///     None => {},\n    /// }\n    /// assert_eq!(x, Ok(40));\n    ///\n    /// let mut x: Result<u32, &str> = Err(\"nothing!\");\n    /// assert_eq!(x.iter_mut().next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n}\n\n    ////////////////////////////////////////////////////////////////////////\n    // Boolean operations on the values, eager and lazy\n    /////////////////////////////////////////////////////////////////////////\n\n    /// Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// let y: Result<&str, &str> = Err(\"late error\");\n    /// assert_eq!(x.and(y), Err(\"late error\"));\n    ///\n    /// let x: Result<u32, &str> = Err(\"early error\");\n    /// let y: Result<&str, &str> = Ok(\"foo\");\n    /// assert_eq!(x.and(y), Err(\"early error\"));\n    ///\n    /// let x: Result<u32, &str> = Err(\"not a 2\");\n    /// let y: Result<&str, &str> = Err(\"late error\");\n    /// assert_eq!(x.and(y), Err(\"not a 2\"));\n    ///\n    /// let x: Result<u32, &str> = Ok(2);\n    /// let y: Result<&str, &str> = Ok(\"different result type\");\n    /// assert_eq!(x.and(y), Ok(\"different result type\"));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n}\n\n    /// Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// This function can be used for control flow based on `Result` values.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n    ///\n    /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n    /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n    /// assert_eq!(Ok(2).and_then(err).and_then(sq), Err(2));\n    /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n}\n\n    /// Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n    ///\n    /// Arguments passed to `or` are eagerly evaluated; if you are passing the\n    /// result of a function call, it is recommended to use [`or_else`], which is\n    /// lazily evaluated.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    /// [`or_else`]: #method.or_else\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// let y: Result<u32, &str> = Err(\"late error\");\n    /// assert_eq!(x.or(y), Ok(2));\n    ///\n    /// let x: Result<u32, &str> = Err(\"early error\");\n    /// let y: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.or(y), Ok(2));\n    ///\n    /// let x: Result<u32, &str> = Err(\"not a 2\");\n    /// let y: Result<u32, &str> = Err(\"late error\");\n    /// assert_eq!(x.or(y), Err(\"late error\"));\n    ///\n    /// let x: Result<u32, &str> = Ok(2);\n    /// let y: Result<u32, &str> = Ok(100);\n    /// assert_eq!(x.or(y), Ok(2));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> {\n}\n\n    /// Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n    ///\n    /// This function can be used for control flow based on result values.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n    ///\n    /// assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));\n    /// assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));\n    /// assert_eq!(Err(3).or_else(sq).or_else(err), Ok(9));\n    /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n}\n\n    /// Unwraps a result, yielding the content of an [`Ok`].\n    /// Else, it returns `optb`.\n    ///\n    /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n    /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n    /// which is lazily evaluated.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    /// [`unwrap_or_else`]: #method.unwrap_or_else\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let optb = 2;\n    /// let x: Result<u32, &str> = Ok(9);\n    /// assert_eq!(x.unwrap_or(optb), 9);\n    ///\n    /// let x: Result<u32, &str> = Err(\"error\");\n    /// assert_eq!(x.unwrap_or(optb), optb);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or(self, optb: T) -> T {\n}\n\n    /// Unwraps a result, yielding the content of an [`Ok`].\n    /// If the value is an [`Err`] then it calls `op` with its value.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// fn count(x: &str) -> usize { x.len() }\n    ///\n    /// assert_eq!(Ok(2).unwrap_or_else(count), 2);\n    /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n}\n}\n\nimpl<T: Copy, E> Result<&T, E> {\n    /// Maps a `Result<&T, E>` to a `Result<T, E>` by copying the contents of the\n    /// `Ok` part.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(result_copied)]\n    /// let val = 12;\n    /// let x: Result<&i32, i32> = Ok(&val);\n    /// assert_eq!(x, Ok(&12));\n    /// let copied = x.copied();\n    /// assert_eq!(copied, Ok(12));\n    /// ```\n    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n    pub fn copied(self) -> Result<T, E> {\n}\n}\n\nimpl<T: Copy, E> Result<&mut T, E> {\n    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by copying the contents of the\n    /// `Ok` part.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(result_copied)]\n    /// let mut val = 12;\n    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n    /// assert_eq!(x, Ok(&mut 12));\n    /// let copied = x.copied();\n    /// assert_eq!(copied, Ok(12));\n    /// ```\n    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n    pub fn copied(self) -> Result<T, E> {\n}\n}\n\nimpl<T: Clone, E> Result<&T, E> {\n    /// Maps a `Result<&T, E>` to a `Result<T, E>` by cloning the contents of the\n    /// `Ok` part.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(result_cloned)]\n    /// let val = 12;\n    /// let x: Result<&i32, i32> = Ok(&val);\n    /// assert_eq!(x, Ok(&12));\n    /// let cloned = x.cloned();\n    /// assert_eq!(cloned, Ok(12));\n    /// ```\n    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n    pub fn cloned(self) -> Result<T, E> {\n}\n}\n\nimpl<T: Clone, E> Result<&mut T, E> {\n    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by cloning the contents of the\n    /// `Ok` part.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(result_cloned)]\n    /// let mut val = 12;\n    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n    /// assert_eq!(x, Ok(&mut 12));\n    /// let cloned = x.cloned();\n    /// assert_eq!(cloned, Ok(12));\n    /// ```\n    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n    pub fn cloned(self) -> Result<T, E> {\n}\n}\n\nimpl<T, E: fmt::Debug> Result<T, E> {\n    /// Unwraps a result, yielding the content of an [`Ok`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is an [`Err`], with a panic message provided by the\n    /// [`Err`]'s value.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(2);\n    /// assert_eq!(x.unwrap(), 2);\n    /// ```\n    ///\n    /// ```{.should_panic}\n    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n    /// x.unwrap(); // panics with `emergency failure`\n    /// ```\n    #[inline]\n    #[track_caller]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap(self) -> T {\n}\n\n    /// Unwraps a result, yielding the content of an [`Ok`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is an [`Err`], with a panic message including the\n    /// passed message, and the content of the [`Err`].\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```{.should_panic}\n    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n    /// ```\n    #[inline]\n    #[track_caller]\n    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n    pub fn expect(self, msg: &str) -> T {\n}\n}\n\nimpl<T: fmt::Debug, E> Result<T, E> {\n    /// Unwraps a result, yielding the content of an [`Err`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is an [`Ok`], with a custom panic message provided\n    /// by the [`Ok`]'s value.\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    ///\n    /// # Examples\n    ///\n    /// ```{.should_panic}\n    /// let x: Result<u32, &str> = Ok(2);\n    /// x.unwrap_err(); // panics with `2`\n    /// ```\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n    /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n    /// ```\n    #[inline]\n    #[track_caller]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn unwrap_err(self) -> E {\n}\n\n    /// Unwraps a result, yielding the content of an [`Err`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if the value is an [`Ok`], with a panic message including the\n    /// passed message, and the content of the [`Ok`].\n    ///\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```{.should_panic}\n    /// let x: Result<u32, &str> = Ok(10);\n    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n    /// ```\n    #[inline]\n    #[track_caller]\n    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n    pub fn expect_err(self, msg: &str) -> E {\n}\n}\n\nimpl<T: Default, E> Result<T, E> {\n    /// Returns the contained value or a default\n    ///\n    /// Consumes the `self` argument then, if [`Ok`], returns the contained\n    /// value, otherwise if [`Err`], returns the default value for that\n    /// type.\n    ///\n    /// # Examples\n    ///\n    /// Converts a string to an integer, turning poorly-formed strings\n    /// into 0 (the default value for integers). [`parse`] converts\n    /// a string to any other type that implements [`FromStr`], returning an\n    /// [`Err`] on error.\n    ///\n    /// ```\n    /// let good_year_from_input = \"1909\";\n    /// let bad_year_from_input = \"190blarg\";\n    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n    ///\n    /// assert_eq!(1909, good_year);\n    /// assert_eq!(0, bad_year);\n    /// ```\n    ///\n    /// [`parse`]: ../../std/primitive.str.html#method.parse\n    /// [`FromStr`]: ../../std/str/trait.FromStr.html\n    /// [`Ok`]: enum.Result.html#variant.Ok\n    /// [`Err`]: enum.Result.html#variant.Err\n    #[inline]\n    #[stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")]\n    pub fn unwrap_or_default(self) -> T {\n}\n}\n\n#[unstable(feature = \"unwrap_infallible\", reason = \"newly added\", issue = \"61695\")]\nimpl<T, E: Into<!>> Result<T, E> {\n}\n\n#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\nimpl<T: Deref, E> Result<T, E> {\n}\n\n#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\nimpl<T, E: Deref> Result<T, E> {\n}\n\n#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\nimpl<T: DerefMut, E> Result<T, E> {\n}\n\n#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\nimpl<T, E: DerefMut> Result<T, E> {\n}\n\nimpl<T, E> Result<Option<T>, E> {\n    /// Transposes a `Result` of an `Option` into an `Option` of a `Result`.\n    ///\n    /// `Ok(None)` will be mapped to `None`.\n    /// `Ok(Some(_))` and `Err(_)` will be mapped to `Some(Ok(_))` and `Some(Err(_))`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #[derive(Debug, Eq, PartialEq)]\n    /// struct SomeErr;\n    ///\n    /// let x: Result<Option<i32>, SomeErr> = Ok(Some(5));\n    /// let y: Option<Result<i32, SomeErr>> = Some(Ok(5));\n    /// assert_eq!(x.transpose(), y);\n    /// ```\n    #[inline]\n    #[stable(feature = \"transpose_result\", since = \"1.33.0\")]\n    pub fn transpose(self) -> Option<Result<T, E>> {\n}\n}\n\n// This is a separate function to reduce the code size of the methods\n#[inline(never)]\n#[cold]\n#[track_caller]\nfn unwrap_failed(msg: &str, error: &dyn fmt::Debug) -> ! {\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Trait implementations\n/////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone, E: Clone> Clone for Result<T, E> {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n\n    #[inline]\n    fn clone_from(&mut self, source: &Self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, E> IntoIterator for Result<T, E> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Returns a consuming iterator over the possibly contained value.\n    ///\n    /// The iterator yields one value if the result is [`Result::Ok`], otherwise none.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let x: Result<u32, &str> = Ok(5);\n    /// let v: Vec<u32> = x.into_iter().collect();\n    /// assert_eq!(v, [5]);\n    ///\n    /// let x: Result<u32, &str> = Err(\"nothing!\");\n    /// let v: Vec<u32> = x.into_iter().collect();\n    /// assert_eq!(v, []);\n    /// ```\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n}\n}\n\n#[stable(since = \"1.4.0\", feature = \"result_iter\")]\nimpl<'a, T, E> IntoIterator for &'a Result<T, E> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n}\n}\n\n#[stable(since = \"1.4.0\", feature = \"result_iter\")]\nimpl<'a, T, E> IntoIterator for &'a mut Result<T, E> {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n}\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// The Result Iterators\n/////////////////////////////////////////////////////////////////////////////\n\n/// An iterator over a reference to the [`Ok`] variant of a [`Result`].\n///\n/// The iterator yields one value if the result is [`Ok`], otherwise none.\n///\n/// Created by [`Result::iter`].\n///\n/// [`Ok`]: enum.Result.html#variant.Ok\n/// [`Result`]: enum.Result.html\n/// [`Result::iter`]: enum.Result.html#method.iter\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> {\n    inner: Option<&'a T>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n}\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for Iter<'_, T> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for Iter<'_, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<A> TrustedLen for Iter<'_, A> {}}\npub mod sync {\n//! Synchronization primitives\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\npub mod atomic {\n//! Atomic types\n//!\n//! Atomic types provide primitive shared-memory communication between\n//! threads, and are the building blocks of other concurrent\n//! types.\n//!\n//! This module defines atomic versions of a select number of primitive\n//! types, including [`AtomicBool`], [`AtomicIsize`], [`AtomicUsize`],\n//! [`AtomicI8`], [`AtomicU16`], etc.\n//! Atomic types present operations that, when used correctly, synchronize\n//! updates between threads.\n//!\n//! [`AtomicBool`]: struct.AtomicBool.html\n//! [`AtomicIsize`]: struct.AtomicIsize.html\n//! [`AtomicUsize`]: struct.AtomicUsize.html\n//! [`AtomicI8`]: struct.AtomicI8.html\n//! [`AtomicU16`]: struct.AtomicU16.html\n//!\n//! Each method takes an [`Ordering`] which represents the strength of\n//! the memory barrier for that operation. These orderings are the\n//! same as the [C++20 atomic orderings][1]. For more information see the [nomicon][2].\n//!\n//! [`Ordering`]: enum.Ordering.html\n//!\n//! [1]: https://en.cppreference.com/w/cpp/atomic/memory_order\n//! [2]: ../../../nomicon/atomics.html\n//!\n//! Atomic variables are safe to share between threads (they implement [`Sync`])\n//! but they do not themselves provide the mechanism for sharing and follow the\n//! [threading model](../../../std/thread/index.html#the-threading-model) of Rust.\n//! The most common way to share an atomic variable is to put it into an [`Arc`][arc] (an\n//! atomically-reference-counted shared pointer).\n//!\n//! [`Sync`]: ../../marker/trait.Sync.html\n//! [arc]: ../../../std/sync/struct.Arc.html\n//!\n//! Atomic types may be stored in static variables, initialized using\n//! the constant initializers like [`AtomicBool::new`]. Atomic statics\n//! are often used for lazy global initialization.\n//!\n//! [`AtomicBool::new`]: struct.AtomicBool.html#method.new\n//!\n//! # Portability\n//!\n//! All atomic types in this module are guaranteed to be [lock-free] if they're\n//! available. This means they don't internally acquire a global mutex. Atomic\n//! types and operations are not guaranteed to be wait-free. This means that\n//! operations like `fetch_or` may be implemented with a compare-and-swap loop.\n//!\n//! Atomic operations may be implemented at the instruction layer with\n//! larger-size atomics. For example some platforms use 4-byte atomic\n//! instructions to implement `AtomicI8`. Note that this emulation should not\n//! have an impact on correctness of code, it's just something to be aware of.\n//!\n//! The atomic types in this module may not be available on all platforms. The\n//! atomic types here are all widely available, however, and can generally be\n//! relied upon existing. Some notable exceptions are:\n//!\n//! * PowerPC and MIPS platforms with 32-bit pointers do not have `AtomicU64` or\n//!   `AtomicI64` types.\n//! * ARM platforms like `armv5te` that aren't for Linux do not have any atomics\n//!   at all.\n//! * ARM targets with `thumbv6m` do not have atomic operations at all.\n//!\n//! Note that future platforms may be added that also do not have support for\n//! some atomic operations. Maximally portable code will want to be careful\n//! about which atomic types are used. `AtomicUsize` and `AtomicIsize` are\n//! generally the most portable, but even then they're not available everywhere.\n//! For reference, the `std` library requires pointer-sized atomics, although\n//! `core` does not.\n//!\n//! Currently you'll need to use `#[cfg(target_arch)]` primarily to\n//! conditionally compile in code with atomics. There is an unstable\n//! `#[cfg(target_has_atomic)]` as well which may be stabilized in the future.\n//!\n//! [lock-free]: https://en.wikipedia.org/wiki/Non-blocking_algorithm\n//!\n//! # Examples\n//!\n//! A simple spinlock:\n//!\n//! ```\n//! use std::sync::Arc;\n//! use std::sync::atomic::{AtomicUsize, Ordering};\n//! use std::thread;\n//!\n//! fn main() {\n//!     let spinlock = Arc::new(AtomicUsize::new(1));\n//!\n//!     let spinlock_clone = spinlock.clone();\n//!     let thread = thread::spawn(move|| {\n//!         spinlock_clone.store(0, Ordering::SeqCst);\n//!     });\n//!\n//!     // Wait for the other thread to release the lock\n//!     while spinlock.load(Ordering::SeqCst) != 0 {}\n//!\n//!     if let Err(panic) = thread.join() {\n//!         println!(\"Thread had an error: {:?}\", panic);\n//!     }\n//! }\n//! ```\n//!\n//! Keep a global count of live threads:\n//!\n//! ```\n//! use std::sync::atomic::{AtomicUsize, Ordering};\n//!\n//! static GLOBAL_THREAD_COUNT: AtomicUsize = AtomicUsize::new(0);\n//!\n//! let old_thread_count = GLOBAL_THREAD_COUNT.fetch_add(1, Ordering::SeqCst);\n//! println!(\"live threads: {}\", old_thread_count + 1);\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]\n\nuse self::Ordering::*;\n\nuse crate::cell::UnsafeCell;\nuse crate::fmt;\nuse crate::intrinsics;\n\nuse crate::hint::spin_loop;\n\n/// Signals the processor that it is inside a busy-wait spin-loop (\"spin lock\").\n///\n/// Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving\n/// power or switching hyper-threads.\n///\n/// This function is different from [`std::thread::yield_now`] which directly yields to the\n/// system's scheduler, whereas `spin_loop_hint` does not interact with the operating system.\n///\n/// A common use case for `spin_loop_hint` is implementing bounded optimistic spinning in a CAS\n/// loop in synchronization primitives. To avoid problems like priority inversion, it is strongly\n/// recommended that the spin loop is terminated after a finite amount of iterations and an\n/// appropriate blocking syscall is made.\n///\n/// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n/// do anything at all.\n///\n/// [`std::thread::yield_now`]: ../../../std/thread/fn.yield_now.html\n/// [`std::thread::sleep`]: ../../../std/thread/fn.sleep.html\n/// [`std::sync::Mutex`]: ../../../std/sync/struct.Mutex.html\n#[inline]\n#[stable(feature = \"spin_loop_hint\", since = \"1.24.0\")]\npub fn spin_loop_hint() {\n}\n\n/// A boolean type which can be safely shared between threads.\n///\n/// This type has the same in-memory representation as a [`bool`].\n///\n/// [`bool`]: ../../../std/primitive.bool.html\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[repr(C, align(1))]\npub struct AtomicBool {\n    v: UnsafeCell<u8>,\n}\n\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Default for AtomicBool {\n    /// Creates an `AtomicBool` initialized to `false`.\n    fn default() -> Self {\n}\n}\n\n// Send is implicitly implemented for AtomicBool.\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl Sync for AtomicBool {}\n\n/// A raw pointer type which can be safely shared between threads.\n///\n/// This type has the same in-memory representation as a `*mut T`.\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[cfg_attr(target_pointer_width = \"16\", repr(C, align(2)))]\n#[cfg_attr(target_pointer_width = \"32\", repr(C, align(4)))]\n#[cfg_attr(target_pointer_width = \"64\", repr(C, align(8)))]\npub struct AtomicPtr<T> {\n    p: UnsafeCell<*mut T>,\n}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for AtomicPtr<T> {\n    /// Creates a null `AtomicPtr<T>`.\n    fn default() -> AtomicPtr<T> {\n}\n}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T> Send for AtomicPtr<T> {}\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T> Sync for AtomicPtr<T> {}\n\n/// Atomic memory orderings\n///\n/// Memory orderings specify the way atomic operations synchronize memory.\n/// In its weakest [`Relaxed`][Ordering::Relaxed], only the memory directly touched by the\n/// operation is synchronized. On the other hand, a store-load pair of [`SeqCst`][Ordering::SeqCst]\n/// operations synchronize other memory while additionally preserving a total order of such\n/// operations across all threads.\n///\n/// Rust's memory orderings are [the same as those of\n/// C++20](https://en.cppreference.com/w/cpp/atomic/memory_order).\n///\n/// For more information see the [nomicon].\n///\n/// [nomicon]: ../../../nomicon/atomics.html\n/// [Ordering::Relaxed]: #variant.Relaxed\n/// [Ordering::SeqCst]: #variant.SeqCst\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n#[non_exhaustive]\npub enum Ordering {\n    /// No ordering constraints, only atomic operations.\n    ///\n    /// Corresponds to [`memory_order_relaxed`] in C++20.\n    ///\n    /// [`memory_order_relaxed`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Relaxed_ordering\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Relaxed,\n    /// When coupled with a store, all previous operations become ordered\n    /// before any load of this value with [`Acquire`] (or stronger) ordering.\n    /// In particular, all previous writes become visible to all threads\n    /// that perform an [`Acquire`] (or stronger) load of this value.\n    ///\n    /// Notice that using this ordering for an operation that combines loads\n    /// and stores leads to a [`Relaxed`] load operation!\n    ///\n    /// This ordering is only applicable for operations that can perform a store.\n    ///\n    /// Corresponds to [`memory_order_release`] in C++20.\n    ///\n    /// [`Release`]: #variant.Release\n    /// [`Acquire`]: #variant.Acquire\n    /// [`Relaxed`]: #variant.Relaxed\n    /// [`memory_order_release`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Release,\n    /// When coupled with a load, if the loaded value was written by a store operation with\n    /// [`Release`] (or stronger) ordering, then all subsequent operations\n    /// become ordered after that store. In particular, all subsequent loads will see data\n    /// written before the store.\n    ///\n    /// Notice that using this ordering for an operation that combines loads\n    /// and stores leads to a [`Relaxed`] store operation!\n    ///\n    /// This ordering is only applicable for operations that can perform a load.\n    ///\n    /// Corresponds to [`memory_order_acquire`] in C++20.\n    ///\n    /// [`Acquire`]: #variant.Acquire\n    /// [`Release`]: #variant.Release\n    /// [`Relaxed`]: #variant.Relaxed\n    /// [`memory_order_acquire`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Acquire,\n    /// Has the effects of both [`Acquire`] and [`Release`] together:\n    /// For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n    ///\n    /// Notice that in the case of `compare_and_swap`, it is possible that the operation ends up\n    /// not performing any store and hence it has just [`Acquire`] ordering. However,\n    /// `AcqRel` will never perform [`Relaxed`] accesses.\n    ///\n    /// This ordering is only applicable for operations that combine both loads and stores.\n    ///\n    /// Corresponds to [`memory_order_acq_rel`] in C++20.\n    ///\n    /// [`memory_order_acq_rel`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n    /// [`Acquire`]: #variant.Acquire\n    /// [`Release`]: #variant.Release\n    /// [`Relaxed`]: #variant.Relaxed\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    AcqRel,\n    /// Like [`Acquire`]/[`Release`]/[`AcqRel`] (for load, store, and load-with-store\n    /// operations, respectively) with the additional guarantee that all threads see all\n    /// sequentially consistent operations in the same order.\n    ///\n    /// Corresponds to [`memory_order_seq_cst`] in C++20.\n    ///\n    /// [`memory_order_seq_cst`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Sequentially-consistent_ordering\n    /// [`Acquire`]: #variant.Acquire\n    /// [`Release`]: #variant.Release\n    /// [`AcqRel`]: #variant.AcqRel\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    SeqCst,\n}\n\n/// An [`AtomicBool`] initialized to `false`.\n///\n/// [`AtomicBool`]: struct.AtomicBool.html\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"1.34.0\",\n    reason = \"the `new` function is now preferred\",\n    suggestion = \"AtomicBool::new(false)\"\n)]\npub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n\n#[cfg(target_has_atomic_load_store = \"8\")]\nimpl AtomicBool {\n    /// Creates a new `AtomicBool`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicBool;\n    ///\n    /// let atomic_true  = AtomicBool::new(true);\n    /// let atomic_false = AtomicBool::new(false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_atomic_new\", since = \"1.32.0\")]\n    pub const fn new(v: bool) -> AtomicBool {\n}\n\n    /// Returns a mutable reference to the underlying [`bool`].\n    ///\n    /// This is safe because the mutable reference guarantees that no other threads are\n    /// concurrently accessing the atomic data.\n    ///\n    /// [`bool`]: ../../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let mut some_bool = AtomicBool::new(true);\n    /// assert_eq!(*some_bool.get_mut(), true);\n    /// *some_bool.get_mut() = false;\n    /// assert_eq!(some_bool.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n    pub fn get_mut(&mut self) -> &mut bool {\n}\n\n    /// Consumes the atomic and returns the contained value.\n    ///\n    /// This is safe because passing `self` by value guarantees that no other threads are\n    /// concurrently accessing the atomic data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicBool;\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    /// assert_eq!(some_bool.into_inner(), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n    pub fn into_inner(self) -> bool {\n}\n\n    /// Loads a value from the bool.\n    ///\n    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `order` is [`Release`] or [`AcqRel`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn load(&self, order: Ordering) -> bool {\n}\n\n    /// Stores a value into the bool.\n    ///\n    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// some_bool.store(false, Ordering::Relaxed);\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn store(&self, val: bool, order: Ordering) {\n}\n\n    /// Stores a value into the bool, returning the previous value.\n    ///\n    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. All ordering modes are possible. Note that using\n    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n    /// using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// assert_eq!(some_bool.swap(false, Ordering::Relaxed), true);\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn swap(&self, val: bool, order: Ordering) -> bool {\n}\n\n    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n    ///\n    /// The return value is always the previous value. If it is equal to `current`, then the value\n    /// was updated.\n    ///\n    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n    /// ordering of this operation. Notice that even when using [`AcqRel`], the operation\n    /// might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n    /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n    /// happens, and using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n    /// [`bool`]: ../../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// assert_eq!(some_bool.compare_and_swap(true, false, Ordering::Relaxed), true);\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    ///\n    /// assert_eq!(some_bool.compare_and_swap(true, true, Ordering::Relaxed), false);\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n}\n\n    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n    ///\n    /// The return value is a result indicating whether the new value was written and containing\n    /// the previous value. On success this value is guaranteed to be equal to `current`.\n    ///\n    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. The first describes the required ordering if the\n    /// operation succeeds while the second describes the required ordering when the\n    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n    /// and must be equivalent to or weaker than the success ordering.\n    ///\n    ///\n    /// [`bool`]: ../../../std/primitive.bool.html\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let some_bool = AtomicBool::new(true);\n    ///\n    /// assert_eq!(some_bool.compare_exchange(true,\n    ///                                       false,\n    ///                                       Ordering::Acquire,\n    ///                                       Ordering::Relaxed),\n    ///            Ok(true));\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    ///\n    /// assert_eq!(some_bool.compare_exchange(true, true,\n    ///                                       Ordering::SeqCst,\n    ///                                       Ordering::Acquire),\n    ///            Err(false));\n    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn compare_exchange(\n        &self,\n        current: bool,\n        new: bool,\n        success: Ordering,\n        failure: Ordering,\n    ) -> Result<bool, bool> {\n}\n\n    /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n    ///\n    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n    /// comparison succeeds, which can result in more efficient code on some platforms. The\n    /// return value is a result indicating whether the new value was written and containing the\n    /// previous value.\n    ///\n    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. The first describes the required ordering if the\n    /// operation succeeds while the second describes the required ordering when the\n    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n    /// and must be equivalent to or weaker than the success ordering.\n    ///\n    /// [`bool`]: ../../../std/primitive.bool.html\n    /// [`compare_exchange`]: #method.compare_exchange\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let val = AtomicBool::new(false);\n    ///\n    /// let new = true;\n    /// let mut old = val.load(Ordering::Relaxed);\n    /// loop {\n    ///     match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n    ///         Ok(_) => break,\n    ///         Err(x) => old = x,\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn compare_exchange_weak(\n        &self,\n        current: bool,\n        new: bool,\n        success: Ordering,\n        failure: Ordering,\n    ) -> Result<bool, bool> {\n}\n\n    /// Logical \"and\" with a boolean value.\n    ///\n    /// Performs a logical \"and\" operation on the current value and the argument `val`, and sets\n    /// the new value to the result.\n    ///\n    /// Returns the previous value.\n    ///\n    /// `fetch_and` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. All ordering modes are possible. Note that using\n    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n    /// using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_and(false, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_and(true, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(false);\n    /// assert_eq!(foo.fetch_and(false, Ordering::SeqCst), false);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n}\n\n    /// Logical \"nand\" with a boolean value.\n    ///\n    /// Performs a logical \"nand\" operation on the current value and the argument `val`, and sets\n    /// the new value to the result.\n    ///\n    /// Returns the previous value.\n    ///\n    /// `fetch_nand` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. All ordering modes are possible. Note that using\n    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n    /// using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_nand(false, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_nand(true, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst) as usize, 0);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    ///\n    /// let foo = AtomicBool::new(false);\n    /// assert_eq!(foo.fetch_nand(false, Ordering::SeqCst), false);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n}\n\n    /// Logical \"or\" with a boolean value.\n    ///\n    /// Performs a logical \"or\" operation on the current value and the argument `val`, and sets the\n    /// new value to the result.\n    ///\n    /// Returns the previous value.\n    ///\n    /// `fetch_or` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. All ordering modes are possible. Note that using\n    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n    /// using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_or(false, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_or(true, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(false);\n    /// assert_eq!(foo.fetch_or(false, Ordering::SeqCst), false);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n}\n\n    /// Logical \"xor\" with a boolean value.\n    ///\n    /// Performs a logical \"xor\" operation on the current value and the argument `val`, and sets\n    /// the new value to the result.\n    ///\n    /// Returns the previous value.\n    ///\n    /// `fetch_xor` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. All ordering modes are possible. Note that using\n    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n    /// using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicBool, Ordering};\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_xor(false, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), true);\n    ///\n    /// let foo = AtomicBool::new(true);\n    /// assert_eq!(foo.fetch_xor(true, Ordering::SeqCst), true);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    ///\n    /// let foo = AtomicBool::new(false);\n    /// assert_eq!(foo.fetch_xor(false, Ordering::SeqCst), false);\n    /// assert_eq!(foo.load(Ordering::SeqCst), false);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"8\")]\n    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n}\n\n    /// Returns a mutable pointer to the underlying [`bool`].\n    ///\n    /// Doing non-atomic reads and writes on the resulting integer can be a data race.\n    /// This method is mostly useful for FFI, where the function signature may use\n    /// `*mut bool` instead of `&AtomicBool`.\n    ///\n    /// Returning an `*mut` pointer from a shared reference to this atomic is safe because the\n    /// atomic types work with interior mutability. All modifications of an atomic change the value\n    /// through a shared reference, and can do so safely as long as they use atomic operations. Any\n    /// use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n    /// restriction: operations on it must be atomic.\n    ///\n    /// [`bool`]: ../../../std/primitive.bool.html\n    ///\n    /// # Examples\n    ///\n    /// ```ignore (extern-declaration)\n    /// # fn main() {\n    /// use std::sync::atomic::AtomicBool;\n    /// extern {\n    ///     fn my_atomic_op(arg: *mut bool);\n    /// }\n    ///\n    /// let mut atomic = AtomicBool::new(true);\n    /// unsafe {\n    ///     my_atomic_op(atomic.as_mut_ptr());\n    /// }\n    /// # }\n    /// ```\n    #[inline]\n    #[unstable(feature = \"atomic_mut_ptr\", reason = \"recently added\", issue = \"66893\")]\n    pub fn as_mut_ptr(&self) -> *mut bool {\n}\n}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\nimpl<T> AtomicPtr<T> {\n    /// Creates a new `AtomicPtr`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicPtr;\n    ///\n    /// let ptr = &mut 5;\n    /// let atomic_ptr  = AtomicPtr::new(ptr);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_atomic_new\", since = \"1.32.0\")]\n    pub const fn new(p: *mut T) -> AtomicPtr<T> {\n}\n\n    /// Returns a mutable reference to the underlying pointer.\n    ///\n    /// This is safe because the mutable reference guarantees that no other threads are\n    /// concurrently accessing the atomic data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let mut atomic_ptr = AtomicPtr::new(&mut 10);\n    /// *atomic_ptr.get_mut() = &mut 5;\n    /// assert_eq!(unsafe { *atomic_ptr.load(Ordering::SeqCst) }, 5);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n    pub fn get_mut(&mut self) -> &mut *mut T {\n}\n\n    /// Consumes the atomic and returns the contained value.\n    ///\n    /// This is safe because passing `self` by value guarantees that no other threads are\n    /// concurrently accessing the atomic data.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicPtr;\n    ///\n    /// let atomic_ptr = AtomicPtr::new(&mut 5);\n    /// assert_eq!(unsafe { *atomic_ptr.into_inner() }, 5);\n    /// ```\n    #[inline]\n    #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n    pub fn into_inner(self) -> *mut T {\n}\n\n    /// Loads a value from the pointer.\n    ///\n    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `order` is [`Release`] or [`AcqRel`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let value = some_ptr.load(Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn load(&self, order: Ordering) -> *mut T {\n}\n\n    /// Stores a value into the pointer.\n    ///\n    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n    ///\n    /// # Panics\n    ///\n    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let other_ptr = &mut 10;\n    ///\n    /// some_ptr.store(other_ptr, Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn store(&self, ptr: *mut T, order: Ordering) {\n}\n\n    /// Stores a value into the pointer, returning the previous value.\n    ///\n    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n    /// of this operation. All ordering modes are possible. Note that using\n    /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n    /// using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let other_ptr = &mut 10;\n    ///\n    /// let value = some_ptr.swap(other_ptr, Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"ptr\")]\n    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n}\n\n    /// Stores a value into the pointer if the current value is the same as the `current` value.\n    ///\n    /// The return value is always the previous value. If it is equal to `current`, then the value\n    /// was updated.\n    ///\n    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n    /// ordering of this operation. Notice that even when using [`AcqRel`], the operation\n    /// might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n    /// Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n    /// happens, and using [`Release`] makes the load part [`Relaxed`].\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let other_ptr   = &mut 10;\n    ///\n    /// let value = some_ptr.compare_and_swap(ptr, other_ptr, Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[cfg(target_has_atomic = \"ptr\")]\n    pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n}\n\n    /// Stores a value into the pointer if the current value is the same as the `current` value.\n    ///\n    /// The return value is a result indicating whether the new value was written and containing\n    /// the previous value. On success this value is guaranteed to be equal to `current`.\n    ///\n    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. The first describes the required ordering if the\n    /// operation succeeds while the second describes the required ordering when the\n    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n    /// and must be equivalent to or weaker than the success ordering.\n    ///\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let ptr = &mut 5;\n    /// let some_ptr  = AtomicPtr::new(ptr);\n    ///\n    /// let other_ptr   = &mut 10;\n    ///\n    /// let value = some_ptr.compare_exchange(ptr, other_ptr,\n    ///                                       Ordering::SeqCst, Ordering::Relaxed);\n    /// ```\n    #[inline]\n    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n    #[cfg(target_has_atomic = \"ptr\")]\n    pub fn compare_exchange(\n        &self,\n        current: *mut T,\n        new: *mut T,\n        success: Ordering,\n        failure: Ordering,\n    ) -> Result<*mut T, *mut T> {\n}\n\n    /// Stores a value into the pointer if the current value is the same as the `current` value.\n    ///\n    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n    /// comparison succeeds, which can result in more efficient code on some platforms. The\n    /// return value is a result indicating whether the new value was written and containing the\n    /// previous value.\n    ///\n    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n    /// ordering of this operation. The first describes the required ordering if the\n    /// operation succeeds while the second describes the required ordering when the\n    /// operation fails. Using [`Acquire`] as success ordering makes the store part\n    /// of this operation [`Relaxed`], and using [`Release`] makes the successful load\n    /// [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n    /// and must be equivalent to or weaker than the success ordering.\n    ///\n    /// [`compare_exchange`]: #method.compare_exchange\n    /// [`Ordering`]: enum.Ordering.html\n    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n    /// [`Release`]: enum.Ordering.html#variant.Release\n    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::{AtomicPtr, Ordering};\n    ///\n    /// let some_ptr = AtomicPtr::new(&mut 5);\n    ///\n    /// let new = &mut 10;\n    /// let mut old = some_ptr.load(Ordering::Relaxed);\n    /// loop {\n    ///     match some_ptr.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n    ///         Ok(_) => break,\n    ///         Err(x) => old = x,\n    ///     }\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n    #[cfg(target_has_atomic = \"ptr\")]\n    pub fn compare_exchange_weak(\n        &self,\n        current: *mut T,\n        new: *mut T,\n        success: Ordering,\n        failure: Ordering,\n    ) -> Result<*mut T, *mut T> {\n}\n}\n\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\nimpl From<bool> for AtomicBool {\n    /// Converts a `bool` into an `AtomicBool`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::sync::atomic::AtomicBool;\n    /// let atomic_bool = AtomicBool::from(true);\n    /// assert_eq!(format!(\"{:?}\", atomic_bool), \"true\")\n    /// ```\n    #[inline]\n    fn from(b: bool) -> Self {\n}\n}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"atomic_from\", since = \"1.23.0\")]\nimpl<T> From<*mut T> for AtomicPtr<T> {\n    #[inline]\n    fn from(p: *mut T) -> Self {\n}\n}\n\n#[cfg(target_has_atomic_load_store = \"8\")]\nmacro_rules! atomic_int {\n    ($cfg_cas:meta,\n     $stable:meta,\n     $stable_cxchg:meta,\n     $stable_debug:meta,\n     $stable_access:meta,\n     $stable_from:meta,\n     $stable_nand:meta,\n     $const_stable:meta,\n     $stable_init_const:meta,\n     $s_int_type:expr, $int_ref:expr,\n     $extra_feature:expr,\n     $min_fn:ident, $max_fn:ident,\n     $align:expr,\n     $atomic_new:expr,\n     $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n        /// An integer type which can be safely shared between threads.\n        ///\n        /// This type has the same in-memory representation as the underlying\n        /// integer type, [`\n        #[doc = $s_int_type]\n        /// `](\n        #[doc = $int_ref]\n        /// ). For more about the differences between atomic types and\n        /// non-atomic types as well as information about the portability of\n        /// this type, please see the [module-level documentation].\n        ///\n        /// [module-level documentation]: index.html\n        #[$stable]\n        #[repr(C, align($align))]\n        pub struct $atomic_type {\n            v: UnsafeCell<$int_type>,\n        }\n\n        /// An atomic integer initialized to `0`.\n        #[$stable_init_const]\n        #[rustc_deprecated(\n            since = \"1.34.0\",\n            reason = \"the `new` function is now preferred\",\n            suggestion = $atomic_new,\n        )]\n        pub const $atomic_init: $atomic_type = $atomic_type::new(0);\n\n        #[$stable]\n        impl Default for $atomic_type {\n            fn default() -> Self {\n}\n        }\n\n        #[$stable_from]\n        impl From<$int_type> for $atomic_type {\n            doc_comment! {\n                concat!(\n\"Converts an `\", stringify!($int_type), \"` into an `\", stringify!($atomic_type), \"`.\"),\n                #[inline]\n                fn from(v: $int_type) -> Self { }\n            }\n        }\n\n        #[$stable_debug]\n        impl fmt::Debug for $atomic_type {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n        }\n\n        // Send is implicitly implemented.\n        #[$stable]\n        unsafe impl Sync for $atomic_type {}\n\n        impl $atomic_type {\n            doc_comment! {\n                concat!(\"Creates a new atomic integer.\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n\nlet atomic_forty_two = \", stringify!($atomic_type), \"::new(42);\n```\"),\n                #[inline]\n                #[$stable]\n                #[$const_stable]\n                pub const fn new(v: $int_type) -> Self {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Returns a mutable reference to the underlying integer.\n\nThis is safe because the mutable reference guarantees that no other threads are\nconcurrently accessing the atomic data.\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet mut some_var = \", stringify!($atomic_type), \"::new(10);\nassert_eq!(*some_var.get_mut(), 10);\n*some_var.get_mut() = 5;\nassert_eq!(some_var.load(Ordering::SeqCst), 5);\n```\"),\n                #[inline]\n                #[$stable_access]\n                pub fn get_mut(&mut self) -> &mut $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Consumes the atomic and returns the contained value.\n\nThis is safe because passing `self` by value guarantees that no other threads are\nconcurrently accessing the atomic data.\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::\", stringify!($atomic_type), \";\n\nlet some_var = \", stringify!($atomic_type), \"::new(5);\nassert_eq!(some_var.into_inner(), 5);\n```\"),\n                #[inline]\n                #[$stable_access]\n                pub fn into_inner(self) -> $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Loads a value from the atomic integer.\n\n`load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\nPossible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n# Panics\n\nPanics if `order` is [`Release`] or [`AcqRel`].\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet some_var = \", stringify!($atomic_type), \"::new(5);\n\nassert_eq!(some_var.load(Ordering::Relaxed), 5);\n```\"),\n                #[inline]\n                #[$stable]\n                pub fn load(&self, order: Ordering) -> $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Stores a value into the atomic integer.\n\n`store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n# Panics\n\nPanics if `order` is [`Acquire`] or [`AcqRel`].\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet some_var = \", stringify!($atomic_type), \"::new(5);\n\nsome_var.store(10, Ordering::Relaxed);\nassert_eq!(some_var.load(Ordering::Relaxed), 10);\n```\"),\n                #[inline]\n                #[$stable]\n                pub fn store(&self, val: $int_type, order: Ordering) {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Stores a value into the atomic integer, returning the previous value.\n\n`swap` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet some_var = \", stringify!($atomic_type), \"::new(5);\n\nassert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n```\"),\n                #[inline]\n                #[$stable]\n                #[$cfg_cas]\n                pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Stores a value into the atomic integer if the current value is the same as\nthe `current` value.\n\nThe return value is always the previous value. If it is equal to `current`, then the\nvalue was updated.\n\n`compare_and_swap` also takes an [`Ordering`] argument which describes the memory\nordering of this operation. Notice that even when using [`AcqRel`], the operation\nmight fail and hence just perform an `Acquire` load, but not have `Release` semantics.\nUsing [`Acquire`] makes the store part of this operation [`Relaxed`] if it\nhappens, and using [`Release`] makes the load part [`Relaxed`].\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet some_var = \", stringify!($atomic_type), \"::new(5);\n\nassert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\nassert_eq!(some_var.load(Ordering::Relaxed), 10);\n\nassert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\nassert_eq!(some_var.load(Ordering::Relaxed), 10);\n```\"),\n                #[inline]\n                #[$stable]\n                #[$cfg_cas]\n                pub fn compare_and_swap(&self,\n                                        current: $int_type,\n                                        new: $int_type,\n                                        order: Ordering) -> $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Stores a value into the atomic integer if the current value is the same as\nthe `current` value.\n\nThe return value is a result indicating whether the new value was written and\ncontaining the previous value. On success this value is guaranteed to be equal to\n`current`.\n\n`compare_exchange` takes two [`Ordering`] arguments to describe the memory\nordering of this operation. The first describes the required ordering if the\noperation succeeds while the second describes the required ordering when the\noperation fails. Using [`Acquire`] as success ordering makes the store part\nof this operation [`Relaxed`], and using [`Release`] makes the successful load\n[`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\nand must be equivalent to or weaker than the success ordering.\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet some_var = \", stringify!($atomic_type), \"::new(5);\n\nassert_eq!(some_var.compare_exchange(5, 10,\n                                     Ordering::Acquire,\n                                     Ordering::Relaxed),\n           Ok(5));\nassert_eq!(some_var.load(Ordering::Relaxed), 10);\n\nassert_eq!(some_var.compare_exchange(6, 12,\n                                     Ordering::SeqCst,\n                                     Ordering::Acquire),\n           Err(10));\nassert_eq!(some_var.load(Ordering::Relaxed), 10);\n```\"),\n                #[inline]\n                #[$stable_cxchg]\n                #[$cfg_cas]\n                pub fn compare_exchange(&self,\n                                        current: $int_type,\n                                        new: $int_type,\n                                        success: Ordering,\n                                        failure: Ordering) -> Result<$int_type, $int_type> {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Stores a value into the atomic integer if the current value is the same as\nthe `current` value.\n\nUnlike [`compare_exchange`], this function is allowed to spuriously fail even\nwhen the comparison succeeds, which can result in more efficient code on some\nplatforms. The return value is a result indicating whether the new value was\nwritten and containing the previous value.\n\n`compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\nordering of this operation. The first describes the required ordering if the\noperation succeeds while the second describes the required ordering when the\noperation fails. Using [`Acquire`] as success ordering makes the store part\nof this operation [`Relaxed`], and using [`Release`] makes the successful load\n[`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\nand must be equivalent to or weaker than the success ordering.\n\n[`compare_exchange`]: #method.compare_exchange\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet val = \", stringify!($atomic_type), \"::new(4);\n\nlet mut old = val.load(Ordering::Relaxed);\nloop {\n    let new = old * 2;\n    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n        Ok(_) => break,\n        Err(x) => old = x,\n    }\n}\n```\"),\n                #[inline]\n                #[$stable_cxchg]\n                #[$cfg_cas]\n                pub fn compare_exchange_weak(&self,\n                                             current: $int_type,\n                                             new: $int_type,\n                                             success: Ordering,\n                                             failure: Ordering) -> Result<$int_type, $int_type> {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Adds to the current value, returning the previous value.\n\nThis operation wraps around on overflow.\n\n`fetch_add` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet foo = \", stringify!($atomic_type), \"::new(0);\nassert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\nassert_eq!(foo.load(Ordering::SeqCst), 10);\n```\"),\n                #[inline]\n                #[$stable]\n                #[$cfg_cas]\n                pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Subtracts from the current value, returning the previous value.\n\nThis operation wraps around on overflow.\n\n`fetch_sub` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet foo = \", stringify!($atomic_type), \"::new(20);\nassert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\nassert_eq!(foo.load(Ordering::SeqCst), 10);\n```\"),\n                #[inline]\n                #[$stable]\n                #[$cfg_cas]\n                pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Bitwise \\\"and\\\" with the current value.\n\nPerforms a bitwise \\\"and\\\" operation on the current value and the argument `val`, and\nsets the new value to the result.\n\nReturns the previous value.\n\n`fetch_and` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet foo = \", stringify!($atomic_type), \"::new(0b101101);\nassert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);\nassert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n```\"),\n                #[inline]\n                #[$stable]\n                #[$cfg_cas]\n                pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Bitwise \\\"nand\\\" with the current value.\n\nPerforms a bitwise \\\"nand\\\" operation on the current value and the argument `val`, and\nsets the new value to the result.\n\nReturns the previous value.\n\n`fetch_nand` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n\n# Examples\n\n```\n\", $extra_feature, \"\nuse std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet foo = \", stringify!($atomic_type), \"::new(0x13);\nassert_eq!(foo.fetch_nand(0x31, Ordering::SeqCst), 0x13);\nassert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n```\"),\n                #[inline]\n                #[$stable_nand]\n                #[$cfg_cas]\n                pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Bitwise \\\"or\\\" with the current value.\n\nPerforms a bitwise \\\"or\\\" operation on the current value and the argument `val`, and\nsets the new value to the result.\n\nReturns the previous value.\n\n`fetch_or` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet foo = \", stringify!($atomic_type), \"::new(0b101101);\nassert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\nassert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n```\"),\n                #[inline]\n                #[$stable]\n                #[$cfg_cas]\n                pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Bitwise \\\"xor\\\" with the current value.\n\nPerforms a bitwise \\\"xor\\\" operation on the current value and the argument `val`, and\nsets the new value to the result.\n\nReturns the previous value.\n\n`fetch_xor` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n\n# Examples\n\n```\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet foo = \", stringify!($atomic_type), \"::new(0b101101);\nassert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);\nassert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n```\"),\n                #[inline]\n                #[$stable]\n                #[$cfg_cas]\n                pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Fetches the value, and applies a function to it that returns an optional\nnew value. Returns a `Result` of `Ok(previous_value)` if the function returned `Some(_)`, else\n`Err(previous_value)`.\n\nNote: This may call the function multiple times if the value has been changed from other threads in\nthe meantime, as long as the function returns `Some(_)`, but the function will have been applied\nbut once to the stored value.\n\n`fetch_update` takes two [`Ordering`] arguments to describe the memory\nordering of this operation. The first describes the required ordering for loads\nand failed updates while the second describes the required ordering when the\noperation finally succeeds. Beware that this is different from the two\nmodes in [`compare_exchange`]!\n\nUsing [`Acquire`] as success ordering makes the store part\nof this operation [`Relaxed`], and using [`Release`] makes the final successful load\n[`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\nand must be equivalent to or weaker than the success ordering.\n\n[`bool`]: ../../../std/primitive.bool.html\n[`compare_exchange`]: #method.compare_exchange\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n\n# Examples\n\n```rust\n#![feature(no_more_cas)]\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet x = \", stringify!($atomic_type), \"::new(7);\nassert_eq!(x.fetch_update(|_| None, Ordering::SeqCst, Ordering::SeqCst), Err(7));\nassert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(7));\nassert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(8));\nassert_eq!(x.load(Ordering::SeqCst), 9);\n```\"),\n                #[inline]\n                #[unstable(feature = \"no_more_cas\",\n                       reason = \"no more CAS loops in user code\",\n                       issue = \"48655\")]\n                #[$cfg_cas]\n                pub fn fetch_update<F>(&self,\n                                       mut f: F,\n                                       fetch_order: Ordering,\n                                       set_order: Ordering) -> Result<$int_type, $int_type>\n                where F: FnMut($int_type) -> Option<$int_type> {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Maximum with the current value.\n\nFinds the maximum of the current value and the argument `val`, and\nsets the new value to the result.\n\nReturns the previous value.\n\n`fetch_max` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n\n# Examples\n\n```\n#![feature(atomic_min_max)]\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet foo = \", stringify!($atomic_type), \"::new(23);\nassert_eq!(foo.fetch_max(42, Ordering::SeqCst), 23);\nassert_eq!(foo.load(Ordering::SeqCst), 42);\n```\n\nIf you want to obtain the maximum value in one step, you can use the following:\n\n```\n#![feature(atomic_min_max)]\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet foo = \", stringify!($atomic_type), \"::new(23);\nlet bar = 42;\nlet max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\nassert!(max_foo == 42);\n```\"),\n                #[inline]\n                #[unstable(feature = \"atomic_min_max\",\n                       reason = \"easier and faster min/max than writing manual CAS loop\",\n                       issue = \"48655\")]\n                #[$cfg_cas]\n                pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Minimum with the current value.\n\nFinds the minimum of the current value and the argument `val`, and\nsets the new value to the result.\n\nReturns the previous value.\n\n`fetch_min` takes an [`Ordering`] argument which describes the memory ordering\nof this operation. All ordering modes are possible. Note that using\n[`Acquire`] makes the store part of this operation [`Relaxed`], and\nusing [`Release`] makes the load part [`Relaxed`].\n\n[`Ordering`]: enum.Ordering.html\n[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n[`Release`]: enum.Ordering.html#variant.Release\n[`Acquire`]: enum.Ordering.html#variant.Acquire\n\n# Examples\n\n```\n#![feature(atomic_min_max)]\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet foo = \", stringify!($atomic_type), \"::new(23);\nassert_eq!(foo.fetch_min(42, Ordering::Relaxed), 23);\nassert_eq!(foo.load(Ordering::Relaxed), 23);\nassert_eq!(foo.fetch_min(22, Ordering::Relaxed), 23);\nassert_eq!(foo.load(Ordering::Relaxed), 22);\n```\n\nIf you want to obtain the minimum value in one step, you can use the following:\n\n```\n#![feature(atomic_min_max)]\n\", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n\nlet foo = \", stringify!($atomic_type), \"::new(23);\nlet bar = 12;\nlet min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\nassert_eq!(min_foo, 12);\n```\"),\n                #[inline]\n                #[unstable(feature = \"atomic_min_max\",\n                       reason = \"easier and faster min/max than writing manual CAS loop\",\n                       issue = \"48655\")]\n                #[$cfg_cas]\n                pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n}\n            }\n\n            doc_comment! {\n                concat!(\"Returns a mutable pointer to the underlying integer.\n\nDoing non-atomic reads and writes on the resulting integer can be a data race.\nThis method is mostly useful for FFI, where the function signature may use\n`*mut \", stringify!($int_type), \"` instead of `&\", stringify!($atomic_type), \"`.\n\nReturning an `*mut` pointer from a shared reference to this atomic is safe because the\natomic types work with interior mutability. All modifications of an atomic change the value\nthrough a shared reference, and can do so safely as long as they use atomic operations. Any\nuse of the returned raw pointer requires an `unsafe` block and still has to uphold the same\nrestriction: operations on it must be atomic.\n\n# Examples\n\n```ignore (extern-declaration)\n# fn main() {\n}\n```\"),\n                #[inline]\n                #[unstable(feature = \"atomic_mut_ptr\",\n                       reason = \"recently added\",\n                       issue = \"66893\")]\n                pub fn as_mut_ptr(&self) -> *mut $int_type {\n}\n            }\n        }\n    }\n}\n\n#[cfg(target_has_atomic_load_store = \"8\")]\natomic_int! {\n    cfg(target_has_atomic = \"8\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"i8\", \"../../../std/primitive.i8.html\",\n    \"\",\n    atomic_min, atomic_max,\n    1,\n    \"AtomicI8::new(0)\",\n    i8 AtomicI8 ATOMIC_I8_INIT\n}\n#[cfg(target_has_atomic_load_store = \"8\")]\natomic_int! {\n    cfg(target_has_atomic = \"8\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"u8\", \"../../../std/primitive.u8.html\",\n    \"\",\n    atomic_umin, atomic_umax,\n    1,\n    \"AtomicU8::new(0)\",\n    u8 AtomicU8 ATOMIC_U8_INIT\n}\n#[cfg(target_has_atomic_load_store = \"16\")]\natomic_int! {\n    cfg(target_has_atomic = \"16\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"i16\", \"../../../std/primitive.i16.html\",\n    \"\",\n    atomic_min, atomic_max,\n    2,\n    \"AtomicI16::new(0)\",\n    i16 AtomicI16 ATOMIC_I16_INIT\n}\n#[cfg(target_has_atomic_load_store = \"16\")]\natomic_int! {\n    cfg(target_has_atomic = \"16\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"u16\", \"../../../std/primitive.u16.html\",\n    \"\",\n    atomic_umin, atomic_umax,\n    2,\n    \"AtomicU16::new(0)\",\n    u16 AtomicU16 ATOMIC_U16_INIT\n}\n#[cfg(target_has_atomic_load_store = \"32\")]\natomic_int! {\n    cfg(target_has_atomic = \"32\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"i32\", \"../../../std/primitive.i32.html\",\n    \"\",\n    atomic_min, atomic_max,\n    4,\n    \"AtomicI32::new(0)\",\n    i32 AtomicI32 ATOMIC_I32_INIT\n}\n#[cfg(target_has_atomic_load_store = \"32\")]\natomic_int! {\n    cfg(target_has_atomic = \"32\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"u32\", \"../../../std/primitive.u32.html\",\n    \"\",\n    atomic_umin, atomic_umax,\n    4,\n    \"AtomicU32::new(0)\",\n    u32 AtomicU32 ATOMIC_U32_INIT\n}\n#[cfg(target_has_atomic_load_store = \"64\")]\natomic_int! {\n    cfg(target_has_atomic = \"64\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"i64\", \"../../../std/primitive.i64.html\",\n    \"\",\n    atomic_min, atomic_max,\n    8,\n    \"AtomicI64::new(0)\",\n    i64 AtomicI64 ATOMIC_I64_INIT\n}\n#[cfg(target_has_atomic_load_store = \"64\")]\natomic_int! {\n    cfg(target_has_atomic = \"64\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"u64\", \"../../../std/primitive.u64.html\",\n    \"\",\n    atomic_umin, atomic_umax,\n    8,\n    \"AtomicU64::new(0)\",\n    u64 AtomicU64 ATOMIC_U64_INIT\n}\n#[cfg(target_has_atomic_load_store = \"128\")]\natomic_int! {\n    cfg(target_has_atomic = \"128\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"i128\", \"../../../std/primitive.i128.html\",\n    \"#![feature(integer_atomics)]\\n\\n\",\n    atomic_min, atomic_max,\n    16,\n    \"AtomicI128::new(0)\",\n    i128 AtomicI128 ATOMIC_I128_INIT\n}\n#[cfg(target_has_atomic_load_store = \"128\")]\natomic_int! {\n    cfg(target_has_atomic = \"128\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n    \"u128\", \"../../../std/primitive.u128.html\",\n    \"#![feature(integer_atomics)]\\n\\n\",\n    atomic_umin, atomic_umax,\n    16,\n    \"AtomicU128::new(0)\",\n    u128 AtomicU128 ATOMIC_U128_INIT\n}\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[cfg(target_pointer_width = \"16\")]\nmacro_rules! ptr_width {\n    () => {\n        2\n    };\n}\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[cfg(target_pointer_width = \"32\")]\nmacro_rules! ptr_width {\n    () => {\n        4\n    };\n}\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[cfg(target_pointer_width = \"64\")]\nmacro_rules! ptr_width {\n    () => {\n        8\n    };\n}\n#[cfg(target_has_atomic_load_store = \"ptr\")]\natomic_int! {\n    cfg(target_has_atomic = \"ptr\"),\n    stable(feature = \"rust1\", since = \"1.0.0\"),\n    stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n    stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n    stable(feature = \"atomic_access\", since = \"1.15.0\"),\n    stable(feature = \"atomic_from\", since = \"1.23.0\"),\n    stable(feature = \"atomic_nand\", since = \"1.27.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    stable(feature = \"rust1\", since = \"1.0.0\"),\n    \"isize\", \"../../../std/primitive.isize.html\",\n    \"\",\n    atomic_min, atomic_max,\n    ptr_width!(),\n    \"AtomicIsize::new(0)\",\n    isize AtomicIsize ATOMIC_ISIZE_INIT\n}\n#[cfg(target_has_atomic_load_store = \"ptr\")]\natomic_int! {\n    cfg(target_has_atomic = \"ptr\"),\n    stable(feature = \"rust1\", since = \"1.0.0\"),\n    stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n    stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n    stable(feature = \"atomic_access\", since = \"1.15.0\"),\n    stable(feature = \"atomic_from\", since = \"1.23.0\"),\n    stable(feature = \"atomic_nand\", since = \"1.27.0\"),\n    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n    stable(feature = \"rust1\", since = \"1.0.0\"),\n    \"usize\", \"../../../std/primitive.usize.html\",\n    \"\",\n    atomic_umin, atomic_umax,\n    ptr_width!(),\n    \"AtomicUsize::new(0)\",\n    usize AtomicUsize ATOMIC_USIZE_INIT\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nfn strongest_failure_ordering(order: Ordering) -> Ordering {\n}\n\n#[inline]\nunsafe fn atomic_store<T>(dst: *mut T, val: T, order: Ordering) {\n}\n\n#[inline]\nunsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n}\n\n/// Returns the previous value (like __sync_fetch_and_add).\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n}\n\n/// Returns the previous value (like __sync_fetch_and_sub).\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_compare_exchange<T>(\n    dst: *mut T,\n    old: T,\n    new: T,\n    success: Ordering,\n    failure: Ordering,\n) -> Result<T, T> {\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_compare_exchange_weak<T>(\n    dst: *mut T,\n    old: T,\n    new: T,\n    success: Ordering,\n    failure: Ordering,\n) -> Result<T, T> {\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n}\n\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n}\n\n/// returns the max value (signed comparison)\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n}\n\n/// returns the min value (signed comparison)\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n}\n\n/// returns the max value (signed comparison)\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n}\n\n/// returns the min value (signed comparison)\n#[inline]\n#[cfg(target_has_atomic = \"8\")]\nunsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n}\n\n/// An atomic fence.\n///\n/// Depending on the specified order, a fence prevents the compiler and CPU from\n/// reordering certain types of memory operations around it.\n/// That creates synchronizes-with relationships between it and atomic operations\n/// or fences in other threads.\n///\n/// A fence 'A' which has (at least) [`Release`] ordering semantics, synchronizes\n/// with a fence 'B' with (at least) [`Acquire`] semantics, if and only if there\n/// exist operations X and Y, both operating on some atomic object 'M' such\n/// that A is sequenced before X, Y is synchronized before B and Y observes\n/// the change to M. This provides a happens-before dependence between A and B.\n///\n/// ```text\n///     Thread 1                                          Thread 2\n///\n/// fence(Release);      A --------------\n/// x.store(3, Relaxed); X ---------    |\n///                                |    |\n///                                |    |\n///                                -------------> Y  if x.load(Relaxed) == 3 {\n///                                     |-------> B      fence(Acquire);\n///                                                      ...\n///                                                  }\n/// ```\n///\n/// Atomic operations with [`Release`] or [`Acquire`] semantics can also synchronize\n/// with a fence.\n///\n/// A fence which has [`SeqCst`] ordering, in addition to having both [`Acquire`]\n/// and [`Release`] semantics, participates in the global program order of the\n/// other [`SeqCst`] operations and/or fences.\n///\n/// Accepts [`Acquire`], [`Release`], [`AcqRel`] and [`SeqCst`] orderings.\n///\n/// # Panics\n///\n/// Panics if `order` is [`Relaxed`].\n///\n/// # Examples\n///\n/// ```\n/// use std::sync::atomic::AtomicBool;\n/// use std::sync::atomic::fence;\n/// use std::sync::atomic::Ordering;\n///\n/// // A mutual exclusion primitive based on spinlock.\n/// pub struct Mutex {\n///     flag: AtomicBool,\n/// }\n///\n/// impl Mutex {\n///     pub fn new() -> Mutex {\n///         Mutex {\n///             flag: AtomicBool::new(false),\n///         }\n///     }\n///\n///     pub fn lock(&self) {\n///         while !self.flag.compare_and_swap(false, true, Ordering::Relaxed) {}\n///         // This fence synchronizes-with store in `unlock`.\n///         fence(Ordering::Acquire);\n///     }\n///\n///     pub fn unlock(&self) {\n///         self.flag.store(false, Ordering::Release);\n///     }\n/// }\n/// ```\n///\n/// [`Ordering`]: enum.Ordering.html\n/// [`Acquire`]: enum.Ordering.html#variant.Acquire\n/// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n/// [`Release`]: enum.Ordering.html#variant.Release\n/// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n/// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[cfg_attr(target_arch = \"wasm32\", allow(unused_variables))]\npub fn fence(order: Ordering) {\n}\n\n/// A compiler memory fence.\n///\n/// `compiler_fence` does not emit any machine code, but restricts the kinds\n/// of memory re-ordering the compiler is allowed to do. Specifically, depending on\n/// the given [`Ordering`] semantics, the compiler may be disallowed from moving reads\n/// or writes from before or after the call to the other side of the call to\n/// `compiler_fence`. Note that it does **not** prevent the *hardware*\n/// from doing such re-ordering. This is not a problem in a single-threaded,\n/// execution context, but when other threads may modify memory at the same\n/// time, stronger synchronization primitives such as [`fence`] are required.\n///\n/// The re-ordering prevented by the different ordering semantics are:\n///\n///  - with [`SeqCst`], no re-ordering of reads and writes across this point is allowed.\n///  - with [`Release`], preceding reads and writes cannot be moved past subsequent writes.\n///  - with [`Acquire`], subsequent reads and writes cannot be moved ahead of preceding reads.\n///  - with [`AcqRel`], both of the above rules are enforced.\n///\n/// `compiler_fence` is generally only useful for preventing a thread from\n/// racing *with itself*. That is, if a given thread is executing one piece\n/// of code, and is then interrupted, and starts executing code elsewhere\n/// (while still in the same thread, and conceptually still on the same\n/// core). In traditional programs, this can only occur when a signal\n/// handler is registered. In more low-level code, such situations can also\n/// arise when handling interrupts, when implementing green threads with\n/// pre-emption, etc. Curious readers are encouraged to read the Linux kernel's\n/// discussion of [memory barriers].\n///\n/// # Panics\n///\n/// Panics if `order` is [`Relaxed`].\n///\n/// # Examples\n///\n/// Without `compiler_fence`, the `assert_eq!` in following code\n/// is *not* guaranteed to succeed, despite everything happening in a single thread.\n/// To see why, remember that the compiler is free to swap the stores to\n/// `IMPORTANT_VARIABLE` and `IS_READ` since they are both\n/// `Ordering::Relaxed`. If it does, and the signal handler is invoked right\n/// after `IS_READY` is updated, then the signal handler will see\n/// `IS_READY=1`, but `IMPORTANT_VARIABLE=0`.\n/// Using a `compiler_fence` remedies this situation.\n///\n/// ```\n/// use std::sync::atomic::{AtomicBool, AtomicUsize};\n/// use std::sync::atomic::Ordering;\n/// use std::sync::atomic::compiler_fence;\n///\n/// static IMPORTANT_VARIABLE: AtomicUsize = AtomicUsize::new(0);\n/// static IS_READY: AtomicBool = AtomicBool::new(false);\n///\n/// fn main() {\n///     IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n///     // prevent earlier writes from being moved beyond this point\n///     compiler_fence(Ordering::Release);\n///     IS_READY.store(true, Ordering::Relaxed);\n/// }\n///\n/// fn signal_handler() {\n///     if IS_READY.load(Ordering::Relaxed) {\n///         assert_eq!(IMPORTANT_VARIABLE.load(Ordering::Relaxed), 42);\n///     }\n/// }\n/// ```\n///\n/// [`fence`]: fn.fence.html\n/// [`Ordering`]: enum.Ordering.html\n/// [`Acquire`]: enum.Ordering.html#variant.Acquire\n/// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n/// [`Release`]: enum.Ordering.html#variant.Release\n/// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n/// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n/// [memory barriers]: https://www.kernel.org/doc/Documentation/memory-barriers.txt\n#[inline]\n#[stable(feature = \"compiler_fences\", since = \"1.21.0\")]\npub fn compiler_fence(order: Ordering) {\n}\n\n#[cfg(target_has_atomic_load_store = \"8\")]\n#[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\nimpl fmt::Debug for AtomicBool {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\nimpl<T> fmt::Debug for AtomicPtr<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[cfg(target_has_atomic_load_store = \"ptr\")]\n#[stable(feature = \"atomic_pointer\", since = \"1.24.0\")]\nimpl<T> fmt::Pointer for AtomicPtr<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n}\n}\n\n#[cfg(not(test))] // See #65860\npub mod fmt {\n//! Utilities for formatting and printing strings.\n\n// ignore-tidy-undocumented-unsafe\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::cell::{Cell, Ref, RefCell, RefMut, UnsafeCell};\nuse crate::marker::PhantomData;\nuse crate::mem;\nuse crate::num::flt2dec;\nuse crate::ops::Deref;\nuse crate::result;\nuse crate::str;\n\nmod builders {\nuse crate::fmt;\n\nstruct PadAdapter<'buf, 'state> {\n    buf: &'buf mut (dyn fmt::Write + 'buf),\n    state: &'state mut PadAdapterState,\n}\n\nstruct PadAdapterState {\n    on_newline: bool,\n}\n\nimpl Default for PadAdapterState {\n    fn default() -> Self {\n}\n}\n\nimpl<'buf, 'state> PadAdapter<'buf, 'state> {\n    fn wrap<'slot, 'fmt: 'buf + 'slot>(\n        fmt: &'fmt mut fmt::Formatter<'_>,\n        slot: &'slot mut Option<Self>,\n        state: &'state mut PadAdapterState,\n    ) -> fmt::Formatter<'slot> {\n}\n}\n\nimpl fmt::Write for PadAdapter<'_, '_> {\n    fn write_str(&mut self, mut s: &str) -> fmt::Result {\n}\n}\n\n/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n///\n/// This is useful when you wish to output a formatted struct as a part of your\n/// [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n///\n/// This can be constructed by the\n/// [`Formatter::debug_struct`](struct.Formatter.html#method.debug_struct)\n/// method.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo {\n///     bar: i32,\n///     baz: String,\n/// }\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_struct(\"Foo\")\n///            .field(\"bar\", &self.bar)\n///            .field(\"baz\", &self.baz)\n///            .finish()\n///     }\n/// }\n///\n/// assert_eq!(\n///     format!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() }),\n///     \"Foo { bar: 10, baz: \\\"Hello World\\\" }\",\n/// );\n/// ```\n#[must_use = \"must eventually call `finish()` on Debug builders\"]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugStruct<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    result: fmt::Result,\n    has_fields: bool,\n}\n\npub(super) fn debug_struct_new<'a, 'b>(\n    fmt: &'a mut fmt::Formatter<'b>,\n    name: &str,\n) -> DebugStruct<'a, 'b> {\n}\n\nimpl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n    /// Adds a new field to the generated struct output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Bar {\n    ///     bar: i32,\n    ///     another: String,\n    /// }\n    ///\n    /// impl fmt::Debug for Bar {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_struct(\"Bar\")\n    ///            .field(\"bar\", &self.bar) // We add `bar` field.\n    ///            .field(\"another\", &self.another) // We add `another` field.\n    ///            // We even add a field which doesn't exist (because why not?).\n    ///            .field(\"not_existing_field\", &1)\n    ///            .finish() // We're good to go!\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Bar { bar: 10, another: \"Hello World\".to_string() }),\n    ///     \"Bar { bar: 10, another: \\\"Hello World\\\", not_existing_field: 1 }\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn field(&mut self, name: &str, value: &dyn fmt::Debug) -> &mut Self {\n}\n\n    fn is_pretty(&self) -> bool {\n}\n}\n\n/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n///\n/// This is useful when you wish to output a formatted tuple as a part of your\n/// [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n///\n/// This can be constructed by the\n/// [`Formatter::debug_tuple`](struct.Formatter.html#method.debug_tuple)\n/// method.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo(i32, String);\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_tuple(\"Foo\")\n///            .field(&self.0)\n///            .field(&self.1)\n///            .finish()\n///     }\n/// }\n///\n/// assert_eq!(\n///     format!(\"{:?}\", Foo(10, \"Hello World\".to_string())),\n///     \"Foo(10, \\\"Hello World\\\")\",\n/// );\n/// ```\n#[must_use = \"must eventually call `finish()` on Debug builders\"]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugTuple<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    result: fmt::Result,\n    fields: usize,\n    empty_name: bool,\n}\n\npub(super) fn debug_tuple_new<'a, 'b>(\n    fmt: &'a mut fmt::Formatter<'b>,\n    name: &str,\n) -> DebugTuple<'a, 'b> {\n}\n\nimpl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n    /// Adds a new field to the generated tuple struct output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32, String);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_tuple(\"Foo\")\n    ///            .field(&self.0) // We add the first field.\n    ///            .field(&self.1) // We add the second field.\n    ///            .finish() // We're good to go!\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(10, \"Hello World\".to_string())),\n    ///     \"Foo(10, \\\"Hello World\\\")\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn field(&mut self, value: &dyn fmt::Debug) -> &mut Self {\n}\n\n    /// Finishes output and returns any error encountered.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32, String);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_tuple(\"Foo\")\n    ///            .field(&self.0)\n    ///            .field(&self.1)\n    ///            .finish() // You need to call it to \"finish\" the\n    ///                      // tuple formatting.\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(10, \"Hello World\".to_string())),\n    ///     \"Foo(10, \\\"Hello World\\\")\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn finish(&mut self) -> fmt::Result {\n}\n\n    fn is_pretty(&self) -> bool {\n}\n}\n\nstruct DebugInner<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    result: fmt::Result,\n    has_fields: bool,\n}\n\nimpl<'a, 'b: 'a> DebugInner<'a, 'b> {\n    fn entry(&mut self, entry: &dyn fmt::Debug) {\n}\n\n    fn is_pretty(&self) -> bool {\n}\n}\n\n/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n///\n/// This is useful when you wish to output a formatted set of items as a part\n/// of your [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n///\n/// This can be constructed by the\n/// [`Formatter::debug_set`](struct.Formatter.html#method.debug_set)\n/// method.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo(Vec<i32>);\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_set().entries(self.0.iter()).finish()\n///     }\n/// }\n///\n/// assert_eq!(\n///     format!(\"{:?}\", Foo(vec![10, 11])),\n///     \"{10, 11}\",\n/// );\n/// ```\n#[must_use = \"must eventually call `finish()` on Debug builders\"]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugSet<'a, 'b: 'a> {\n    inner: DebugInner<'a, 'b>,\n}\n\npub(super) fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b> {\n}\n\n/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n///\n/// This is useful when you wish to output a formatted list of items as a part\n/// of your [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n///\n/// This can be constructed by the\n/// [`Formatter::debug_list`](struct.Formatter.html#method.debug_list)\n/// method.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo(Vec<i32>);\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_list().entries(self.0.iter()).finish()\n///     }\n/// }\n///\n/// assert_eq!(\n///     format!(\"{:?}\", Foo(vec![10, 11])),\n///     \"[10, 11]\",\n/// );\n/// ```\n#[must_use = \"must eventually call `finish()` on Debug builders\"]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugList<'a, 'b: 'a> {\n    inner: DebugInner<'a, 'b>,\n}\n\npub(super) fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a, 'b> {\n}\n\nimpl<'a, 'b: 'a> DebugList<'a, 'b> {\n    /// Adds a new entry to the list output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>, Vec<u32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_list()\n    ///            .entry(&self.0) // We add the first \"entry\".\n    ///            .entry(&self.1) // We add the second \"entry\".\n    ///            .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![10, 11], vec![12, 13])),\n    ///     \"[[10, 11], [12, 13]]\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entry(&mut self, entry: &dyn fmt::Debug) -> &mut Self {\n}\n\n    /// Adds the contents of an iterator of entries to the list output.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>, Vec<u32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_list()\n    ///            .entries(self.0.iter())\n    ///            .entries(self.1.iter())\n    ///            .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![10, 11], vec![12, 13])),\n    ///     \"[10, 11, 12, 13]\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn entries<D, I>(&mut self, entries: I) -> &mut Self\n    where\n        D: fmt::Debug,\n        I: IntoIterator<Item = D>,\n    {\n}\n\n    /// Finishes output and returns any error encountered.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         fmt.debug_list()\n    ///            .entries(self.0.iter())\n    ///            .finish() // Ends the struct formatting.\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\", Foo(vec![10, 11])),\n    ///     \"[10, 11]\",\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn finish(&mut self) -> fmt::Result {\n}\n}\n\n/// A struct to help with [`fmt::Debug`](trait.Debug.html) implementations.\n///\n/// This is useful when you wish to output a formatted map as a part of your\n/// [`Debug::fmt`](trait.Debug.html#tymethod.fmt) implementation.\n///\n/// This can be constructed by the\n/// [`Formatter::debug_map`](struct.Formatter.html#method.debug_map)\n/// method.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Foo(Vec<(String, i32)>);\n///\n/// impl fmt::Debug for Foo {\n///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref v)| (k, v))).finish()\n///     }\n/// }\n///\n/// assert_eq!(\n///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n///     \"{\\\"A\\\": 10, \\\"B\\\": 11}\",\n/// );\n/// ```\n#[must_use = \"must eventually call `finish()` on Debug builders\"]\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub struct DebugMap<'a, 'b: 'a> {\n    fmt: &'a mut fmt::Formatter<'b>,\n    result: fmt::Result,\n    has_fields: bool,\n    has_key: bool,\n    // The state of newlines is tracked between keys and values\n    state: PadAdapterState,\n}\n\npub(super) fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> {\n}\n}\nmod float {\nuse crate::fmt::{Debug, Display, Formatter, LowerExp, Result, UpperExp};\nuse crate::mem::MaybeUninit;\nuse crate::num::flt2dec;\n\n// ignore-tidy-undocumented-unsafe\n\n// Don't inline this so callers don't use the stack space this function\n// requires unless they have to.\n#[inline(never)]\nfn float_to_decimal_common_exact<T>(\n    fmt: &mut Formatter<'_>,\n    num: &T,\n    sign: flt2dec::Sign,\n    precision: usize,\n) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n}\n\n// Don't inline this so callers that call both this and the above won't wind\n// up using the combined stack space of both functions in some cases.\n#[inline(never)]\nfn float_to_decimal_common_shortest<T>(\n    fmt: &mut Formatter<'_>,\n    num: &T,\n    sign: flt2dec::Sign,\n    precision: usize,\n) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n}\n\n// Common code of floating point Debug and Display.\nfn float_to_decimal_common<T>(\n    fmt: &mut Formatter<'_>,\n    num: &T,\n    negative_zero: bool,\n    min_precision: usize,\n) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n}\n\n// Don't inline this so callers don't use the stack space this function\n// requires unless they have to.\n#[inline(never)]\nfn float_to_exponential_common_exact<T>(\n    fmt: &mut Formatter<'_>,\n    num: &T,\n    sign: flt2dec::Sign,\n    precision: usize,\n    upper: bool,\n) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n}\n\n// Don't inline this so callers that call both this and the above won't wind\n// up using the combined stack space of both functions in some cases.\n#[inline(never)]\nfn float_to_exponential_common_shortest<T>(\n    fmt: &mut Formatter<'_>,\n    num: &T,\n    sign: flt2dec::Sign,\n    upper: bool,\n) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n}\n\n// Common code of floating point LowerExp and UpperExp.\nfn float_to_exponential_common<T>(fmt: &mut Formatter<'_>, num: &T, upper: bool) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n}\n\nmacro_rules! floating {\n    ($ty:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Debug for $ty {\n            fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n}\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl Display for $ty {\n            fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n}\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl LowerExp for $ty {\n            fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n}\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl UpperExp for $ty {\n            fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n}\n        }\n    };\n}\n\nfloating! { f32 }\nfloating! { f64 }\n}\nmod num {\n//! Integer and floating-point number formatting\n\n// ignore-tidy-undocumented-unsafe\n\nuse crate::fmt;\nuse crate::mem::MaybeUninit;\nuse crate::ops::{Div, Rem, Sub};\nuse crate::ptr;\nuse crate::slice;\nuse crate::str;\n\n#[doc(hidden)]\ntrait Int:\n    PartialEq + PartialOrd + Div<Output = Self> + Rem<Output = Self> + Sub<Output = Self> + Copy\n{\n    fn zero() -> Self;\n    fn from_u8(u: u8) -> Self;\n    fn to_u8(&self) -> u8;\n    fn to_u16(&self) -> u16;\n    fn to_u32(&self) -> u32;\n    fn to_u64(&self) -> u64;\n    fn to_u128(&self) -> u128;\n}\n\nmacro_rules! doit {\n    ($($t:ident)*) => ($(impl Int for $t {\n        fn zero() -> Self { }\n        fn from_u8(u: u8) -> Self { }\n        fn to_u8(&self) -> u8 { }\n        fn to_u16(&self) -> u16 { }\n        fn to_u32(&self) -> u32 { }\n        fn to_u64(&self) -> u64 { }\n        fn to_u128(&self) -> u128 { }\n    })*)\n}\ndoit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n\n/// A type that represents a specific radix\n#[doc(hidden)]\ntrait GenericRadix {\n    /// The number of digits.\n    const BASE: u8;\n\n    /// A radix-specific prefix string.\n    const PREFIX: &'static str;\n\n    /// Converts an integer to corresponding radix digit.\n    fn digit(x: u8) -> u8;\n\n    /// Format an integer using the radix using a formatter.\n    fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // The radix can be as low as 2, so we need a buffer of at least 128\n        // characters for a base 2 number.\n        let zero = T::zero();\n        let is_nonnegative = x >= zero;\n        let mut buf = [MaybeUninit::<u8>::uninit(); 128];\n        let mut curr = buf.len();\n        let base = T::from_u8(Self::BASE);\n        if is_nonnegative {\n            // Accumulate each digit of the number from the least significant\n            // to the most significant figure.\n            for byte in buf.iter_mut().rev() {\n                let n = x % base; // Get the current place value.\n                x = x / base; // Deaccumulate the number.\n                byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                curr -= 1;\n                if x == zero {\n                    // No more digits left to accumulate.\n                    break;\n                };\n            }\n        } else {\n            // Do the same as above, but accounting for two's complement.\n            for byte in buf.iter_mut().rev() {\n                let n = zero - (x % base); // Get the current place value.\n                x = x / base; // Deaccumulate the number.\n                byte.write(Self::digit(n.to_u8())); // Store the digit in the buffer.\n                curr -= 1;\n                if x == zero {\n                    // No more digits left to accumulate.\n                    break;\n                };\n            }\n        }\n        let buf = &buf[curr..];\n        let buf = unsafe {\n            str::from_utf8_unchecked(slice::from_raw_parts(MaybeUninit::first_ptr(buf), buf.len()))\n        };\n        f.pad_integral(is_nonnegative, Self::PREFIX, buf)\n    }\n}\n\n/// A binary (base 2) radix\n#[derive(Clone, PartialEq)]\nstruct Binary;\n\n/// An octal (base 8) radix\n#[derive(Clone, PartialEq)]\nstruct Octal;\n\n/// A hexadecimal (base 16) radix, formatted with lower-case characters\n#[derive(Clone, PartialEq)]\nstruct LowerHex;\n\n/// A hexadecimal (base 16) radix, formatted with upper-case characters\n#[derive(Clone, PartialEq)]\nstruct UpperHex;\n\nmacro_rules! radix {\n    ($T:ident, $base:expr, $prefix:expr, $($x:pat => $conv:expr),+) => {\n        impl GenericRadix for $T {\n            const BASE: u8 = $base;\n            const PREFIX: &'static str = $prefix;\n            fn digit(x: u8) -> u8 {\n}\n        }\n    }\n}\n\nradix! { Binary,    2, \"0b\", x @  0 ..=  1 => b'0' + x }\nradix! { Octal,     8, \"0o\", x @  0 ..=  7 => b'0' + x }\nradix! { LowerHex, 16, \"0x\", x @  0 ..=  9 => b'0' + x,\nx @ 10 ..= 15 => b'a' + (x - 10) }\nradix! { UpperHex, 16, \"0x\", x @  0 ..=  9 => b'0' + x,\nx @ 10 ..= 15 => b'A' + (x - 10) }\n\nmacro_rules! int_base {\n    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::$Trait for $T {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n        }\n    };\n}\n\nmacro_rules! debug {\n    ($T:ident) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl fmt::Debug for $T {\n            #[inline]\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n        }\n    };\n}\n\nmacro_rules! integer {\n    ($Int:ident, $Uint:ident) => {\n        int_base! { Binary   for $Int as $Uint  -> Binary }\n        int_base! { Octal    for $Int as $Uint  -> Octal }\n        int_base! { LowerHex for $Int as $Uint  -> LowerHex }\n        int_base! { UpperHex for $Int as $Uint  -> UpperHex }\n        debug! { $Int }\n\n        int_base! { Binary   for $Uint as $Uint -> Binary }\n        int_base! { Octal    for $Uint as $Uint -> Octal }\n        int_base! { LowerHex for $Uint as $Uint -> LowerHex }\n        int_base! { UpperHex for $Uint as $Uint -> UpperHex }\n        debug! { $Uint }\n    };\n}\ninteger! { isize, usize }\ninteger! { i8, u8 }\ninteger! { i16, u16 }\ninteger! { i32, u32 }\ninteger! { i64, u64 }\ninteger! { i128, u128 }\n\nstatic DEC_DIGITS_LUT: &[u8; 200] = b\"0001020304050607080910111213141516171819\\\n      2021222324252627282930313233343536373839\\\n      4041424344454647484950515253545556575859\\\n      6061626364656667686970717273747576777879\\\n      8081828384858687888990919293949596979899\";\n\nmacro_rules! impl_Display {\n    ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) => {\n        fn $name(mut n: $u, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n\n        $(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl fmt::Display for $t {\n                #[allow(unused_comparisons)]\n                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n            })*\n    };\n}\n\n// Include wasm32 in here since it doesn't reflect the native pointer size, and\n// often cares strongly about getting a smaller code size.\n#[cfg(any(target_pointer_width = \"64\", target_arch = \"wasm32\"))]\nmod imp {\n    use super::*;\n    impl_Display!(\n        i8, u8, i16, u16, i32, u32, i64, u64, usize, isize\n            as u64 via to_u64 named fmt_u64\n    );\n}\n\n#[cfg(not(any(target_pointer_width = \"64\", target_arch = \"wasm32\")))]\nmod imp {\n    use super::*;\n    impl_Display!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named fmt_u32);\n    impl_Display!(i64, u64 as u64 via to_u64 named fmt_u64);\n}\n\nimpl_Display!(i128, u128 as u128 via to_u128 named fmt_u128);\n}\n\n#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n/// Possible alignments returned by `Formatter::align`\n#[derive(Debug)]\npub enum Alignment {\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    /// Indication that contents should be left-aligned.\n    Left,\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    /// Indication that contents should be right-aligned.\n    Right,\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    /// Indication that contents should be center-aligned.\n    Center,\n}\n\n#[stable(feature = \"debug_builders\", since = \"1.2.0\")]\npub use self::builders::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n#[doc(hidden)]\npub mod rt {\n}\n\n/// The type returned by formatter methods.\n///\n/// # Examples\n///\n/// ```\n/// use std::fmt;\n///\n/// #[derive(Debug)]\n/// struct Triangle {\n///     a: f32,\n///     b: f32,\n///     c: f32\n/// }\n///\n/// impl fmt::Display for Triangle {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         write!(f, \"({}, {}, {})\", self.a, self.b, self.c)\n///     }\n/// }\n///\n/// let pythagorean_triple = Triangle { a: 3.0, b: 4.0, c: 5.0 };\n///\n/// assert_eq!(format!(\"{}\", pythagorean_triple), \"(3, 4, 5)\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub type Result = result::Result<(), Error>;\n\n/// The error type which is returned from formatting a message into a stream.\n///\n/// This type does not support transmission of an error other than that an error\n/// occurred. Any extra information must be arranged to be transmitted through\n/// some other means.\n///\n/// An important thing to remember is that the type `fmt::Error` should not be\n/// confused with [`std::io::Error`] or [`std::error::Error`], which you may also\n/// have in scope.\n///\n/// [`std::io::Error`]: ../../std/io/struct.Error.html\n/// [`std::error::Error`]: ../../std/error/trait.Error.html\n///\n/// # Examples\n///\n/// ```rust\n/// use std::fmt::{self, write};\n///\n/// let mut output = String::new();\n/// if let Err(fmt::Error) = write(&mut output, format_args!(\"Hello {}!\", \"world\")) {\n///     panic!(\"An error occurred\");\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\npub struct Error;\n\n/// A collection of methods that are required to format a message into a stream.\n///\n/// This trait is the type which this modules requires when formatting\n/// information. This is similar to the standard library's [`io::Write`] trait,\n/// but it is only intended for use in libcore.\n///\n/// This trait should generally not be implemented by consumers of the standard\n/// library. The [`write!`] macro accepts an instance of [`io::Write`], and the\n/// [`io::Write`] trait is favored over implementing this trait.\n///\n/// [`write!`]: ../../std/macro.write.html\n/// [`io::Write`]: ../../std/io/trait.Write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Write {\n    /// Writes a string slice into this writer, returning whether the write\n    /// succeeded.\n    ///\n    /// This method can only succeed if the entire string slice was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// [`Error`]: struct.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n    ///     f.write_str(s)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, \"hola\").unwrap();\n    /// assert_eq!(&buf, \"hola\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_str(&mut self, s: &str) -> Result;\n\n    /// Writes a [`char`] into this writer, returning whether the write succeeded.\n    ///\n    /// A single [`char`] may be encoded as more than one byte.\n    /// This method can only succeed if the entire byte sequence was successfully\n    /// written, and this method will not return until all data has been\n    /// written or an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// This function will return an instance of [`Error`] on error.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    /// [`Error`]: struct.Error.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n    ///     f.write_char(c)\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, 'a').unwrap();\n    /// writer(&mut buf, 'b').unwrap();\n    /// assert_eq!(&buf, \"ab\");\n    /// ```\n    #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n    fn write_char(&mut self, c: char) -> Result {\n}\n\n    /// Glue for usage of the [`write!`] macro with implementors of this trait.\n    ///\n    /// This method should generally not be invoked manually, but rather through\n    /// the [`write!`] macro itself.\n    ///\n    /// [`write!`]: ../../std/macro.write.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt::{Error, Write};\n    ///\n    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n    ///     f.write_fmt(format_args!(\"{}\", s))\n    /// }\n    ///\n    /// let mut buf = String::new();\n    /// writer(&mut buf, \"world\").unwrap();\n    /// assert_eq!(&buf, \"world\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write_fmt(mut self: &mut Self, args: Arguments<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"fmt_write_blanket_impl\", since = \"1.4.0\")]\nimpl<W: Write + ?Sized> Write for &mut W {\n    fn write_str(&mut self, s: &str) -> Result {\n}\n\n    fn write_char(&mut self, c: char) -> Result {\n}\n\n    fn write_fmt(&mut self, args: Arguments<'_>) -> Result {\n}\n}\n\n/// Configuration for formatting.\n///\n/// A `Formatter` represents various options related to formatting. Users do not\n/// construct `Formatter`s directly; a mutable reference to one is passed to\n/// the `fmt` method of all formatting traits, like [`Debug`] and [`Display`].\n///\n/// To interact with a `Formatter`, you'll call various methods to change the\n/// various options related to formatting. For examples, please see the\n/// documentation of the methods defined on `Formatter` below.\n///\n/// [`Debug`]: trait.Debug.html\n/// [`Display`]: trait.Display.html\n#[allow(missing_debug_implementations)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Formatter<'a> {\n    flags: u32,\n    fill: char,\n    align: rt::v1::Alignment,\n    width: Option<usize>,\n    precision: Option<usize>,\n\n    buf: &'a mut (dyn Write + 'a),\n}\n\n// NB. Argument is essentially an optimized partially applied formatting function,\n// equivalent to `exists T.(&T, fn(&T, &mut Formatter<'_>) -> Result`.\n\nstruct Void {\n    _priv: (),\n    /// Erases all oibits, because `Void` erases the type of the object that\n    /// will be used to produce formatted output. Since we do not know what\n    /// oibits the real types have (and they can have any or none), we need to\n    /// take the most conservative approach and forbid all oibits.\n    ///\n    /// It was added after #45197 showed that one could share a `!Sync`\n    /// object across threads by passing it into `format_args!`.\n    _oibit_remover: PhantomData<*mut dyn Fn()>,\n}\n\n/// This struct represents the generic \"argument\" which is taken by the Xprintf\n/// family of functions. It contains a function to format the given value. At\n/// compile time it is ensured that the function and the value have the correct\n/// types, and then this struct is used to canonicalize arguments to one type.\n#[derive(Copy, Clone)]\n#[allow(missing_debug_implementations)]\n#[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n#[doc(hidden)]\npub struct ArgumentV1<'a> {\n}\n\nimpl<'a> ArgumentV1<'a> {\n    #[inline(never)]\n    fn show_usize(x: &usize, f: &mut Formatter<'_>) -> Result {\n}\n\n    #[doc(hidden)]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> ArgumentV1<'b> {\n}\n\n    #[doc(hidden)]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn from_usize(x: &usize) -> ArgumentV1<'_> {\n}\n\n    fn as_usize(&self) -> Option<usize> {\n}\n}\n\n// flags available in the v1 format of format_args\n#[derive(Copy, Clone)]\nenum FlagV1 {\n    SignPlus,\n    SignMinus,\n    Alternate,\n    SignAwareZeroPad,\n    DebugLowerHex,\n    DebugUpperHex,\n}\n\nimpl<'a> Arguments<'a> {\n    /// When using the format_args!() macro, this function is used to generate the\n    /// Arguments structure.\n    #[doc(hidden)]\n    #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn new_v1(pieces: &'a [&'a str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n}\n\n    /// This function is used to specify nonstandard formatting parameters.\n    /// The `pieces` array must be at least as long as `fmt` to construct\n    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n    /// created with `argumentusize`. However, failing to do so doesn't cause\n    /// unsafety, but will ignore invalid .\n    #[doc(hidden)]\n    #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn new_v1_formatted(\n        pieces: &'a [&'a str],\n        args: &'a [ArgumentV1<'a>],\n        fmt: &'a [rt::v1::Argument],\n    ) -> Arguments<'a> {\n}\n\n    /// Estimates the length of the formatted text.\n    ///\n    /// This is intended to be used for setting initial `String` capacity\n    /// when using `format!`. Note: this is neither the lower nor upper bound.\n    #[doc(hidden)]\n    #[inline]\n    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n    pub fn estimated_capacity(&self) -> usize {\n}\n}\n\n/// This structure represents a safely precompiled version of a format string\n/// and its arguments. This cannot be generated at runtime because it cannot\n/// safely be done, so no constructors are given and the fields are private\n/// to prevent modification.\n///\n/// The [`format_args!`] macro will safely create an instance of this structure.\n/// The macro validates the format string at compile-time so usage of the\n/// [`write`] and [`format`] functions can be safely performed.\n///\n/// You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`\n/// and `Display` contexts as seen below. The example also shows that `Debug`\n/// and `Display` format to the same thing: the interpolated format string\n/// in `format_args!`.\n///\n/// ```rust\n/// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n/// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n/// assert_eq!(\"1 foo 2\", display);\n/// assert_eq!(display, debug);\n/// ```\n///\n/// [`format_args!`]: ../../std/macro.format_args.html\n/// [`format`]: ../../std/fmt/fn.format.html\n/// [`write`]: ../../std/fmt/fn.write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Copy, Clone)]\npub struct Arguments<'a> {\n    // Format string pieces to print.\n    pieces: &'a [&'a str],\n\n    // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n    fmt: Option<&'a [rt::v1::Argument]>,\n\n    // Dynamic arguments for interpolation, to be interleaved with string\n    // pieces. (Every argument is preceded by a string piece.)\n    args: &'a [ArgumentV1<'a>],\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for Arguments<'_> {\n    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for Arguments<'_> {\n    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n}\n}\n\n/// `?` formatting.\n///\n/// `Debug` should format the output in a programmer-facing, debugging context.\n///\n/// Generally speaking, you should just `derive` a `Debug` implementation.\n///\n/// When used with the alternate format specifier `#?`, the output is pretty-printed.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// This trait can be used with `#[derive]` if all fields implement `Debug`. When\n/// `derive`d for structs, it will use the name of the `struct`, then `{`, then a\n/// comma-separated list of each field's name and `Debug` value, then `}`. For\n/// `enum`s, it will use the name of the variant and, if applicable, `(`, then the\n/// `Debug` values of the fields, then `)`.\n///\n/// # Examples\n///\n/// Deriving an implementation:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {:?}\", origin), \"The origin is: Point { x: 0, y: 0 }\");\n/// ```\n///\n/// Manually implementing:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl fmt::Debug for Point {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         f.debug_struct(\"Point\")\n///          .field(\"x\", &self.x)\n///          .field(\"y\", &self.y)\n///          .finish()\n///     }\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {:?}\", origin), \"The origin is: Point { x: 0, y: 0 }\");\n/// ```\n///\n/// There are a number of helper methods on the [`Formatter`] struct to help you with manual\n/// implementations, such as [`debug_struct`].\n///\n/// `Debug` implementations using either `derive` or the debug builder API\n/// on [`Formatter`] support pretty-printing using the alternate flag: `{:#?}`.\n///\n/// [`debug_struct`]: ../../std/fmt/struct.Formatter.html#method.debug_struct\n/// [`Formatter`]: ../../std/fmt/struct.Formatter.html\n///\n/// Pretty-printing with `#?`:\n///\n/// ```\n/// #[derive(Debug)]\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {:#?}\", origin),\n/// \"The origin is: Point {\n///     x: 0,\n///     y: 0,\n/// }\");\n/// ```\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    on(\n        crate_local,\n        label = \"`{Self}` cannot be formatted using `{{:?}}`\",\n        note = \"add `#[derive(Debug)]` or manually implement `{Debug}`\"\n    ),\n    message = \"`{Self}` doesn't implement `{Debug}`\",\n    label = \"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\"\n)]\n#[doc(alias = \"{:?}\")]\n#[rustc_diagnostic_item = \"debug_trait\"]\npub trait Debug {\n    /// Formats the value using the given formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Position {\n    ///     longitude: f32,\n    ///     latitude: f32,\n    /// }\n    ///\n    /// impl fmt::Debug for Position {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         f.debug_tuple(\"\")\n    ///          .field(&self.longitude)\n    ///          .field(&self.latitude)\n    ///          .finish()\n    ///     }\n    /// }\n    ///\n    /// let position = Position { longitude: 1.987, latitude: 2.983 };\n    /// assert_eq!(format!(\"{:?}\", position), \"(1.987, 2.983)\");\n    ///\n    /// assert_eq!(format!(\"{:#?}\", position), \"(\n    ///     1.987,\n    ///     2.983,\n    /// )\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n// Separate module to reexport the macro `Debug` from prelude without the trait `Debug`.\npub(crate) mod macros {\n    /// Derive macro generating an impl of the trait `Debug`.\n    #[rustc_builtin_macro]\n    #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n    #[allow_internal_unstable(core_intrinsics)]\n    pub macro Debug($item:item) {\n        /* compiler built-in */\n    }\n}\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[doc(inline)]\npub use macros::Debug;\n\n/// Format trait for an empty format, `{}`.\n///\n/// `Display` is similar to [`Debug`][debug], but `Display` is for user-facing\n/// output, and so cannot be derived.\n///\n/// [debug]: trait.Debug.html\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Implementing `Display` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Point {\n///     x: i32,\n///     y: i32,\n/// }\n///\n/// impl fmt::Display for Point {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         write!(f, \"({}, {})\", self.x, self.y)\n///     }\n/// }\n///\n/// let origin = Point { x: 0, y: 0 };\n///\n/// assert_eq!(format!(\"The origin is: {}\", origin), \"The origin is: (0, 0)\");\n/// ```\n#[rustc_on_unimplemented(\n    on(\n        _Self = \"std::path::Path\",\n        label = \"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n        note = \"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n                as they may contain non-Unicode data\"\n    ),\n    message = \"`{Self}` doesn't implement `{Display}`\",\n    label = \"`{Self}` cannot be formatted with the default formatter\",\n    note = \"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\"\n)]\n#[doc(alias = \"{}\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Display {\n    /// Formats the value using the given formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Position {\n    ///     longitude: f32,\n    ///     latitude: f32,\n    /// }\n    ///\n    /// impl fmt::Display for Position {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"({}, {})\", self.longitude, self.latitude)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\"(1.987, 2.983)\",\n    ///            format!(\"{}\", Position { longitude: 1.987, latitude: 2.983, }));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `o` formatting.\n///\n/// The `Octal` trait should format its output as a number in base-8.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0o` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '52' in octal\n///\n/// assert_eq!(format!(\"{:o}\", x), \"52\");\n/// assert_eq!(format!(\"{:#o}\", x), \"0o52\");\n///\n/// assert_eq!(format!(\"{:o}\", -16), \"37777777760\");\n/// ```\n///\n/// Implementing `Octal` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Octal for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         let val = self.0;\n///\n///         fmt::Octal::fmt(&val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// assert_eq!(format!(\"l as octal is: {:o}\", l), \"l as octal is: 11\");\n///\n/// assert_eq!(format!(\"l as octal is: {:#06o}\", l), \"l as octal is: 0o0011\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Octal {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `b` formatting.\n///\n/// The `Binary` trait should format its output as a number in binary.\n///\n/// For primitive signed integers ([`i8`] to [`i128`], and [`isize`]),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0b` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// # Examples\n///\n/// Basic usage with [`i32`]:\n///\n/// ```\n/// let x = 42; // 42 is '101010' in binary\n///\n/// assert_eq!(format!(\"{:b}\", x), \"101010\");\n/// assert_eq!(format!(\"{:#b}\", x), \"0b101010\");\n///\n/// assert_eq!(format!(\"{:b}\", -16), \"11111111111111111111111111110000\");\n/// ```\n///\n/// Implementing `Binary` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Binary for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         let val = self.0;\n///\n///         fmt::Binary::fmt(&val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(107);\n///\n/// assert_eq!(format!(\"l as binary is: {:b}\", l), \"l as binary is: 1101011\");\n///\n/// assert_eq!(\n///     format!(\"l as binary is: {:#032b}\", l),\n///     \"l as binary is: 0b000000000000000000000001101011\"\n/// );\n/// ```\n///\n/// [module]: ../../std/fmt/index.html\n/// [`i8`]: ../../std/primitive.i8.html\n/// [`i128`]: ../../std/primitive.i128.html\n/// [`isize`]: ../../std/primitive.isize.html\n/// [`i32`]: ../../std/primitive.i32.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Binary {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `x` formatting.\n///\n/// The `LowerHex` trait should format its output as a number in hexadecimal, with `a` through `f`\n/// in lower case.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0x` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '2a' in hex\n///\n/// assert_eq!(format!(\"{:x}\", x), \"2a\");\n/// assert_eq!(format!(\"{:#x}\", x), \"0x2a\");\n///\n/// assert_eq!(format!(\"{:x}\", -16), \"fffffff0\");\n/// ```\n///\n/// Implementing `LowerHex` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::LowerHex for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         let val = self.0;\n///\n///         fmt::LowerHex::fmt(&val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(9);\n///\n/// assert_eq!(format!(\"l as hex is: {:x}\", l), \"l as hex is: 9\");\n///\n/// assert_eq!(format!(\"l as hex is: {:#010x}\", l), \"l as hex is: 0x00000009\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait LowerHex {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `X` formatting.\n///\n/// The `UpperHex` trait should format its output as a number in hexadecimal, with `A` through `F`\n/// in upper case.\n///\n/// For primitive signed integers (`i8` to `i128`, and `isize`),\n/// negative values are formatted as the two’s complement representation.\n///\n/// The alternate flag, `#`, adds a `0x` in front of the output.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `i32`:\n///\n/// ```\n/// let x = 42; // 42 is '2A' in hex\n///\n/// assert_eq!(format!(\"{:X}\", x), \"2A\");\n/// assert_eq!(format!(\"{:#X}\", x), \"0x2A\");\n///\n/// assert_eq!(format!(\"{:X}\", -16), \"FFFFFFF0\");\n/// ```\n///\n/// Implementing `UpperHex` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::UpperHex for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         let val = self.0;\n///\n///         fmt::UpperHex::fmt(&val, f) // delegate to i32's implementation\n///     }\n/// }\n///\n/// let l = Length(i32::max_value());\n///\n/// assert_eq!(format!(\"l as hex is: {:X}\", l), \"l as hex is: 7FFFFFFF\");\n///\n/// assert_eq!(format!(\"l as hex is: {:#010X}\", l), \"l as hex is: 0x7FFFFFFF\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait UpperHex {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `p` formatting.\n///\n/// The `Pointer` trait should format its output as a memory location. This is commonly presented\n/// as hexadecimal.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `&i32`:\n///\n/// ```\n/// let x = &42;\n///\n/// let address = format!(\"{:p}\", x); // this produces something like '0x7f06092ac6d0'\n/// ```\n///\n/// Implementing `Pointer` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::Pointer for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         // use `as` to convert to a `*const T`, which implements Pointer, which we can use\n///\n///         let ptr = self as *const Self;\n///         fmt::Pointer::fmt(&ptr, f)\n///     }\n/// }\n///\n/// let l = Length(42);\n///\n/// println!(\"l is in memory here: {:p}\", l);\n///\n/// let l_ptr = format!(\"{:018p}\", l);\n/// assert_eq!(l_ptr.len(), 18);\n/// assert_eq!(&l_ptr[..2], \"0x\");\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Pointer {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `e` formatting.\n///\n/// The `LowerExp` trait should format its output in scientific notation with a lower-case `e`.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `f64`:\n///\n/// ```\n/// let x = 42.0; // 42.0 is '4.2e1' in scientific notation\n///\n/// assert_eq!(format!(\"{:e}\", x), \"4.2e1\");\n/// ```\n///\n/// Implementing `LowerExp` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::LowerExp for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         let val = f64::from(self.0);\n///         fmt::LowerExp::fmt(&val, f) // delegate to f64's implementation\n///     }\n/// }\n///\n/// let l = Length(100);\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:e}\", l),\n///     \"l in scientific notation is: 1e2\"\n/// );\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:05e}\", l),\n///     \"l in scientific notation is: 001e2\"\n/// );\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait LowerExp {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// `E` formatting.\n///\n/// The `UpperExp` trait should format its output in scientific notation with an upper-case `E`.\n///\n/// For more information on formatters, see [the module-level documentation][module].\n///\n/// [module]: ../../std/fmt/index.html\n///\n/// # Examples\n///\n/// Basic usage with `f64`:\n///\n/// ```\n/// let x = 42.0; // 42.0 is '4.2E1' in scientific notation\n///\n/// assert_eq!(format!(\"{:E}\", x), \"4.2E1\");\n/// ```\n///\n/// Implementing `UpperExp` on a type:\n///\n/// ```\n/// use std::fmt;\n///\n/// struct Length(i32);\n///\n/// impl fmt::UpperExp for Length {\n///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n///         let val = f64::from(self.0);\n///         fmt::UpperExp::fmt(&val, f) // delegate to f64's implementation\n///     }\n/// }\n///\n/// let l = Length(100);\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:E}\", l),\n///     \"l in scientific notation is: 1E2\"\n/// );\n///\n/// assert_eq!(\n///     format!(\"l in scientific notation is: {:05E}\", l),\n///     \"l in scientific notation is: 001E2\"\n/// );\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait UpperExp {\n    /// Formats the value using the given formatter.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n}\n\n/// The `write` function takes an output stream, and an `Arguments` struct\n/// that can be precompiled with the `format_args!` macro.\n///\n/// The arguments will be formatted according to the specified format string\n/// into the output stream provided.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::fmt;\n///\n/// let mut output = String::new();\n/// fmt::write(&mut output, format_args!(\"Hello {}!\", \"world\"))\n///     .expect(\"Error occurred while trying to write in String\");\n/// assert_eq!(output, \"Hello world!\");\n/// ```\n///\n/// Please note that using [`write!`] might be preferable. Example:\n///\n/// ```\n/// use std::fmt::Write;\n///\n/// let mut output = String::new();\n/// write!(&mut output, \"Hello {}!\", \"world\")\n///     .expect(\"Error occurred while trying to write in String\");\n/// assert_eq!(output, \"Hello world!\");\n/// ```\n///\n/// [`write!`]: ../../std/macro.write.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n}\n\nfn run(fmt: &mut Formatter<'_>, arg: &rt::v1::Argument, args: &[ArgumentV1<'_>]) -> Result {\n}\n\nfn getcount(args: &[ArgumentV1<'_>], cnt: &rt::v1::Count) -> Option<usize> {\n}\n\n/// Padding after the end of something. Returned by `Formatter::padding`.\n#[must_use = \"don't forget to write the post padding\"]\nstruct PostPadding {\n    fill: char,\n    padding: usize,\n}\n\nimpl PostPadding {\n    fn new(fill: char, padding: usize) -> PostPadding {\n}\n\n    /// Write this post padding.\n    fn write(self, buf: &mut dyn Write) -> Result {\n}\n}\n\nimpl<'a> Formatter<'a> {\n    fn wrap_buf<'b, 'c, F>(&'b mut self, wrap: F) -> Formatter<'c>\n    where\n        'b: 'c,\n        F: FnOnce(&'b mut (dyn Write + 'b)) -> &'c mut (dyn Write + 'c),\n    {\n}\n\n    // Helper methods used for padding and processing formatting arguments that\n    // all formatting traits can use.\n\n    /// Performs the correct padding for an integer which has already been\n    /// emitted into a str. The str should *not* contain the sign for the\n    /// integer, that will be added by this method.\n    ///\n    /// # Arguments\n    ///\n    /// * is_nonnegative - whether the original integer was either positive or zero.\n    /// * prefix - if the '#' character (Alternate) is provided, this\n    ///   is the prefix to put in front of the number.\n    /// * buf - the byte array that the number has been formatted into\n    ///\n    /// This function will correctly account for the flags provided as well as\n    /// the minimum width. It will not take precision into account.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo { nb: i32 };\n    ///\n    /// impl Foo {\n    ///     fn new(nb: i32) -> Foo {\n    ///         Foo {\n    ///             nb,\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         // We need to remove \"-\" from the number output.\n    ///         let tmp = self.nb.abs().to_string();\n    ///\n    ///         formatter.pad_integral(self.nb > 0, \"Foo \", &tmp)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{}\", Foo::new(2)), \"2\");\n    /// assert_eq!(&format!(\"{}\", Foo::new(-1)), \"-1\");\n    /// assert_eq!(&format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n    /// assert_eq!(&format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pad_integral(&mut self, is_nonnegative: bool, prefix: &str, buf: &str) -> Result {\n}\n\n    /// This function takes a string slice and emits it to the internal buffer\n    /// after applying the relevant formatting flags specified. The flags\n    /// recognized for generic strings are:\n    ///\n    /// * width - the minimum width of what to emit\n    /// * fill/align - what to emit and where to emit it if the string\n    ///                provided needs to be padded\n    /// * precision - the maximum length to emit, the string is truncated if it\n    ///               is longer than this length\n    ///\n    /// Notably this function ignores the `flag` parameters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         formatter.pad(\"Foo\")\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:<4}\", Foo), \"Foo \");\n    /// assert_eq!(&format!(\"{:0>4}\", Foo), \"0Foo\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pad(&mut self, s: &str) -> Result {\n}\n\n    /// Write the pre-padding and return the unwritten post-padding. Callers are\n    /// responsible for ensuring post-padding is written after the thing that is\n    /// being padded.\n    fn padding(\n        &mut self,\n        padding: usize,\n        default: rt::v1::Alignment,\n    ) -> result::Result<PostPadding, Error> {\n}\n\n    /// Takes the formatted parts and applies the padding.\n    /// Assumes that the caller already has rendered the parts with required precision,\n    /// so that `self.precision` can be ignored.\n    fn pad_formatted_parts(&mut self, formatted: &flt2dec::Formatted<'_>) -> Result {\n}\n\n    fn write_formatted_parts(&mut self, formatted: &flt2dec::Formatted<'_>) -> Result {\n}\n\n    /// Writes some data to the underlying buffer contained within this\n    /// formatter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         formatter.write_str(\"Foo\")\n    ///         // This is equivalent to:\n    ///         // write!(formatter, \"Foo\")\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{}\", Foo), \"Foo\");\n    /// assert_eq!(&format!(\"{:0>8}\", Foo), \"Foo\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write_str(&mut self, data: &str) -> Result {\n}\n\n    /// Writes some formatted information into this instance.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         formatter.write_fmt(format_args!(\"Foo {}\", self.0))\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{}\", Foo(-1)), \"Foo -1\");\n    /// assert_eq!(&format!(\"{:0>8}\", Foo(2)), \"Foo 2\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn write_fmt(&mut self, fmt: Arguments<'_>) -> Result {\n}\n\n    /// Flags for formatting\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(\n        since = \"1.24.0\",\n        reason = \"use the `sign_plus`, `sign_minus`, `alternate`, \\\n                  or `sign_aware_zero_pad` methods instead\"\n    )]\n    pub fn flags(&self) -> u32 {\n}\n\n    /// Character used as 'fill' whenever there is alignment.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         let c = formatter.fill();\n    ///         if let Some(width) = formatter.width() {\n    ///             for _ in 0..width {\n    ///                 write!(formatter, \"{}\", c)?;\n    ///             }\n    ///             Ok(())\n    ///         } else {\n    ///             write!(formatter, \"{}\", c)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// // We set alignment to the left with \">\".\n    /// assert_eq!(&format!(\"{:G>3}\", Foo), \"GGG\");\n    /// assert_eq!(&format!(\"{:t>6}\", Foo), \"tttttt\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn fill(&self) -> char {\n}\n\n    /// Flag indicating what form of alignment was requested.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// extern crate core;\n    ///\n    /// use std::fmt::{self, Alignment};\n    ///\n    /// struct Foo;\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         let s = if let Some(s) = formatter.align() {\n    ///             match s {\n    ///                 Alignment::Left    => \"left\",\n    ///                 Alignment::Right   => \"right\",\n    ///                 Alignment::Center  => \"center\",\n    ///             }\n    ///         } else {\n    ///             \"into the void\"\n    ///         };\n    ///         write!(formatter, \"{}\", s)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:<}\", Foo), \"left\");\n    /// assert_eq!(&format!(\"{:>}\", Foo), \"right\");\n    /// assert_eq!(&format!(\"{:^}\", Foo), \"center\");\n    /// assert_eq!(&format!(\"{}\", Foo), \"into the void\");\n    /// ```\n    #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n    pub fn align(&self) -> Option<Alignment> {\n}\n\n    /// Optionally specified integer width that the output should be.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         if let Some(width) = formatter.width() {\n    ///             // If we received a width, we use it\n    ///             write!(formatter, \"{:width$}\", &format!(\"Foo({})\", self.0), width = width)\n    ///         } else {\n    ///             // Otherwise we do nothing special\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\n    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn width(&self) -> Option<usize> {\n}\n\n    /// Optionally specified precision for numeric types.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(f32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         if let Some(precision) = formatter.precision() {\n    ///             // If we received a precision, we use it.\n    ///             write!(formatter, \"Foo({1:.*})\", precision, self.0)\n    ///         } else {\n    ///             // Otherwise we default to 2.\n    ///             write!(formatter, \"Foo({:.2})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n    /// assert_eq!(&format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn precision(&self) -> Option<usize> {\n}\n\n    /// Determines if the `+` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         if formatter.sign_plus() {\n    ///             write!(formatter,\n    ///                    \"Foo({}{})\",\n    ///                    if self.0 < 0 { '-' } else { '+' },\n    ///                    self.0)\n    ///         } else {\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_plus(&self) -> bool {\n}\n\n    /// Determines if the `-` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         if formatter.sign_minus() {\n    ///             // You want a minus sign? Have one!\n    ///             write!(formatter, \"-Foo({})\", self.0)\n    ///         } else {\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:-}\", Foo(23)), \"-Foo(23)\");\n    /// assert_eq!(&format!(\"{}\", Foo(23)), \"Foo(23)\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_minus(&self) -> bool {\n}\n\n    /// Determines if the `#` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         if formatter.alternate() {\n    ///             write!(formatter, \"Foo({})\", self.0)\n    ///         } else {\n    ///             write!(formatter, \"{}\", self.0)\n    ///         }\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n    /// assert_eq!(&format!(\"{}\", Foo(23)), \"23\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn alternate(&self) -> bool {\n}\n\n    /// Determines if the `0` flag was specified.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::fmt;\n    ///\n    /// struct Foo(i32);\n    ///\n    /// impl fmt::Display for Foo {\n    ///     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    ///         assert!(formatter.sign_aware_zero_pad());\n    ///         assert_eq!(formatter.width(), Some(4));\n    ///         // We ignore the formatter's options.\n    ///         write!(formatter, \"{}\", self.0)\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(&format!(\"{:04}\", Foo(23)), \"23\");\n    /// ```\n    #[stable(feature = \"fmt_flags\", since = \"1.5.0\")]\n    pub fn sign_aware_zero_pad(&self) -> bool {\n}\n\n    // FIXME: Decide what public API we want for these two flags.\n    // https://github.com/rust-lang/rust/issues/48584\n    fn debug_lower_hex(&self) -> bool {\n}\n\n    fn debug_upper_hex(&self) -> bool {\n}\n\n    /// Creates a [`DebugStruct`] builder designed to assist with creation of\n    /// [`fmt::Debug`] implementations for structs.\n    ///\n    /// [`DebugStruct`]: ../../std/fmt/struct.DebugStruct.html\n    /// [`fmt::Debug`]: ../../std/fmt/trait.Debug.html\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    /// use std::net::Ipv4Addr;\n    ///\n    /// struct Foo {\n    ///     bar: i32,\n    ///     baz: String,\n    ///     addr: Ipv4Addr,\n    /// }\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_struct(\"Foo\")\n    ///             .field(\"bar\", &self.bar)\n    ///             .field(\"baz\", &self.baz)\n    ///             .field(\"addr\", &format_args!(\"{}\", self.addr))\n    ///             .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n    ///     format!(\"{:?}\", Foo {\n    ///         bar: 10,\n    ///         baz: \"Hello World\".to_string(),\n    ///         addr: Ipv4Addr::new(127, 0, 0, 1),\n    ///     })\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> {\n}\n\n    /// Creates a `DebugTuple` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for tuple structs.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    /// use std::marker::PhantomData;\n    ///\n    /// struct Foo<T>(i32, String, PhantomData<T>);\n    ///\n    /// impl<T> fmt::Debug for Foo<T> {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_tuple(\"Foo\")\n    ///             .field(&self.0)\n    ///             .field(&self.1)\n    ///             .field(&format_args!(\"_\"))\n    ///             .finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     \"Foo(10, \\\"Hello\\\", _)\",\n    ///     format!(\"{:?}\", Foo(10, \"Hello\".to_string(), PhantomData::<u8>))\n    /// );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> {\n}\n\n    /// Creates a `DebugList` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for list-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_list().entries(self.0.iter()).finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(format!(\"{:?}\", Foo(vec![10, 11])), \"[10, 11]\");\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_list<'b>(&'b mut self) -> DebugList<'b, 'a> {\n}\n\n    /// Creates a `DebugSet` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for set-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<i32>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_set().entries(self.0.iter()).finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(format!(\"{:?}\", Foo(vec![10, 11])), \"{10, 11}\");\n    /// ```\n    ///\n    /// [`format_args!`]: ../../std/macro.format_args.html\n    ///\n    /// In this more complex example, we use [`format_args!`] and `.debug_set()`\n    /// to build a list of match arms:\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Arm<'a, L: 'a, R: 'a>(&'a (L, R));\n    /// struct Table<'a, K: 'a, V: 'a>(&'a [(K, V)], V);\n    ///\n    /// impl<'a, L, R> fmt::Debug for Arm<'a, L, R>\n    /// where\n    ///     L: 'a + fmt::Debug, R: 'a + fmt::Debug\n    /// {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         L::fmt(&(self.0).0, fmt)?;\n    ///         fmt.write_str(\" => \")?;\n    ///         R::fmt(&(self.0).1, fmt)\n    ///     }\n    /// }\n    ///\n    /// impl<'a, K, V> fmt::Debug for Table<'a, K, V>\n    /// where\n    ///     K: 'a + fmt::Debug, V: 'a + fmt::Debug\n    /// {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_set()\n    ///         .entries(self.0.iter().map(Arm))\n    ///         .entry(&Arm(&(format_args!(\"_\"), &self.1)))\n    ///         .finish()\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_set<'b>(&'b mut self) -> DebugSet<'b, 'a> {\n}\n\n    /// Creates a `DebugMap` builder designed to assist with creation of\n    /// `fmt::Debug` implementations for map-like structures.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::fmt;\n    ///\n    /// struct Foo(Vec<(String, i32)>);\n    ///\n    /// impl fmt::Debug for Foo {\n    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n    ///         fmt.debug_map().entries(self.0.iter().map(|&(ref k, ref v)| (k, v))).finish()\n    ///     }\n    /// }\n    ///\n    /// assert_eq!(\n    ///     format!(\"{:?}\",  Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n    ///     r#\"{\"A\": 10, \"B\": 11}\"#\n    ///  );\n    /// ```\n    #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n    pub fn debug_map<'b>(&'b mut self) -> DebugMap<'b, 'a> {\n}\n}\n\n#[stable(since = \"1.2.0\", feature = \"formatter_write\")]\nimpl Write for Formatter<'_> {\n    fn write_str(&mut self, s: &str) -> Result {\n}\n\n    fn write_char(&mut self, c: char) -> Result {\n}\n\n    fn write_fmt(&mut self, args: Arguments<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for Error {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n// Implementations of the core formatting traits\n\nmacro_rules! fmt_refs {\n    ($($tr:ident),*) => {\n        $(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized + $tr> $tr for &T {\n            fn fmt(&self, f: &mut Formatter<'_>) -> Result { }\n        }\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized + $tr> $tr for &mut T {\n            fn fmt(&self, f: &mut Formatter<'_>) -> Result { }\n        }\n        )*\n    }\n}\n\nfmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl Debug for ! {\n}\n\n#[unstable(feature = \"never_type\", issue = \"35121\")]\nimpl Display for ! {\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for bool {\n    #[inline]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for bool {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for str {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for str {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for char {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Display for char {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Pointer for *const T {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Pointer for *mut T {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Pointer for &T {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Pointer for &mut T {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n// Implementation of Display/Debug for various core types\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Debug for *const T {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Debug for *mut T {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\nmacro_rules! peel {\n    ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n}\n\nmacro_rules! tuple {\n    () => ();\n    ( $($name:ident,)+ ) => (\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<$($name:Debug),+> Debug for ($($name,)+) where last_type!($($name,)+): ?Sized {\n            #[allow(non_snake_case, unused_assignments)]\n            fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n        }\n        peel! { $($name,)+ }\n    )\n}\n\nmacro_rules! last_type {\n    ($a:ident,) => { $a };\n    ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n}\n\ntuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Debug> Debug for [T] {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Debug for () {\n    #[inline]\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Debug for PhantomData<T> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Copy + Debug> Debug for Cell<T> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Debug> Debug for RefCell<T> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Debug> Debug for Ref<'_, T> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Debug> Debug for RefMut<'_, T> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: ?Sized + Debug> Debug for UnsafeCell<T> {\n    fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n}\n}\n\n// If you expected tests to be here, look instead at the ui/ifmt.rs test,\n// it's a lot easier than creating all of the rt::Piece structures here.\n}\n#[cfg(not(test))] // See #65860\npub mod hash {\n//! Generic hashing support.\n//!\n//! This module provides a generic way to compute the hash of a value. The\n//! simplest way to make a type hashable is to use `#[derive(Hash)]`:\n//!\n//! # Examples\n//!\n//! ```rust\n//! use std::collections::hash_map::DefaultHasher;\n//! use std::hash::{Hash, Hasher};\n//!\n//! #[derive(Hash)]\n//! struct Person {\n//!     id: u32,\n//!     name: String,\n//!     phone: u64,\n//! }\n//!\n//! let person1 = Person {\n//!     id: 5,\n//!     name: \"Janet\".to_string(),\n//!     phone: 555_666_7777,\n//! };\n//! let person2 = Person {\n//!     id: 5,\n//!     name: \"Bob\".to_string(),\n//!     phone: 555_666_7777,\n//! };\n//!\n//! assert!(calculate_hash(&person1) != calculate_hash(&person2));\n//!\n//! fn calculate_hash<T: Hash>(t: &T) -> u64 {\n//!     let mut s = DefaultHasher::new();\n//!     t.hash(&mut s);\n//!     s.finish()\n//! }\n//! ```\n//!\n//! If you need more control over how a value is hashed, you need to implement\n//! the [`Hash`] trait:\n//!\n//! [`Hash`]: trait.Hash.html\n//!\n//! ```rust\n//! use std::collections::hash_map::DefaultHasher;\n//! use std::hash::{Hash, Hasher};\n//!\n//! struct Person {\n//!     id: u32,\n//!     # #[allow(dead_code)]\n//!     name: String,\n//!     phone: u64,\n//! }\n//!\n//! impl Hash for Person {\n//!     fn hash<H: Hasher>(&self, state: &mut H) {\n//!         self.id.hash(state);\n//!         self.phone.hash(state);\n//!     }\n//! }\n//!\n//! let person1 = Person {\n//!     id: 5,\n//!     name: \"Janet\".to_string(),\n//!     phone: 555_666_7777,\n//! };\n//! let person2 = Person {\n//!     id: 5,\n//!     name: \"Bob\".to_string(),\n//!     phone: 555_666_7777,\n//! };\n//!\n//! assert_eq!(calculate_hash(&person1), calculate_hash(&person2));\n//!\n//! fn calculate_hash<T: Hash>(t: &T) -> u64 {\n//!     let mut s = DefaultHasher::new();\n//!     t.hash(&mut s);\n//!     s.finish()\n//! }\n//! ```\n\n// ignore-tidy-undocumented-unsafe\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse crate::fmt;\nuse crate::marker;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow(deprecated)]\npub use self::sip::SipHasher;\n\n#[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n#[allow(deprecated)]\n#[doc(hidden)]\npub use self::sip::SipHasher13;\n\nmod sip {\n//! An implementation of SipHash.\n\n// ignore-tidy-undocumented-unsafe\n\n#![allow(deprecated)] // the types in this module are deprecated\n\nuse crate::cmp;\nuse crate::marker::PhantomData;\nuse crate::mem;\nuse crate::ptr;\n\n/// An implementation of SipHash 1-3.\n///\n/// This is currently the default hashing function used by standard library\n/// (e.g., `collections::HashMap` uses it by default).\n///\n/// See: <https://131002.net/siphash>\n#[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n#[rustc_deprecated(\n    since = \"1.13.0\",\n    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n)]\n#[derive(Debug, Clone, Default)]\n#[doc(hidden)]\npub struct SipHasher13 {\n}\n\n/// An implementation of SipHash 2-4.\n///\n/// See: <https://131002.net/siphash/>\n#[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n#[rustc_deprecated(\n    since = \"1.13.0\",\n    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n)]\n#[derive(Debug, Clone, Default)]\nstruct SipHasher24 {\n}\n\n/// An implementation of SipHash 2-4.\n///\n/// See: <https://131002.net/siphash/>\n///\n/// SipHash is a general-purpose hashing function: it runs at a good\n/// speed (competitive with Spooky and City) and permits strong _keyed_\n/// hashing. This lets you key your hashtables from a strong RNG, such as\n/// [`rand::os::OsRng`](https://doc.rust-lang.org/rand/rand/os/struct.OsRng.html).\n///\n/// Although the SipHash algorithm is considered to be generally strong,\n/// it is not intended for cryptographic purposes. As such, all\n/// cryptographic uses of this implementation are _strongly discouraged_.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_deprecated(\n    since = \"1.13.0\",\n    reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n)]\n#[derive(Debug, Clone, Default)]\npub struct SipHasher(SipHasher24);\n\n#[derive(Debug)]\nstruct Hasher<S: Sip> {\n    k0: u64,\n    k1: u64,\n    length: usize, // how many bytes we've processed\n    state: State,  // hash State\n    tail: u64,     // unprocessed bytes le\n    ntail: usize,  // how many bytes in tail are valid\n    _marker: PhantomData<S>,\n}\n\n#[derive(Debug, Clone, Copy)]\n#[repr(C)]\nstruct State {\n    // v0, v2 and v1, v3 show up in pairs in the algorithm,\n    // and simd implementations of SipHash will use vectors\n    // of v02 and v13. By placing them in this order in the struct,\n    // the compiler can pick up on just a few simd optimizations by itself.\n    v0: u64,\n    v2: u64,\n    v1: u64,\n    v3: u64,\n}\n\nmacro_rules! compress {\n    ($state:expr) => {{ compress!($state.v0, $state.v1, $state.v2, $state.v3) }};\n    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) => {{\n        $v0 = $v0.wrapping_add($v1);\n        $v1 = $v1.rotate_left(13);\n        $v1 ^= $v0;\n        $v0 = $v0.rotate_left(32);\n        $v2 = $v2.wrapping_add($v3);\n        $v3 = $v3.rotate_left(16);\n        $v3 ^= $v2;\n        $v0 = $v0.wrapping_add($v3);\n        $v3 = $v3.rotate_left(21);\n        $v3 ^= $v0;\n        $v2 = $v2.wrapping_add($v1);\n        $v1 = $v1.rotate_left(17);\n        $v1 ^= $v2;\n        $v2 = $v2.rotate_left(32);\n    }};\n}\n\n/// Loads an integer of the desired type from a byte stream, in LE order. Uses\n/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n/// to load it from a possibly unaligned address.\n///\n/// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\nmacro_rules! load_int_le {\n    ($buf:expr, $i:expr, $int_ty:ident) => {{\n        debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n        let mut data = 0 as $int_ty;\n        ptr::copy_nonoverlapping(\n            $buf.get_unchecked($i),\n            &mut data as *mut _ as *mut u8,\n            mem::size_of::<$int_ty>(),\n        );\n        data.to_le()\n    }};\n}\n\n/// Loads an u64 using up to 7 bytes of a byte slice.\n///\n/// Unsafe because: unchecked indexing at start..start+len\n#[inline]\nunsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n}\n\nimpl SipHasher {\n    /// Creates a new `SipHasher` with the two initial keys set to 0.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(\n        since = \"1.13.0\",\n        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n    )]\n    pub fn new() -> SipHasher {\n}\n\n    /// Creates a `SipHasher` that is keyed off the provided keys.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(\n        since = \"1.13.0\",\n        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n    )]\n    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n}\n}\n\nimpl SipHasher13 {\n    /// Creates a new `SipHasher13` with the two initial keys set to 0.\n    #[inline]\n    #[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n    #[rustc_deprecated(\n        since = \"1.13.0\",\n        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n    )]\n    pub fn new() -> SipHasher13 {\n}\n\n    /// Creates a `SipHasher13` that is keyed off the provided keys.\n    #[inline]\n    #[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n    #[rustc_deprecated(\n        since = \"1.13.0\",\n        reason = \"use `std::collections::hash_map::DefaultHasher` instead\"\n    )]\n    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n}\n}\n\nimpl<S: Sip> Hasher<S> {\n    #[inline]\n    fn new_with_keys(key0: u64, key1: u64) -> Hasher<S> {\n}\n\n    #[inline]\n    fn reset(&mut self) {\n}\n\n    // Specialized write function that is only valid for buffers with len <= 8.\n    // It's used to force inlining of write_u8 and write_usize, those would normally be inlined\n    // except for composite types (that includes slices and str hashing because of delimiter).\n    // Without this extra push the compiler is very reluctant to inline delimiter writes,\n    // degrading performance substantially for the most common use cases.\n    #[inline]\n    fn short_write(&mut self, msg: &[u8]) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl super::Hasher for SipHasher {\n    #[inline]\n    fn write(&mut self, msg: &[u8]) {\n}\n\n    #[inline]\n    fn finish(&self) -> u64 {\n}\n}\n\n#[unstable(feature = \"hashmap_internals\", issue = \"none\")]\nimpl super::Hasher for SipHasher13 {\n}\n\nimpl<S: Sip> super::Hasher for Hasher<S> {\n    // see short_write comment for explanation\n    #[inline]\n    fn write_usize(&mut self, i: usize) {\n}\n\n    // see short_write comment for explanation\n    #[inline]\n    fn write_u8(&mut self, i: u8) {\n}\n\n    #[inline]\n    fn write(&mut self, msg: &[u8]) {\n}\n\n    #[inline]\n    fn finish(&self) -> u64 {\n}\n}\n\nimpl<S: Sip> Clone for Hasher<S> {\n    #[inline]\n    fn clone(&self) -> Hasher<S> {\n}\n}\n\nimpl<S: Sip> Default for Hasher<S> {\n    /// Creates a `Hasher<S>` with the two initial keys set to 0.\n    #[inline]\n    fn default() -> Hasher<S> {\n}\n}\n\n#[doc(hidden)]\ntrait Sip {\n    fn c_rounds(_: &mut State);\n    fn d_rounds(_: &mut State);\n}\n\n#[derive(Debug, Clone, Default)]\nstruct Sip13Rounds;\n\nimpl Sip for Sip13Rounds {\n    #[inline]\n    fn c_rounds(state: &mut State) {\n}\n\n    #[inline]\n    fn d_rounds(state: &mut State) {\n}\n}\n\n#[derive(Debug, Clone, Default)]\nstruct Sip24Rounds;\n\nimpl Sip for Sip24Rounds {\n    #[inline]\n    fn c_rounds(state: &mut State) {\n}\n\n    #[inline]\n    fn d_rounds(state: &mut State) {\n}\n}\n}\n\n/// A hashable type.\n///\n/// Types implementing `Hash` are able to be [`hash`]ed with an instance of\n/// [`Hasher`].\n///\n/// ## Implementing `Hash`\n///\n/// You can derive `Hash` with `#[derive(Hash)]` if all fields implement `Hash`.\n/// The resulting hash will be the combination of the values from calling\n/// [`hash`] on each field.\n///\n/// ```\n/// #[derive(Hash)]\n/// struct Rustacean {\n///     name: String,\n///     country: String,\n/// }\n/// ```\n///\n/// If you need more control over how a value is hashed, you can of course\n/// implement the `Hash` trait yourself:\n///\n/// ```\n/// use std::hash::{Hash, Hasher};\n///\n/// struct Person {\n///     id: u32,\n///     name: String,\n///     phone: u64,\n/// }\n///\n/// impl Hash for Person {\n///     fn hash<H: Hasher>(&self, state: &mut H) {\n///         self.id.hash(state);\n///         self.phone.hash(state);\n///     }\n/// }\n/// ```\n///\n/// ## `Hash` and `Eq`\n///\n/// When implementing both `Hash` and [`Eq`], it is important that the following\n/// property holds:\n///\n/// ```text\n/// k1 == k2 -> hash(k1) == hash(k2)\n/// ```\n///\n/// In other words, if two keys are equal, their hashes must also be equal.\n/// [`HashMap`] and [`HashSet`] both rely on this behavior.\n///\n/// Thankfully, you won't need to worry about upholding this property when\n/// deriving both [`Eq`] and `Hash` with `#[derive(PartialEq, Eq, Hash)]`.\n///\n/// [`Eq`]: ../../std/cmp/trait.Eq.html\n/// [`Hasher`]: trait.Hasher.html\n/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n/// [`HashSet`]: ../../std/collections/struct.HashSet.html\n/// [`hash`]: #tymethod.hash\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Hash {\n    /// Feeds this value into the given [`Hasher`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::DefaultHasher;\n    /// use std::hash::{Hash, Hasher};\n    ///\n    /// let mut hasher = DefaultHasher::new();\n    /// 7920.hash(&mut hasher);\n    /// println!(\"Hash is {:x}!\", hasher.finish());\n    /// ```\n    ///\n    /// [`Hasher`]: trait.Hasher.html\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn hash<H: Hasher>(&self, state: &mut H);\n\n    /// Feeds a slice of this type into the given [`Hasher`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::DefaultHasher;\n    /// use std::hash::{Hash, Hasher};\n    ///\n    /// let mut hasher = DefaultHasher::new();\n    /// let numbers = [6, 28, 496, 8128];\n    /// Hash::hash_slice(&numbers, &mut hasher);\n    /// println!(\"Hash is {:x}!\", hasher.finish());\n    /// ```\n    ///\n    /// [`Hasher`]: trait.Hasher.html\n    #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n    where\n        Self: Sized,\n    {\n}\n}\n\n// Separate module to reexport the macro `Hash` from prelude without the trait `Hash`.\npub(crate) mod macros {\n    /// Derive macro generating an impl of the trait `Hash`.\n    #[rustc_builtin_macro]\n    #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n    #[allow_internal_unstable(core_intrinsics)]\n    pub macro Hash($item:item) {\n        /* compiler built-in */\n    }\n}\n#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n#[doc(inline)]\npub use macros::Hash;\n\n/// A trait for hashing an arbitrary stream of bytes.\n///\n/// Instances of `Hasher` usually represent state that is changed while hashing\n/// data.\n///\n/// `Hasher` provides a fairly basic interface for retrieving the generated hash\n/// (with [`finish`]), and writing integers as well as slices of bytes into an\n/// instance (with [`write`] and [`write_u8`] etc.). Most of the time, `Hasher`\n/// instances are used in conjunction with the [`Hash`] trait.\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::hash_map::DefaultHasher;\n/// use std::hash::Hasher;\n///\n/// let mut hasher = DefaultHasher::new();\n///\n/// hasher.write_u32(1989);\n/// hasher.write_u8(11);\n/// hasher.write_u8(9);\n/// hasher.write(b\"Huh?\");\n///\n/// println!(\"Hash is {:x}!\", hasher.finish());\n/// ```\n///\n/// [`Hash`]: trait.Hash.html\n/// [`finish`]: #tymethod.finish\n/// [`write`]: #tymethod.write\n/// [`write_u8`]: #method.write_u8\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait Hasher {\n    /// Returns the hash value for the values written so far.\n    ///\n    /// Despite its name, the method does not reset the hasher’s internal\n    /// state. Additional [`write`]s will continue from the current value.\n    /// If you need to start a fresh hash value, you will have to create\n    /// a new hasher.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::DefaultHasher;\n    /// use std::hash::Hasher;\n    ///\n    /// let mut hasher = DefaultHasher::new();\n    /// hasher.write(b\"Cool!\");\n    ///\n    /// println!(\"Hash is {:x}!\", hasher.finish());\n    /// ```\n    ///\n    /// [`write`]: #tymethod.write\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn finish(&self) -> u64;\n\n    /// Writes some data into this `Hasher`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::DefaultHasher;\n    /// use std::hash::Hasher;\n    ///\n    /// let mut hasher = DefaultHasher::new();\n    /// let data = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];\n    ///\n    /// hasher.write(&data);\n    ///\n    /// println!(\"Hash is {:x}!\", hasher.finish());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn write(&mut self, bytes: &[u8]);\n\n    /// Writes a single `u8` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_u8(&mut self, i: u8) {\n        self.write(&[i])\n    }\n    /// Writes a single `u16` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_u16(&mut self, i: u16) {\n}\n    /// Writes a single `u32` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_u32(&mut self, i: u32) {\n}\n    /// Writes a single `u64` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_u64(&mut self, i: u64) {\n}\n    /// Writes a single `u128` into this hasher.\n    #[inline]\n    #[stable(feature = \"i128\", since = \"1.26.0\")]\n    fn write_u128(&mut self, i: u128) {\n}\n    /// Writes a single `usize` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_usize(&mut self, i: usize) {\n}\n\n    /// Writes a single `i8` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_i8(&mut self, i: i8) {\n}\n    /// Writes a single `i16` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_i16(&mut self, i: i16) {\n}\n    /// Writes a single `i32` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_i32(&mut self, i: i32) {\n}\n    /// Writes a single `i64` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_i64(&mut self, i: i64) {\n}\n    /// Writes a single `i128` into this hasher.\n    #[inline]\n    #[stable(feature = \"i128\", since = \"1.26.0\")]\n    fn write_i128(&mut self, i: i128) {\n}\n    /// Writes a single `isize` into this hasher.\n    #[inline]\n    #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n    fn write_isize(&mut self, i: isize) {\n}\n}\n\n#[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\nimpl<H: Hasher + ?Sized> Hasher for &mut H {\n    fn finish(&self) -> u64 {\n}\n    fn write(&mut self, bytes: &[u8]) {\n}\n    fn write_u8(&mut self, i: u8) {\n}\n    fn write_u16(&mut self, i: u16) {\n}\n    fn write_u32(&mut self, i: u32) {\n}\n    fn write_u64(&mut self, i: u64) {\n}\n    fn write_u128(&mut self, i: u128) {\n}\n    fn write_usize(&mut self, i: usize) {\n}\n    fn write_i8(&mut self, i: i8) {\n}\n    fn write_i16(&mut self, i: i16) {\n}\n    fn write_i32(&mut self, i: i32) {\n}\n    fn write_i64(&mut self, i: i64) {\n}\n    fn write_i128(&mut self, i: i128) {\n}\n    fn write_isize(&mut self, i: isize) {\n}\n}\n\n/// A trait for creating instances of [`Hasher`].\n///\n/// A `BuildHasher` is typically used (e.g., by [`HashMap`]) to create\n/// [`Hasher`]s for each key such that they are hashed independently of one\n/// another, since [`Hasher`]s contain state.\n///\n/// For each instance of `BuildHasher`, the [`Hasher`]s created by\n/// [`build_hasher`] should be identical. That is, if the same stream of bytes\n/// is fed into each hasher, the same output will also be generated.\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::hash_map::RandomState;\n/// use std::hash::{BuildHasher, Hasher};\n///\n/// let s = RandomState::new();\n/// let mut hasher_1 = s.build_hasher();\n/// let mut hasher_2 = s.build_hasher();\n///\n/// hasher_1.write_u32(8128);\n/// hasher_2.write_u32(8128);\n///\n/// assert_eq!(hasher_1.finish(), hasher_2.finish());\n/// ```\n///\n/// [`build_hasher`]: #tymethod.build_hasher\n/// [`Hasher`]: trait.Hasher.html\n/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\npub trait BuildHasher {\n    /// Type of the hasher that will be created.\n    #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n    type Hasher: Hasher;\n\n    /// Creates a new hasher.\n    ///\n    /// Each call to `build_hasher` on the same instance should produce identical\n    /// [`Hasher`]s.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::hash_map::RandomState;\n    /// use std::hash::BuildHasher;\n    ///\n    /// let s = RandomState::new();\n    /// let new_s = s.build_hasher();\n    /// ```\n    ///\n    /// [`Hasher`]: trait.Hasher.html\n    #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n    fn build_hasher(&self) -> Self::Hasher;\n}\n\n/// Used to create a default [`BuildHasher`] instance for types that implement\n/// [`Hasher`] and [`Default`].\n///\n/// `BuildHasherDefault<H>` can be used when a type `H` implements [`Hasher`] and\n/// [`Default`], and you need a corresponding [`BuildHasher`] instance, but none is\n/// defined.\n///\n/// Any `BuildHasherDefault` is [zero-sized]. It can be created with\n/// [`default`][method.Default]. When using `BuildHasherDefault` with [`HashMap`] or\n/// [`HashSet`], this doesn't need to be done, since they implement appropriate\n/// [`Default`] instances themselves.\n///\n/// # Examples\n///\n/// Using `BuildHasherDefault` to specify a custom [`BuildHasher`] for\n/// [`HashMap`]:\n///\n/// ```\n/// use std::collections::HashMap;\n/// use std::hash::{BuildHasherDefault, Hasher};\n///\n/// #[derive(Default)]\n/// struct MyHasher;\n///\n/// impl Hasher for MyHasher {\n///     fn write(&mut self, bytes: &[u8]) {\n///         // Your hashing algorithm goes here!\n///        unimplemented!()\n///     }\n///\n///     fn finish(&self) -> u64 {\n///         // Your hashing algorithm goes here!\n///         unimplemented!()\n///     }\n/// }\n///\n/// type MyBuildHasher = BuildHasherDefault<MyHasher>;\n///\n/// let hash_map = HashMap::<u32, u32, MyBuildHasher>::default();\n/// ```\n///\n/// [`BuildHasher`]: trait.BuildHasher.html\n/// [`Default`]: ../default/trait.Default.html\n/// [method.default]: #method.default\n/// [`Hasher`]: trait.Hasher.html\n/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n/// [`HashSet`]: ../../std/collections/struct.HashSet.html\n/// [zero-sized]: https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts\n#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\npub struct BuildHasherDefault<H>(marker::PhantomData<H>);\n\n#[stable(since = \"1.9.0\", feature = \"core_impl_debug\")]\nimpl<H> fmt::Debug for BuildHasherDefault<H> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\nimpl<H: Default + Hasher> BuildHasher for BuildHasherDefault<H> {\n    type Hasher = H;\n\n    fn build_hasher(&self) -> H {\n}\n}\n\n#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\nimpl<H> Clone for BuildHasherDefault<H> {\n    fn clone(&self) -> BuildHasherDefault<H> {\n}\n}\n\n#[stable(since = \"1.7.0\", feature = \"build_hasher\")]\nimpl<H> Default for BuildHasherDefault<H> {\n    fn default() -> BuildHasherDefault<H> {\n}\n}\n\n#[stable(since = \"1.29.0\", feature = \"build_hasher_eq\")]\nimpl<H> PartialEq for BuildHasherDefault<H> {\n    fn eq(&self, _other: &BuildHasherDefault<H>) -> bool {\n}\n}\n\n#[stable(since = \"1.29.0\", feature = \"build_hasher_eq\")]\nimpl<H> Eq for BuildHasherDefault<H> {}\n\nmod impls {\n    use crate::mem;\n    use crate::slice;\n\n    use super::*;\n\n    macro_rules! impl_write {\n        ($(($ty:ident, $meth:ident),)*) => {$(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Hash for $ty {\n                fn hash<H: Hasher>(&self, state: &mut H) {\n}\n\n                fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n}\n            }\n        )*}\n    }\n\n    impl_write! {\n        (u8, write_u8),\n        (u16, write_u16),\n        (u32, write_u32),\n        (u64, write_u64),\n        (usize, write_usize),\n        (i8, write_i8),\n        (i16, write_i16),\n        (i32, write_i32),\n        (i64, write_i64),\n        (isize, write_isize),\n        (u128, write_u128),\n        (i128, write_i128),\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Hash for bool {\n        fn hash<H: Hasher>(&self, state: &mut H) {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Hash for char {\n        fn hash<H: Hasher>(&self, state: &mut H) {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl Hash for str {\n        fn hash<H: Hasher>(&self, state: &mut H) {\n}\n    }\n\n    #[stable(feature = \"never_hash\", since = \"1.29.0\")]\n    impl Hash for ! {\n        fn hash<H: Hasher>(&self, _: &mut H) {\n}\n    }\n\n    macro_rules! impl_hash_tuple {\n        () => (\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Hash for () {\n                fn hash<H: Hasher>(&self, _state: &mut H) {}}\n        );\n\n        ( $($name:ident)+) => (\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($name: Hash),+> Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n                #[allow(non_snake_case)]\n                fn hash<S: Hasher>(&self, state: &mut S) {\n}\n            }\n        );\n    }\n\n    macro_rules! last_type {\n        ($a:ident,) => { $a };\n        ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n    }\n\n    impl_hash_tuple! {}\n    impl_hash_tuple! { A }\n    impl_hash_tuple! { A B }\n    impl_hash_tuple! { A B C }\n    impl_hash_tuple! { A B C D }\n    impl_hash_tuple! { A B C D E }\n    impl_hash_tuple! { A B C D E F }\n    impl_hash_tuple! { A B C D E F G }\n    impl_hash_tuple! { A B C D E F G H }\n    impl_hash_tuple! { A B C D E F G H I }\n    impl_hash_tuple! { A B C D E F G H I J }\n    impl_hash_tuple! { A B C D E F G H I J K }\n    impl_hash_tuple! { A B C D E F G H I J K L }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: Hash> Hash for [T] {\n        fn hash<H: Hasher>(&self, state: &mut H) {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized + Hash> Hash for &T {\n        fn hash<H: Hasher>(&self, state: &mut H) {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized + Hash> Hash for &mut T {\n        fn hash<H: Hasher>(&self, state: &mut H) {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> Hash for *const T {\n        fn hash<H: Hasher>(&self, state: &mut H) {\n}\n    }\n\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    impl<T: ?Sized> Hash for *mut T {\n        fn hash<H: Hasher>(&self, state: &mut H) {\n}\n    }\n}\n}\npub mod slice {\n// ignore-tidy-filelength\n// ignore-tidy-undocumented-unsafe\n\n//! Slice management and manipulation.\n//!\n//! For more details see [`std::slice`].\n//!\n//! [`std::slice`]: ../../std/slice/index.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n// How this module is organized.\n//\n// The library infrastructure for slices is fairly messy. There's\n// a lot of stuff defined here. Let's keep it clean.\n//\n// The layout of this file is thus:\n//\n// * Inherent methods. This is where most of the slice API resides.\n// * Implementations of a few common traits with important slice ops.\n// * Definitions of a bunch of iterators.\n// * Free functions.\n// * The `raw` and `bytes` submodules.\n// * Boilerplate trait implementations.\n\nuse crate::cmp;\nuse crate::cmp::Ordering::{self, Equal, Greater, Less};\nuse crate::fmt;\nuse crate::intrinsics::{assume, exact_div, is_aligned_and_not_null, unchecked_sub};\nuse crate::isize;\nuse crate::iter::*;\nuse crate::marker::{self, Copy, Send, Sized, Sync};\nuse crate::mem;\nuse crate::ops::{self, FnMut, Range};\nuse crate::option::Option;\nuse crate::option::Option::{None, Some};\nuse crate::ptr::{self, NonNull};\nuse crate::result::Result;\nuse crate::result::Result::{Err, Ok};\n\n#[unstable(\n    feature = \"slice_internals\",\n    issue = \"none\",\n    reason = \"exposed from core to be reused in std; use the memchr crate\"\n)]\n/// Pure rust memchr implementation, taken from rust-memchr\npub mod memchr {\n// Original implementation taken from rust-memchr.\n// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n\n// ignore-tidy-undocumented-unsafe\n\nuse crate::cmp;\nuse crate::mem;\n\nconst LO_U64: u64 = 0x0101010101010101;\nconst HI_U64: u64 = 0x8080808080808080;\n\n// Use truncation.\nconst LO_USIZE: usize = LO_U64 as usize;\nconst HI_USIZE: usize = HI_U64 as usize;\n\n/// Returns `true` if `x` contains any zero byte.\n///\n/// From *Matters Computational*, J. Arndt:\n///\n/// \"The idea is to subtract one from each of the bytes and then look for\n/// bytes where the borrow propagated all the way to the most significant\n/// bit.\"\n#[inline]\nfn contains_zero_byte(x: usize) -> bool {\n}\n\n#[cfg(target_pointer_width = \"16\")]\n#[inline]\nfn repeat_byte(b: u8) -> usize {\n}\n\n#[cfg(not(target_pointer_width = \"16\"))]\n#[inline]\nfn repeat_byte(b: u8) -> usize {\n}\n\n/// Returns the first index matching the byte `x` in `text`.\npub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n}\n\n/// Returns the last index matching the byte `x` in `text`.\npub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n}\n}\n\nmod rotate {\nuse crate::cmp;\nuse crate::mem::{self, MaybeUninit};\nuse crate::ptr;\n\n/// Rotates the range `[mid-left, mid+right)` such that the element at `mid` becomes the first\n/// element. Equivalently, rotates the range `left` elements to the left or `right` elements to the\n/// right.\n///\n/// # Safety\n///\n/// The specified range must be valid for reading and writing.\n///\n/// # Algorithm\n///\n/// Algorithm 1 is used for small values of `left + right` or for large `T`. The elements are moved\n/// into their final positions one at a time starting at `mid - left` and advancing by `right` steps\n/// modulo `left + right`, such that only one temporary is needed. Eventually, we arrive back at\n/// `mid - left`. However, if `gcd(left + right, right)` is not 1, the above steps skipped over\n/// elements. For example:\n/// ```text\n/// left = 10, right = 6\n/// the `^` indicates an element in its final place\n/// 6 7 8 9 10 11 12 13 14 15 . 0 1 2 3 4 5\n/// after using one step of the above algorithm (The X will be overwritten at the end of the round,\n/// and 12 is stored in a temporary):\n/// X 7 8 9 10 11 6 13 14 15 . 0 1 2 3 4 5\n///               ^\n/// after using another step (now 2 is in the temporary):\n/// X 7 8 9 10 11 6 13 14 15 . 0 1 12 3 4 5\n///               ^                 ^\n/// after the third step (the steps wrap around, and 8 is in the temporary):\n/// X 7 2 9 10 11 6 13 14 15 . 0 1 12 3 4 5\n///     ^         ^                 ^\n/// after 7 more steps, the round ends with the temporary 0 getting put in the X:\n/// 0 7 2 9 4 11 6 13 8 15 . 10 1 12 3 14 5\n/// ^   ^   ^    ^    ^       ^    ^    ^\n/// ```\n/// Fortunately, the number of skipped over elements between finalized elements is always equal, so\n/// we can just offset our starting position and do more rounds (the total number of rounds is the\n/// `gcd(left + right, right)` value). The end result is that all elements are finalized once and\n/// only once.\n///\n/// Algorithm 2 is used if `left + right` is large but `min(left, right)` is small enough to\n/// fit onto a stack buffer. The `min(left, right)` elements are copied onto the buffer, `memmove`\n/// is applied to the others, and the ones on the buffer are moved back into the hole on the\n/// opposite side of where they originated.\n///\n/// Algorithms that can be vectorized outperform the above once `left + right` becomes large enough.\n/// Algorithm 1 can be vectorized by chunking and performing many rounds at once, but there are too\n/// few rounds on average until `left + right` is enormous, and the worst case of a single\n/// round is always there. Instead, algorithm 3 utilizes repeated swapping of\n/// `min(left, right)` elements until a smaller rotate problem is left.\n///\n/// ```text\n/// left = 11, right = 4\n/// [4 5 6 7 8 9 10 11 12 13 14 . 0 1 2 3]\n///                  ^  ^  ^  ^   ^ ^ ^ ^ swapping the right most elements with elements to the left\n/// [4 5 6 7 8 9 10 . 0 1 2 3] 11 12 13 14\n///        ^ ^ ^  ^   ^ ^ ^ ^ swapping these\n/// [4 5 6 . 0 1 2 3] 7 8 9 10 11 12 13 14\n/// we cannot swap any more, but a smaller rotation problem is left to solve\n/// ```\n/// when `left < right` the swapping happens from the left instead.\npub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize) {\n}\n}\nmod sort {\n//! Slice sorting\n//!\n//! This module contains an sort algorithm based on Orson Peters' pattern-defeating quicksort,\n//! published at: https://github.com/orlp/pdqsort\n//!\n//! Unstable sorting is compatible with libcore because it doesn't allocate memory, unlike our\n//! stable sorting implementation.\n\n// ignore-tidy-undocumented-unsafe\n\nuse crate::cmp;\nuse crate::mem::{self, MaybeUninit};\nuse crate::ptr;\n\n/// When dropped, copies from `src` into `dest`.\nstruct CopyOnDrop<T> {\n    src: *mut T,\n    dest: *mut T,\n}\n\nimpl<T> Drop for CopyOnDrop<T> {\n    fn drop(&mut self) {\n}\n}\n\n/// Shifts the first element to the right until it encounters a greater or equal element.\nfn shift_head<T, F>(v: &mut [T], is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\n/// Shifts the last element to the left until it encounters a smaller or equal element.\nfn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\n/// Partially sorts a slice by shifting several out-of-order elements around.\n///\n/// Returns `true` if the slice is sorted at the end. This function is `O(n)` worst-case.\n#[cold]\nfn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\n/// Sorts a slice using insertion sort, which is `O(n^2)` worst-case.\nfn insertion_sort<T, F>(v: &mut [T], is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\n/// Sorts `v` using heapsort, which guarantees `O(n log n)` worst-case.\n#[cold]\npub fn heapsort<T, F>(v: &mut [T], is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\n/// Partitions `v` into elements smaller than `pivot`, followed by elements greater than or equal\n/// to `pivot`.\n///\n/// Returns the number of elements smaller than `pivot`.\n///\n/// Partitioning is performed block-by-block in order to minimize the cost of branching operations.\n/// This idea is presented in the [BlockQuicksort][pdf] paper.\n///\n/// [pdf]: http://drops.dagstuhl.de/opus/volltexte/2016/6389/pdf/LIPIcs-ESA-2016-38.pdf\nfn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\n/// Partitions `v` into elements smaller than `v[pivot]`, followed by elements greater than or\n/// equal to `v[pivot]`.\n///\n/// Returns a tuple of:\n///\n/// 1. Number of elements smaller than `v[pivot]`.\n/// 2. True if `v` was already partitioned.\nfn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\n/// Partitions `v` into elements equal to `v[pivot]` followed by elements greater than `v[pivot]`.\n///\n/// Returns the number of elements equal to the pivot. It is assumed that `v` does not contain\n/// elements smaller than the pivot.\nfn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\n/// Scatters some elements around in an attempt to break patterns that might cause imbalanced\n/// partitions in quicksort.\n#[cold]\nfn break_patterns<T>(v: &mut [T]) {\n}\n\n/// Chooses a pivot in `v` and returns the index and `true` if the slice is likely already sorted.\n///\n/// Elements in `v` might be reordered in the process.\nfn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\n/// Sorts `v` recursively.\n///\n/// If the slice had a predecessor in the original array, it is specified as `pred`.\n///\n/// `limit` is the number of allowed imbalanced partitions before switching to `heapsort`. If zero,\n/// this function will immediately switch to heapsort.\nfn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T>, mut limit: usize)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\n/// Sorts `v` using pattern-defeating quicksort, which is `O(n log n)` worst-case.\npub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\nfn partition_at_index_loop<'a, T, F>(\n    mut v: &'a mut [T],\n    mut index: usize,\n    is_less: &mut F,\n    mut pred: Option<&'a T>,\n) where\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\npub fn partition_at_index<T, F>(\n    v: &mut [T],\n    index: usize,\n    mut is_less: F,\n) -> (&mut [T], &mut T, &mut [T])\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n}\n\n//\n// Extension traits\n//\n\n#[lang = \"slice\"]\n#[cfg(not(test))]\nimpl<T> [T] {\n    /// Returns the number of elements in the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert_eq!(a.len(), 3);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_slice_len\", since = \"1.32.0\")]\n    #[inline]\n    // SAFETY: const sound because we transmute out the length field as a usize (which it must be)\n    #[allow(unused_attributes)]\n    #[allow_internal_unstable(const_fn_union)]\n    pub const fn len(&self) -> usize {\n}\n\n    /// Returns `true` if the slice has a length of 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = [1, 2, 3];\n    /// assert!(!a.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_slice_is_empty\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn is_empty(&self) -> bool {\n}\n\n    /// Returns the first element of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert_eq!(Some(&10), v.first());\n    ///\n    /// let w: &[i32] = &[];\n    /// assert_eq!(None, w.first());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn first(&self) -> Option<&T> {\n}\n\n    /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some(first) = x.first_mut() {\n    ///     *first = 5;\n    /// }\n    /// assert_eq!(x, &[5, 1, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn first_mut(&mut self) -> Option<&mut T> {\n}\n\n    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[0, 1, 2];\n    ///\n    /// if let Some((first, elements)) = x.split_first() {\n    ///     assert_eq!(first, &0);\n    ///     assert_eq!(elements, &[1, 2]);\n    /// }\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[inline]\n    pub fn split_first(&self) -> Option<(&T, &[T])> {\n}\n\n    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some((first, elements)) = x.split_first_mut() {\n    ///     *first = 3;\n    ///     elements[0] = 4;\n    ///     elements[1] = 5;\n    /// }\n    /// assert_eq!(x, &[3, 4, 5]);\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[inline]\n    pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n}\n\n    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[0, 1, 2];\n    ///\n    /// if let Some((last, elements)) = x.split_last() {\n    ///     assert_eq!(last, &2);\n    ///     assert_eq!(elements, &[0, 1]);\n    /// }\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[inline]\n    pub fn split_last(&self) -> Option<(&T, &[T])> {\n}\n\n    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some((last, elements)) = x.split_last_mut() {\n    ///     *last = 3;\n    ///     elements[0] = 4;\n    ///     elements[1] = 5;\n    /// }\n    /// assert_eq!(x, &[4, 5, 3]);\n    /// ```\n    #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n    #[inline]\n    pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n}\n\n    /// Returns the last element of the slice, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert_eq!(Some(&30), v.last());\n    ///\n    /// let w: &[i32] = &[];\n    /// assert_eq!(None, w.last());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn last(&self) -> Option<&T> {\n}\n\n    /// Returns a mutable pointer to the last item in the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some(last) = x.last_mut() {\n    ///     *last = 10;\n    /// }\n    /// assert_eq!(x, &[0, 1, 10]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn last_mut(&mut self) -> Option<&mut T> {\n}\n\n    /// Returns a reference to an element or subslice depending on the type of\n    /// index.\n    ///\n    /// - If given a position, returns a reference to the element at that\n    ///   position or `None` if out of bounds.\n    /// - If given a range, returns the subslice corresponding to that range,\n    ///   or `None` if out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert_eq!(Some(&40), v.get(1));\n    /// assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n    /// assert_eq!(None, v.get(3));\n    /// assert_eq!(None, v.get(0..4));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn get<I>(&self, index: I) -> Option<&I::Output>\n    where\n        I: SliceIndex<Self>,\n    {\n}\n\n    /// Returns a mutable reference to an element or subslice depending on the\n    /// type of index (see [`get`]) or `None` if the index is out of bounds.\n    ///\n    /// [`get`]: #method.get\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [0, 1, 2];\n    ///\n    /// if let Some(elem) = x.get_mut(1) {\n    ///     *elem = 42;\n    /// }\n    /// assert_eq!(x, &[0, 42, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n    where\n        I: SliceIndex<Self>,\n    {\n}\n\n    /// Returns a reference to an element or subslice, without doing bounds\n    /// checking.\n    ///\n    /// This is generally not recommended, use with caution!\n    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n    /// even if the resulting reference is not used.\n    /// For a safe alternative see [`get`].\n    ///\n    /// [`get`]: #method.get\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[1, 2, 4];\n    ///\n    /// unsafe {\n    ///     assert_eq!(x.get_unchecked(1), &2);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n    where\n        I: SliceIndex<Self>,\n    {\n}\n\n    /// Returns a mutable reference to an element or subslice, without doing\n    /// bounds checking.\n    ///\n    /// This is generally not recommended, use with caution!\n    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n    /// even if the resulting reference is not used.\n    /// For a safe alternative see [`get_mut`].\n    ///\n    /// [`get_mut`]: #method.get_mut\n    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [1, 2, 4];\n    ///\n    /// unsafe {\n    ///     let elem = x.get_unchecked_mut(1);\n    ///     *elem = 13;\n    /// }\n    /// assert_eq!(x, &[1, 13, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n    where\n        I: SliceIndex<Self>,\n    {\n}\n\n    /// Returns a raw pointer to the slice's buffer.\n    ///\n    /// The caller must ensure that the slice outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    ///\n    /// The caller must also ensure that the memory the pointer (non-transitively) points to\n    /// is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n    /// derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n    ///\n    /// Modifying the container referenced by this slice may cause its buffer\n    /// to be reallocated, which would also make any pointers to it invalid.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[1, 2, 4];\n    /// let x_ptr = x.as_ptr();\n    ///\n    /// unsafe {\n    ///     for i in 0..x.len() {\n    ///         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`as_mut_ptr`]: #method.as_mut_ptr\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_const_stable(feature = \"const_slice_as_ptr\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn as_ptr(&self) -> *const T {\n}\n\n    /// Returns an unsafe mutable pointer to the slice's buffer.\n    ///\n    /// The caller must ensure that the slice outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    ///\n    /// Modifying the container referenced by this slice may cause its buffer\n    /// to be reallocated, which would also make any pointers to it invalid.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [1, 2, 4];\n    /// let x_ptr = x.as_mut_ptr();\n    ///\n    /// unsafe {\n    ///     for i in 0..x.len() {\n    ///         *x_ptr.add(i) += 2;\n    ///     }\n    /// }\n    /// assert_eq!(x, &[3, 4, 6]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn as_mut_ptr(&mut self) -> *mut T {\n}\n\n    /// Returns the two raw pointers spanning the slice.\n    ///\n    /// The returned range is half-open, which means that the end pointer\n    /// points *one past* the last element of the slice. This way, an empty\n    /// slice is represented by two equal pointers, and the difference between\n    /// the two pointers represents the size of the size.\n    ///\n    /// See [`as_ptr`] for warnings on using these pointers. The end pointer\n    /// requires extra caution, as it does not point to a valid element in the\n    /// slice.\n    ///\n    /// This function is useful for interacting with foreign interfaces which\n    /// use two pointers to refer to a range of elements in memory, as is\n    /// common in C++.\n    ///\n    /// It can also be useful to check if a pointer to an element refers to an\n    /// element of this slice:\n    ///\n    /// ```\n    /// #![feature(slice_ptr_range)]\n    ///\n    /// let a = [1, 2, 3];\n    /// let x = &a[1] as *const _;\n    /// let y = &5 as *const _;\n    ///\n    /// assert!(a.as_ptr_range().contains(&x));\n    /// assert!(!a.as_ptr_range().contains(&y));\n    /// ```\n    ///\n    /// [`as_ptr`]: #method.as_ptr\n    #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n    #[inline]\n    pub fn as_ptr_range(&self) -> Range<*const T> {\n}\n\n    /// Returns the two unsafe mutable pointers spanning the slice.\n    ///\n    /// The returned range is half-open, which means that the end pointer\n    /// points *one past* the last element of the slice. This way, an empty\n    /// slice is represented by two equal pointers, and the difference between\n    /// the two pointers represents the size of the size.\n    ///\n    /// See [`as_mut_ptr`] for warnings on using these pointers. The end\n    /// pointer requires extra caution, as it does not point to a valid element\n    /// in the slice.\n    ///\n    /// This function is useful for interacting with foreign interfaces which\n    /// use two pointers to refer to a range of elements in memory, as is\n    /// common in C++.\n    ///\n    /// [`as_mut_ptr`]: #method.as_mut_ptr\n    #[unstable(feature = \"slice_ptr_range\", issue = \"65807\")]\n    #[inline]\n    pub fn as_mut_ptr_range(&mut self) -> Range<*mut T> {\n}\n\n    /// Swaps two elements in the slice.\n    ///\n    /// # Arguments\n    ///\n    /// * a - The index of the first element\n    /// * b - The index of the second element\n    ///\n    /// # Panics\n    ///\n    /// Panics if `a` or `b` are out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n    /// v.swap(1, 3);\n    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn swap(&mut self, a: usize, b: usize) {\n}\n\n    /// Reverses the order of elements in the slice, in place.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [1, 2, 3];\n    /// v.reverse();\n    /// assert!(v == [3, 2, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn reverse(&mut self) {\n}\n\n    /// Returns an iterator over the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &[1, 2, 4];\n    /// let mut iterator = x.iter();\n    ///\n    /// assert_eq!(iterator.next(), Some(&1));\n    /// assert_eq!(iterator.next(), Some(&2));\n    /// assert_eq!(iterator.next(), Some(&4));\n    /// assert_eq!(iterator.next(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn iter(&self) -> Iter<'_, T> {\n}\n\n    /// Returns an iterator that allows modifying each value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = &mut [1, 2, 4];\n    /// for elem in x.iter_mut() {\n    ///     *elem += 2;\n    /// }\n    /// assert_eq!(x, &[3, 4, 6]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n}\n\n    /// Returns an iterator over all contiguous windows of length\n    /// `size`. The windows overlap. If the slice is shorter than\n    /// `size`, the iterator returns no values.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = ['r', 'u', 's', 't'];\n    /// let mut iter = slice.windows(2);\n    /// assert_eq!(iter.next().unwrap(), &['r', 'u']);\n    /// assert_eq!(iter.next().unwrap(), &['u', 's']);\n    /// assert_eq!(iter.next().unwrap(), &['s', 't']);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If the slice is shorter than `size`:\n    ///\n    /// ```\n    /// let slice = ['f', 'o', 'o'];\n    /// let mut iter = slice.windows(4);\n    /// assert!(iter.next().is_none());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn windows(&self, size: usize) -> Windows<'_, T> {\n}\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n    /// beginning of the slice.\n    ///\n    /// The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n    /// slice, then the last chunk will not have length `chunk_size`.\n    ///\n    /// See [`chunks_exact`] for a variant of this iterator that returns chunks of always exactly\n    /// `chunk_size` elements, and [`rchunks`] for the same iterator but starting at the end of the\n    /// slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let mut iter = slice.chunks(2);\n    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n    /// assert_eq!(iter.next().unwrap(), &['m']);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// [`chunks_exact`]: #method.chunks_exact\n    /// [`rchunks`]: #method.rchunks\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n}\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n    /// beginning of the slice.\n    ///\n    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the\n    /// length of the slice, then the last chunk will not have length `chunk_size`.\n    ///\n    /// See [`chunks_exact_mut`] for a variant of this iterator that returns chunks of always\n    /// exactly `chunk_size` elements, and [`rchunks_mut`] for the same iterator but starting at\n    /// the end of the slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// for chunk in v.chunks_mut(2) {\n    ///     for elem in chunk.iter_mut() {\n    ///         *elem += count;\n    ///     }\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n    /// ```\n    ///\n    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n    /// [`rchunks_mut`]: #method.rchunks_mut\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<'_, T> {\n}\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n    /// beginning of the slice.\n    ///\n    /// The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n    /// slice, then the last up to `chunk_size-1` elements will be omitted and can be retrieved\n    /// from the `remainder` function of the iterator.\n    ///\n    /// Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n    /// resulting code better than in the case of [`chunks`].\n    ///\n    /// See [`chunks`] for a variant of this iterator that also returns the remainder as a smaller\n    /// chunk, and [`rchunks_exact`] for the same iterator but starting at the end of the slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let mut iter = slice.chunks_exact(2);\n    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n    /// assert!(iter.next().is_none());\n    /// assert_eq!(iter.remainder(), &['m']);\n    /// ```\n    ///\n    /// [`chunks`]: #method.chunks\n    /// [`rchunks_exact`]: #method.rchunks_exact\n    #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n    #[inline]\n    pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<'_, T> {\n}\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n    /// beginning of the slice.\n    ///\n    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the\n    /// length of the slice, then the last up to `chunk_size-1` elements will be omitted and can be\n    /// retrieved from the `into_remainder` function of the iterator.\n    ///\n    /// Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n    /// resulting code better than in the case of [`chunks_mut`].\n    ///\n    /// See [`chunks_mut`] for a variant of this iterator that also returns the remainder as a\n    /// smaller chunk, and [`rchunks_exact_mut`] for the same iterator but starting at the end of\n    /// the slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// for chunk in v.chunks_exact_mut(2) {\n    ///     for elem in chunk.iter_mut() {\n    ///         *elem += count;\n    ///     }\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n    /// ```\n    ///\n    /// [`chunks_mut`]: #method.chunks_mut\n    /// [`rchunks_exact_mut`]: #method.rchunks_exact_mut\n    #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n    #[inline]\n    pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ChunksExactMut<'_, T> {\n}\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n    /// of the slice.\n    ///\n    /// The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n    /// slice, then the last chunk will not have length `chunk_size`.\n    ///\n    /// See [`rchunks_exact`] for a variant of this iterator that returns chunks of always exactly\n    /// `chunk_size` elements, and [`chunks`] for the same iterator but starting at the beginning\n    /// of the slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let mut iter = slice.rchunks(2);\n    /// assert_eq!(iter.next().unwrap(), &['e', 'm']);\n    /// assert_eq!(iter.next().unwrap(), &['o', 'r']);\n    /// assert_eq!(iter.next().unwrap(), &['l']);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// [`rchunks_exact`]: #method.rchunks_exact\n    /// [`chunks`]: #method.chunks\n    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n    #[inline]\n    pub fn rchunks(&self, chunk_size: usize) -> RChunks<'_, T> {\n}\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n    /// of the slice.\n    ///\n    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the\n    /// length of the slice, then the last chunk will not have length `chunk_size`.\n    ///\n    /// See [`rchunks_exact_mut`] for a variant of this iterator that returns chunks of always\n    /// exactly `chunk_size` elements, and [`chunks_mut`] for the same iterator but starting at the\n    /// beginning of the slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// for chunk in v.rchunks_mut(2) {\n    ///     for elem in chunk.iter_mut() {\n    ///         *elem += count;\n    ///     }\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[3, 2, 2, 1, 1]);\n    /// ```\n    ///\n    /// [`rchunks_exact_mut`]: #method.rchunks_exact_mut\n    /// [`chunks_mut`]: #method.chunks_mut\n    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n    #[inline]\n    pub fn rchunks_mut(&mut self, chunk_size: usize) -> RChunksMut<'_, T> {\n}\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n    /// end of the slice.\n    ///\n    /// The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n    /// slice, then the last up to `chunk_size-1` elements will be omitted and can be retrieved\n    /// from the `remainder` function of the iterator.\n    ///\n    /// Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n    /// resulting code better than in the case of [`chunks`].\n    ///\n    /// See [`rchunks`] for a variant of this iterator that also returns the remainder as a smaller\n    /// chunk, and [`chunks_exact`] for the same iterator but starting at the beginning of the\n    /// slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n    /// let mut iter = slice.rchunks_exact(2);\n    /// assert_eq!(iter.next().unwrap(), &['e', 'm']);\n    /// assert_eq!(iter.next().unwrap(), &['o', 'r']);\n    /// assert!(iter.next().is_none());\n    /// assert_eq!(iter.remainder(), &['l']);\n    /// ```\n    ///\n    /// [`chunks`]: #method.chunks\n    /// [`rchunks`]: #method.rchunks\n    /// [`chunks_exact`]: #method.chunks_exact\n    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n    #[inline]\n    pub fn rchunks_exact(&self, chunk_size: usize) -> RChunksExact<'_, T> {\n}\n\n    /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n    /// of the slice.\n    ///\n    /// The chunks are mutable slices, and do not overlap. If `chunk_size` does not divide the\n    /// length of the slice, then the last up to `chunk_size-1` elements will be omitted and can be\n    /// retrieved from the `into_remainder` function of the iterator.\n    ///\n    /// Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n    /// resulting code better than in the case of [`chunks_mut`].\n    ///\n    /// See [`rchunks_mut`] for a variant of this iterator that also returns the remainder as a\n    /// smaller chunk, and [`chunks_exact_mut`] for the same iterator but starting at the beginning\n    /// of the slice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `chunk_size` is 0.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = &mut [0, 0, 0, 0, 0];\n    /// let mut count = 1;\n    ///\n    /// for chunk in v.rchunks_exact_mut(2) {\n    ///     for elem in chunk.iter_mut() {\n    ///         *elem += count;\n    ///     }\n    ///     count += 1;\n    /// }\n    /// assert_eq!(v, &[0, 2, 2, 1, 1]);\n    /// ```\n    ///\n    /// [`chunks_mut`]: #method.chunks_mut\n    /// [`rchunks_mut`]: #method.rchunks_mut\n    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n    #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n    #[inline]\n    pub fn rchunks_exact_mut(&mut self, chunk_size: usize) -> RChunksExactMut<'_, T> {\n}\n\n    /// Divides one slice into two at an index.\n    ///\n    /// The first will contain all indices from `[0, mid)` (excluding\n    /// the index `mid` itself) and the second will contain all\n    /// indices from `[mid, len)` (excluding the index `len` itself).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `mid > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [1, 2, 3, 4, 5, 6];\n    ///\n    /// {\n    ///    let (left, right) = v.split_at(0);\n    ///    assert!(left == []);\n    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n    /// }\n    ///\n    /// {\n    ///     let (left, right) = v.split_at(2);\n    ///     assert!(left == [1, 2]);\n    ///     assert!(right == [3, 4, 5, 6]);\n    /// }\n    ///\n    /// {\n    ///     let (left, right) = v.split_at(6);\n    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n    ///     assert!(right == []);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n}\n\n    /// Divides one mutable slice into two at an index.\n    ///\n    /// The first will contain all indices from `[0, mid)` (excluding\n    /// the index `mid` itself) and the second will contain all\n    /// indices from `[mid, len)` (excluding the index `len` itself).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `mid > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [1, 0, 3, 0, 5, 6];\n    /// // scoped to restrict the lifetime of the borrows\n    /// {\n    ///     let (left, right) = v.split_at_mut(2);\n    ///     assert!(left == [1, 0]);\n    ///     assert!(right == [3, 0, 5, 6]);\n    ///     left[1] = 2;\n    ///     right[1] = 4;\n    /// }\n    /// assert!(v == [1, 2, 3, 4, 5, 6]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n}\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`. The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = [10, 40, 33, 20];\n    /// let mut iter = slice.split(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n    /// assert_eq!(iter.next().unwrap(), &[20]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If the first element is matched, an empty slice will be the first item\n    /// returned by the iterator. Similarly, if the last element in the slice\n    /// is matched, an empty slice will be the last item returned by the\n    /// iterator:\n    ///\n    /// ```\n    /// let slice = [10, 40, 33];\n    /// let mut iter = slice.split(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n    /// assert_eq!(iter.next().unwrap(), &[]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    ///\n    /// If two matched elements are directly adjacent, an empty slice will be\n    /// present between them:\n    ///\n    /// ```\n    /// let slice = [10, 6, 33, 20];\n    /// let mut iter = slice.split(|num| num % 3 == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[10]);\n    /// assert_eq!(iter.next().unwrap(), &[]);\n    /// assert_eq!(iter.next().unwrap(), &[20]);\n    /// assert!(iter.next().is_none());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split<F>(&self, pred: F) -> Split<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n}\n\n    /// Returns an iterator over mutable subslices separated by elements that\n    /// match `pred`. The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.split_mut(|num| *num % 3 == 0) {\n    ///     group[0] = 1;\n    /// }\n    /// assert_eq!(v, [1, 40, 30, 1, 60, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n}\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`, starting at the end of the slice and working backwards.\n    /// The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let slice = [11, 22, 33, 0, 44, 55];\n    /// let mut iter = slice.rsplit(|num| *num == 0);\n    ///\n    /// assert_eq!(iter.next().unwrap(), &[44, 55]);\n    /// assert_eq!(iter.next().unwrap(), &[11, 22, 33]);\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    ///\n    /// As with `split()`, if the first or last element is matched, an empty\n    /// slice will be the first (or last) item returned by the iterator.\n    ///\n    /// ```\n    /// let v = &[0, 1, 1, 2, 3, 5, 8];\n    /// let mut it = v.rsplit(|n| *n % 2 == 0);\n    /// assert_eq!(it.next().unwrap(), &[]);\n    /// assert_eq!(it.next().unwrap(), &[3, 5]);\n    /// assert_eq!(it.next().unwrap(), &[1, 1]);\n    /// assert_eq!(it.next().unwrap(), &[]);\n    /// assert_eq!(it.next(), None);\n    /// ```\n    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n    #[inline]\n    pub fn rsplit<F>(&self, pred: F) -> RSplit<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n}\n\n    /// Returns an iterator over mutable subslices separated by elements that\n    /// match `pred`, starting at the end of the slice and working\n    /// backwards. The matched element is not contained in the subslices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [100, 400, 300, 200, 600, 500];\n    ///\n    /// let mut count = 0;\n    /// for group in v.rsplit_mut(|num| *num % 3 == 0) {\n    ///     count += 1;\n    ///     group[0] = count;\n    /// }\n    /// assert_eq!(v, [3, 400, 300, 2, 600, 1]);\n    /// ```\n    ///\n    #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n    #[inline]\n    pub fn rsplit_mut<F>(&mut self, pred: F) -> RSplitMut<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n}\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`, limited to returning at most `n` items. The matched element is\n    /// not contained in the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// Print the slice split once by numbers divisible by 3 (i.e., `[10, 40]`,\n    /// `[20, 60, 50]`):\n    ///\n    /// ```\n    /// let v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.splitn(2, |num| *num % 3 == 0) {\n    ///     println!(\"{:?}\", group);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n}\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred`, limited to returning at most `n` items. The matched element is\n    /// not contained in the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.splitn_mut(2, |num| *num % 3 == 0) {\n    ///     group[0] = 1;\n    /// }\n    /// assert_eq!(v, [1, 40, 30, 1, 60, 50]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n}\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred` limited to returning at most `n` items. This starts at the end of\n    /// the slice and works backwards. The matched element is not contained in\n    /// the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// Print the slice split once, starting from the end, by numbers divisible\n    /// by 3 (i.e., `[50]`, `[10, 40, 30, 20]`):\n    ///\n    /// ```\n    /// let v = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n    ///     println!(\"{:?}\", group);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n}\n\n    /// Returns an iterator over subslices separated by elements that match\n    /// `pred` limited to returning at most `n` items. This starts at the end of\n    /// the slice and works backwards. The matched element is not contained in\n    /// the subslices.\n    ///\n    /// The last element returned, if any, will contain the remainder of the\n    /// slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut s = [10, 40, 30, 20, 60, 50];\n    ///\n    /// for group in s.rsplitn_mut(2, |num| *num % 3 == 0) {\n    ///     group[0] = 1;\n    /// }\n    /// assert_eq!(s, [1, 40, 30, 20, 60, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n}\n\n    /// Returns `true` if the slice contains an element with the given value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert!(v.contains(&30));\n    /// assert!(!v.contains(&50));\n    /// ```\n    ///\n    /// If you do not have an `&T`, but just an `&U` such that `T: Borrow<U>`\n    /// (e.g. `String: Borrow<str>`), you can use `iter().any`:\n    ///\n    /// ```\n    /// let v = [String::from(\"hello\"), String::from(\"world\")]; // slice of `String`\n    /// assert!(v.iter().any(|e| e == \"hello\")); // search with `&str`\n    /// assert!(!v.iter().any(|e| e == \"hi\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn contains(&self, x: &T) -> bool\n    where\n        T: PartialEq,\n    {\n}\n\n    /// Returns `true` if `needle` is a prefix of the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert!(v.starts_with(&[10]));\n    /// assert!(v.starts_with(&[10, 40]));\n    /// assert!(!v.starts_with(&[50]));\n    /// assert!(!v.starts_with(&[10, 50]));\n    /// ```\n    ///\n    /// Always returns `true` if `needle` is an empty slice:\n    ///\n    /// ```\n    /// let v = &[10, 40, 30];\n    /// assert!(v.starts_with(&[]));\n    /// let v: &[u8] = &[];\n    /// assert!(v.starts_with(&[]));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn starts_with(&self, needle: &[T]) -> bool\n    where\n        T: PartialEq,\n    {\n}\n\n    /// Returns `true` if `needle` is a suffix of the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = [10, 40, 30];\n    /// assert!(v.ends_with(&[30]));\n    /// assert!(v.ends_with(&[40, 30]));\n    /// assert!(!v.ends_with(&[50]));\n    /// assert!(!v.ends_with(&[50, 30]));\n    /// ```\n    ///\n    /// Always returns `true` if `needle` is an empty slice:\n    ///\n    /// ```\n    /// let v = &[10, 40, 30];\n    /// assert!(v.ends_with(&[]));\n    /// let v: &[u8] = &[];\n    /// assert!(v.ends_with(&[]));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn ends_with(&self, needle: &[T]) -> bool\n    where\n        T: PartialEq,\n    {\n}\n\n    /// Binary searches this sorted slice for a given element.\n    ///\n    /// If the value is found then [`Result::Ok`] is returned, containing the\n    /// index of the matching element. If there are multiple matches, then any\n    /// one of the matches could be returned. If the value is not found then\n    /// [`Result::Err`] is returned, containing the index where a matching\n    /// element could be inserted while maintaining sorted order.\n    ///\n    /// # Examples\n    ///\n    /// Looks up a series of four elements. The first is found, with a\n    /// uniquely determined position; the second and third are not\n    /// found; the fourth could match any position in `[1, 4]`.\n    ///\n    /// ```\n    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n    ///\n    /// assert_eq!(s.binary_search(&13),  Ok(9));\n    /// assert_eq!(s.binary_search(&4),   Err(7));\n    /// assert_eq!(s.binary_search(&100), Err(13));\n    /// let r = s.binary_search(&1);\n    /// assert!(match r { Ok(1..=4) => true, _ => false, });\n    /// ```\n    ///\n    /// If you want to insert an item to a sorted vector, while maintaining\n    /// sort order:\n    ///\n    /// ```\n    /// let mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n    /// let num = 42;\n    /// let idx = s.binary_search(&num).unwrap_or_else(|x| x);\n    /// s.insert(idx, num);\n    /// assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n    where\n        T: Ord,\n    {\n}\n\n    /// Binary searches this sorted slice with a comparator function.\n    ///\n    /// The comparator function should implement an order consistent\n    /// with the sort order of the underlying slice, returning an\n    /// order code that indicates whether its argument is `Less`,\n    /// `Equal` or `Greater` the desired target.\n    ///\n    /// If the value is found then [`Result::Ok`] is returned, containing the\n    /// index of the matching element. If there are multiple matches, then any\n    /// one of the matches could be returned. If the value is not found then\n    /// [`Result::Err`] is returned, containing the index where a matching\n    /// element could be inserted while maintaining sorted order.\n    ///\n    /// # Examples\n    ///\n    /// Looks up a series of four elements. The first is found, with a\n    /// uniquely determined position; the second and third are not\n    /// found; the fourth could match any position in `[1, 4]`.\n    ///\n    /// ```\n    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n    ///\n    /// let seek = 13;\n    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n    /// let seek = 4;\n    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n    /// let seek = 100;\n    /// assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n    /// let seek = 1;\n    /// let r = s.binary_search_by(|probe| probe.cmp(&seek));\n    /// assert!(match r { Ok(1..=4) => true, _ => false, });\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> Ordering,\n    {\n}\n\n    /// Binary searches this sorted slice with a key extraction function.\n    ///\n    /// Assumes that the slice is sorted by the key, for instance with\n    /// [`sort_by_key`] using the same key extraction function.\n    ///\n    /// If the value is found then [`Result::Ok`] is returned, containing the\n    /// index of the matching element. If there are multiple matches, then any\n    /// one of the matches could be returned. If the value is not found then\n    /// [`Result::Err`] is returned, containing the index where a matching\n    /// element could be inserted while maintaining sorted order.\n    ///\n    /// [`sort_by_key`]: #method.sort_by_key\n    ///\n    /// # Examples\n    ///\n    /// Looks up a series of four elements in a slice of pairs sorted by\n    /// their second elements. The first is found, with a uniquely\n    /// determined position; the second and third are not found; the\n    /// fourth could match any position in `[1, 4]`.\n    ///\n    /// ```\n    /// let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n    ///          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n    ///          (1, 21), (2, 34), (4, 55)];\n    ///\n    /// assert_eq!(s.binary_search_by_key(&13, |&(a,b)| b),  Ok(9));\n    /// assert_eq!(s.binary_search_by_key(&4, |&(a,b)| b),   Err(7));\n    /// assert_eq!(s.binary_search_by_key(&100, |&(a,b)| b), Err(13));\n    /// let r = s.binary_search_by_key(&1, |&(a,b)| b);\n    /// assert!(match r { Ok(1..=4) => true, _ => false, });\n    /// ```\n    #[stable(feature = \"slice_binary_search_by_key\", since = \"1.10.0\")]\n    #[inline]\n    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> B,\n        B: Ord,\n    {\n}\n\n    /// Sorts the slice, but may not preserve the order of equal elements.\n    ///\n    /// This sort is unstable (i.e., may reorder equal elements), in-place\n    /// (i.e., does not allocate), and `O(n log n)` worst-case.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n    /// which combines the fast average case of randomized quicksort with the fast worst case of\n    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n    /// deterministic behavior.\n    ///\n    /// It is typically faster than stable sorting, except in a few special cases, e.g., when the\n    /// slice consists of several concatenated sorted sequences.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5, 4, 1, -3, 2];\n    ///\n    /// v.sort_unstable();\n    /// assert!(v == [-5, -3, 1, 2, 4]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    #[inline]\n    pub fn sort_unstable(&mut self)\n    where\n        T: Ord,\n    {\n}\n\n    /// Sorts the slice with a comparator function, but may not preserve the order of equal\n    /// elements.\n    ///\n    /// This sort is unstable (i.e., may reorder equal elements), in-place\n    /// (i.e., does not allocate), and `O(n log n)` worst-case.\n    ///\n    /// The comparator function must define a total ordering for the elements in the slice. If\n    /// the ordering is not total, the order of the elements is unspecified. An order is a\n    /// total order if it is (for all a, b and c):\n    ///\n    /// * total and antisymmetric: exactly one of a < b, a == b or a > b is true; and\n    /// * transitive, a < b and b < c implies a < c. The same must hold for both == and >.\n    ///\n    /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n    /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`.\n    ///\n    /// ```\n    /// let mut floats = [5f64, 4.0, 1.0, 3.0, 2.0];\n    /// floats.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    /// assert_eq!(floats, [1.0, 2.0, 3.0, 4.0, 5.0]);\n    /// ```\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n    /// which combines the fast average case of randomized quicksort with the fast worst case of\n    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n    /// deterministic behavior.\n    ///\n    /// It is typically faster than stable sorting, except in a few special cases, e.g., when the\n    /// slice consists of several concatenated sorted sequences.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [5, 4, 1, 3, 2];\n    /// v.sort_unstable_by(|a, b| a.cmp(b));\n    /// assert!(v == [1, 2, 3, 4, 5]);\n    ///\n    /// // reverse sorting\n    /// v.sort_unstable_by(|a, b| b.cmp(a));\n    /// assert!(v == [5, 4, 3, 2, 1]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    #[inline]\n    pub fn sort_unstable_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n}\n\n    /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n    /// elements.\n    ///\n    /// This sort is unstable (i.e., may reorder equal elements), in-place\n    /// (i.e., does not allocate), and `O(m n log(m n))` worst-case, where the key function is\n    /// `O(m)`.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n    /// which combines the fast average case of randomized quicksort with the fast worst case of\n    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n    /// deterministic behavior.\n    ///\n    /// Due to its key calling strategy, [`sort_unstable_by_key`](#method.sort_unstable_by_key)\n    /// is likely to be slower than [`sort_by_cached_key`](#method.sort_by_cached_key) in\n    /// cases where the key function is expensive.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// v.sort_unstable_by_key(|k| k.abs());\n    /// assert!(v == [1, 2, -3, 4, -5]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n    #[inline]\n    pub fn sort_unstable_by_key<K, F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n}\n\n    /// Reorder the slice such that the element at `index` is at its final sorted position.\n    ///\n    /// This reordering has the additional property that any value at position `i < index` will be\n    /// less than or equal to any value at a position `j > index`. Additionally, this reordering is\n    /// unstable (i.e. any number of equal elements may end up at position `index`), in-place\n    /// (i.e. does not allocate), and `O(n)` worst-case. This function is also/ known as \"kth\n    /// element\" in other libraries. It returns a triplet of the following values: all elements less\n    /// than the one at the given index, the value at the given index, and all elements greater than\n    /// the one at the given index.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n    /// used for [`sort_unstable`].\n    ///\n    /// [`sort_unstable`]: #method.sort_unstable\n    ///\n    /// # Panics\n    ///\n    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_partition_at_index)]\n    ///\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// // Find the median\n    /// v.partition_at_index(2);\n    ///\n    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n    /// // about the specified index.\n    /// assert!(v == [-3, -5, 1, 2, 4] ||\n    ///         v == [-5, -3, 1, 2, 4] ||\n    ///         v == [-3, -5, 1, 4, 2] ||\n    ///         v == [-5, -3, 1, 4, 2]);\n    /// ```\n    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n    #[inline]\n    pub fn partition_at_index(&mut self, index: usize) -> (&mut [T], &mut T, &mut [T])\n    where\n        T: Ord,\n    {\n}\n\n    /// Reorder the slice with a comparator function such that the element at `index` is at its\n    /// final sorted position.\n    ///\n    /// This reordering has the additional property that any value at position `i < index` will be\n    /// less than or equal to any value at a position `j > index` using the comparator function.\n    /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n    /// position `index`), in-place (i.e. does not allocate), and `O(n)` worst-case. This function\n    /// is also known as \"kth element\" in other libraries. It returns a triplet of the following\n    /// values: all elements less than the one at the given index, the value at the given index,\n    /// and all elements greater than the one at the given index, using the provided comparator\n    /// function.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n    /// used for [`sort_unstable`].\n    ///\n    /// [`sort_unstable`]: #method.sort_unstable\n    ///\n    /// # Panics\n    ///\n    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_partition_at_index)]\n    ///\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// // Find the median as if the slice were sorted in descending order.\n    /// v.partition_at_index_by(2, |a, b| b.cmp(a));\n    ///\n    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n    /// // about the specified index.\n    /// assert!(v == [2, 4, 1, -5, -3] ||\n    ///         v == [2, 4, 1, -3, -5] ||\n    ///         v == [4, 2, 1, -5, -3] ||\n    ///         v == [4, 2, 1, -3, -5]);\n    /// ```\n    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n    #[inline]\n    pub fn partition_at_index_by<F>(\n        &mut self,\n        index: usize,\n        mut compare: F,\n    ) -> (&mut [T], &mut T, &mut [T])\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n}\n\n    /// Reorder the slice with a key extraction function such that the element at `index` is at its\n    /// final sorted position.\n    ///\n    /// This reordering has the additional property that any value at position `i < index` will be\n    /// less than or equal to any value at a position `j > index` using the key extraction function.\n    /// Additionally, this reordering is unstable (i.e. any number of equal elements may end up at\n    /// position `index`), in-place (i.e. does not allocate), and `O(n)` worst-case. This function\n    /// is also known as \"kth element\" in other libraries. It returns a triplet of the following\n    /// values: all elements less than the one at the given index, the value at the given index, and\n    /// all elements greater than the one at the given index, using the provided key extraction\n    /// function.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on the quickselect portion of the same quicksort algorithm\n    /// used for [`sort_unstable`].\n    ///\n    /// [`sort_unstable`]: #method.sort_unstable\n    ///\n    /// # Panics\n    ///\n    /// Panics when `index >= len()`, meaning it always panics on empty slices.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_partition_at_index)]\n    ///\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// // Return the median as if the array were sorted according to absolute value.\n    /// v.partition_at_index_by_key(2, |a| a.abs());\n    ///\n    /// // We are only guaranteed the slice will be one of the following, based on the way we sort\n    /// // about the specified index.\n    /// assert!(v == [1, 2, -3, 4, -5] ||\n    ///         v == [1, 2, -3, -5, 4] ||\n    ///         v == [2, 1, -3, 4, -5] ||\n    ///         v == [2, 1, -3, -5, 4]);\n    /// ```\n    #[unstable(feature = \"slice_partition_at_index\", issue = \"55300\")]\n    #[inline]\n    pub fn partition_at_index_by_key<K, F>(\n        &mut self,\n        index: usize,\n        mut f: F,\n    ) -> (&mut [T], &mut T, &mut [T])\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n}\n\n    /// Moves all consecutive repeated elements to the end of the slice according to the\n    /// [`PartialEq`] trait implementation.\n    ///\n    /// Returns two slices. The first contains no consecutive repeated elements.\n    /// The second contains all the duplicates in no specified order.\n    ///\n    /// If the slice is sorted, the first returned slice contains no duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_partition_dedup)]\n    ///\n    /// let mut slice = [1, 2, 2, 3, 3, 2, 1, 1];\n    ///\n    /// let (dedup, duplicates) = slice.partition_dedup();\n    ///\n    /// assert_eq!(dedup, [1, 2, 3, 2, 1]);\n    /// assert_eq!(duplicates, [2, 3, 1]);\n    /// ```\n    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n    #[inline]\n    pub fn partition_dedup(&mut self) -> (&mut [T], &mut [T])\n    where\n        T: PartialEq,\n    {\n}\n\n    /// Moves all but the first of consecutive elements to the end of the slice satisfying\n    /// a given equality relation.\n    ///\n    /// Returns two slices. The first contains no consecutive repeated elements.\n    /// The second contains all the duplicates in no specified order.\n    ///\n    /// The `same_bucket` function is passed references to two elements from the slice and\n    /// must determine if the elements compare equal. The elements are passed in opposite order\n    /// from their order in the slice, so if `same_bucket(a, b)` returns `true`, `a` is moved\n    /// at the end of the slice.\n    ///\n    /// If the slice is sorted, the first returned slice contains no duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_partition_dedup)]\n    ///\n    /// let mut slice = [\"foo\", \"Foo\", \"BAZ\", \"Bar\", \"bar\", \"baz\", \"BAZ\"];\n    ///\n    /// let (dedup, duplicates) = slice.partition_dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n    ///\n    /// assert_eq!(dedup, [\"foo\", \"BAZ\", \"Bar\", \"baz\"]);\n    /// assert_eq!(duplicates, [\"bar\", \"Foo\", \"BAZ\"]);\n    /// ```\n    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n    #[inline]\n    pub fn partition_dedup_by<F>(&mut self, mut same_bucket: F) -> (&mut [T], &mut [T])\n    where\n        F: FnMut(&mut T, &mut T) -> bool,\n    {\n}\n\n    /// Moves all but the first of consecutive elements to the end of the slice that resolve\n    /// to the same key.\n    ///\n    /// Returns two slices. The first contains no consecutive repeated elements.\n    /// The second contains all the duplicates in no specified order.\n    ///\n    /// If the slice is sorted, the first returned slice contains no duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_partition_dedup)]\n    ///\n    /// let mut slice = [10, 20, 21, 30, 30, 20, 11, 13];\n    ///\n    /// let (dedup, duplicates) = slice.partition_dedup_by_key(|i| *i / 10);\n    ///\n    /// assert_eq!(dedup, [10, 20, 30, 20, 11]);\n    /// assert_eq!(duplicates, [21, 30, 13]);\n    /// ```\n    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n    #[inline]\n    pub fn partition_dedup_by_key<K, F>(&mut self, mut key: F) -> (&mut [T], &mut [T])\n    where\n        F: FnMut(&mut T) -> K,\n        K: PartialEq,\n    {\n}\n\n    /// Rotates the slice in-place such that the first `mid` elements of the\n    /// slice move to the end while the last `self.len() - mid` elements move to\n    /// the front. After calling `rotate_left`, the element previously at index\n    /// `mid` will become the first element in the slice.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if `mid` is greater than the length of the\n    /// slice. Note that `mid == self.len()` does _not_ panic and is a no-op\n    /// rotation.\n    ///\n    /// # Complexity\n    ///\n    /// Takes linear (in `self.len()`) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n    /// a.rotate_left(2);\n    /// assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n    /// ```\n    ///\n    /// Rotating a subslice:\n    ///\n    /// ```\n    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n    /// a[1..5].rotate_left(1);\n    /// assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n    /// ```\n    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n    pub fn rotate_left(&mut self, mid: usize) {\n}\n\n    /// Rotates the slice in-place such that the first `self.len() - k`\n    /// elements of the slice move to the end while the last `k` elements move\n    /// to the front. After calling `rotate_right`, the element previously at\n    /// index `self.len() - k` will become the first element in the slice.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if `k` is greater than the length of the\n    /// slice. Note that `k == self.len()` does _not_ panic and is a no-op\n    /// rotation.\n    ///\n    /// # Complexity\n    ///\n    /// Takes linear (in `self.len()`) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n    /// a.rotate_right(2);\n    /// assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);\n    /// ```\n    ///\n    /// Rotate a subslice:\n    ///\n    /// ```\n    /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n    /// a[1..5].rotate_right(1);\n    /// assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);\n    /// ```\n    #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n    pub fn rotate_right(&mut self, k: usize) {\n}\n\n    /// Copies the elements from `src` into `self`.\n    ///\n    /// The length of `src` must be the same as `self`.\n    ///\n    /// If `src` implements `Copy`, it can be more performant to use\n    /// [`copy_from_slice`].\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Examples\n    ///\n    /// Cloning two elements from a slice into another:\n    ///\n    /// ```\n    /// let src = [1, 2, 3, 4];\n    /// let mut dst = [0, 0];\n    ///\n    /// // Because the slices have to be the same length,\n    /// // we slice the source slice from four elements\n    /// // to two. It will panic if we don't do this.\n    /// dst.clone_from_slice(&src[2..]);\n    ///\n    /// assert_eq!(src, [1, 2, 3, 4]);\n    /// assert_eq!(dst, [3, 4]);\n    /// ```\n    ///\n    /// Rust enforces that there can only be one mutable reference with no\n    /// immutable references to a particular piece of data in a particular\n    /// scope. Because of this, attempting to use `clone_from_slice` on a\n    /// single slice will result in a compile failure:\n    ///\n    /// ```compile_fail\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// slice[..2].clone_from_slice(&slice[3..]); // compile fail!\n    /// ```\n    ///\n    /// To work around this, we can use [`split_at_mut`] to create two distinct\n    /// sub-slices from a slice:\n    ///\n    /// ```\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// {\n    ///     let (left, right) = slice.split_at_mut(2);\n    ///     left.clone_from_slice(&right[1..]);\n    /// }\n    ///\n    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n    /// ```\n    ///\n    /// [`copy_from_slice`]: #method.copy_from_slice\n    /// [`split_at_mut`]: #method.split_at_mut\n    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n    pub fn clone_from_slice(&mut self, src: &[T])\n    where\n        T: Clone,\n    {\n}\n\n    /// Copies all elements from `src` into `self`, using a memcpy.\n    ///\n    /// The length of `src` must be the same as `self`.\n    ///\n    /// If `src` does not implement `Copy`, use [`clone_from_slice`].\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Examples\n    ///\n    /// Copying two elements from a slice into another:\n    ///\n    /// ```\n    /// let src = [1, 2, 3, 4];\n    /// let mut dst = [0, 0];\n    ///\n    /// // Because the slices have to be the same length,\n    /// // we slice the source slice from four elements\n    /// // to two. It will panic if we don't do this.\n    /// dst.copy_from_slice(&src[2..]);\n    ///\n    /// assert_eq!(src, [1, 2, 3, 4]);\n    /// assert_eq!(dst, [3, 4]);\n    /// ```\n    ///\n    /// Rust enforces that there can only be one mutable reference with no\n    /// immutable references to a particular piece of data in a particular\n    /// scope. Because of this, attempting to use `copy_from_slice` on a\n    /// single slice will result in a compile failure:\n    ///\n    /// ```compile_fail\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// slice[..2].copy_from_slice(&slice[3..]); // compile fail!\n    /// ```\n    ///\n    /// To work around this, we can use [`split_at_mut`] to create two distinct\n    /// sub-slices from a slice:\n    ///\n    /// ```\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// {\n    ///     let (left, right) = slice.split_at_mut(2);\n    ///     left.copy_from_slice(&right[1..]);\n    /// }\n    ///\n    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n    /// ```\n    ///\n    /// [`clone_from_slice`]: #method.clone_from_slice\n    /// [`split_at_mut`]: #method.split_at_mut\n    #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n    pub fn copy_from_slice(&mut self, src: &[T])\n    where\n        T: Copy,\n    {\n}\n\n    /// Copies elements from one part of the slice to another part of itself,\n    /// using a memmove.\n    ///\n    /// `src` is the range within `self` to copy from. `dest` is the starting\n    /// index of the range within `self` to copy to, which will have the same\n    /// length as `src`. The two ranges may overlap. The ends of the two ranges\n    /// must be less than or equal to `self.len()`.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if either range exceeds the end of the slice,\n    /// or if the end of `src` is before the start.\n    ///\n    /// # Examples\n    ///\n    /// Copying four bytes within a slice:\n    ///\n    /// ```\n    /// let mut bytes = *b\"Hello, World!\";\n    ///\n    /// bytes.copy_within(1..5, 8);\n    ///\n    /// assert_eq!(&bytes, b\"Hello, Wello!\");\n    /// ```\n    #[stable(feature = \"copy_within\", since = \"1.37.0\")]\n    pub fn copy_within<R: ops::RangeBounds<usize>>(&mut self, src: R, dest: usize)\n    where\n        T: Copy,\n    {\n}\n\n    /// Swaps all elements in `self` with those in `other`.\n    ///\n    /// The length of `other` must be the same as `self`.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the two slices have different lengths.\n    ///\n    /// # Example\n    ///\n    /// Swapping two elements across slices:\n    ///\n    /// ```\n    /// let mut slice1 = [0, 0];\n    /// let mut slice2 = [1, 2, 3, 4];\n    ///\n    /// slice1.swap_with_slice(&mut slice2[2..]);\n    ///\n    /// assert_eq!(slice1, [3, 4]);\n    /// assert_eq!(slice2, [1, 2, 0, 0]);\n    /// ```\n    ///\n    /// Rust enforces that there can only be one mutable reference to a\n    /// particular piece of data in a particular scope. Because of this,\n    /// attempting to use `swap_with_slice` on a single slice will result in\n    /// a compile failure:\n    ///\n    /// ```compile_fail\n    /// let mut slice = [1, 2, 3, 4, 5];\n    /// slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!\n    /// ```\n    ///\n    /// To work around this, we can use [`split_at_mut`] to create two distinct\n    /// mutable sub-slices from a slice:\n    ///\n    /// ```\n    /// let mut slice = [1, 2, 3, 4, 5];\n    ///\n    /// {\n    ///     let (left, right) = slice.split_at_mut(2);\n    ///     left.swap_with_slice(&mut right[1..]);\n    /// }\n    ///\n    /// assert_eq!(slice, [4, 5, 3, 1, 2]);\n    /// ```\n    ///\n    /// [`split_at_mut`]: #method.split_at_mut\n    #[stable(feature = \"swap_with_slice\", since = \"1.27.0\")]\n    pub fn swap_with_slice(&mut self, other: &mut [T]) {\n}\n\n    /// Function to calculate lengths of the middle and trailing slice for `align_to{,_mut}`.\n    fn align_to_offsets<U>(&self) -> (usize, usize) {\n}\n\n    /// Transmute the slice to a slice of another type, ensuring alignment of the types is\n    /// maintained.\n    ///\n    /// This method splits the slice into three distinct slices: prefix, correctly aligned middle\n    /// slice of a new type, and the suffix slice. The method may make the middle slice the greatest\n    /// length possible for a given type and input slice, but only your algorithm's performance\n    /// should depend on that, not its correctness. It is permissible for all of the input data to\n    /// be returned as the prefix or suffix slice.\n    ///\n    /// This method has no purpose when either input element `T` or output element `U` are\n    /// zero-sized and will return the original slice without splitting anything.\n    ///\n    /// # Safety\n    ///\n    /// This method is essentially a `transmute` with respect to the elements in the returned\n    /// middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// unsafe {\n    ///     let bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n    ///     let (prefix, shorts, suffix) = bytes.align_to::<u16>();\n    ///     // less_efficient_algorithm_for_bytes(prefix);\n    ///     // more_efficient_algorithm_for_aligned_shorts(shorts);\n    ///     // less_efficient_algorithm_for_bytes(suffix);\n    /// }\n    /// ```\n    #[stable(feature = \"slice_align_to\", since = \"1.30.0\")]\n    pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n}\n\n    /// Transmute the slice to a slice of another type, ensuring alignment of the types is\n    /// maintained.\n    ///\n    /// This method splits the slice into three distinct slices: prefix, correctly aligned middle\n    /// slice of a new type, and the suffix slice. The method may make the middle slice the greatest\n    /// length possible for a given type and input slice, but only your algorithm's performance\n    /// should depend on that, not its correctness. It is permissible for all of the input data to\n    /// be returned as the prefix or suffix slice.\n    ///\n    /// This method has no purpose when either input element `T` or output element `U` are\n    /// zero-sized and will return the original slice without splitting anything.\n    ///\n    /// # Safety\n    ///\n    /// This method is essentially a `transmute` with respect to the elements in the returned\n    /// middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// unsafe {\n    ///     let mut bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n    ///     let (prefix, shorts, suffix) = bytes.align_to_mut::<u16>();\n    ///     // less_efficient_algorithm_for_bytes(prefix);\n    ///     // more_efficient_algorithm_for_aligned_shorts(shorts);\n    ///     // less_efficient_algorithm_for_bytes(suffix);\n    /// }\n    /// ```\n    #[stable(feature = \"slice_align_to\", since = \"1.30.0\")]\n    pub unsafe fn align_to_mut<U>(&mut self) -> (&mut [T], &mut [U], &mut [T]) {\n}\n\n    /// Checks if the elements of this slice are sorted.\n    ///\n    /// That is, for each element `a` and its following element `b`, `a <= b` must hold. If the\n    /// slice yields exactly zero or one element, `true` is returned.\n    ///\n    /// Note that if `Self::Item` is only `PartialOrd`, but not `Ord`, the above definition\n    /// implies that this function returns `false` if any two consecutive items are not\n    /// comparable.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(is_sorted)]\n    /// let empty: [i32; 0] = [];\n    ///\n    /// assert!([1, 2, 2, 9].is_sorted());\n    /// assert!(![1, 3, 2, 4].is_sorted());\n    /// assert!([0].is_sorted());\n    /// assert!(empty.is_sorted());\n    /// assert!(![0.0, 1.0, std::f32::NAN].is_sorted());\n    /// ```\n    #[inline]\n    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n    pub fn is_sorted(&self) -> bool\n    where\n        T: PartialOrd,\n    {\n}\n\n    /// Checks if the elements of this slice are sorted using the given comparator function.\n    ///\n    /// Instead of using `PartialOrd::partial_cmp`, this function uses the given `compare`\n    /// function to determine the ordering of two elements. Apart from that, it's equivalent to\n    /// [`is_sorted`]; see its documentation for more information.\n    ///\n    /// [`is_sorted`]: #method.is_sorted\n    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n    pub fn is_sorted_by<F>(&self, mut compare: F) -> bool\n    where\n        F: FnMut(&T, &T) -> Option<Ordering>,\n    {\n}\n\n    /// Checks if the elements of this slice are sorted using the given key extraction function.\n    ///\n    /// Instead of comparing the slice's elements directly, this function compares the keys of the\n    /// elements, as determined by `f`. Apart from that, it's equivalent to [`is_sorted`]; see its\n    /// documentation for more information.\n    ///\n    /// [`is_sorted`]: #method.is_sorted\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(is_sorted)]\n    ///\n    /// assert!([\"c\", \"bb\", \"aaa\"].is_sorted_by_key(|s| s.len()));\n    /// assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));\n    /// ```\n    #[inline]\n    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n    pub fn is_sorted_by_key<F, K>(&self, f: F) -> bool\n    where\n        F: FnMut(&T) -> K,\n        K: PartialOrd,\n    {\n}\n}\n\n#[lang = \"slice_u8\"]\n#[cfg(not(test))]\nimpl [u8] {\n    /// Checks if all bytes in this slice are within the ASCII range.\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn is_ascii(&self) -> bool {\n}\n\n    /// Checks that two slices are an ASCII case-insensitive match.\n    ///\n    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n    /// but without allocating and copying temporaries.\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n}\n\n    /// Converts this slice to its ASCII upper case equivalent in-place.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new uppercased value without modifying the existing one, use\n    /// [`to_ascii_uppercase`].\n    ///\n    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_uppercase(&mut self) {\n}\n\n    /// Converts this slice to its ASCII lower case equivalent in-place.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To return a new lowercased value without modifying the existing one, use\n    /// [`to_ascii_lowercase`].\n    ///\n    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn make_ascii_lowercase(&mut self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, I> ops::Index<I> for [T]\nwhere\n    I: SliceIndex<[T]>,\n{\n    type Output = I::Output;\n\n    #[inline]\n    fn index(&self, index: I) -> &I::Output {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, I> ops::IndexMut<I> for [T]\nwhere\n    I: SliceIndex<[T]>,\n{\n    #[inline]\n    fn index_mut(&mut self, index: I) -> &mut I::Output {\n}\n}\n\n#[inline(never)]\n#[cold]\nfn slice_index_len_fail(index: usize, len: usize) -> ! {\n}\n\n#[inline(never)]\n#[cold]\nfn slice_index_order_fail(index: usize, end: usize) -> ! {\n}\n\n#[inline(never)]\n#[cold]\nfn slice_index_overflow_fail() -> ! {\n}\n\nmod private_slice_index {\n    use super::ops;\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    pub trait Sealed {}\n\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for usize {}\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for ops::Range<usize> {}\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for ops::RangeTo<usize> {}\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for ops::RangeFrom<usize> {}\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for ops::RangeFull {}\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for ops::RangeInclusive<usize> {}\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    impl Sealed for ops::RangeToInclusive<usize> {}\n}\n\n/// A helper trait used for indexing operations.\n#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n#[rustc_on_unimplemented(\n    on(T = \"str\", label = \"string indices are ranges of `usize`\",),\n    on(\n        all(any(T = \"str\", T = \"&str\", T = \"std::string::String\"), _Self = \"{integer}\"),\n        note = \"you can use `.chars().nth()` or `.bytes().nth()`\nsee chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n    ),\n    message = \"the type `{T}` cannot be indexed by `{Self}`\",\n    label = \"slice indices are of type `usize` or ranges of `usize`\"\n)]\npub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n    /// The output type returned by methods.\n    #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n    type Output: ?Sized;\n\n    /// Returns a shared reference to the output at this location, if in\n    /// bounds.\n    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n    fn get(self, slice: &T) -> Option<&Self::Output>;\n\n    /// Returns a mutable reference to the output at this location, if in\n    /// bounds.\n    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n    fn get_mut(self, slice: &mut T) -> Option<&mut Self::Output>;\n\n    /// Returns a shared reference to the output at this location, without\n    /// performing any bounds checking.\n    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n    /// even if the resulting reference is not used.\n    /// [undefined behavior]: ../../reference/behavior-considered-undefined.html\n    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n    unsafe fn get_unchecked(self, slice: &T) -> &Self::Output;\n\n    /// Returns a mutable reference to the output at this location, without\n    /// performing any bounds checking.\n    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n    /// even if the resulting reference is not used.\n    /// [undefined behavior]: ../../reference/behavior-considered-undefined.html\n    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n    unsafe fn get_unchecked_mut(self, slice: &mut T) -> &mut Self::Output;\n\n    /// Returns a shared reference to the output at this location, panicking\n    /// if out of bounds.\n    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n    fn index(self, slice: &T) -> &Self::Output;\n\n    /// Returns a mutable reference to the output at this location, panicking\n    /// if out of bounds.\n    #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n    fn index_mut(self, slice: &mut T) -> &mut Self::Output;\n}\n\n#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for usize {\n    type Output = T;\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&T> {\n}\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n}\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &T {\n}\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {\n}\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &T {\n}\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut T {\n}\n}\n\n#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for ops::Range<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n}\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n}\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n}\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n}\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n}\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n}\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n}\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n}\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n}\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n}\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n}\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n}\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n}\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n}\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n}\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\nimpl<T> SliceIndex<[T]> for ops::RangeFull {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n}\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n}\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n}\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n}\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n}\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n}\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n}\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n}\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n}\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n}\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n    type Output = [T];\n\n    #[inline]\n    fn get(self, slice: &[T]) -> Option<&[T]> {\n}\n\n    #[inline]\n    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n}\n\n    #[inline]\n    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n}\n\n    #[inline]\n    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n}\n\n    #[inline]\n    fn index(self, slice: &[T]) -> &[T] {\n}\n\n    #[inline]\n    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Common traits\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for &[T] {\n    /// Creates an empty slice.\n    fn default() -> Self {\n}\n}\n\n#[stable(feature = \"mut_slice_default\", since = \"1.5.0\")]\nimpl<T> Default for &mut [T] {\n    /// Creates a mutable empty slice.\n    fn default() -> Self {\n}\n}\n\n//\n// Iterators\n//\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a [T] {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a mut [T] {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n}\n}\n\n// Macro helper functions\n#[inline(always)]\nfn size_from_ptr<T>(_: *const T) -> usize {\n}\n\n// Inlining is_empty and len makes a huge performance difference\nmacro_rules! is_empty {\n    // The way we encode the length of a ZST iterator, this works both for ZST\n    // and non-ZST.\n    ($self: ident) => {\n        $self.ptr.as_ptr() as *const T == $self.end\n    };\n}\n// To get rid of some bounds checks (see `position`), we compute the length in a somewhat\n// unexpected way. (Tested by `codegen/slice-position-bounds-check`.)\nmacro_rules! len {\n    ($self: ident) => {{\n        #![allow(unused_unsafe)] // we're sometimes used within an unsafe block\n\n        let start = $self.ptr;\n        let size = size_from_ptr(start.as_ptr());\n        if size == 0 {\n            // This _cannot_ use `unchecked_sub` because we depend on wrapping\n            // to represent the length of long ZST slice iterators.\n            ($self.end as usize).wrapping_sub(start.as_ptr() as usize)\n        } else {\n            // We know that `start <= end`, so can do better than `offset_from`,\n            // which needs to deal in signed.  By setting appropriate flags here\n            // we can tell LLVM this, which helps it remove bounds checks.\n            // SAFETY: By the type invariant, `start <= end`\n            let diff = unsafe { unchecked_sub($self.end as usize, start.as_ptr() as usize) };\n            // By also telling LLVM that the pointers are apart by an exact\n            // multiple of the type size, it can optimize `len() == 0` down to\n            // `start == end` instead of `(end - start) < size`.\n            // SAFETY: By the type invariant, the pointers are aligned so the\n            //         distance between them must be a multiple of pointee size\n            unsafe { exact_div(diff, size) }\n        }\n    }};\n}\n\n// The shared definition of the `Iter` and `IterMut` iterators\nmacro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )*},\n        {$($extra:tt)*}\n    ) => {\n        // Returns the first element and moves the start of the iterator forwards by 1.\n        // Greatly improves performance compared to an inlined function. The iterator\n        // must not be empty.\n        macro_rules! next_unchecked {\n            ($self: ident) => {& $( $mut_ )* *$self.post_inc_start(1)}\n        }\n\n        // Returns the last element and moves the end of the iterator backwards by 1.\n        // Greatly improves performance compared to an inlined function. The iterator\n        // must not be empty.\n        macro_rules! next_back_unchecked {\n            ($self: ident) => {& $( $mut_ )* *$self.pre_dec_end(1)}\n        }\n\n        // Shrinks the iterator when T is a ZST, by moving the end of the iterator\n        // backwards by `n`. `n` must not exceed `self.len()`.\n        macro_rules! zst_shrink {\n            ($self: ident, $n: ident) => {\n                $self.end = ($self.end as * $raw_mut u8).wrapping_offset(-$n) as * $raw_mut T;\n            }\n        }\n\n        impl<'a, T> $name<'a, T> {\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n}\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: isize) -> * $raw_mut T {\n}\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: isize) -> * $raw_mut T {\n}\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n}\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n}\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n}\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n            #[inline]\n            fn count(self) -> usize {\n}\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n}\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n}\n\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n}\n\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n}\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n}\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n}\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}}\n}\n\n/// Immutable slice iterator\n///\n/// This struct is created by the [`iter`] method on [slices].\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // First, we declare a type which has `iter` method to get the `Iter` struct (&[usize here]):\n/// let slice = &[1, 2, 3];\n///\n/// // Then, we iterate over it:\n/// for element in slice.iter() {\n///     println!(\"{}\", element);\n/// }\n/// ```\n///\n/// [`iter`]: ../../std/primitive.slice.html#method.iter\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> {\n    ptr: NonNull<T>,\n    end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n    // ptr == end is a quick test for the Iterator being empty, that works\n    // for both ZST and non-ZST.\n    _marker: marker::PhantomData<&'a T>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Sync for Iter<'_, T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Send for Iter<'_, T> {}\n\nimpl<'a, T> Iter<'a, T> {\n    /// Views the underlying data as a subslice of the original data.\n    ///\n    /// This has the same lifetime as the original slice, and so the\n    /// iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // First, we declare a type which has the `iter` method to get the `Iter`\n    /// // struct (&[usize here]):\n    /// let slice = &[1, 2, 3];\n    ///\n    /// // Then, we get the iterator:\n    /// let mut iter = slice.iter();\n    /// // So if we print what `as_slice` method returns here, we have \"[1, 2, 3]\":\n    /// println!(\"{:?}\", iter.as_slice());\n    ///\n    /// // Next, we move to the second element of the slice:\n    /// iter.next();\n    /// // Now `as_slice` returns \"[2, 3]\":\n    /// println!(\"{:?}\", iter.as_slice());\n    /// ```\n    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n    pub fn as_slice(&self) -> &'a [T] {\n}\n}\n\niterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> Option<Ordering>,\n    {\n}\n}}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Iter<'_, T> {\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"slice_iter_as_ref\", since = \"1.13.0\")]\nimpl<T> AsRef<[T]> for Iter<'_, T> {\n    fn as_ref(&self) -> &[T] {\n}\n}\n\n/// Mutable slice iterator.\n///\n/// This struct is created by the [`iter_mut`] method on [slices].\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // First, we declare a type which has `iter_mut` method to get the `IterMut`\n/// // struct (&[usize here]):\n/// let mut slice = &mut [1, 2, 3];\n///\n/// // Then, we iterate over it and increment each element value:\n/// for element in slice.iter_mut() {\n///     *element += 1;\n/// }\n///\n/// // We now have \"[2, 3, 4]\":\n/// println!(\"{:?}\", slice);\n/// ```\n///\n/// [`iter_mut`]: ../../std/primitive.slice.html#method.iter_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IterMut<'a, T: 'a> {\n    ptr: NonNull<T>,\n    end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n    // ptr == end is a quick test for the Iterator being empty, that works\n    // for both ZST and non-ZST.\n    _marker: marker::PhantomData<&'a mut T>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Send> Send for IterMut<'_, T> {}\n\nimpl<'a, T> IterMut<'a, T> {\n    /// Views the underlying data as a subslice of the original data.\n    ///\n    /// To avoid creating `&mut` references that alias, this is forced\n    /// to consume the iterator.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // First, we declare a type which has `iter_mut` method to get the `IterMut`\n    /// // struct (&[usize here]):\n    /// let mut slice = &mut [1, 2, 3];\n    ///\n    /// {\n    ///     // Then, we get the iterator:\n    ///     let mut iter = slice.iter_mut();\n    ///     // We move to next element:\n    ///     iter.next();\n    ///     // So if we print what `into_slice` method returns here, we have \"[2, 3]\":\n    ///     println!(\"{:?}\", iter.into_slice());\n    /// }\n    ///\n    /// // Now let's modify a value of the slice:\n    /// {\n    ///     // First we get back the iterator:\n    ///     let mut iter = slice.iter_mut();\n    ///     // We change the value of the first element of the slice returned by the `next` method:\n    ///     *iter.next().unwrap() += 1;\n    /// }\n    /// // Now slice is \"[2, 2, 3]\":\n    /// println!(\"{:?}\", slice);\n    /// ```\n    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n    pub fn into_slice(self) -> &'a mut [T] {\n}\n\n    /// Views the underlying data as a subslice of the original data.\n    ///\n    /// To avoid creating `&mut [T]` references that alias, the returned slice\n    /// borrows its lifetime from the iterator the method is applied on.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # #![feature(slice_iter_mut_as_slice)]\n    /// let mut slice: &mut [usize] = &mut [1, 2, 3];\n    ///\n    /// // First, we get the iterator:\n    /// let mut iter = slice.iter_mut();\n    /// // So if we check what the `as_slice` method returns here, we have \"[1, 2, 3]\":\n    /// assert_eq!(iter.as_slice(), &[1, 2, 3]);\n    ///\n    /// // Next, we move to the second element of the slice:\n    /// iter.next();\n    /// // Now `as_slice` returns \"[2, 3]\":\n    /// assert_eq!(iter.as_slice(), &[2, 3]);\n    /// ```\n    #[unstable(feature = \"slice_iter_mut_as_slice\", reason = \"recently added\", issue = \"58957\")]\n    pub fn as_slice(&self) -> &[T] {\n}\n}\n\niterator! {struct IterMut -> *mut T, &'a mut T, mut, {mut}, {}}\n\n/// An internal abstraction over the splitting iterators, so that\n/// splitn, splitn_mut etc can be implemented once.\n#[doc(hidden)]\ntrait SplitIter: DoubleEndedIterator {\n    /// Marks the underlying iterator as complete, extracting the remaining\n    /// portion of the slice.\n    fn finish(&mut self) -> Option<Self::Item>;\n}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function.\n///\n/// This struct is created by the [`split`] method on [slices].\n///\n/// [`split`]: ../../std/primitive.slice.html#method.split\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Split<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    v: &'a [T],\n    pred: P,\n    finished: bool,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for Split<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, P> Clone for Split<'_, T, P>\nwhere\n    P: Clone + FnMut(&T) -> bool,\n{\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> Iterator for Split<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> DoubleEndedIterator for Split<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n}\n}\n\nimpl<'a, T, P> SplitIter for Split<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn finish(&mut self) -> Option<&'a [T]> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, P> FusedIterator for Split<'_, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over the subslices of the vector which are separated\n/// by elements that match `pred`.\n///\n/// This struct is created by the [`split_mut`] method on [slices].\n///\n/// [`split_mut`]: ../../std/primitive.slice.html#method.split_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SplitMut<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    v: &'a mut [T],\n    pred: P,\n    finished: bool,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for SplitMut<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<'a, T, P> SplitIter for SplitMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn finish(&mut self) -> Option<&'a mut [T]> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> Iterator for SplitMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, P> FusedIterator for SplitMut<'_, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function, starting from the end of the slice.\n///\n/// This struct is created by the [`rsplit`] method on [slices].\n///\n/// [`rsplit`]: ../../std/primitive.slice.html#method.rsplit\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n#[derive(Clone)] // Is this correct, or does it incorrectly require `T: Clone`?\npub struct RSplit<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    inner: Split<'a, T, P>,\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for RSplit<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<'a, T, P> Iterator for RSplit<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<'a, T, P> DoubleEndedIterator for RSplit<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n}\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<'a, T, P> SplitIter for RSplit<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn finish(&mut self) -> Option<&'a [T]> {\n}\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<T, P> FusedIterator for RSplit<'_, T, P> where P: FnMut(&T) -> bool {}\n\n/// An iterator over the subslices of the vector which are separated\n/// by elements that match `pred`, starting from the end of the slice.\n///\n/// This struct is created by the [`rsplit_mut`] method on [slices].\n///\n/// [`rsplit_mut`]: ../../std/primitive.slice.html#method.rsplit_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\npub struct RSplitMut<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    inner: SplitMut<'a, T, P>,\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for RSplitMut<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<'a, T, P> SplitIter for RSplitMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn finish(&mut self) -> Option<&'a mut [T]> {\n}\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<'a, T, P> Iterator for RSplitMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    type Item = &'a mut [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut [T]> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<'a, T, P> DoubleEndedIterator for RSplitMut<'a, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut [T]> {\n}\n}\n\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\nimpl<T, P> FusedIterator for RSplitMut<'_, T, P> where P: FnMut(&T) -> bool {}\n\n/// An private iterator over subslices separated by elements that\n/// match a predicate function, splitting at most a fixed number of\n/// times.\n#[derive(Debug)]\nstruct GenericSplitN<I> {\n    iter: I,\n    count: usize,\n}\n\nimpl<T, I: SplitIter<Item = T>> Iterator for GenericSplitN<I> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function, limited to a given number of splits.\n///\n/// This struct is created by the [`splitn`] method on [slices].\n///\n/// [`splitn`]: ../../std/primitive.slice.html#method.splitn\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SplitN<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    inner: GenericSplitN<Split<'a, T, P>>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for SplitN<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// An iterator over subslices separated by elements that match a\n/// predicate function, limited to a given number of splits, starting\n/// from the end of the slice.\n///\n/// This struct is created by the [`rsplitn`] method on [slices].\n///\n/// [`rsplitn`]: ../../std/primitive.slice.html#method.rsplitn\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RSplitN<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    inner: GenericSplitN<RSplit<'a, T, P>>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for RSplitN<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// An iterator over subslices separated by elements that match a predicate\n/// function, limited to a given number of splits.\n///\n/// This struct is created by the [`splitn_mut`] method on [slices].\n///\n/// [`splitn_mut`]: ../../std/primitive.slice.html#method.splitn_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SplitNMut<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    inner: GenericSplitN<SplitMut<'a, T, P>>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for SplitNMut<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// An iterator over subslices separated by elements that match a\n/// predicate function, limited to a given number of splits, starting\n/// from the end of the slice.\n///\n/// This struct is created by the [`rsplitn_mut`] method on [slices].\n///\n/// [`rsplitn_mut`]: ../../std/primitive.slice.html#method.rsplitn_mut\n/// [slices]: ../../std/primitive.slice.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct RSplitNMut<'a, T: 'a, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    inner: GenericSplitN<RSplitMut<'a, T, P>>,\n}\n\n#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\nimpl<T: fmt::Debug, P> fmt::Debug for RSplitNMut<'_, T, P>\nwhere\n    P: FnMut(&T) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nmacro_rules! forward_iterator {\n    ($name:ident: $elem:ident, $iter_of:ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, $elem, P> Iterator for $name<'a, $elem, P>\n        where\n            P: FnMut(&T) -> bool,\n        {\n            type Item = $iter_of;\n\n            #[inline]\n            fn next(&mut self) -> Option<$iter_of> {\n}\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n}\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<'a, $elem, P> FusedIterator for $name<'a, $elem, P> where P: FnMut(&T) -> bool {}\n    };\n}\n\nforward_iterator! { SplitN: T, &'a [T] }\nforward_iterator! { RSplitN: T, &'a [T] }\nforward_iterator! { SplitNMut: T, &'a mut [T] }\nforward_iterator! { RSplitNMut: T, &'a mut [T] }\n\n/// An iterator over overlapping subslices of length `size`.\n///\n/// This struct is created by the [`windows`] method on [slices].\n///\n/// [`windows`]: ../../std/primitive.slice.html#method.windows\n/// [slices]: ../../std/primitive.slice.html\n#[derive(Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Windows<'a, T: 'a> {\n    v: &'a [T],\n    size: usize,\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Windows<'_, T> {\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Windows<'a, T> {\n    type Item = &'a [T];\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a [T]> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn count(self) -> usize {\n}\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n}\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a [T]> {\n}\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for Windows<'_, T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for Windows<'_, T> {}}\n#[cfg(not(test))] // See #65860\npub mod str {\n// ignore-tidy-filelength\n\n//! String manipulation.\n//!\n//! For more details, see the `std::str` module.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse self::pattern::Pattern;\nuse self::pattern::{DoubleEndedSearcher, ReverseSearcher, SearchStep, Searcher};\n\nuse crate::char;\nuse crate::fmt::{self, Write};\nuse crate::iter::{Chain, FlatMap, Flatten};\nuse crate::iter::{Cloned, Filter, FusedIterator, Map, TrustedLen, TrustedRandomAccess};\nuse crate::mem;\nuse crate::ops::Try;\nuse crate::option;\nuse crate::slice::{self, SliceIndex, Split as SliceSplit};\n\npub mod pattern {\n//! The string Pattern API.\n//!\n//! For more details, see the traits [`Pattern`], [`Searcher`],\n//! [`ReverseSearcher`], and [`DoubleEndedSearcher`].\n\n#![unstable(\n    feature = \"pattern\",\n    reason = \"API not fully fleshed out and ready to be stabilized\",\n    issue = \"27721\"\n)]\n\nuse crate::cmp;\nuse crate::fmt;\nuse crate::slice::memchr;\nuse crate::usize;\n\n// Pattern\n\n/// A string pattern.\n///\n/// A `Pattern<'a>` expresses that the implementing type\n/// can be used as a string pattern for searching in a `&'a str`.\n///\n/// For example, both `'a'` and `\"aa\"` are patterns that\n/// would match at index `1` in the string `\"baaaab\"`.\n///\n/// The trait itself acts as a builder for an associated\n/// `Searcher` type, which does the actual work of finding\n/// occurrences of the pattern in a string.\npub trait Pattern<'a>: Sized {\n    /// Associated searcher for this pattern\n    type Searcher: Searcher<'a>;\n\n    /// Constructs the associated searcher from\n    /// `self` and the `haystack` to search in.\n    fn into_searcher(self, haystack: &'a str) -> Self::Searcher;\n\n    /// Checks whether the pattern matches anywhere in the haystack\n    #[inline]\n    fn is_contained_in(self, haystack: &'a str) -> bool {\n        self.into_searcher(haystack).next_match().is_some()\n    }\n\n    /// Checks whether the pattern matches at the front of the haystack\n    #[inline]\n    fn is_prefix_of(self, haystack: &'a str) -> bool {\n}\n\n    /// Checks whether the pattern matches at the back of the haystack\n    #[inline]\n    fn is_suffix_of(self, haystack: &'a str) -> bool\n    where\n        Self::Searcher: ReverseSearcher<'a>,\n    {\n}\n}\n\n// Searcher\n\n/// Result of calling `Searcher::next()` or `ReverseSearcher::next_back()`.\n#[derive(Copy, Clone, Eq, PartialEq, Debug)]\npub enum SearchStep {\n    /// Expresses that a match of the pattern has been found at\n    /// `haystack[a..b]`.\n    Match(usize, usize),\n    /// Expresses that `haystack[a..b]` has been rejected as a possible match\n    /// of the pattern.\n    ///\n    /// Note that there might be more than one `Reject` between two `Match`es,\n    /// there is no requirement for them to be combined into one.\n    Reject(usize, usize),\n    /// Expresses that every byte of the haystack has been visited, ending\n    /// the iteration.\n    Done,\n}\n\n/// A searcher for a string pattern.\n///\n/// This trait provides methods for searching for non-overlapping\n/// matches of a pattern starting from the front (left) of a string.\n///\n/// It will be implemented by associated `Searcher`\n/// types of the `Pattern` trait.\n///\n/// The trait is marked unsafe because the indices returned by the\n/// `next()` methods are required to lie on valid utf8 boundaries in\n/// the haystack. This enables consumers of this trait to\n/// slice the haystack without additional runtime checks.\npub unsafe trait Searcher<'a> {\n    /// Getter for the underlying string to be searched in\n    ///\n    /// Will always return the same `&str`\n    fn haystack(&self) -> &'a str;\n\n    /// Performs the next search step starting from the front.\n    ///\n    /// - Returns `Match(a, b)` if `haystack[a..b]` matches the pattern.\n    /// - Returns `Reject(a, b)` if `haystack[a..b]` can not match the\n    ///   pattern, even partially.\n    /// - Returns `Done` if every byte of the haystack has been visited\n    ///\n    /// The stream of `Match` and `Reject` values up to a `Done`\n    /// will contain index ranges that are adjacent, non-overlapping,\n    /// covering the whole haystack, and laying on utf8 boundaries.\n    ///\n    /// A `Match` result needs to contain the whole matched pattern,\n    /// however `Reject` results may be split up into arbitrary\n    /// many adjacent fragments. Both ranges may have zero length.\n    ///\n    /// As an example, the pattern `\"aaa\"` and the haystack `\"cbaaaaab\"`\n    /// might produce the stream\n    /// `[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]`\n    fn next(&mut self) -> SearchStep;\n\n    /// Finds the next `Match` result. See `next()`\n    ///\n    /// Unlike next(), there is no guarantee that the returned ranges\n    /// of this and next_reject will overlap. This will return (start_match, end_match),\n    /// where start_match is the index of where the match begins, and end_match is\n    /// the index after the end of the match.\n    #[inline]\n    fn next_match(&mut self) -> Option<(usize, usize)> {\n        loop {\n            match self.next() {\n                SearchStep::Match(a, b) => return Some((a, b)),\n                SearchStep::Done => return None,\n                _ => continue,\n            }\n        }\n    }\n\n    /// Finds the next `Reject` result. See `next()` and `next_match()`\n    ///\n    /// Unlike next(), there is no guarantee that the returned ranges\n    /// of this and next_match will overlap.\n    #[inline]\n    fn next_reject(&mut self) -> Option<(usize, usize)> {\n}\n}\n\n/// A reverse searcher for a string pattern.\n///\n/// This trait provides methods for searching for non-overlapping\n/// matches of a pattern starting from the back (right) of a string.\n///\n/// It will be implemented by associated `Searcher`\n/// types of the `Pattern` trait if the pattern supports searching\n/// for it from the back.\n///\n/// The index ranges returned by this trait are not required\n/// to exactly match those of the forward search in reverse.\n///\n/// For the reason why this trait is marked unsafe, see them\n/// parent trait `Searcher`.\npub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n    /// Performs the next search step starting from the back.\n    ///\n    /// - Returns `Match(a, b)` if `haystack[a..b]` matches the pattern.\n    /// - Returns `Reject(a, b)` if `haystack[a..b]` can not match the\n    ///   pattern, even partially.\n    /// - Returns `Done` if every byte of the haystack has been visited\n    ///\n    /// The stream of `Match` and `Reject` values up to a `Done`\n    /// will contain index ranges that are adjacent, non-overlapping,\n    /// covering the whole haystack, and laying on utf8 boundaries.\n    ///\n    /// A `Match` result needs to contain the whole matched pattern,\n    /// however `Reject` results may be split up into arbitrary\n    /// many adjacent fragments. Both ranges may have zero length.\n    ///\n    /// As an example, the pattern `\"aaa\"` and the haystack `\"cbaaaaab\"`\n    /// might produce the stream\n    /// `[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]`\n    fn next_back(&mut self) -> SearchStep;\n\n    /// Finds the next `Match` result. See `next_back()`\n    #[inline]\n    fn next_match_back(&mut self) -> Option<(usize, usize)> {\n        loop {\n            match self.next_back() {\n                SearchStep::Match(a, b) => return Some((a, b)),\n                SearchStep::Done => return None,\n                _ => continue,\n            }\n        }\n    }\n\n    /// Finds the next `Reject` result. See `next_back()`\n    #[inline]\n    fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n}\n}\n\n/// A marker trait to express that a `ReverseSearcher`\n/// can be used for a `DoubleEndedIterator` implementation.\n///\n/// For this, the impl of `Searcher` and `ReverseSearcher` need\n/// to follow these conditions:\n///\n/// - All results of `next()` need to be identical\n///   to the results of `next_back()` in reverse order.\n/// - `next()` and `next_back()` need to behave as\n///   the two ends of a range of values, that is they\n///   can not \"walk past each other\".\n///\n/// # Examples\n///\n/// `char::Searcher` is a `DoubleEndedSearcher` because searching for a\n/// `char` only requires looking at one at a time, which behaves the same\n/// from both ends.\n///\n/// `(&str)::Searcher` is not a `DoubleEndedSearcher` because\n/// the pattern `\"aa\"` in the haystack `\"aaa\"` matches as either\n/// `\"[aa]a\"` or `\"a[aa]\"`, depending from which side it is searched.\npub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}\n\n/////////////////////////////////////////////////////////////////////////////\n// Impl for char\n/////////////////////////////////////////////////////////////////////////////\n\n/// Associated type for `<char as Pattern<'a>>::Searcher`.\n#[derive(Clone, Debug)]\npub struct CharSearcher<'a> {\n    haystack: &'a str,\n    // safety invariant: `finger`/`finger_back` must be a valid utf8 byte index of `haystack`\n    // This invariant can be broken *within* next_match and next_match_back, however\n    // they must exit with fingers on valid code point boundaries.\n    /// `finger` is the current byte index of the forward search.\n    /// Imagine that it exists before the byte at its index, i.e.\n    /// `haystack[finger]` is the first byte of the slice we must inspect during\n    /// forward searching\n    finger: usize,\n    /// `finger_back` is the current byte index of the reverse search.\n    /// Imagine that it exists after the byte at its index, i.e.\n    /// haystack[finger_back - 1] is the last byte of the slice we must inspect during\n    /// forward searching (and thus the first byte to be inspected when calling next_back())\n    finger_back: usize,\n    /// The character being searched for\n    needle: char,\n\n    // safety invariant: `utf8_size` must be less than 5\n    /// The number of bytes `needle` takes up when encoded in utf8\n    utf8_size: usize,\n    /// A utf8 encoded copy of the `needle`\n    utf8_encoded: [u8; 4],\n}\n\nunsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n    #[inline]\n    fn haystack(&self) -> &'a str {\n}\n    #[inline]\n    fn next(&mut self) -> SearchStep {\n}\n    #[inline]\n    fn next_match(&mut self) -> Option<(usize, usize)> {\n}\n\n    // let next_reject use the default implementation from the Searcher trait\n}\n\nunsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n    #[inline]\n    fn next_back(&mut self) -> SearchStep {\n}\n    #[inline]\n    fn next_match_back(&mut self) -> Option<(usize, usize)> {\n}\n\n    // let next_reject_back use the default implementation from the Searcher trait\n}\n\nimpl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n\n/// Searches for chars that are equal to a given char\nimpl<'a> Pattern<'a> for char {\n    type Searcher = CharSearcher<'a>;\n\n    #[inline]\n    fn into_searcher(self, haystack: &'a str) -> Self::Searcher {\n}\n\n    #[inline]\n    fn is_contained_in(self, haystack: &'a str) -> bool {\n}\n\n    #[inline]\n    fn is_prefix_of(self, haystack: &'a str) -> bool {\n}\n\n    #[inline]\n    fn is_suffix_of(self, haystack: &'a str) -> bool\n    where\n        Self::Searcher: ReverseSearcher<'a>,\n    {\n}\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Impl for a MultiCharEq wrapper\n/////////////////////////////////////////////////////////////////////////////\n\n#[doc(hidden)]\ntrait MultiCharEq {\n    fn matches(&mut self, c: char) -> bool;\n}\n\nimpl<F> MultiCharEq for F\nwhere\n    F: FnMut(char) -> bool,\n{\n    #[inline]\n    fn matches(&mut self, c: char) -> bool {\n}\n}\n\nimpl MultiCharEq for &[char] {\n    #[inline]\n    fn matches(&mut self, c: char) -> bool {\n}\n}\n\nstruct MultiCharEqPattern<C: MultiCharEq>(C);\n\n#[derive(Clone, Debug)]\nstruct MultiCharEqSearcher<'a, C: MultiCharEq> {\n    char_eq: C,\n    haystack: &'a str,\n    char_indices: super::CharIndices<'a>,\n}\n\nimpl<'a, C: MultiCharEq> Pattern<'a> for MultiCharEqPattern<C> {\n    type Searcher = MultiCharEqSearcher<'a, C>;\n\n    #[inline]\n    fn into_searcher(self, haystack: &'a str) -> MultiCharEqSearcher<'a, C> {\n}\n}\n\nunsafe impl<'a, C: MultiCharEq> Searcher<'a> for MultiCharEqSearcher<'a, C> {\n    #[inline]\n    fn haystack(&self) -> &'a str {\n}\n\n    #[inline]\n    fn next(&mut self) -> SearchStep {\n}\n}\n\nunsafe impl<'a, C: MultiCharEq> ReverseSearcher<'a> for MultiCharEqSearcher<'a, C> {\n    #[inline]\n    fn next_back(&mut self) -> SearchStep {\n}\n}\n\nimpl<'a, C: MultiCharEq> DoubleEndedSearcher<'a> for MultiCharEqSearcher<'a, C> {}\n\n/////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! pattern_methods {\n    ($t:ty, $pmap:expr, $smap:expr) => {\n        type Searcher = $t;\n\n        #[inline]\n        fn into_searcher(self, haystack: &'a str) -> $t {\n}\n\n        #[inline]\n        fn is_contained_in(self, haystack: &'a str) -> bool {\n}\n\n        #[inline]\n        fn is_prefix_of(self, haystack: &'a str) -> bool {\n}\n\n        #[inline]\n        fn is_suffix_of(self, haystack: &'a str) -> bool\n            where $t: ReverseSearcher<'a>\n        {\n}\n    }\n}\n\nmacro_rules! searcher_methods {\n    (forward) => {\n        #[inline]\n        fn haystack(&self) -> &'a str {\n}\n        #[inline]\n        fn next(&mut self) -> SearchStep {\n}\n        #[inline]\n        fn next_match(&mut self) -> Option<(usize, usize)> {\n}\n        #[inline]\n        fn next_reject(&mut self) -> Option<(usize, usize)> {\n}\n    };\n    (reverse) => {\n        #[inline]\n        fn next_back(&mut self) -> SearchStep {\n}\n        #[inline]\n        fn next_match_back(&mut self) -> Option<(usize, usize)> {\n}\n        #[inline]\n        fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n}\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Impl for &[char]\n/////////////////////////////////////////////////////////////////////////////\n\n// Todo: Change / Remove due to ambiguity in meaning.\n\n/// Associated type for `<&[char] as Pattern<'a>>::Searcher`.\n#[derive(Clone, Debug)]\npub struct CharSliceSearcher<'a, 'b>(<MultiCharEqPattern<&'b [char]> as Pattern<'a>>::Searcher);\n\nunsafe impl<'a, 'b> Searcher<'a> for CharSliceSearcher<'a, 'b> {\n    searcher_methods!(forward);\n}\n\nunsafe impl<'a, 'b> ReverseSearcher<'a> for CharSliceSearcher<'a, 'b> {\n    searcher_methods!(reverse);\n}\n\nimpl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}\n\n/// Searches for chars that are equal to any of the chars in the array\nimpl<'a, 'b> Pattern<'a> for &'b [char] {\n    pattern_methods!(CharSliceSearcher<'a, 'b>, MultiCharEqPattern, CharSliceSearcher);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Impl for F: FnMut(char) -> bool\n/////////////////////////////////////////////////////////////////////////////\n\n/// Associated type for `<F as Pattern<'a>>::Searcher`.\n#[derive(Clone)]\npub struct CharPredicateSearcher<'a, F>(<MultiCharEqPattern<F> as Pattern<'a>>::Searcher)\nwhere\n    F: FnMut(char) -> bool;\n\nimpl<F> fmt::Debug for CharPredicateSearcher<'_, F>\nwhere\n    F: FnMut(char) -> bool,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\nunsafe impl<'a, F> Searcher<'a> for CharPredicateSearcher<'a, F>\nwhere\n    F: FnMut(char) -> bool,\n{\n    searcher_methods!(forward);\n}\n\nunsafe impl<'a, F> ReverseSearcher<'a> for CharPredicateSearcher<'a, F>\nwhere\n    F: FnMut(char) -> bool,\n{\n    searcher_methods!(reverse);\n}\n\nimpl<'a, F> DoubleEndedSearcher<'a> for CharPredicateSearcher<'a, F> where F: FnMut(char) -> bool {}\n\n/// Searches for chars that match the given predicate\nimpl<'a, F> Pattern<'a> for F\nwhere\n    F: FnMut(char) -> bool,\n{\n    pattern_methods!(CharPredicateSearcher<'a, F>, MultiCharEqPattern, CharPredicateSearcher);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Impl for &&str\n/////////////////////////////////////////////////////////////////////////////\n\n/// Delegates to the `&str` impl.\nimpl<'a, 'b, 'c> Pattern<'a> for &'c &'b str {\n    pattern_methods!(StrSearcher<'a, 'b>, |&s| s, |s| s);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Impl for &str\n/////////////////////////////////////////////////////////////////////////////\n\n/// Non-allocating substring search.\n///\n/// Will handle the pattern `\"\"` as returning empty matches at each character\n/// boundary.\nimpl<'a, 'b> Pattern<'a> for &'b str {\n    type Searcher = StrSearcher<'a, 'b>;\n\n    #[inline]\n    fn into_searcher(self, haystack: &'a str) -> StrSearcher<'a, 'b> {\n}\n\n    /// Checks whether the pattern matches at the front of the haystack\n    #[inline]\n    fn is_prefix_of(self, haystack: &'a str) -> bool {\n}\n\n    /// Checks whether the pattern matches at the back of the haystack\n    #[inline]\n    fn is_suffix_of(self, haystack: &'a str) -> bool {\n}\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Two Way substring searcher\n/////////////////////////////////////////////////////////////////////////////\n\n#[derive(Clone, Debug)]\n/// Associated type for `<&str as Pattern<'a>>::Searcher`.\npub struct StrSearcher<'a, 'b> {\n    haystack: &'a str,\n    needle: &'b str,\n\n    searcher: StrSearcherImpl,\n}\n\n#[derive(Clone, Debug)]\nenum StrSearcherImpl {\n    Empty(EmptyNeedle),\n    TwoWay(TwoWaySearcher),\n}\n\n#[derive(Clone, Debug)]\nstruct EmptyNeedle {\n    position: usize,\n    end: usize,\n    is_match_fw: bool,\n    is_match_bw: bool,\n}\n\nimpl<'a, 'b> StrSearcher<'a, 'b> {\n    fn new(haystack: &'a str, needle: &'b str) -> StrSearcher<'a, 'b> {\n}\n}\n\nunsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {\n    #[inline]\n    fn haystack(&self) -> &'a str {\n}\n\n    #[inline]\n    fn next(&mut self) -> SearchStep {\n}\n\n    #[inline]\n    fn next_match(&mut self) -> Option<(usize, usize)> {\n}\n}\n\nunsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n    #[inline]\n    fn next_back(&mut self) -> SearchStep {\n}\n\n    #[inline]\n    fn next_match_back(&mut self) -> Option<(usize, usize)> {\n}\n}\n\n/// The internal state of the two-way substring search algorithm.\n#[derive(Clone, Debug)]\nstruct TwoWaySearcher {\n    // constants\n    /// critical factorization index\n    crit_pos: usize,\n    /// critical factorization index for reversed needle\n    crit_pos_back: usize,\n    period: usize,\n    /// `byteset` is an extension (not part of the two way algorithm);\n    /// it's a 64-bit \"fingerprint\" where each set bit `j` corresponds\n    /// to a (byte & 63) == j present in the needle.\n    byteset: u64,\n\n    // variables\n    position: usize,\n    end: usize,\n    /// index into needle before which we have already matched\n    memory: usize,\n    /// index into needle after which we have already matched\n    memory_back: usize,\n}\n\n/*\n    This is the Two-Way search algorithm, which was introduced in the paper:\n    Crochemore, M., Perrin, D., 1991, Two-way string-matching, Journal of the ACM 38(3):651-675.\n\n    Here's some background information.\n\n    A *word* is a string of symbols. The *length* of a word should be a familiar\n    notion, and here we denote it for any word x by |x|.\n    (We also allow for the possibility of the *empty word*, a word of length zero).\n\n    If x is any non-empty word, then an integer p with 0 < p <= |x| is said to be a\n    *period* for x iff for all i with 0 <= i <= |x| - p - 1, we have x[i] == x[i+p].\n    For example, both 1 and 2 are periods for the string \"aa\". As another example,\n    the only period of the string \"abcd\" is 4.\n\n    We denote by period(x) the *smallest* period of x (provided that x is non-empty).\n    This is always well-defined since every non-empty word x has at least one period,\n    |x|. We sometimes call this *the period* of x.\n\n    If u, v and x are words such that x = uv, where uv is the concatenation of u and\n    v, then we say that (u, v) is a *factorization* of x.\n\n    Let (u, v) be a factorization for a word x. Then if w is a non-empty word such\n    that both of the following hold\n\n      - either w is a suffix of u or u is a suffix of w\n      - either w is a prefix of v or v is a prefix of w\n\n    then w is said to be a *repetition* for the factorization (u, v).\n\n    Just to unpack this, there are four possibilities here. Let w = \"abc\". Then we\n    might have:\n\n      - w is a suffix of u and w is a prefix of v. ex: (\"lolabc\", \"abcde\")\n      - w is a suffix of u and v is a prefix of w. ex: (\"lolabc\", \"ab\")\n      - u is a suffix of w and w is a prefix of v. ex: (\"bc\", \"abchi\")\n      - u is a suffix of w and v is a prefix of w. ex: (\"bc\", \"a\")\n\n    Note that the word vu is a repetition for any factorization (u,v) of x = uv,\n    so every factorization has at least one repetition.\n\n    If x is a string and (u, v) is a factorization for x, then a *local period* for\n    (u, v) is an integer r such that there is some word w such that |w| = r and w is\n    a repetition for (u, v).\n\n    We denote by local_period(u, v) the smallest local period of (u, v). We sometimes\n    call this *the local period* of (u, v). Provided that x = uv is non-empty, this\n    is well-defined (because each non-empty word has at least one factorization, as\n    noted above).\n\n    It can be proven that the following is an equivalent definition of a local period\n    for a factorization (u, v): any positive integer r such that x[i] == x[i+r] for\n    all i such that |u| - r <= i <= |u| - 1 and such that both x[i] and x[i+r] are\n    defined. (i.e., i > 0 and i + r < |x|).\n\n    Using the above reformulation, it is easy to prove that\n\n        1 <= local_period(u, v) <= period(uv)\n\n    A factorization (u, v) of x such that local_period(u,v) = period(x) is called a\n    *critical factorization*.\n\n    The algorithm hinges on the following theorem, which is stated without proof:\n\n    **Critical Factorization Theorem** Any word x has at least one critical\n    factorization (u, v) such that |u| < period(x).\n\n    The purpose of maximal_suffix is to find such a critical factorization.\n\n    If the period is short, compute another factorization x = u' v' to use\n    for reverse search, chosen instead so that |v'| < period(x).\n\n*/\nimpl TwoWaySearcher {\n    fn new(needle: &[u8], end: usize) -> TwoWaySearcher {\n}\n\n    #[inline]\n    fn byteset_create(bytes: &[u8]) -> u64 {\n}\n\n    #[inline]\n    fn byteset_contains(&self, byte: u8) -> bool {\n}\n\n    // One of the main ideas of Two-Way is that we factorize the needle into\n    // two halves, (u, v), and begin trying to find v in the haystack by scanning\n    // left to right. If v matches, we try to match u by scanning right to left.\n    // How far we can jump when we encounter a mismatch is all based on the fact\n    // that (u, v) is a critical factorization for the needle.\n    #[inline]\n    fn next<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> S::Output\n    where\n        S: TwoWayStrategy,\n    {\n}\n\n    // Follows the ideas in `next()`.\n    //\n    // The definitions are symmetrical, with period(x) = period(reverse(x))\n    // and local_period(u, v) = local_period(reverse(v), reverse(u)), so if (u, v)\n    // is a critical factorization, so is (reverse(v), reverse(u)).\n    //\n    // For the reverse case we have computed a critical factorization x = u' v'\n    // (field `crit_pos_back`). We need |u| < period(x) for the forward case and\n    // thus |v'| < period(x) for the reverse.\n    //\n    // To search in reverse through the haystack, we search forward through\n    // a reversed haystack with a reversed needle, matching first u' and then v'.\n    #[inline]\n    fn next_back<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> S::Output\n    where\n        S: TwoWayStrategy,\n    {\n}\n\n    // Compute the maximal suffix of `arr`.\n    //\n    // The maximal suffix is a possible critical factorization (u, v) of `arr`.\n    //\n    // Returns (`i`, `p`) where `i` is the starting index of v and `p` is the\n    // period of v.\n    //\n    // `order_greater` determines if lexical order is `<` or `>`. Both\n    // orders must be computed -- the ordering with the largest `i` gives\n    // a critical factorization.\n    //\n    // For long period cases, the resulting period is not exact (it is too short).\n    #[inline]\n    fn maximal_suffix(arr: &[u8], order_greater: bool) -> (usize, usize) {\n}\n\n    // Compute the maximal suffix of the reverse of `arr`.\n    //\n    // The maximal suffix is a possible critical factorization (u', v') of `arr`.\n    //\n    // Returns `i` where `i` is the starting index of v', from the back;\n    // returns immediately when a period of `known_period` is reached.\n    //\n    // `order_greater` determines if lexical order is `<` or `>`. Both\n    // orders must be computed -- the ordering with the largest `i` gives\n    // a critical factorization.\n    //\n    // For long period cases, the resulting period is not exact (it is too short).\n    fn reverse_maximal_suffix(arr: &[u8], known_period: usize, order_greater: bool) -> usize {\n}\n}\n\n// TwoWayStrategy allows the algorithm to either skip non-matches as quickly\n// as possible, or to work in a mode where it emits Rejects relatively quickly.\ntrait TwoWayStrategy {\n    type Output;\n    fn use_early_reject() -> bool;\n    fn rejecting(a: usize, b: usize) -> Self::Output;\n    fn matching(a: usize, b: usize) -> Self::Output;\n}\n\n/// Skip to match intervals as quickly as possible\nenum MatchOnly {}\n\nimpl TwoWayStrategy for MatchOnly {\n    type Output = Option<(usize, usize)>;\n\n    #[inline]\n    fn use_early_reject() -> bool {\n}\n    #[inline]\n    fn rejecting(_a: usize, _b: usize) -> Self::Output {\n}\n    #[inline]\n    fn matching(a: usize, b: usize) -> Self::Output {\n}\n}\n\n/// Emit Rejects regularly\nenum RejectAndMatch {}\n\nimpl TwoWayStrategy for RejectAndMatch {\n    type Output = SearchStep;\n\n    #[inline]\n    fn use_early_reject() -> bool {\n}\n    #[inline]\n    fn rejecting(a: usize, b: usize) -> Self::Output {\n}\n    #[inline]\n    fn matching(a: usize, b: usize) -> Self::Output {\n}\n}\n}\n\n#[unstable(feature = \"str_internals\", issue = \"none\")]\n#[allow(missing_docs)]\npub mod lossy {\n}\n\n/// Parse a value from a string\n///\n/// `FromStr`'s [`from_str`] method is often used implicitly, through\n/// [`str`]'s [`parse`] method. See [`parse`]'s documentation for examples.\n///\n/// [`from_str`]: #tymethod.from_str\n/// [`str`]: ../../std/primitive.str.html\n/// [`parse`]: ../../std/primitive.str.html#method.parse\n///\n/// `FromStr` does not have a lifetime parameter, and so you can only parse types\n/// that do not contain a lifetime parameter themselves. In other words, you can\n/// parse an `i32` with `FromStr`, but not a `&i32`. You can parse a struct that\n/// contains an `i32`, but not one that contains an `&i32`.\n///\n/// # Examples\n///\n/// Basic implementation of `FromStr` on an example `Point` type:\n///\n/// ```\n/// use std::str::FromStr;\n/// use std::num::ParseIntError;\n///\n/// #[derive(Debug, PartialEq)]\n/// struct Point {\n///     x: i32,\n///     y: i32\n/// }\n///\n/// impl FromStr for Point {\n///     type Err = ParseIntError;\n///\n///     fn from_str(s: &str) -> Result<Self, Self::Err> {\n///         let coords: Vec<&str> = s.trim_matches(|p| p == '(' || p == ')' )\n///                                  .split(',')\n///                                  .collect();\n///\n///         let x_fromstr = coords[0].parse::<i32>()?;\n///         let y_fromstr = coords[1].parse::<i32>()?;\n///\n///         Ok(Point { x: x_fromstr, y: y_fromstr })\n///     }\n/// }\n///\n/// let p = Point::from_str(\"(1,2)\");\n/// assert_eq!(p.unwrap(), Point{ x: 1, y: 2} )\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait FromStr: Sized {\n    /// The associated error which can be returned from parsing.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Err;\n\n    /// Parses a string `s` to return a value of this type.\n    ///\n    /// If parsing succeeds, return the value inside [`Ok`], otherwise\n    /// when the string is ill-formatted return an error specific to the\n    /// inside [`Err`]. The error type is specific to implementation of the trait.\n    ///\n    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage with [`i32`][ithirtytwo], a type that implements `FromStr`:\n    ///\n    /// [ithirtytwo]: ../../std/primitive.i32.html\n    ///\n    /// ```\n    /// use std::str::FromStr;\n    ///\n    /// let s = \"5\";\n    /// let x = i32::from_str(s).unwrap();\n    ///\n    /// assert_eq!(5, x);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn from_str(s: &str) -> Result<Self, Self::Err>;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromStr for bool {\n    type Err = ParseBoolError;\n\n    /// Parse a `bool` from a string.\n    ///\n    /// Yields a `Result<bool, ParseBoolError>`, because `s` may or may not\n    /// actually be parseable.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::str::FromStr;\n    ///\n    /// assert_eq!(FromStr::from_str(\"true\"), Ok(true));\n    /// assert_eq!(FromStr::from_str(\"false\"), Ok(false));\n    /// assert!(<bool as FromStr>::from_str(\"not even a boolean\").is_err());\n    /// ```\n    ///\n    /// Note, in many cases, the `.parse()` method on `str` is more proper.\n    ///\n    /// ```\n    /// assert_eq!(\"true\".parse(), Ok(true));\n    /// assert_eq!(\"false\".parse(), Ok(false));\n    /// assert!(\"not even a boolean\".parse::<bool>().is_err());\n    /// ```\n    #[inline]\n    fn from_str(s: &str) -> Result<bool, ParseBoolError> {\n}\n}\n\n/// An error returned when parsing a `bool` using [`from_str`] fails\n///\n/// [`from_str`]: ../../std/primitive.bool.html#method.from_str\n#[derive(Debug, Clone, PartialEq, Eq)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct ParseBoolError {\n    _priv: (),\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for ParseBoolError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/*\nSection: Creating a string\n*/\n\n/// Errors which can occur when attempting to interpret a sequence of [`u8`]\n/// as a string.\n///\n/// [`u8`]: ../../std/primitive.u8.html\n///\n/// As such, the `from_utf8` family of functions and methods for both [`String`]s\n/// and [`&str`]s make use of this error, for example.\n///\n/// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n/// [`&str`]: ../../std/str/fn.from_utf8.html\n///\n/// # Examples\n///\n/// This error type’s methods can be used to create functionality\n/// similar to `String::from_utf8_lossy` without allocating heap memory:\n///\n/// ```\n/// fn from_utf8_lossy<F>(mut input: &[u8], mut push: F) where F: FnMut(&str) {\n///     loop {\n///         match std::str::from_utf8(input) {\n///             Ok(valid) => {\n///                 push(valid);\n///                 break\n///             }\n///             Err(error) => {\n///                 let (valid, after_valid) = input.split_at(error.valid_up_to());\n///                 unsafe {\n///                     push(std::str::from_utf8_unchecked(valid))\n///                 }\n///                 push(\"\\u{FFFD}\");\n///\n///                 if let Some(invalid_sequence_length) = error.error_len() {\n///                     input = &after_valid[invalid_sequence_length..]\n///                 } else {\n///                     break\n///                 }\n///             }\n///         }\n///     }\n/// }\n/// ```\n#[derive(Copy, Eq, PartialEq, Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Utf8Error {\n    valid_up_to: usize,\n    error_len: Option<u8>,\n}\n\nimpl Utf8Error {\n    /// Returns the index in the given string up to which valid UTF-8 was\n    /// verified.\n    ///\n    /// It is the maximum index such that `from_utf8(&input[..index])`\n    /// would return `Ok(_)`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::str;\n    ///\n    /// // some invalid bytes, in a vector\n    /// let sparkle_heart = vec![0, 159, 146, 150];\n    ///\n    /// // std::str::from_utf8 returns a Utf8Error\n    /// let error = str::from_utf8(&sparkle_heart).unwrap_err();\n    ///\n    /// // the second byte is invalid here\n    /// assert_eq!(1, error.valid_up_to());\n    /// ```\n    #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n    pub fn valid_up_to(&self) -> usize {\n}\n\n    /// Provides more information about the failure:\n    ///\n    /// * `None`: the end of the input was reached unexpectedly.\n    ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n    ///   If a byte stream (such as a file or a network socket) is being decoded incrementally,\n    ///   this could be a valid `char` whose UTF-8 byte sequence is spanning multiple chunks.\n    ///\n    /// * `Some(len)`: an unexpected byte was encountered.\n    ///   The length provided is that of the invalid byte sequence\n    ///   that starts at the index given by `valid_up_to()`.\n    ///   Decoding should resume after that sequence\n    ///   (after inserting a [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD]) in case of\n    ///   lossy decoding.\n    ///\n    /// [U+FFFD]: ../../std/char/constant.REPLACEMENT_CHARACTER.html\n    #[stable(feature = \"utf8_error_error_len\", since = \"1.20.0\")]\n    pub fn error_len(&self) -> Option<usize> {\n}\n}\n\n/// Converts a slice of bytes to a string slice.\n///\n/// A string slice ([`&str`]) is made of bytes ([`u8`]), and a byte slice\n/// ([`&[u8]`][byteslice]) is made of bytes, so this function converts between\n/// the two. Not all byte slices are valid string slices, however: [`&str`] requires\n/// that it is valid UTF-8. `from_utf8()` checks to ensure that the bytes are valid\n/// UTF-8, and then does the conversion.\n///\n/// [`&str`]: ../../std/primitive.str.html\n/// [`u8`]: ../../std/primitive.u8.html\n/// [byteslice]: ../../std/primitive.slice.html\n///\n/// If you are sure that the byte slice is valid UTF-8, and you don't want to\n/// incur the overhead of the validity check, there is an unsafe version of\n/// this function, [`from_utf8_unchecked`][fromutf8u], which has the same\n/// behavior but skips the check.\n///\n/// [fromutf8u]: fn.from_utf8_unchecked.html\n///\n/// If you need a `String` instead of a `&str`, consider\n/// [`String::from_utf8`][string].\n///\n/// [string]: ../../std/string/struct.String.html#method.from_utf8\n///\n/// Because you can stack-allocate a `[u8; N]`, and you can take a\n/// [`&[u8]`][byteslice] of it, this function is one way to have a\n/// stack-allocated string. There is an example of this in the\n/// examples section below.\n///\n/// [byteslice]: ../../std/primitive.slice.html\n///\n/// # Errors\n///\n/// Returns `Err` if the slice is not UTF-8 with a description as to why the\n/// provided slice is not UTF-8.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::str;\n///\n/// // some bytes, in a vector\n/// let sparkle_heart = vec![240, 159, 146, 150];\n///\n/// // We know these bytes are valid, so just use `unwrap()`.\n/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n///\n/// assert_eq!(\"💖\", sparkle_heart);\n/// ```\n///\n/// Incorrect bytes:\n///\n/// ```\n/// use std::str;\n///\n/// // some invalid bytes, in a vector\n/// let sparkle_heart = vec![0, 159, 146, 150];\n///\n/// assert!(str::from_utf8(&sparkle_heart).is_err());\n/// ```\n///\n/// See the docs for [`Utf8Error`][error] for more details on the kinds of\n/// errors that can be returned.\n///\n/// [error]: struct.Utf8Error.html\n///\n/// A \"stack allocated string\":\n///\n/// ```\n/// use std::str;\n///\n/// // some bytes, in a stack-allocated array\n/// let sparkle_heart = [240, 159, 146, 150];\n///\n/// // We know these bytes are valid, so just use `unwrap()`.\n/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n///\n/// assert_eq!(\"💖\", sparkle_heart);\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n}\n\n/// Converts a mutable slice of bytes to a mutable string slice.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::str;\n///\n/// // \"Hello, Rust!\" as a mutable vector\n/// let mut hellorust = vec![72, 101, 108, 108, 111, 44, 32, 82, 117, 115, 116, 33];\n///\n/// // As we know these bytes are valid, we can use `unwrap()`\n/// let outstr = str::from_utf8_mut(&mut hellorust).unwrap();\n///\n/// assert_eq!(\"Hello, Rust!\", outstr);\n/// ```\n///\n/// Incorrect bytes:\n///\n/// ```\n/// use std::str;\n///\n/// // Some invalid bytes in a mutable vector\n/// let mut invalid = vec![128, 223];\n///\n/// assert!(str::from_utf8_mut(&mut invalid).is_err());\n/// ```\n/// See the docs for [`Utf8Error`][error] for more details on the kinds of\n/// errors that can be returned.\n///\n/// [error]: struct.Utf8Error.html\n#[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\npub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n}\n\n/// Converts a slice of bytes to a string slice without checking\n/// that the string contains valid UTF-8.\n///\n/// See the safe version, [`from_utf8`][fromutf8], for more information.\n///\n/// [fromutf8]: fn.from_utf8.html\n///\n/// # Safety\n///\n/// This function is unsafe because it does not check that the bytes passed to\n/// it are valid UTF-8. If this constraint is violated, undefined behavior\n/// results, as the rest of Rust assumes that [`&str`]s are valid UTF-8.\n///\n/// [`&str`]: ../../std/primitive.str.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::str;\n///\n/// // some bytes, in a vector\n/// let sparkle_heart = vec![240, 159, 146, 150];\n///\n/// let sparkle_heart = unsafe {\n///     str::from_utf8_unchecked(&sparkle_heart)\n/// };\n///\n/// assert_eq!(\"💖\", sparkle_heart);\n/// ```\n#[inline]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n}\n\n/// Converts a slice of bytes to a string slice without checking\n/// that the string contains valid UTF-8; mutable version.\n///\n/// See the immutable version, [`from_utf8_unchecked()`][fromutf8], for more information.\n///\n/// [fromutf8]: fn.from_utf8_unchecked.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::str;\n///\n/// let mut heart = vec![240, 159, 146, 150];\n/// let heart = unsafe { str::from_utf8_unchecked_mut(&mut heart) };\n///\n/// assert_eq!(\"💖\", heart);\n/// ```\n#[inline]\n#[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\npub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for Utf8Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/*\nSection: Iterators\n*/\n\n/// An iterator over the [`char`]s of a string slice.\n///\n/// [`char`]: ../../std/primitive.char.html\n///\n/// This struct is created by the [`chars`] method on [`str`].\n/// See its documentation for more.\n///\n/// [`chars`]: ../../std/primitive.str.html#method.chars\n/// [`str`]: ../../std/primitive.str.html\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Chars<'a> {\n    iter: slice::Iter<'a, u8>,\n}\n\n/// Returns the initial codepoint accumulator for the first byte.\n/// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n/// for width 3, and 3 bits for width 4.\n#[inline]\nfn utf8_first_byte(byte: u8, width: u32) -> u32 {\n}\n\n/// Returns the value of `ch` updated with continuation byte `byte`.\n#[inline]\nfn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n}\n\n/// Checks whether the byte is a UTF-8 continuation byte (i.e., starts with the\n/// bits `10`).\n#[inline]\nfn utf8_is_cont_byte(byte: u8) -> bool {\n}\n\n#[inline]\nfn unwrap_or_0(opt: Option<&u8>) -> u8 {\n}\n\n/// Reads the next code point out of a byte iterator (assuming a\n/// UTF-8-like encoding).\n#[unstable(feature = \"str_internals\", issue = \"none\")]\n#[inline]\npub fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n}\n\n/// Reads the last code point out of a byte iterator (assuming a\n/// UTF-8-like encoding).\n#[inline]\nfn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>\nwhere\n    I: DoubleEndedIterator<Item = &'a u8>,\n{\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for Chars<'a> {\n    type Item = char;\n\n    #[inline]\n    fn next(&mut self) -> Option<char> {\n}\n\n    #[inline]\n    fn count(self) -> usize {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn last(mut self) -> Option<char> {\n}\n}\n\n#[stable(feature = \"chars_debug_impl\", since = \"1.38.0\")]\nimpl fmt::Debug for Chars<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> DoubleEndedIterator for Chars<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<char> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for Chars<'_> {}\n\nimpl<'a> Chars<'a> {\n    /// Views the underlying data as a subslice of the original data.\n    ///\n    /// This has the same lifetime as the original slice, and so the\n    /// iterator can continue to be used while this exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut chars = \"abc\".chars();\n    ///\n    /// assert_eq!(chars.as_str(), \"abc\");\n    /// chars.next();\n    /// assert_eq!(chars.as_str(), \"bc\");\n    /// chars.next();\n    /// chars.next();\n    /// assert_eq!(chars.as_str(), \"\");\n    /// ```\n    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n    #[inline]\n    pub fn as_str(&self) -> &'a str {\n}\n}\n\n/// An iterator over the [`char`]s of a string slice, and their positions.\n///\n/// [`char`]: ../../std/primitive.char.html\n///\n/// This struct is created by the [`char_indices`] method on [`str`].\n/// See its documentation for more.\n///\n/// [`char_indices`]: ../../std/primitive.str.html#method.char_indices\n/// [`str`]: ../../std/primitive.str.html\n#[derive(Clone, Debug)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct CharIndices<'a> {\n    front_offset: usize,\n    iter: Chars<'a>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Iterator for CharIndices<'a> {\n    type Item = (usize, char);\n\n    #[inline]\n    fn next(&mut self) -> Option<(usize, char)> {\n}\n\n    #[inline]\n    fn count(self) -> usize {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn last(mut self) -> Option<(usize, char)> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> DoubleEndedIterator for CharIndices<'a> {\n    #[inline]\n    fn next_back(&mut self) -> Option<(usize, char)> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for CharIndices<'_> {}\n\nimpl<'a> CharIndices<'a> {\n    /// Views the underlying data as a subslice of the original data.\n    ///\n    /// This has the same lifetime as the original slice, and so the\n    /// iterator can continue to be used while this exists.\n    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n    #[inline]\n    pub fn as_str(&self) -> &'a str {\n}\n}\n\n/// An iterator over the bytes of a string slice.\n///\n/// This struct is created by the [`bytes`] method on [`str`].\n/// See its documentation for more.\n///\n/// [`bytes`]: ../../std/primitive.str.html#method.bytes\n/// [`str`]: ../../std/primitive.str.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone, Debug)]\npub struct Bytes<'a>(Cloned<slice::Iter<'a, u8>>);\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Iterator for Bytes<'_> {\n    type Item = u8;\n\n    #[inline]\n    fn next(&mut self) -> Option<u8> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn count(self) -> usize {\n}\n\n    #[inline]\n    fn last(self) -> Option<Self::Item> {\n}\n\n    #[inline]\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n}\n\n    #[inline]\n    fn all<F>(&mut self, f: F) -> bool\n    where\n        F: FnMut(Self::Item) -> bool,\n    {\n}\n\n    #[inline]\n    fn any<F>(&mut self, f: F) -> bool\n    where\n        F: FnMut(Self::Item) -> bool,\n    {\n}\n\n    #[inline]\n    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n    where\n        P: FnMut(&Self::Item) -> bool,\n    {\n}\n\n    #[inline]\n    fn position<P>(&mut self, predicate: P) -> Option<usize>\n    where\n        P: FnMut(Self::Item) -> bool,\n    {\n}\n\n    #[inline]\n    fn rposition<P>(&mut self, predicate: P) -> Option<usize>\n    where\n        P: FnMut(Self::Item) -> bool,\n    {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl DoubleEndedIterator for Bytes<'_> {\n    #[inline]\n    fn next_back(&mut self) -> Option<u8> {\n}\n\n    #[inline]\n    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n}\n\n    #[inline]\n    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n    where\n        P: FnMut(&Self::Item) -> bool,\n    {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ExactSizeIterator for Bytes<'_> {\n    #[inline]\n    fn len(&self) -> usize {\n}\n\n    #[inline]\n    fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for Bytes<'_> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl TrustedLen for Bytes<'_> {}}\npub mod time {\n#![stable(feature = \"duration_core\", since = \"1.25.0\")]\n\n//! Temporal quantification.\n//!\n//! Example:\n//!\n//! ```\n//! use std::time::Duration;\n//!\n//! let five_seconds = Duration::new(5, 0);\n//! // both declarations are equivalent\n//! assert_eq!(Duration::new(5, 0), Duration::from_secs(5));\n//! ```\n\nuse crate::iter::Sum;\nuse crate::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\nuse crate::{fmt, u64};\n\nconst NANOS_PER_SEC: u32 = 1_000_000_000;\nconst NANOS_PER_MILLI: u32 = 1_000_000;\nconst NANOS_PER_MICRO: u32 = 1_000;\nconst MILLIS_PER_SEC: u64 = 1_000;\nconst MICROS_PER_SEC: u64 = 1_000_000;\n\n/// A `Duration` type to represent a span of time, typically used for system\n/// timeouts.\n///\n/// Each `Duration` is composed of a whole number of seconds and a fractional part\n/// represented in nanoseconds. If the underlying system does not support\n/// nanosecond-level precision, APIs binding a system timeout will typically round up\n/// the number of nanoseconds.\n///\n/// `Duration`s implement many common traits, including [`Add`], [`Sub`], and other\n/// [`ops`] traits.\n///\n/// [`Add`]: ../../std/ops/trait.Add.html\n/// [`Sub`]: ../../std/ops/trait.Sub.html\n/// [`ops`]: ../../std/ops/index.html\n///\n/// # Examples\n///\n/// ```\n/// use std::time::Duration;\n///\n/// let five_seconds = Duration::new(5, 0);\n/// let five_seconds_and_five_nanos = five_seconds + Duration::new(0, 5);\n///\n/// assert_eq!(five_seconds_and_five_nanos.as_secs(), 5);\n/// assert_eq!(five_seconds_and_five_nanos.subsec_nanos(), 5);\n///\n/// let ten_millis = Duration::from_millis(10);\n/// ```\n#[stable(feature = \"duration\", since = \"1.3.0\")]\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]\npub struct Duration {\n    secs: u64,\n    nanos: u32, // Always 0 <= nanos < NANOS_PER_SEC\n}\n\nimpl Duration {\n    /// The duration of one second.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(duration_constants)]\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::SECOND, Duration::from_secs(1));\n    /// ```\n    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n    pub const SECOND: Duration = Duration::from_secs(1);\n\n    /// The duration of one millisecond.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(duration_constants)]\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::MILLISECOND, Duration::from_millis(1));\n    /// ```\n    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n    pub const MILLISECOND: Duration = Duration::from_millis(1);\n\n    /// The duration of one microsecond.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(duration_constants)]\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::MICROSECOND, Duration::from_micros(1));\n    /// ```\n    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n    pub const MICROSECOND: Duration = Duration::from_micros(1);\n\n    /// The duration of one nanosecond.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(duration_constants)]\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::NANOSECOND, Duration::from_nanos(1));\n    /// ```\n    #[unstable(feature = \"duration_constants\", issue = \"57391\")]\n    pub const NANOSECOND: Duration = Duration::from_nanos(1);\n\n    /// Creates a new `Duration` from the specified number of whole seconds and\n    /// additional nanoseconds.\n    ///\n    /// If the number of nanoseconds is greater than 1 billion (the number of\n    /// nanoseconds in a second), then it will carry over into the seconds provided.\n    ///\n    /// # Panics\n    ///\n    /// This constructor will panic if the carry from the nanoseconds overflows\n    /// the seconds counter.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let five_seconds = Duration::new(5, 0);\n    /// ```\n    #[stable(feature = \"duration\", since = \"1.3.0\")]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub fn new(secs: u64, nanos: u32) -> Duration {\n}\n\n    /// Creates a new `Duration` from the specified number of whole seconds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_secs(5);\n    ///\n    /// assert_eq!(5, duration.as_secs());\n    /// assert_eq!(0, duration.subsec_nanos());\n    /// ```\n    #[stable(feature = \"duration\", since = \"1.3.0\")]\n    #[inline]\n    #[rustc_promotable]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_secs(secs: u64) -> Duration {\n}\n\n    /// Creates a new `Duration` from the specified number of milliseconds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_millis(2569);\n    ///\n    /// assert_eq!(2, duration.as_secs());\n    /// assert_eq!(569_000_000, duration.subsec_nanos());\n    /// ```\n    #[stable(feature = \"duration\", since = \"1.3.0\")]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_millis(millis: u64) -> Duration {\n}\n\n    /// Creates a new `Duration` from the specified number of microseconds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_micros(1_000_002);\n    ///\n    /// assert_eq!(1, duration.as_secs());\n    /// assert_eq!(2000, duration.subsec_nanos());\n    /// ```\n    #[stable(feature = \"duration_from_micros\", since = \"1.27.0\")]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_micros(micros: u64) -> Duration {\n}\n\n    /// Creates a new `Duration` from the specified number of nanoseconds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_nanos(1_000_000_123);\n    ///\n    /// assert_eq!(1, duration.as_secs());\n    /// assert_eq!(123, duration.subsec_nanos());\n    /// ```\n    #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n    #[inline]\n    #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]\n    pub const fn from_nanos(nanos: u64) -> Duration {\n}\n\n    /// Returns the number of _whole_ seconds contained by this `Duration`.\n    ///\n    /// The returned value does not include the fractional (nanosecond) part of the\n    /// duration, which can be obtained using [`subsec_nanos`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::new(5, 730023852);\n    /// assert_eq!(duration.as_secs(), 5);\n    /// ```\n    ///\n    /// To determine the total number of seconds represented by the `Duration`,\n    /// use `as_secs` in combination with [`subsec_nanos`]:\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::new(5, 730023852);\n    ///\n    /// assert_eq!(5.730023852,\n    ///            duration.as_secs() as f64\n    ///            + duration.subsec_nanos() as f64 * 1e-9);\n    /// ```\n    ///\n    /// [`subsec_nanos`]: #method.subsec_nanos\n    #[stable(feature = \"duration\", since = \"1.3.0\")]\n    #[rustc_const_stable(feature = \"duration\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn as_secs(&self) -> u64 {\n}\n\n    /// Returns the fractional part of this `Duration`, in whole milliseconds.\n    ///\n    /// This method does **not** return the length of the duration when\n    /// represented by milliseconds. The returned number always represents a\n    /// fractional portion of a second (i.e., it is less than one thousand).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_millis(5432);\n    /// assert_eq!(duration.as_secs(), 5);\n    /// assert_eq!(duration.subsec_millis(), 432);\n    /// ```\n    #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n    #[rustc_const_stable(feature = \"duration_extras\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn subsec_millis(&self) -> u32 {\n}\n\n    /// Returns the fractional part of this `Duration`, in whole microseconds.\n    ///\n    /// This method does **not** return the length of the duration when\n    /// represented by microseconds. The returned number always represents a\n    /// fractional portion of a second (i.e., it is less than one million).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_micros(1_234_567);\n    /// assert_eq!(duration.as_secs(), 1);\n    /// assert_eq!(duration.subsec_micros(), 234_567);\n    /// ```\n    #[stable(feature = \"duration_extras\", since = \"1.27.0\")]\n    #[rustc_const_stable(feature = \"duration_extras\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn subsec_micros(&self) -> u32 {\n}\n\n    /// Returns the fractional part of this `Duration`, in nanoseconds.\n    ///\n    /// This method does **not** return the length of the duration when\n    /// represented by nanoseconds. The returned number always represents a\n    /// fractional portion of a second (i.e., it is less than one billion).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::from_millis(5010);\n    /// assert_eq!(duration.as_secs(), 5);\n    /// assert_eq!(duration.subsec_nanos(), 10_000_000);\n    /// ```\n    #[stable(feature = \"duration\", since = \"1.3.0\")]\n    #[rustc_const_stable(feature = \"duration\", since = \"1.32.0\")]\n    #[inline]\n    pub const fn subsec_nanos(&self) -> u32 {\n}\n\n    /// Returns the total number of whole milliseconds contained by this `Duration`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::new(5, 730023852);\n    /// assert_eq!(duration.as_millis(), 5730);\n    /// ```\n    #[stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n    #[rustc_const_stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n    #[inline]\n    pub const fn as_millis(&self) -> u128 {\n}\n\n    /// Returns the total number of whole microseconds contained by this `Duration`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::new(5, 730023852);\n    /// assert_eq!(duration.as_micros(), 5730023);\n    /// ```\n    #[stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n    #[rustc_const_stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n    #[inline]\n    pub const fn as_micros(&self) -> u128 {\n}\n\n    /// Returns the total number of nanoseconds contained by this `Duration`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let duration = Duration::new(5, 730023852);\n    /// assert_eq!(duration.as_nanos(), 5730023852);\n    /// ```\n    #[stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n    #[rustc_const_stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n    #[inline]\n    pub const fn as_nanos(&self) -> u128 {\n}\n\n    /// Checked `Duration` addition. Computes `self + other`, returning [`None`]\n    /// if overflow occurred.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)), Some(Duration::new(0, 1)));\n    /// assert_eq!(Duration::new(1, 0).checked_add(Duration::new(std::u64::MAX, 0)), None);\n    /// ```\n    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n    #[inline]\n    pub fn checked_add(self, rhs: Duration) -> Option<Duration> {\n}\n\n    /// Checked `Duration` subtraction. Computes `self - other`, returning [`None`]\n    /// if the result would be negative or if overflow occurred.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::new(0, 1).checked_sub(Duration::new(0, 0)), Some(Duration::new(0, 1)));\n    /// assert_eq!(Duration::new(0, 0).checked_sub(Duration::new(0, 1)), None);\n    /// ```\n    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n    #[inline]\n    pub fn checked_sub(self, rhs: Duration) -> Option<Duration> {\n}\n\n    /// Checked `Duration` multiplication. Computes `self * other`, returning\n    /// [`None`] if overflow occurred.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::new(0, 500_000_001).checked_mul(2), Some(Duration::new(1, 2)));\n    /// assert_eq!(Duration::new(std::u64::MAX - 1, 0).checked_mul(2), None);\n    /// ```\n    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n    #[inline]\n    pub fn checked_mul(self, rhs: u32) -> Option<Duration> {\n}\n\n    /// Checked `Duration` division. Computes `self / other`, returning [`None`]\n    /// if `other == 0`.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// assert_eq!(Duration::new(2, 0).checked_div(2), Some(Duration::new(1, 0)));\n    /// assert_eq!(Duration::new(1, 0).checked_div(2), Some(Duration::new(0, 500_000_000)));\n    /// assert_eq!(Duration::new(2, 0).checked_div(0), None);\n    /// ```\n    #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n    #[inline]\n    pub fn checked_div(self, rhs: u32) -> Option<Duration> {\n}\n\n    /// Returns the number of seconds contained by this `Duration` as `f64`.\n    ///\n    /// The returned value does include the fractional (nanosecond) part of the duration.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::new(2, 700_000_000);\n    /// assert_eq!(dur.as_secs_f64(), 2.7);\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    pub fn as_secs_f64(&self) -> f64 {\n}\n\n    /// Returns the number of seconds contained by this `Duration` as `f32`.\n    ///\n    /// The returned value does include the fractional (nanosecond) part of the duration.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::new(2, 700_000_000);\n    /// assert_eq!(dur.as_secs_f32(), 2.7);\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    pub fn as_secs_f32(&self) -> f32 {\n}\n\n    /// Creates a new `Duration` from the specified number of seconds represented\n    /// as `f64`.\n    ///\n    /// # Panics\n    /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::from_secs_f64(2.7);\n    /// assert_eq!(dur, Duration::new(2, 700_000_000));\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    pub fn from_secs_f64(secs: f64) -> Duration {\n}\n\n    /// Creates a new `Duration` from the specified number of seconds represented\n    /// as `f32`.\n    ///\n    /// # Panics\n    /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::from_secs_f32(2.7);\n    /// assert_eq!(dur, Duration::new(2, 700_000_000));\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    pub fn from_secs_f32(secs: f32) -> Duration {\n}\n\n    /// Multiplies `Duration` by `f64`.\n    ///\n    /// # Panics\n    /// This method will panic if result is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::new(2, 700_000_000);\n    /// assert_eq!(dur.mul_f64(3.14), Duration::new(8, 478_000_000));\n    /// assert_eq!(dur.mul_f64(3.14e5), Duration::new(847_800, 0));\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    pub fn mul_f64(self, rhs: f64) -> Duration {\n}\n\n    /// Multiplies `Duration` by `f32`.\n    ///\n    /// # Panics\n    /// This method will panic if result is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::new(2, 700_000_000);\n    /// // note that due to rounding errors result is slightly different\n    /// // from 8.478 and 847800.0\n    /// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_640));\n    /// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847799, 969_120_256));\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    pub fn mul_f32(self, rhs: f32) -> Duration {\n}\n\n    /// Divide `Duration` by `f64`.\n    ///\n    /// # Panics\n    /// This method will panic if result is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::new(2, 700_000_000);\n    /// assert_eq!(dur.div_f64(3.14), Duration::new(0, 859_872_611));\n    /// // note that truncation is used, not rounding\n    /// assert_eq!(dur.div_f64(3.14e5), Duration::new(0, 8_598));\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    pub fn div_f64(self, rhs: f64) -> Duration {\n}\n\n    /// Divide `Duration` by `f32`.\n    ///\n    /// # Panics\n    /// This method will panic if result is not finite, negative or overflows `Duration`.\n    ///\n    /// # Examples\n    /// ```\n    /// use std::time::Duration;\n    ///\n    /// let dur = Duration::new(2, 700_000_000);\n    /// // note that due to rounding errors result is slightly\n    /// // different from 0.859_872_611\n    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_576));\n    /// // note that truncation is used, not rounding\n    /// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_598));\n    /// ```\n    #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n    #[inline]\n    pub fn div_f32(self, rhs: f32) -> Duration {\n}\n\n    /// Divide `Duration` by `Duration` and return `f64`.\n    ///\n    /// # Examples\n    /// ```\n    /// #![feature(div_duration)]\n    /// use std::time::Duration;\n    ///\n    /// let dur1 = Duration::new(2, 700_000_000);\n    /// let dur2 = Duration::new(5, 400_000_000);\n    /// assert_eq!(dur1.div_duration_f64(dur2), 0.5);\n    /// ```\n    #[unstable(feature = \"div_duration\", issue = \"63139\")]\n    #[inline]\n    pub fn div_duration_f64(self, rhs: Duration) -> f64 {\n}\n\n    /// Divide `Duration` by `Duration` and return `f32`.\n    ///\n    /// # Examples\n    /// ```\n    /// #![feature(div_duration)]\n    /// use std::time::Duration;\n    ///\n    /// let dur1 = Duration::new(2, 700_000_000);\n    /// let dur2 = Duration::new(5, 400_000_000);\n    /// assert_eq!(dur1.div_duration_f32(dur2), 0.5);\n    /// ```\n    #[unstable(feature = \"div_duration\", issue = \"63139\")]\n    #[inline]\n    pub fn div_duration_f32(self, rhs: Duration) -> f32 {\n}\n}\n\n#[stable(feature = \"duration\", since = \"1.3.0\")]\nimpl Add for Duration {\n    type Output = Duration;\n\n    fn add(self, rhs: Duration) -> Duration {\n}\n}\n\n#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\nimpl AddAssign for Duration {\n    fn add_assign(&mut self, rhs: Duration) {\n}\n}\n\n#[stable(feature = \"duration\", since = \"1.3.0\")]\nimpl Sub for Duration {\n    type Output = Duration;\n\n    fn sub(self, rhs: Duration) -> Duration {\n}\n}\n\n#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\nimpl SubAssign for Duration {\n    fn sub_assign(&mut self, rhs: Duration) {\n}\n}\n\n#[stable(feature = \"duration\", since = \"1.3.0\")]\nimpl Mul<u32> for Duration {\n    type Output = Duration;\n\n    fn mul(self, rhs: u32) -> Duration {\n}\n}\n\n#[stable(feature = \"symmetric_u32_duration_mul\", since = \"1.31.0\")]\nimpl Mul<Duration> for u32 {\n    type Output = Duration;\n\n    fn mul(self, rhs: Duration) -> Duration {\n}\n}\n\n#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\nimpl MulAssign<u32> for Duration {\n    fn mul_assign(&mut self, rhs: u32) {\n}\n}\n\n#[stable(feature = \"duration\", since = \"1.3.0\")]\nimpl Div<u32> for Duration {\n    type Output = Duration;\n\n    fn div(self, rhs: u32) -> Duration {\n}\n}\n\n#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\nimpl DivAssign<u32> for Duration {\n    fn div_assign(&mut self, rhs: u32) {\n}\n}\n\nmacro_rules! sum_durations {\n    ($iter:expr) => {{\n        let mut total_secs: u64 = 0;\n        let mut total_nanos: u64 = 0;\n\n        for entry in $iter {\n            total_secs =\n                total_secs.checked_add(entry.secs).expect(\"overflow in iter::sum over durations\");\n            total_nanos = match total_nanos.checked_add(entry.nanos as u64) {\n                Some(n) => n,\n                None => {\n                    total_secs = total_secs\n                        .checked_add(total_nanos / NANOS_PER_SEC as u64)\n                        .expect(\"overflow in iter::sum over durations\");\n                    (total_nanos % NANOS_PER_SEC as u64) + entry.nanos as u64\n                }\n            };\n        }\n        total_secs = total_secs\n            .checked_add(total_nanos / NANOS_PER_SEC as u64)\n            .expect(\"overflow in iter::sum over durations\");\n        total_nanos = total_nanos % NANOS_PER_SEC as u64;\n        Duration { secs: total_secs, nanos: total_nanos as u32 }\n    }};\n}\n\n#[stable(feature = \"duration_sum\", since = \"1.16.0\")]\nimpl Sum for Duration {\n    fn sum<I: Iterator<Item = Duration>>(iter: I) -> Duration {\n}\n}\n\n#[stable(feature = \"duration_sum\", since = \"1.16.0\")]\nimpl<'a> Sum<&'a Duration> for Duration {\n    fn sum<I: Iterator<Item = &'a Duration>>(iter: I) -> Duration {\n}\n}\n\n#[stable(feature = \"duration_debug_impl\", since = \"1.27.0\")]\nimpl fmt::Debug for Duration {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n}\n\npub mod unicode {\n#![unstable(feature = \"unicode_internals\", issue = \"none\")]\n#![allow(missing_docs)]\n\npub(crate) mod printable {\n// NOTE: The following code was generated by \"src/libcore/unicode/printable.py\",\n//       do not edit directly!\n\nfn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8], normal: &[u8]) -> bool {\n}\n\npub(crate) fn is_printable(x: char) -> bool {\n}\n\n#[rustfmt::skip]\nconst SINGLETONS0U: &[(u8, u8)] = &[\n    (0x00, 1),\n    (0x03, 5),\n    (0x05, 6),\n    (0x06, 3),\n    (0x07, 6),\n    (0x08, 8),\n    (0x09, 17),\n    (0x0a, 28),\n    (0x0b, 25),\n    (0x0c, 20),\n    (0x0d, 18),\n    (0x0e, 13),\n    (0x0f, 4),\n    (0x10, 3),\n    (0x12, 18),\n    (0x13, 9),\n    (0x16, 1),\n    (0x17, 5),\n    (0x18, 2),\n    (0x19, 3),\n    (0x1a, 7),\n    (0x1c, 2),\n    (0x1d, 1),\n    (0x1f, 22),\n    (0x20, 3),\n    (0x2b, 4),\n    (0x2c, 2),\n    (0x2d, 11),\n    (0x2e, 1),\n    (0x30, 3),\n    (0x31, 2),\n    (0x32, 1),\n    (0xa7, 2),\n    (0xa9, 2),\n    (0xaa, 4),\n    (0xab, 8),\n    (0xfa, 2),\n    (0xfb, 5),\n    (0xfd, 4),\n    (0xfe, 3),\n    (0xff, 9),\n];\n#[rustfmt::skip]\nconst SINGLETONS0L: &[u8] = &[\n    0xad, 0x78, 0x79, 0x8b, 0x8d, 0xa2, 0x30, 0x57,\n    0x58, 0x8b, 0x8c, 0x90, 0x1c, 0x1d, 0xdd, 0x0e,\n    0x0f, 0x4b, 0x4c, 0xfb, 0xfc, 0x2e, 0x2f, 0x3f,\n    0x5c, 0x5d, 0x5f, 0xb5, 0xe2, 0x84, 0x8d, 0x8e,\n    0x91, 0x92, 0xa9, 0xb1, 0xba, 0xbb, 0xc5, 0xc6,\n    0xc9, 0xca, 0xde, 0xe4, 0xe5, 0xff, 0x00, 0x04,\n    0x11, 0x12, 0x29, 0x31, 0x34, 0x37, 0x3a, 0x3b,\n    0x3d, 0x49, 0x4a, 0x5d, 0x84, 0x8e, 0x92, 0xa9,\n    0xb1, 0xb4, 0xba, 0xbb, 0xc6, 0xca, 0xce, 0xcf,\n    0xe4, 0xe5, 0x00, 0x04, 0x0d, 0x0e, 0x11, 0x12,\n    0x29, 0x31, 0x34, 0x3a, 0x3b, 0x45, 0x46, 0x49,\n    0x4a, 0x5e, 0x64, 0x65, 0x84, 0x91, 0x9b, 0x9d,\n    0xc9, 0xce, 0xcf, 0x0d, 0x11, 0x29, 0x45, 0x49,\n    0x57, 0x64, 0x65, 0x8d, 0x91, 0xa9, 0xb4, 0xba,\n    0xbb, 0xc5, 0xc9, 0xdf, 0xe4, 0xe5, 0xf0, 0x04,\n    0x0d, 0x11, 0x45, 0x49, 0x64, 0x65, 0x80, 0x81,\n    0x84, 0xb2, 0xbc, 0xbe, 0xbf, 0xd5, 0xd7, 0xf0,\n    0xf1, 0x83, 0x85, 0x8b, 0xa4, 0xa6, 0xbe, 0xbf,\n    0xc5, 0xc7, 0xce, 0xcf, 0xda, 0xdb, 0x48, 0x98,\n    0xbd, 0xcd, 0xc6, 0xce, 0xcf, 0x49, 0x4e, 0x4f,\n    0x57, 0x59, 0x5e, 0x5f, 0x89, 0x8e, 0x8f, 0xb1,\n    0xb6, 0xb7, 0xbf, 0xc1, 0xc6, 0xc7, 0xd7, 0x11,\n    0x16, 0x17, 0x5b, 0x5c, 0xf6, 0xf7, 0xfe, 0xff,\n    0x80, 0x0d, 0x6d, 0x71, 0xde, 0xdf, 0x0e, 0x0f,\n    0x1f, 0x6e, 0x6f, 0x1c, 0x1d, 0x5f, 0x7d, 0x7e,\n    0xae, 0xaf, 0xbb, 0xbc, 0xfa, 0x16, 0x17, 0x1e,\n    0x1f, 0x46, 0x47, 0x4e, 0x4f, 0x58, 0x5a, 0x5c,\n    0x5e, 0x7e, 0x7f, 0xb5, 0xc5, 0xd4, 0xd5, 0xdc,\n    0xf0, 0xf1, 0xf5, 0x72, 0x73, 0x8f, 0x74, 0x75,\n    0x96, 0x97, 0x2f, 0x5f, 0x26, 0x2e, 0x2f, 0xa7,\n    0xaf, 0xb7, 0xbf, 0xc7, 0xcf, 0xd7, 0xdf, 0x9a,\n    0x40, 0x97, 0x98, 0x30, 0x8f, 0x1f, 0xc0, 0xc1,\n    0xce, 0xff, 0x4e, 0x4f, 0x5a, 0x5b, 0x07, 0x08,\n    0x0f, 0x10, 0x27, 0x2f, 0xee, 0xef, 0x6e, 0x6f,\n    0x37, 0x3d, 0x3f, 0x42, 0x45, 0x90, 0x91, 0xfe,\n    0xff, 0x53, 0x67, 0x75, 0xc8, 0xc9, 0xd0, 0xd1,\n    0xd8, 0xd9, 0xe7, 0xfe, 0xff,\n];\n#[rustfmt::skip]\nconst SINGLETONS1U: &[(u8, u8)] = &[\n    (0x00, 6),\n    (0x01, 1),\n    (0x03, 1),\n    (0x04, 2),\n    (0x08, 8),\n    (0x09, 2),\n    (0x0a, 5),\n    (0x0b, 2),\n    (0x10, 1),\n    (0x11, 4),\n    (0x12, 5),\n    (0x13, 17),\n    (0x14, 2),\n    (0x15, 2),\n    (0x17, 2),\n    (0x19, 4),\n    (0x1c, 5),\n    (0x1d, 8),\n    (0x24, 1),\n    (0x6a, 3),\n    (0x6b, 2),\n    (0xbc, 2),\n    (0xd1, 2),\n    (0xd4, 12),\n    (0xd5, 9),\n    (0xd6, 2),\n    (0xd7, 2),\n    (0xda, 1),\n    (0xe0, 5),\n    (0xe1, 2),\n    (0xe8, 2),\n    (0xee, 32),\n    (0xf0, 4),\n    (0xf9, 6),\n    (0xfa, 2),\n];\n#[rustfmt::skip]\nconst SINGLETONS1L: &[u8] = &[\n    0x0c, 0x27, 0x3b, 0x3e, 0x4e, 0x4f, 0x8f, 0x9e,\n    0x9e, 0x9f, 0x06, 0x07, 0x09, 0x36, 0x3d, 0x3e,\n    0x56, 0xf3, 0xd0, 0xd1, 0x04, 0x14, 0x18, 0x36,\n    0x37, 0x56, 0x57, 0xbd, 0x35, 0xce, 0xcf, 0xe0,\n    0x12, 0x87, 0x89, 0x8e, 0x9e, 0x04, 0x0d, 0x0e,\n    0x11, 0x12, 0x29, 0x31, 0x34, 0x3a, 0x45, 0x46,\n    0x49, 0x4a, 0x4e, 0x4f, 0x64, 0x65, 0x5a, 0x5c,\n    0xb6, 0xb7, 0x1b, 0x1c, 0xa8, 0xa9, 0xd8, 0xd9,\n    0x09, 0x37, 0x90, 0x91, 0xa8, 0x07, 0x0a, 0x3b,\n    0x3e, 0x66, 0x69, 0x8f, 0x92, 0x6f, 0x5f, 0xee,\n    0xef, 0x5a, 0x62, 0x9a, 0x9b, 0x27, 0x28, 0x55,\n    0x9d, 0xa0, 0xa1, 0xa3, 0xa4, 0xa7, 0xa8, 0xad,\n    0xba, 0xbc, 0xc4, 0x06, 0x0b, 0x0c, 0x15, 0x1d,\n    0x3a, 0x3f, 0x45, 0x51, 0xa6, 0xa7, 0xcc, 0xcd,\n    0xa0, 0x07, 0x19, 0x1a, 0x22, 0x25, 0x3e, 0x3f,\n    0xc5, 0xc6, 0x04, 0x20, 0x23, 0x25, 0x26, 0x28,\n    0x33, 0x38, 0x3a, 0x48, 0x4a, 0x4c, 0x50, 0x53,\n    0x55, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x63,\n    0x65, 0x66, 0x6b, 0x73, 0x78, 0x7d, 0x7f, 0x8a,\n    0xa4, 0xaa, 0xaf, 0xb0, 0xc0, 0xd0, 0x0c, 0x72,\n    0xa3, 0xa4, 0xcb, 0xcc, 0x6e, 0x6f,\n];\n#[rustfmt::skip]\nconst NORMAL0: &[u8] = &[\n    0x00, 0x20,\n    0x5f, 0x22,\n    0x82, 0xdf, 0x04,\n    0x82, 0x44, 0x08,\n    0x1b, 0x04,\n    0x06, 0x11,\n    0x81, 0xac, 0x0e,\n    0x80, 0xab, 0x35,\n    0x1e, 0x15,\n    0x80, 0xe0, 0x03,\n    0x19, 0x08,\n    0x01, 0x04,\n    0x2f, 0x04,\n    0x34, 0x04,\n    0x07, 0x03,\n    0x01, 0x07,\n    0x06, 0x07,\n    0x11, 0x0a,\n    0x50, 0x0f,\n    0x12, 0x07,\n    0x55, 0x08,\n    0x02, 0x04,\n    0x1c, 0x0a,\n    0x09, 0x03,\n    0x08, 0x03,\n    0x07, 0x03,\n    0x02, 0x03,\n    0x03, 0x03,\n    0x0c, 0x04,\n    0x05, 0x03,\n    0x0b, 0x06,\n    0x01, 0x0e,\n    0x15, 0x05,\n    0x3a, 0x03,\n    0x11, 0x07,\n    0x06, 0x05,\n    0x10, 0x07,\n    0x57, 0x07,\n    0x02, 0x07,\n    0x15, 0x0d,\n    0x50, 0x04,\n    0x43, 0x03,\n    0x2d, 0x03,\n    0x01, 0x04,\n    0x11, 0x06,\n    0x0f, 0x0c,\n    0x3a, 0x04,\n    0x1d, 0x25,\n    0x5f, 0x20,\n    0x6d, 0x04,\n    0x6a, 0x25,\n    0x80, 0xc8, 0x05,\n    0x82, 0xb0, 0x03,\n    0x1a, 0x06,\n    0x82, 0xfd, 0x03,\n    0x59, 0x07,\n    0x15, 0x0b,\n    0x17, 0x09,\n    0x14, 0x0c,\n    0x14, 0x0c,\n    0x6a, 0x06,\n    0x0a, 0x06,\n    0x1a, 0x06,\n    0x59, 0x07,\n    0x2b, 0x05,\n    0x46, 0x0a,\n    0x2c, 0x04,\n    0x0c, 0x04,\n    0x01, 0x03,\n    0x31, 0x0b,\n    0x2c, 0x04,\n    0x1a, 0x06,\n    0x0b, 0x03,\n    0x80, 0xac, 0x06,\n    0x0a, 0x06,\n    0x1f, 0x41,\n    0x4c, 0x04,\n    0x2d, 0x03,\n    0x74, 0x08,\n    0x3c, 0x03,\n    0x0f, 0x03,\n    0x3c, 0x07,\n    0x38, 0x08,\n    0x2b, 0x05,\n    0x82, 0xff, 0x11,\n    0x18, 0x08,\n    0x2f, 0x11,\n    0x2d, 0x03,\n    0x20, 0x10,\n    0x21, 0x0f,\n    0x80, 0x8c, 0x04,\n    0x82, 0x97, 0x19,\n    0x0b, 0x15,\n    0x88, 0x94, 0x05,\n    0x2f, 0x05,\n    0x3b, 0x07,\n    0x02, 0x0e,\n    0x18, 0x09,\n    0x80, 0xb0, 0x30,\n    0x74, 0x0c,\n    0x80, 0xd6, 0x1a,\n    0x0c, 0x05,\n    0x80, 0xff, 0x05,\n    0x80, 0xb6, 0x05,\n    0x24, 0x0c,\n    0x9b, 0xc6, 0x0a,\n    0xd2, 0x30, 0x10,\n    0x84, 0x8d, 0x03,\n    0x37, 0x09,\n    0x81, 0x5c, 0x14,\n    0x80, 0xb8, 0x08,\n    0x80, 0xc7, 0x30,\n    0x35, 0x04,\n    0x0a, 0x06,\n    0x38, 0x08,\n    0x46, 0x08,\n    0x0c, 0x06,\n    0x74, 0x0b,\n    0x1e, 0x03,\n    0x5a, 0x04,\n    0x59, 0x09,\n    0x80, 0x83, 0x18,\n    0x1c, 0x0a,\n    0x16, 0x09,\n    0x48, 0x08,\n    0x80, 0x8a, 0x06,\n    0xab, 0xa4, 0x0c,\n    0x17, 0x04,\n    0x31, 0xa1, 0x04,\n    0x81, 0xda, 0x26,\n    0x07, 0x0c,\n    0x05, 0x05,\n    0x80, 0xa5, 0x11,\n    0x81, 0x6d, 0x10,\n    0x78, 0x28,\n    0x2a, 0x06,\n    0x4c, 0x04,\n    0x80, 0x8d, 0x04,\n    0x80, 0xbe, 0x03,\n    0x1b, 0x03,\n    0x0f, 0x0d,\n];\n#[rustfmt::skip]\nconst NORMAL1: &[u8] = &[\n    0x5e, 0x22,\n    0x7b, 0x05,\n    0x03, 0x04,\n    0x2d, 0x03,\n    0x65, 0x04,\n    0x01, 0x2f,\n    0x2e, 0x80, 0x82,\n    0x1d, 0x03,\n    0x31, 0x0f,\n    0x1c, 0x04,\n    0x24, 0x09,\n    0x1e, 0x05,\n    0x2b, 0x05,\n    0x44, 0x04,\n    0x0e, 0x2a,\n    0x80, 0xaa, 0x06,\n    0x24, 0x04,\n    0x24, 0x04,\n    0x28, 0x08,\n    0x34, 0x0b,\n    0x01, 0x80, 0x90,\n    0x81, 0x37, 0x09,\n    0x16, 0x0a,\n    0x08, 0x80, 0x98,\n    0x39, 0x03,\n    0x63, 0x08,\n    0x09, 0x30,\n    0x16, 0x05,\n    0x21, 0x03,\n    0x1b, 0x05,\n    0x01, 0x40,\n    0x38, 0x04,\n    0x4b, 0x05,\n    0x2f, 0x04,\n    0x0a, 0x07,\n    0x09, 0x07,\n    0x40, 0x20,\n    0x27, 0x04,\n    0x0c, 0x09,\n    0x36, 0x03,\n    0x3a, 0x05,\n    0x1a, 0x07,\n    0x04, 0x0c,\n    0x07, 0x50,\n    0x49, 0x37,\n    0x33, 0x0d,\n    0x33, 0x07,\n    0x2e, 0x08,\n    0x0a, 0x81, 0x26,\n    0x1f, 0x80, 0x81,\n    0x28, 0x08,\n    0x2a, 0x80, 0x86,\n    0x17, 0x09,\n    0x4e, 0x04,\n    0x1e, 0x0f,\n    0x43, 0x0e,\n    0x19, 0x07,\n    0x0a, 0x06,\n    0x47, 0x09,\n    0x27, 0x09,\n    0x75, 0x0b,\n    0x3f, 0x41,\n    0x2a, 0x06,\n    0x3b, 0x05,\n    0x0a, 0x06,\n    0x51, 0x06,\n    0x01, 0x05,\n    0x10, 0x03,\n    0x05, 0x80, 0x8b,\n    0x60, 0x20,\n    0x48, 0x08,\n    0x0a, 0x80, 0xa6,\n    0x5e, 0x22,\n    0x45, 0x0b,\n    0x0a, 0x06,\n    0x0d, 0x13,\n    0x39, 0x07,\n    0x0a, 0x36,\n    0x2c, 0x04,\n    0x10, 0x80, 0xc0,\n    0x3c, 0x64,\n    0x53, 0x0c,\n    0x01, 0x80, 0xa0,\n    0x45, 0x1b,\n    0x48, 0x08,\n    0x53, 0x1d,\n    0x39, 0x81, 0x07,\n    0x46, 0x0a,\n    0x1d, 0x03,\n    0x47, 0x49,\n    0x37, 0x03,\n    0x0e, 0x08,\n    0x0a, 0x06,\n    0x39, 0x07,\n    0x0a, 0x81, 0x36,\n    0x19, 0x80, 0xc7,\n    0x32, 0x0d,\n    0x83, 0x9b, 0x66,\n    0x75, 0x0b,\n    0x80, 0xc4, 0x8a, 0xbc,\n    0x84, 0x2f, 0x8f, 0xd1,\n    0x82, 0x47, 0xa1, 0xb9,\n    0x82, 0x39, 0x07,\n    0x2a, 0x04,\n    0x02, 0x60,\n    0x26, 0x0a,\n    0x46, 0x0a,\n    0x28, 0x05,\n    0x13, 0x82, 0xb0,\n    0x5b, 0x65,\n    0x4b, 0x04,\n    0x39, 0x07,\n    0x11, 0x40,\n    0x04, 0x1c,\n    0x97, 0xf8, 0x08,\n    0x82, 0xf3, 0xa5, 0x0d,\n    0x81, 0x1f, 0x31,\n    0x03, 0x11,\n    0x04, 0x08,\n    0x81, 0x8c, 0x89, 0x04,\n    0x6b, 0x05,\n    0x0d, 0x03,\n    0x09, 0x07,\n    0x10, 0x93, 0x60,\n    0x80, 0xf6, 0x0a,\n    0x73, 0x08,\n    0x6e, 0x17,\n    0x46, 0x80, 0x9a,\n    0x14, 0x0c,\n    0x57, 0x09,\n    0x19, 0x80, 0x87,\n    0x81, 0x47, 0x03,\n    0x85, 0x42, 0x0f,\n    0x15, 0x85, 0x50,\n    0x2b, 0x80, 0xd5,\n    0x2d, 0x03,\n    0x1a, 0x04,\n    0x02, 0x81, 0x70,\n    0x3a, 0x05,\n    0x01, 0x85, 0x00,\n    0x80, 0xd7, 0x29,\n    0x4c, 0x04,\n    0x0a, 0x04,\n    0x02, 0x83, 0x11,\n    0x44, 0x4c,\n    0x3d, 0x80, 0xc2,\n    0x3c, 0x06,\n    0x01, 0x04,\n    0x55, 0x05,\n    0x1b, 0x34,\n    0x02, 0x81, 0x0e,\n    0x2c, 0x04,\n    0x64, 0x0c,\n    0x56, 0x0a,\n    0x0d, 0x03,\n    0x5d, 0x03,\n    0x3d, 0x39,\n    0x1d, 0x0d,\n    0x2c, 0x04,\n    0x09, 0x07,\n    0x02, 0x0e,\n    0x06, 0x80, 0x9a,\n    0x83, 0xd6, 0x0a,\n    0x0d, 0x03,\n    0x0b, 0x05,\n    0x74, 0x0c,\n    0x59, 0x07,\n    0x0c, 0x14,\n    0x0c, 0x04,\n    0x38, 0x08,\n    0x0a, 0x06,\n    0x28, 0x08,\n    0x1e, 0x52,\n    0x77, 0x03,\n    0x31, 0x03,\n    0x80, 0xa6, 0x0c,\n    0x14, 0x04,\n    0x03, 0x05,\n    0x03, 0x0d,\n    0x06, 0x85, 0x6a,\n];\n}\nmod unicode_data {\n///! This file is generated by src/tools/unicode-table-generator; do not edit manually!\nuse super::range_search;\n\npub const UNICODE_VERSION: (u32, u32, u32) = (12, 1, 0);\n\n#[rustfmt::skip]\npub mod alphabetic {\n}\n\n#[rustfmt::skip]\npub mod case_ignorable {\n}\n\n#[rustfmt::skip]\npub mod cased {\n}\n\n#[rustfmt::skip]\npub mod cc {\n}\n\n#[rustfmt::skip]\npub mod grapheme_extend {\n}\n\n#[rustfmt::skip]\npub mod lowercase {\n}\n\n#[rustfmt::skip]\npub mod n {\n}\n\n#[rustfmt::skip]\npub mod uppercase {\n}\n\n#[rustfmt::skip]\npub mod white_space {\n}\n\n#[rustfmt::skip]\npub mod conversions {\n}\n}\npub(crate) mod version {\n/// Represents a Unicode Version.\n///\n/// See also: <http://www.unicode.org/versions/>\n#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n#[unstable(feature = \"unicode_version\", issue = \"49726\")]\npub struct UnicodeVersion {\n}\n}\n\nuse version::UnicodeVersion;\n\n/// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n/// `char` and `str` methods are based on.\n#[unstable(feature = \"unicode_version\", issue = \"49726\")]\npub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n};\n\n// For use in liballoc, not re-exported in libstd.\npub mod derived_property {\n    pub use super::{Case_Ignorable, Cased};\n}\n\npub use unicode_data::alphabetic::lookup as Alphabetic;\npub use unicode_data::case_ignorable::lookup as Case_Ignorable;\npub use unicode_data::cased::lookup as Cased;\npub use unicode_data::cc::lookup as Cc;\npub use unicode_data::conversions;\npub use unicode_data::grapheme_extend::lookup as Grapheme_Extend;\npub use unicode_data::lowercase::lookup as Lowercase;\npub use unicode_data::n::lookup as N;\npub use unicode_data::uppercase::lookup as Uppercase;\npub use unicode_data::white_space::lookup as White_Space;\n\n#[inline(always)]\nfn range_search<const N: usize, const N1: usize, const N2: usize>(\n    needle: u32,\n    chunk_idx_map: &[u8; N],\n    (last_chunk_idx, last_chunk_mapping): (u16, u8),\n    bitset_chunk_idx: &[[u8; 16]; N1],\n    bitset: &[u64; N2],\n) -> bool {\n}\n}\n\n/* Async */\n#[cfg(not(test))] // See #65860\npub mod future {\n#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n\n//! Asynchronous values.\n\nmod future {\n#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n\nuse crate::marker::Unpin;\nuse crate::ops;\nuse crate::pin::Pin;\nuse crate::task::{Context, Poll};\n\n/// A future represents an asynchronous computation.\n///\n/// A future is a value that may not have finished computing yet. This kind of\n/// \"asynchronous value\" makes it possible for a thread to continue doing useful\n/// work while it waits for the value to become available.\n///\n/// # The `poll` method\n///\n/// The core method of future, `poll`, *attempts* to resolve the future into a\n/// final value. This method does not block if the value is not ready. Instead,\n/// the current task is scheduled to be woken up when it's possible to make\n/// further progress by `poll`ing again. The `context` passed to the `poll`\n/// method can provide a [`Waker`], which is a handle for waking up the current\n/// task.\n///\n/// When using a future, you generally won't call `poll` directly, but instead\n/// `.await` the value.\n///\n/// [`Waker`]: ../task/struct.Waker.html\n#[doc(spotlight)]\n#[must_use = \"futures do nothing unless you `.await` or poll them\"]\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n#[lang = \"future_trait\"]\npub trait Future {\n    /// The type of value produced on completion.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    type Output;\n\n    /// Attempt to resolve the future to a final value, registering\n    /// the current task for wakeup if the value is not yet available.\n    ///\n    /// # Return value\n    ///\n    /// This function returns:\n    ///\n    /// - [`Poll::Pending`] if the future is not ready yet\n    /// - [`Poll::Ready(val)`] with the result `val` of this future if it\n    ///   finished successfully.\n    ///\n    /// Once a future has finished, clients should not `poll` it again.\n    ///\n    /// When a future is not ready yet, `poll` returns `Poll::Pending` and\n    /// stores a clone of the [`Waker`] copied from the current [`Context`].\n    /// This [`Waker`] is then woken once the future can make progress.\n    /// For example, a future waiting for a socket to become\n    /// readable would call `.clone()` on the [`Waker`] and store it.\n    /// When a signal arrives elsewhere indicating that the socket is readable,\n    /// [`Waker::wake`] is called and the socket future's task is awoken.\n    /// Once a task has been woken up, it should attempt to `poll` the future\n    /// again, which may or may not produce a final value.\n    ///\n    /// Note that on multiple calls to `poll`, only the [`Waker`] from the\n    /// [`Context`] passed to the most recent call should be scheduled to\n    /// receive a wakeup.\n    ///\n    /// # Runtime characteristics\n    ///\n    /// Futures alone are *inert*; they must be *actively* `poll`ed to make\n    /// progress, meaning that each time the current task is woken up, it should\n    /// actively re-`poll` pending futures that it still has an interest in.\n    ///\n    /// The `poll` function is not called repeatedly in a tight loop -- instead,\n    /// it should only be called when the future indicates that it is ready to\n    /// make progress (by calling `wake()`). If you're familiar with the\n    /// `poll(2)` or `select(2)` syscalls on Unix it's worth noting that futures\n    /// typically do *not* suffer the same problems of \"all wakeups must poll\n    /// all events\"; they are more like `epoll(4)`.\n    ///\n    /// An implementation of `poll` should strive to return quickly, and should\n    /// not block. Returning quickly prevents unnecessarily clogging up\n    /// threads or event loops. If it is known ahead of time that a call to\n    /// `poll` may end up taking awhile, the work should be offloaded to a\n    /// thread pool (or something similar) to ensure that `poll` can return\n    /// quickly.\n    ///\n    /// # Panics\n    ///\n    /// Once a future has completed (returned `Ready` from `poll`), calling its\n    /// `poll` method again may panic, block forever, or cause other kinds of\n    /// problems; the `Future` trait places no requirements on the effects of\n    /// such a call. However, as the `poll` method is not marked `unsafe`,\n    /// Rust's usual rules apply: calls must never cause undefined behavior\n    /// (memory corruption, incorrect use of `unsafe` functions, or the like),\n    /// regardless of the future's state.\n    ///\n    /// [`Poll::Pending`]: ../task/enum.Poll.html#variant.Pending\n    /// [`Poll::Ready(val)`]: ../task/enum.Poll.html#variant.Ready\n    /// [`Context`]: ../task/struct.Context.html\n    /// [`Waker`]: ../task/struct.Waker.html\n    /// [`Waker::wake`]: ../task/struct.Waker.html#method.wake\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl<F: ?Sized + Future + Unpin> Future for &mut F {\n    type Output = F::Output;\n\n    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n}\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl<P> Future for Pin<P>\nwhere\n    P: Unpin + ops::DerefMut<Target: Future>,\n{\n    type Output = <<P as ops::Deref>::Target as Future>::Output;\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n}\n}\n}\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub use self::future::Future;\n}\npub mod task {\n#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n\n//! Types and Traits for working with asynchronous tasks.\n\nmod poll {\n#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n\nuse crate::ops::Try;\nuse crate::result::Result;\n\n/// Indicates whether a value is available or if the current task has been\n/// scheduled to receive a wakeup instead.\n#[must_use = \"this `Poll` may be a `Pending` variant, which should be handled\"]\n#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub enum Poll<T> {\n    /// Represents that a value is immediately ready.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    Ready(#[stable(feature = \"futures_api\", since = \"1.36.0\")] T),\n\n    /// Represents that a value is not ready yet.\n    ///\n    /// When a function returns `Pending`, the function *must* also\n    /// ensure that the current task is scheduled to be awoken when\n    /// progress can be made.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    Pending,\n}\n\nimpl<T> Poll<T> {\n    /// Changes the ready value of this `Poll` with the closure provided.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn map<U, F>(self, f: F) -> Poll<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n}\n\n    /// Returns `true` if this is `Poll::Ready`\n    #[inline]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn is_ready(&self) -> bool {\n}\n\n    /// Returns `true` if this is `Poll::Pending`\n    #[inline]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn is_pending(&self) -> bool {\n}\n}\n\nimpl<T, E> Poll<Result<T, E>> {\n    /// Changes the success value of this `Poll` with the closure provided.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n    where\n        F: FnOnce(T) -> U,\n    {\n}\n\n    /// Changes the error value of this `Poll` with the closure provided.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n    where\n        F: FnOnce(E) -> U,\n    {\n}\n}\n\nimpl<T, E> Poll<Option<Result<T, E>>> {\n    /// Changes the success value of this `Poll` with the closure provided.\n    #[unstable(feature = \"poll_map\", issue = \"63514\")]\n    pub fn map_ok<U, F>(self, f: F) -> Poll<Option<Result<U, E>>>\n    where\n        F: FnOnce(T) -> U,\n    {\n}\n\n    /// Changes the error value of this `Poll` with the closure provided.\n    #[unstable(feature = \"poll_map\", issue = \"63514\")]\n    pub fn map_err<U, F>(self, f: F) -> Poll<Option<Result<T, U>>>\n    where\n        F: FnOnce(E) -> U,\n    {\n}\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl<T> From<T> for Poll<T> {\n    fn from(t: T) -> Poll<T> {\n}\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl<T, E> Try for Poll<Result<T, E>> {\n    type Ok = Poll<T>;\n    type Error = E;\n\n    #[inline]\n    fn into_result(self) -> Result<Self::Ok, Self::Error> {\n}\n\n    #[inline]\n    fn from_error(e: Self::Error) -> Self {\n}\n\n    #[inline]\n    fn from_ok(x: Self::Ok) -> Self {\n}\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl<T, E> Try for Poll<Option<Result<T, E>>> {\n    type Ok = Poll<Option<T>>;\n    type Error = E;\n\n    #[inline]\n    fn into_result(self) -> Result<Self::Ok, Self::Error> {\n}\n\n    #[inline]\n    fn from_error(e: Self::Error) -> Self {\n}\n\n    #[inline]\n    fn from_ok(x: Self::Ok) -> Self {\n}\n}\n}\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub use self::poll::Poll;\n\nmod wake {\n#![stable(feature = \"futures_api\", since = \"1.36.0\")]\n\nuse crate::fmt;\nuse crate::marker::{PhantomData, Unpin};\n\n/// A `RawWaker` allows the implementor of a task executor to create a [`Waker`]\n/// which provides customized wakeup behavior.\n///\n/// [vtable]: https://en.wikipedia.org/wiki/Virtual_method_table\n///\n/// It consists of a data pointer and a [virtual function pointer table (vtable)][vtable] that\n/// customizes the behavior of the `RawWaker`.\n///\n/// [`Waker`]: struct.Waker.html\n#[derive(PartialEq, Debug)]\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub struct RawWaker {\n    /// A data pointer, which can be used to store arbitrary data as required\n    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n    /// that is associated with the task.\n    /// The value of this field gets passed to all functions that are part of\n    /// the vtable as the first parameter.\n    data: *const (),\n    /// Virtual function pointer table that customizes the behavior of this waker.\n    vtable: &'static RawWakerVTable,\n}\n\nimpl RawWaker {\n    /// Creates a new `RawWaker` from the provided `data` pointer and `vtable`.\n    ///\n    /// The `data` pointer can be used to store arbitrary data as required\n    /// by the executor. This could be e.g. a type-erased pointer to an `Arc`\n    /// that is associated with the task.\n    /// The value of this pointer will get passed to all functions that are part\n    /// of the `vtable` as the first parameter.\n    ///\n    /// The `vtable` customizes the behavior of a `Waker` which gets created\n    /// from a `RawWaker`. For each operation on the `Waker`, the associated\n    /// function in the `vtable` of the underlying `RawWaker` will be called.\n    #[rustc_promotable]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    #[rustc_const_stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub const fn new(data: *const (), vtable: &'static RawWakerVTable) -> RawWaker {\n}\n}\n\n/// A virtual function pointer table (vtable) that specifies the behavior\n/// of a [`RawWaker`].\n///\n/// The pointer passed to all functions inside the vtable is the `data` pointer\n/// from the enclosing [`RawWaker`] object.\n///\n/// The functions inside this struct are only intended be called on the `data`\n/// pointer of a properly constructed [`RawWaker`] object from inside the\n/// [`RawWaker`] implementation. Calling one of the contained functions using\n/// any other `data` pointer will cause undefined behavior.\n///\n/// [`RawWaker`]: struct.RawWaker.html\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n#[derive(PartialEq, Copy, Clone, Debug)]\npub struct RawWakerVTable {\n    /// This function will be called when the [`RawWaker`] gets cloned, e.g. when\n    /// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.\n    ///\n    /// The implementation of this function must retain all resources that are\n    /// required for this additional instance of a [`RawWaker`] and associated\n    /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup\n    /// of the same task that would have been awoken by the original [`RawWaker`].\n    ///\n    /// [`Waker`]: struct.Waker.html\n    /// [`RawWaker`]: struct.RawWaker.html\n    clone: unsafe fn(*const ()) -> RawWaker,\n\n    /// This function will be called when `wake` is called on the [`Waker`].\n    /// It must wake up the task associated with this [`RawWaker`].\n    ///\n    /// The implementation of this function must make sure to release any\n    /// resources that are associated with this instance of a [`RawWaker`] and\n    /// associated task.\n    ///\n    /// [`Waker`]: struct.Waker.html\n    /// [`RawWaker`]: struct.RawWaker.html\n    wake: unsafe fn(*const ()),\n\n    /// This function will be called when `wake_by_ref` is called on the [`Waker`].\n    /// It must wake up the task associated with this [`RawWaker`].\n    ///\n    /// This function is similar to `wake`, but must not consume the provided data\n    /// pointer.\n    ///\n    /// [`Waker`]: struct.Waker.html\n    /// [`RawWaker`]: struct.RawWaker.html\n    wake_by_ref: unsafe fn(*const ()),\n\n    /// This function gets called when a [`RawWaker`] gets dropped.\n    ///\n    /// The implementation of this function must make sure to release any\n    /// resources that are associated with this instance of a [`RawWaker`] and\n    /// associated task.\n    ///\n    /// [`RawWaker`]: struct.RawWaker.html\n    drop: unsafe fn(*const ()),\n}\n\nimpl RawWakerVTable {\n    /// Creates a new `RawWakerVTable` from the provided `clone`, `wake`,\n    /// `wake_by_ref`, and `drop` functions.\n    ///\n    /// # `clone`\n    ///\n    /// This function will be called when the [`RawWaker`] gets cloned, e.g. when\n    /// the [`Waker`] in which the [`RawWaker`] is stored gets cloned.\n    ///\n    /// The implementation of this function must retain all resources that are\n    /// required for this additional instance of a [`RawWaker`] and associated\n    /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup\n    /// of the same task that would have been awoken by the original [`RawWaker`].\n    ///\n    /// # `wake`\n    ///\n    /// This function will be called when `wake` is called on the [`Waker`].\n    /// It must wake up the task associated with this [`RawWaker`].\n    ///\n    /// The implementation of this function must make sure to release any\n    /// resources that are associated with this instance of a [`RawWaker`] and\n    /// associated task.\n    ///\n    /// # `wake_by_ref`\n    ///\n    /// This function will be called when `wake_by_ref` is called on the [`Waker`].\n    /// It must wake up the task associated with this [`RawWaker`].\n    ///\n    /// This function is similar to `wake`, but must not consume the provided data\n    /// pointer.\n    ///\n    /// # `drop`\n    ///\n    /// This function gets called when a [`RawWaker`] gets dropped.\n    ///\n    /// The implementation of this function must make sure to release any\n    /// resources that are associated with this instance of a [`RawWaker`] and\n    /// associated task.\n    ///\n    /// [`Waker`]: struct.Waker.html\n    /// [`RawWaker`]: struct.RawWaker.html\n    #[rustc_promotable]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    // `rustc_allow_const_fn_ptr` is a hack that should not be used anywhere else\n    // without first consulting with T-Lang.\n    //\n    // FIXME: remove whenever we have a stable way to accept fn pointers from const fn\n    // (see https://github.com/rust-rfcs/const-eval/issues/19#issuecomment-472799062)\n    #[rustc_allow_const_fn_ptr]\n    #[rustc_const_stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub const fn new(\n        clone: unsafe fn(*const ()) -> RawWaker,\n        wake: unsafe fn(*const ()),\n        wake_by_ref: unsafe fn(*const ()),\n        drop: unsafe fn(*const ()),\n    ) -> Self {\n        Self { clone, wake, wake_by_ref, drop }\n    }\n}\n\n/// The `Context` of an asynchronous task.\n///\n/// Currently, `Context` only serves to provide access to a `&Waker`\n/// which can be used to wake the current task.\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub struct Context<'a> {\n    waker: &'a Waker,\n    // Ensure we future-proof against variance changes by forcing\n    // the lifetime to be invariant (argument-position lifetimes\n    // are contravariant while return-position lifetimes are\n    // covariant).\n    _marker: PhantomData<fn(&'a ()) -> &'a ()>,\n}\n\nimpl<'a> Context<'a> {\n    /// Create a new `Context` from a `&Waker`.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    #[inline]\n    pub fn from_waker(waker: &'a Waker) -> Self {\n}\n\n    /// Returns a reference to the `Waker` for the current task.\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    #[inline]\n    pub fn waker(&self) -> &'a Waker {\n}\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl fmt::Debug for Context<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A `Waker` is a handle for waking up a task by notifying its executor that it\n/// is ready to be run.\n///\n/// This handle encapsulates a [`RawWaker`] instance, which defines the\n/// executor-specific wakeup behavior.\n///\n/// Implements [`Clone`], [`Send`], and [`Sync`].\n///\n/// [`RawWaker`]: struct.RawWaker.html\n#[repr(transparent)]\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub struct Waker {\n    waker: RawWaker,\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl Unpin for Waker {}\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nunsafe impl Send for Waker {}\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nunsafe impl Sync for Waker {}\n\nimpl Waker {\n    /// Wake up the task associated with this `Waker`.\n    #[inline]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn wake(self) {\n}\n\n    /// Wake up the task associated with this `Waker` without consuming the `Waker`.\n    ///\n    /// This is similar to `wake`, but may be slightly less efficient in the case\n    /// where an owned `Waker` is available. This method should be preferred to\n    /// calling `waker.clone().wake()`.\n    #[inline]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn wake_by_ref(&self) {\n}\n\n    /// Returns `true` if this `Waker` and another `Waker` have awoken the same task.\n    ///\n    /// This function works on a best-effort basis, and may return false even\n    /// when the `Waker`s would awaken the same task. However, if this function\n    /// returns `true`, it is guaranteed that the `Waker`s will awaken the same task.\n    ///\n    /// This function is primarily used for optimization purposes.\n    #[inline]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub fn will_wake(&self, other: &Waker) -> bool {\n}\n\n    /// Creates a new `Waker` from [`RawWaker`].\n    ///\n    /// The behavior of the returned `Waker` is undefined if the contract defined\n    /// in [`RawWaker`]'s and [`RawWakerVTable`]'s documentation is not upheld.\n    /// Therefore this method is unsafe.\n    ///\n    /// [`RawWaker`]: struct.RawWaker.html\n    /// [`RawWakerVTable`]: struct.RawWakerVTable.html\n    #[inline]\n    #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n    pub unsafe fn from_raw(waker: RawWaker) -> Waker {\n}\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl Clone for Waker {\n    #[inline]\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl Drop for Waker {\n    #[inline]\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl fmt::Debug for Waker {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n}\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\npub use self::wake::{Context, RawWaker, RawWakerVTable, Waker};\n}\n\n/* Heap memory allocator trait */\n#[allow(missing_docs)]\npub mod alloc {\n//! Memory allocation APIs\n\n// ignore-tidy-undocumented-unsafe\n\n#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n\nuse crate::cmp;\nuse crate::fmt;\nuse crate::mem;\nuse crate::num::NonZeroUsize;\nuse crate::ptr::{self, NonNull};\nuse crate::usize;\n\n/// Represents the combination of a starting address and\n/// a total capacity of the returned block.\n#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n#[derive(Debug)]\npub struct Excess(pub NonNull<u8>, pub usize);\n\nconst fn size_align<T>() -> (usize, usize) {\n}\n\n/// Layout of a block of memory.\n///\n/// An instance of `Layout` describes a particular layout of memory.\n/// You build a `Layout` up as an input to give to an allocator.\n///\n/// All layouts have an associated non-negative size and a\n/// power-of-two alignment.\n///\n/// (Note however that layouts are *not* required to have positive\n/// size, even though many allocators require that all memory\n/// requests have positive size. A caller to the `Alloc::alloc`\n/// method must either ensure that conditions like this are met, or\n/// use specific allocators with looser requirements.)\n#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n#[lang = \"alloc_layout\"]\npub struct Layout {\n    // size of the requested block of memory, measured in bytes.\n    size_: usize,\n\n    // alignment of the requested block of memory, measured in bytes.\n    // we ensure that this is always a power-of-two, because API's\n    // like `posix_memalign` require it and it is a reasonable\n    // constraint to impose on Layout constructors.\n    //\n    // (However, we do not analogously require `align >= sizeof(void*)`,\n    //  even though that is *also* a requirement of `posix_memalign`.)\n    align_: NonZeroUsize,\n}\n\nimpl Layout {\n    /// Constructs a `Layout` from a given `size` and `align`,\n    /// or returns `LayoutErr` if any of the following conditions\n    /// are not met:\n    ///\n    /// * `align` must not be zero,\n    ///\n    /// * `align` must be a power of two,\n    ///\n    /// * `size`, when rounded up to the nearest multiple of `align`,\n    ///    must not overflow (i.e., the rounded value must be less than\n    ///    `usize::MAX`).\n    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n    #[inline]\n    pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n}\n\n    /// Creates a layout, bypassing all checks.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe as it does not verify the preconditions from\n    /// [`Layout::from_size_align`](#method.from_size_align).\n    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n    #[rustc_const_stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n    #[inline]\n    pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n}\n\n    /// The minimum size in bytes for a memory block of this layout.\n    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n    #[inline]\n    pub const fn size(&self) -> usize {\n}\n\n    /// The minimum byte alignment for a memory block of this layout.\n    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n    #[inline]\n    pub const fn align(&self) -> usize {\n}\n\n    /// Constructs a `Layout` suitable for holding a value of type `T`.\n    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n    #[rustc_const_stable(feature = \"alloc_layout_const_new\", since = \"1.42.0\")]\n    #[inline]\n    pub const fn new<T>() -> Self {\n}\n\n    /// Produces layout describing a record that could be used to\n    /// allocate backing structure for `T` (which could be a trait\n    /// or other unsized type like a slice).\n    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n    #[inline]\n    pub fn for_value<T: ?Sized>(t: &T) -> Self {\n}\n\n    /// Creates a layout describing the record that can hold a value\n    /// of the same layout as `self`, but that also is aligned to\n    /// alignment `align` (measured in bytes).\n    ///\n    /// If `self` already meets the prescribed alignment, then returns\n    /// `self`.\n    ///\n    /// Note that this method does not add any padding to the overall\n    /// size, regardless of whether the returned layout has a different\n    /// alignment. In other words, if `K` has size 16, `K.align_to(32)`\n    /// will *still* have size 16.\n    ///\n    /// Returns an error if the combination of `self.size()` and the given\n    /// `align` violates the conditions listed in\n    /// [`Layout::from_size_align`](#method.from_size_align).\n    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n    #[inline]\n    pub fn align_to(&self, align: usize) -> Result<Self, LayoutErr> {\n}\n\n    /// Returns the amount of padding we must insert after `self`\n    /// to ensure that the following address will satisfy `align`\n    /// (measured in bytes).\n    ///\n    /// e.g., if `self.size()` is 9, then `self.padding_needed_for(4)`\n    /// returns 3, because that is the minimum number of bytes of\n    /// padding required to get a 4-aligned address (assuming that the\n    /// corresponding memory block starts at a 4-aligned address).\n    ///\n    /// The return value of this function has no meaning if `align` is\n    /// not a power-of-two.\n    ///\n    /// Note that the utility of the returned value requires `align`\n    /// to be less than or equal to the alignment of the starting\n    /// address for the whole allocated block of memory. One way to\n    /// satisfy this constraint is to ensure `align <= self.align()`.\n    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n    #[inline]\n    pub const fn padding_needed_for(&self, align: usize) -> usize {\n}\n\n    /// Creates a layout by rounding the size of this layout up to a multiple\n    /// of the layout's alignment.\n    ///\n    /// This is equivalent to adding the result of `padding_needed_for`\n    /// to the layout's current size.\n    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n    #[inline]\n    pub fn pad_to_align(&self) -> Layout {\n}\n\n    /// Creates a layout describing the record for `n` instances of\n    /// `self`, with a suitable amount of padding between each to\n    /// ensure that each instance is given its requested size and\n    /// alignment. On success, returns `(k, offs)` where `k` is the\n    /// layout of the array and `offs` is the distance between the start\n    /// of each element in the array.\n    ///\n    /// On arithmetic overflow, returns `LayoutErr`.\n    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n    #[inline]\n    pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n}\n\n    /// Creates a layout describing the record for `self` followed by\n    /// `next`, including any necessary padding to ensure that `next`\n    /// will be properly aligned. Note that the resulting layout will\n    /// satisfy the alignment properties of both `self` and `next`.\n    ///\n    /// The resulting layout will be the same as that of a C struct containing\n    /// two fields with the layouts of `self` and `next`, in that order.\n    ///\n    /// Returns `Some((k, offset))`, where `k` is layout of the concatenated\n    /// record and `offset` is the relative location, in bytes, of the\n    /// start of the `next` embedded within the concatenated record\n    /// (assuming that the record itself starts at offset 0).\n    ///\n    /// On arithmetic overflow, returns `LayoutErr`.\n    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n    #[inline]\n    pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n}\n\n    /// Creates a layout describing the record for `n` instances of\n    /// `self`, with no padding between each instance.\n    ///\n    /// Note that, unlike `repeat`, `repeat_packed` does not guarantee\n    /// that the repeated instances of `self` will be properly\n    /// aligned, even if a given instance of `self` is properly\n    /// aligned. In other words, if the layout returned by\n    /// `repeat_packed` is used to allocate an array, it is not\n    /// guaranteed that all elements in the array will be properly\n    /// aligned.\n    ///\n    /// On arithmetic overflow, returns `LayoutErr`.\n    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n    #[inline]\n    pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutErr> {\n}\n\n    /// Creates a layout describing the record for `self` followed by\n    /// `next` with no additional padding between the two. Since no\n    /// padding is inserted, the alignment of `next` is irrelevant,\n    /// and is not incorporated *at all* into the resulting layout.\n    ///\n    /// On arithmetic overflow, returns `LayoutErr`.\n    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n    #[inline]\n    pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutErr> {\n}\n\n    /// Creates a layout describing the record for a `[T; n]`.\n    ///\n    /// On arithmetic overflow, returns `LayoutErr`.\n    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n    #[inline]\n    pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n}\n}\n\n/// The parameters given to `Layout::from_size_align`\n/// or some other `Layout` constructor\n/// do not satisfy its documented constraints.\n#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n#[derive(Clone, PartialEq, Eq, Debug)]\npub struct LayoutErr {\n    private: (),\n}\n\n// (we need this for downstream impl of trait Error)\n#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\nimpl fmt::Display for LayoutErr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// The `AllocErr` error indicates an allocation failure\n/// that may be due to resource exhaustion or to\n/// something wrong when combining the given input arguments with this\n/// allocator.\n#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n#[derive(Clone, PartialEq, Eq, Debug)]\npub struct AllocErr;\n\n// (we need this for downstream impl of trait Error)\n#[unstable(feature = \"allocator_api\", issue = \"32838\")]\nimpl fmt::Display for AllocErr {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// The `CannotReallocInPlace` error is used when [`grow_in_place`] or\n/// [`shrink_in_place`] were unable to reuse the given memory block for\n/// a requested layout.\n///\n/// [`grow_in_place`]: ./trait.Alloc.html#method.grow_in_place\n/// [`shrink_in_place`]: ./trait.Alloc.html#method.shrink_in_place\n#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n#[derive(Clone, PartialEq, Eq, Debug)]\npub struct CannotReallocInPlace;\n\n#[unstable(feature = \"allocator_api\", issue = \"32838\")]\nimpl CannotReallocInPlace {\n    pub fn description(&self) -> &str {\n}\n}\n\n// (we need this for downstream impl of trait Error)\n#[unstable(feature = \"allocator_api\", issue = \"32838\")]\nimpl fmt::Display for CannotReallocInPlace {\n}\n\n/// A memory allocator that can be registered as the standard library’s default\n/// through the `#[global_allocator]` attribute.\n///\n/// Some of the methods require that a memory block be *currently\n/// allocated* via an allocator. This means that:\n///\n/// * the starting address for that memory block was previously\n///   returned by a previous call to an allocation method\n///   such as `alloc`, and\n///\n/// * the memory block has not been subsequently deallocated, where\n///   blocks are deallocated either by being passed to a deallocation\n///   method such as `dealloc` or by being\n///   passed to a reallocation method that returns a non-null pointer.\n///\n///\n/// # Example\n///\n/// ```no_run\n/// use std::alloc::{GlobalAlloc, Layout, alloc};\n/// use std::ptr::null_mut;\n///\n/// struct MyAllocator;\n///\n/// unsafe impl GlobalAlloc for MyAllocator {\n///     unsafe fn alloc(&self, _layout: Layout) -> *mut u8 { null_mut() }\n///     unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}\n/// }\n///\n/// #[global_allocator]\n/// static A: MyAllocator = MyAllocator;\n///\n/// fn main() {\n///     unsafe {\n///         assert!(alloc(Layout::new::<u32>()).is_null())\n///     }\n/// }\n/// ```\n///\n/// # Safety\n///\n/// The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and\n/// implementors must ensure that they adhere to these contracts:\n///\n/// * It's undefined behavior if global allocators unwind. This restriction may\n///   be lifted in the future, but currently a panic from any of these\n///   functions may lead to memory unsafety.\n///\n/// * `Layout` queries and calculations in general must be correct. Callers of\n///   this trait are allowed to rely on the contracts defined on each method,\n///   and implementors must ensure such contracts remain true.\n#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\npub unsafe trait GlobalAlloc {\n    /// Allocate memory as described by the given `layout`.\n    ///\n    /// Returns a pointer to newly-allocated memory,\n    /// or null to indicate allocation failure.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure that `layout` has non-zero size.\n    ///\n    /// (Extension subtraits might provide more specific bounds on\n    /// behavior, e.g., guarantee a sentinel address or a null pointer\n    /// in response to a zero-size allocation request.)\n    ///\n    /// The allocated block of memory may or may not be initialized.\n    ///\n    /// # Errors\n    ///\n    /// Returning a null pointer indicates that either memory is exhausted\n    /// or `layout` does not meet this allocator's size or alignment constraints.\n    ///\n    /// Implementations are encouraged to return null on memory\n    /// exhaustion rather than aborting, but this is not\n    /// a strict requirement. (Specifically: it is *legal* to\n    /// implement this trait atop an underlying native allocation\n    /// library that aborts on memory exhaustion.)\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n    /// rather than directly invoking `panic!` or similar.\n    ///\n    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8;\n\n    /// Deallocate the block of memory at the given `ptr` pointer with the given `layout`.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure all of the following:\n    ///\n    /// * `ptr` must denote a block of memory currently allocated via\n    ///   this allocator,\n    ///\n    /// * `layout` must be the same layout that was used\n    ///   to allocate that block of memory,\n    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);\n\n    /// Behaves like `alloc`, but also ensures that the contents\n    /// are set to zero before being returned.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe for the same reasons that `alloc` is.\n    /// However the allocated block of memory is guaranteed to be initialized.\n    ///\n    /// # Errors\n    ///\n    /// Returning a null pointer indicates that either memory is exhausted\n    /// or `layout` does not meet allocator's size or alignment constraints,\n    /// just as in `alloc`.\n    ///\n    /// Clients wishing to abort computation in response to an\n    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n    /// rather than directly invoking `panic!` or similar.\n    ///\n    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n        let size = layout.size();\n        let ptr = self.alloc(layout);\n        if !ptr.is_null() {\n            ptr::write_bytes(ptr, 0, size);\n        }\n        ptr\n    }\n\n    /// Shrink or grow a block of memory to the given `new_size`.\n    /// The block is described by the given `ptr` pointer and `layout`.\n    ///\n    /// If this returns a non-null pointer, then ownership of the memory block\n    /// referenced by `ptr` has been transferred to this allocator.\n    /// The memory may or may not have been deallocated,\n    /// and should be considered unusable (unless of course it was\n    /// transferred back to the caller again via the return value of\n    /// this method). The new memory block is allocated with `layout`, but\n    /// with the `size` updated to `new_size`.\n    ///\n    /// If this method returns null, then ownership of the memory\n    /// block has not been transferred to this allocator, and the\n    /// contents of the memory block are unaltered.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because undefined behavior can result\n    /// if the caller does not ensure all of the following:\n    ///\n    /// * `ptr` must be currently allocated via this allocator,\n    ///\n    /// * `layout` must be the same layout that was used\n    ///   to allocate that block of memory,\n    ///\n    /// * `new_size` must be greater than zero.\n    ///\n    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n    ///\n    /// (Extension subtraits might provide more specific bounds on\n    /// behavior, e.g., guarantee a sentinel address or a null pointer\n    /// in response to a zero-size allocation request.)\n    ///\n    /// # Errors\n    ///\n    /// Returns null if the new layout does not meet the size\n    /// and alignment constraints of the allocator, or if reallocation\n    /// otherwise fails.\n    ///\n    /// Implementations are encouraged to return null on memory\n    /// exhaustion rather than panicking or aborting, but this is not\n    /// a strict requirement. (Specifically: it is *legal* to\n    /// implement this trait atop an underlying native allocation\n    /// library that aborts on memory exhaustion.)\n    ///\n    /// Clients wishing to abort computation in response to a\n    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n    /// rather than directly invoking `panic!` or similar.\n    ///\n    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n}\n}\n\n/// An implementation of `Alloc` can allocate, reallocate, and\n/// deallocate arbitrary blocks of data described via `Layout`.\n///\n/// Some of the methods require that a memory block be *currently\n/// allocated* via an allocator. This means that:\n///\n/// * the starting address for that memory block was previously\n///   returned by a previous call to an allocation method (`alloc`,\n///   `alloc_zeroed`, `alloc_excess`, `alloc_one`, `alloc_array`) or\n///   reallocation method (`realloc`, `realloc_excess`, or\n///   `realloc_array`), and\n///\n/// * the memory block has not been subsequently deallocated, where\n///   blocks are deallocated either by being passed to a deallocation\n///   method (`dealloc`, `dealloc_one`, `dealloc_array`) or by being\n///   passed to a reallocation method (see above) that returns `Ok`.\n///\n/// A note regarding zero-sized types and zero-sized layouts: many\n/// methods in the `Alloc` trait state that allocation requests\n/// must be non-zero size, or else undefined behavior can result.\n///\n/// * However, some higher-level allocation methods (`alloc_one`,\n///   `alloc_array`) are well-defined on zero-sized types and can\n///   optionally support them: it is left up to the implementor\n///   whether to return `Err`, or to return `Ok` with some pointer.\n///\n/// * If an `Alloc` implementation chooses to return `Ok` in this\n///   case (i.e., the pointer denotes a zero-sized inaccessible block)\n///   then that returned pointer must be considered \"currently\n///   allocated\". On such an allocator, *all* methods that take\n///   currently-allocated pointers as inputs must accept these\n///   zero-sized pointers, *without* causing undefined behavior.\n///\n/// * In other words, if a zero-sized pointer can flow out of an\n///   allocator, then that allocator must likewise accept that pointer\n///   flowing back into its deallocation and reallocation methods.\n///\n/// Some of the methods require that a layout *fit* a memory block.\n/// What it means for a layout to \"fit\" a memory block means (or\n/// equivalently, for a memory block to \"fit\" a layout) is that the\n/// following two conditions must hold:\n///\n/// 1. The block's starting address must be aligned to `layout.align()`.\n///\n/// 2. The block's size must fall in the range `[use_min, use_max]`, where:\n///\n///    * `use_min` is `self.usable_size(layout).0`, and\n///\n///    * `use_max` is the capacity that was (or would have been)\n///      returned when (if) the block was allocated via a call to\n///      `alloc_excess` or `realloc_excess`.\n///\n/// Note that:\n///\n///  * the size of the layout most recently used to allocate the block\n///    is guaranteed to be in the range `[use_min, use_max]`, and\n///\n///  * a lower-bound on `use_max` can be safely approximated by a call to\n///    `usable_size`.\n///\n///  * if a layout `k` fits a memory block (denoted by `ptr`)\n///    currently allocated via an allocator `a`, then it is legal to\n///    use that layout to deallocate it, i.e., `a.dealloc(ptr, k);`.\n///\n/// # Safety\n///\n/// The `Alloc` trait is an `unsafe` trait for a number of reasons, and\n/// implementors must ensure that they adhere to these contracts:\n///\n/// * Pointers returned from allocation functions must point to valid memory and\n///   retain their validity until at least the instance of `Alloc` is dropped\n///   itself.\n///\n/// * `Layout` queries and calculations in general must be correct. Callers of\n///   this trait are allowed to rely on the contracts defined on each method,\n///   and implementors must ensure such contracts remain true.\n///\n/// Note that this list may get tweaked over time as clarifications are made in\n/// the future.\n#[unstable(feature = \"allocator_api\", issue = \"32838\")]\npub unsafe trait Alloc {\n}\n}\n\n// note: does not need to be public\nmod bool {\n//! impl bool {}\n\n#[lang = \"bool\"]\nimpl bool {\n    /// Returns `Some(t)` if the `bool` is `true`, or `None` otherwise.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(bool_to_option)]\n    ///\n    /// assert_eq!(false.then_some(0), None);\n    /// assert_eq!(true.then_some(0), Some(0));\n    /// ```\n    #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n    #[inline]\n    pub fn then_some<T>(self, t: T) -> Option<T> {\n}\n\n    /// Returns `Some(f())` if the `bool` is `true`, or `None` otherwise.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(bool_to_option)]\n    ///\n    /// assert_eq!(false.then(|| 0), None);\n    /// assert_eq!(true.then(|| 0), Some(0));\n    /// ```\n    #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n    #[inline]\n    pub fn then<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n}\n}\n}\nmod tuple {\n// See src/libstd/primitive_docs.rs for documentation.\n\nuse crate::cmp::Ordering::*;\nuse crate::cmp::*;\n\n// macro for implementing n-ary tuple functions and operations\nmacro_rules! tuple_impls {\n    ($(\n        $Tuple:ident {\n            $(($idx:tt) -> $T:ident)+\n        }\n    )+) => {\n        $(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T:PartialEq),+> PartialEq for ($($T,)+) where last_type!($($T,)+): ?Sized {\n                #[inline]\n                fn eq(&self, other: &($($T,)+)) -> bool {\n}\n                #[inline]\n                fn ne(&self, other: &($($T,)+)) -> bool {\n}\n            }\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T:Eq),+> Eq for ($($T,)+) where last_type!($($T,)+): ?Sized {}\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n                    where last_type!($($T,)+): ?Sized {\n                #[inline]\n                fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n}\n                #[inline]\n                fn lt(&self, other: &($($T,)+)) -> bool {\n}\n                #[inline]\n                fn le(&self, other: &($($T,)+)) -> bool {\n}\n                #[inline]\n                fn ge(&self, other: &($($T,)+)) -> bool {\n}\n                #[inline]\n                fn gt(&self, other: &($($T,)+)) -> bool {\n}\n            }\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T:Ord),+> Ord for ($($T,)+) where last_type!($($T,)+): ?Sized {\n                #[inline]\n                fn cmp(&self, other: &($($T,)+)) -> Ordering {\n}\n            }\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl<$($T:Default),+> Default for ($($T,)+) {\n                #[inline]\n                fn default() -> ($($T,)+) {\n}\n            }\n        )+\n    }\n}\n\n// Constructs an expression that performs a lexical ordering using method $rel.\n// The values are interleaved, so the macro invocation for\n// `(a1, a2, a3) < (b1, b2, b3)` would be `lexical_ord!(lt, a1, b1, a2, b2,\n// a3, b3)` (and similarly for `lexical_cmp`)\nmacro_rules! lexical_ord {\n    ($rel: ident, $a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n        if $a != $b { lexical_ord!($rel, $a, $b) }\n        else { lexical_ord!($rel, $($rest_a, $rest_b),+) }\n    };\n    ($rel: ident, $a:expr, $b:expr) => { ($a) . $rel (& $b) };\n}\n\nmacro_rules! lexical_partial_cmp {\n    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n        match ($a).partial_cmp(&$b) {\n            Some(Equal) => lexical_partial_cmp!($($rest_a, $rest_b),+),\n            ordering   => ordering\n        }\n    };\n    ($a:expr, $b:expr) => { ($a).partial_cmp(&$b) };\n}\n\nmacro_rules! lexical_cmp {\n    ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n        match ($a).cmp(&$b) {\n            Equal => lexical_cmp!($($rest_a, $rest_b),+),\n            ordering   => ordering\n        }\n    };\n    ($a:expr, $b:expr) => { ($a).cmp(&$b) };\n}\n\nmacro_rules! last_type {\n    ($a:ident,) => { $a };\n    ($a:ident, $($rest_a:ident,)+) => { last_type!($($rest_a,)+) };\n}\n\ntuple_impls! {\n    Tuple1 {\n        (0) -> A\n    }\n    Tuple2 {\n        (0) -> A\n        (1) -> B\n    }\n    Tuple3 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n    }\n    Tuple4 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n    }\n    Tuple5 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n    }\n    Tuple6 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n    }\n    Tuple7 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n        (6) -> G\n    }\n    Tuple8 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n        (6) -> G\n        (7) -> H\n    }\n    Tuple9 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n        (6) -> G\n        (7) -> H\n        (8) -> I\n    }\n    Tuple10 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n        (6) -> G\n        (7) -> H\n        (8) -> I\n        (9) -> J\n    }\n    Tuple11 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n        (6) -> G\n        (7) -> H\n        (8) -> I\n        (9) -> J\n        (10) -> K\n    }\n    Tuple12 {\n        (0) -> A\n        (1) -> B\n        (2) -> C\n        (3) -> D\n        (4) -> E\n        (5) -> F\n        (6) -> G\n        (7) -> H\n        (8) -> I\n        (9) -> J\n        (10) -> K\n        (11) -> L\n    }\n}\n}\nmod unit {\nuse crate::iter::FromIterator;\n\n/// Collapses all unit items from an iterator into one.\n///\n/// This is more useful when combined with higher-level abstractions, like\n/// collecting to a `Result<(), E>` where you only care about errors:\n///\n/// ```\n/// use std::io::*;\n/// let data = vec![1, 2, 3, 4, 5];\n/// let res: Result<()> = data.iter()\n///     .map(|x| writeln!(stdout(), \"{}\", x))\n///     .collect();\n/// assert!(res.is_ok());\n/// ```\n#[stable(feature = \"unit_from_iter\", since = \"1.23.0\")]\nimpl FromIterator<()> for () {\n    fn from_iter<I: IntoIterator<Item = ()>>(iter: I) -> Self {\n}\n}\n}\n\n// Pull in the `core_arch` crate directly into libcore. The contents of\n// `core_arch` are in a different repository: rust-lang/stdarch.\n//\n// `core_arch` depends on libcore, but the contents of this module are\n// set up in such a way that directly pulling it here works such that the\n// crate uses the this crate as its libcore.\n#[path = \"../stdarch/crates/core_arch/src/mod.rs\"]\n#[allow(missing_docs, missing_debug_implementations, dead_code, unused_imports)]\n#[unstable(feature = \"stdsimd\", issue = \"48556\")]\nmod core_arch {\n}\n\n#[stable(feature = \"simd_arch\", since = \"1.27.0\")]\npub use core_arch::arch;\n"],[3,"//! # The Rust core allocation and collections library\n//!\n//! This library provides smart pointers and collections for managing\n//! heap-allocated values.\n//!\n//! This library, like libcore, normally doesn’t need to be used directly\n//! since its contents are re-exported in the [`std` crate](../std/index.html).\n//! Crates that use the `#![no_std]` attribute however will typically\n//! not depend on `std`, so they’d use this crate instead.\n//!\n//! ## Boxed values\n//!\n//! The [`Box`] type is a smart pointer type. There can only be one owner of a\n//! [`Box`], and the owner can decide to mutate the contents, which live on the\n//! heap.\n//!\n//! This type can be sent among threads efficiently as the size of a `Box` value\n//! is the same as that of a pointer. Tree-like data structures are often built\n//! with boxes because each node often has only one owner, the parent.\n//!\n//! ## Reference counted pointers\n//!\n//! The [`Rc`] type is a non-threadsafe reference-counted pointer type intended\n//! for sharing memory within a thread. An [`Rc`] pointer wraps a type, `T`, and\n//! only allows access to `&T`, a shared reference.\n//!\n//! This type is useful when inherited mutability (such as using [`Box`]) is too\n//! constraining for an application, and is often paired with the [`Cell`] or\n//! [`RefCell`] types in order to allow mutation.\n//!\n//! ## Atomically reference counted pointers\n//!\n//! The [`Arc`] type is the threadsafe equivalent of the [`Rc`] type. It\n//! provides all the same functionality of [`Rc`], except it requires that the\n//! contained type `T` is shareable. Additionally, [`Arc<T>`][`Arc`] is itself\n//! sendable while [`Rc<T>`][`Rc`] is not.\n//!\n//! This type allows for shared access to the contained data, and is often\n//! paired with synchronization primitives such as mutexes to allow mutation of\n//! shared resources.\n//!\n//! ## Collections\n//!\n//! Implementations of the most common general purpose data structures are\n//! defined in this library. They are re-exported through the\n//! [standard collections library](../std/collections/index.html).\n//!\n//! ## Heap interfaces\n//!\n//! The [`alloc`](alloc/index.html) module defines the low-level interface to the\n//! default global allocator. It is not compatible with the libc allocator API.\n//!\n//! [`Arc`]: sync/index.html\n//! [`Box`]: boxed/index.html\n//! [`Cell`]: ../core/cell/index.html\n//! [`Rc`]: rc/index.html\n//! [`RefCell`]: ../core/cell/index.html\n\n#![allow(unused_attributes)]\n#![stable(feature = \"alloc\", since = \"1.36.0\")]\n#![doc(\n    html_root_url = \"https://doc.rust-lang.org/nightly/\",\n    issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n    test(no_crate_inject, attr(allow(unused_variables), deny(warnings)))\n)]\n#![no_std]\n#![needs_allocator]\n#![warn(deprecated_in_future)]\n#![warn(missing_docs)]\n#![warn(missing_debug_implementations)]\n#![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n#![allow(explicit_outlives_requirements)]\n#![allow(incomplete_features)]\n#![cfg_attr(not(test), feature(generator_trait))]\n#![cfg_attr(test, feature(test))]\n#![feature(allocator_api)]\n#![feature(allow_internal_unstable)]\n#![feature(arbitrary_self_types)]\n#![feature(box_into_raw_non_null)]\n#![feature(box_patterns)]\n#![feature(box_syntax)]\n#![feature(cfg_target_has_atomic)]\n#![feature(coerce_unsized)]\n#![feature(const_generic_impls_guard)]\n#![feature(const_generics)]\n#![feature(const_in_array_repeat_expressions)]\n#![feature(const_if_match)]\n#![feature(cow_is_borrowed)]\n#![feature(dispatch_from_dyn)]\n#![feature(core_intrinsics)]\n#![feature(container_error_extra)]\n#![feature(dropck_eyepatch)]\n#![feature(exact_size_is_empty)]\n#![feature(fmt_internals)]\n#![feature(fn_traits)]\n#![feature(fundamental)]\n#![feature(internal_uninit_const)]\n#![feature(lang_items)]\n#![feature(libc)]\n#![feature(nll)]\n#![feature(optin_builtin_traits)]\n#![feature(pattern)]\n#![feature(ptr_internals)]\n#![feature(ptr_offset_from)]\n#![feature(rustc_attrs)]\n#![feature(receiver_trait)]\n#![feature(specialization)]\n#![feature(staged_api)]\n#![feature(std_internals)]\n#![feature(str_internals)]\n#![feature(trusted_len)]\n#![feature(try_reserve)]\n#![feature(unboxed_closures)]\n#![feature(unicode_internals)]\n#![feature(unsize)]\n#![feature(unsized_locals)]\n#![feature(allocator_internals)]\n#![feature(slice_partition_dedup)]\n#![feature(maybe_uninit_extra, maybe_uninit_slice)]\n#![feature(alloc_layout_extra)]\n#![feature(try_trait)]\n#![feature(associated_type_bounds)]\n\n// Allow testing this library\n\n#[cfg(test)]\n#[macro_use]\nextern crate std;\n#[cfg(test)]\nextern crate test;\n\n// Module with internal macros used by other modules (needs to be included before other modules).\n#[macro_use]\nmod macros {\n/// Creates a [`Vec`] containing the arguments.\n///\n/// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.\n/// There are two forms of this macro:\n///\n/// - Create a [`Vec`] containing a given list of elements:\n///\n/// ```\n/// let v = vec![1, 2, 3];\n/// assert_eq!(v[0], 1);\n/// assert_eq!(v[1], 2);\n/// assert_eq!(v[2], 3);\n/// ```\n///\n/// - Create a [`Vec`] from a given element and size:\n///\n/// ```\n/// let v = vec![1; 3];\n/// assert_eq!(v, [1, 1, 1]);\n/// ```\n///\n/// Note that unlike array expressions this syntax supports all elements\n/// which implement [`Clone`] and the number of elements doesn't have to be\n/// a constant.\n///\n/// This will use `clone` to duplicate an expression, so one should be careful\n/// using this with types having a nonstandard `Clone` implementation. For\n/// example, `vec![Rc::new(1); 5]` will create a vector of five references\n/// to the same boxed integer value, not five references pointing to independently\n/// boxed integers.\n///\n/// [`Vec`]: ../std/vec/struct.Vec.html\n/// [`Clone`]: ../std/clone/trait.Clone.html\n#[cfg(not(test))]\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[allow_internal_unstable(box_syntax)]\nmacro_rules! vec {\n    ($elem:expr; $n:expr) => (\n        $crate::vec::from_elem($elem, $n)\n    );\n    ($($x:expr),*) => (\n        <[_]>::into_vec(box [$($x),*])\n    );\n    ($($x:expr,)*) => ($crate::vec![$($x),*])\n}\n\n// HACK(japaric): with cfg(test) the inherent `[T]::into_vec` method, which is\n// required for this macro definition, is not available. Instead use the\n// `slice::into_vec`  function which is only available with cfg(test)\n// NB see the slice::hack module in slice.rs for more information\n#[cfg(test)]\nmacro_rules! vec {\n}\n\n/// Creates a `String` using interpolation of runtime expressions.\n///\n/// The first argument `format!` receives is a format string. This must be a string\n/// literal. The power of the formatting string is in the `{}`s contained.\n///\n/// Additional parameters passed to `format!` replace the `{}`s within the\n/// formatting string in the order given unless named or positional parameters\n/// are used; see [`std::fmt`][fmt] for more information.\n///\n/// A common use for `format!` is concatenation and interpolation of strings.\n/// The same convention is used with [`print!`] and [`write!`] macros,\n/// depending on the intended destination of the string.\n///\n/// To convert a single value to a string, use the [`to_string`] method. This\n/// will use the [`Display`] formatting trait.\n///\n/// [fmt]: ../std/fmt/index.html\n/// [`print!`]: ../std/macro.print.html\n/// [`write!`]: ../std/macro.write.html\n/// [`to_string`]: ../std/string/trait.ToString.html\n/// [`Display`]: ../std/fmt/trait.Display.html\n///\n/// # Panics\n///\n/// `format!` panics if a formatting trait implementation returns an error.\n/// This indicates an incorrect implementation\n/// since `fmt::Write for String` never returns an error itself.\n///\n/// # Examples\n///\n/// ```\n/// format!(\"test\");\n/// format!(\"hello {}\", \"world!\");\n/// format!(\"x = {}, y = {y}\", 10, y = 30);\n/// ```\n#[macro_export]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nmacro_rules! format {\n    ($($arg:tt)*) => {{\n        let res = $crate::fmt::format($crate::__export::format_args!($($arg)*));\n        res\n    }}\n}\n}\n\n// Heaps provided for low-level allocation strategies\n\npub mod alloc {\n//! Memory allocation APIs\n\n#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n\nuse core::intrinsics::{min_align_of_val, size_of_val};\nuse core::ptr::{NonNull, Unique};\nuse core::usize;\n\n#[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n#[doc(inline)]\npub use core::alloc::*;\n\n#[cfg(test)]\nmod tests {\n}\n\nextern \"Rust\" {\n    // These are the magic symbols to call the global allocator.  rustc generates\n    // them from the `#[global_allocator]` attribute if there is one, or uses the\n    // default implementations in libstd (`__rdl_alloc` etc in `src/libstd/alloc.rs`)\n    // otherwise.\n    #[rustc_allocator]\n    #[rustc_allocator_nounwind]\n    fn __rust_alloc(size: usize, align: usize) -> *mut u8;\n    #[rustc_allocator_nounwind]\n    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n    #[rustc_allocator_nounwind]\n    fn __rust_realloc(ptr: *mut u8, old_size: usize, align: usize, new_size: usize) -> *mut u8;\n    #[rustc_allocator_nounwind]\n    fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;\n}\n\n/// The global memory allocator.\n///\n/// This type implements the [`Alloc`] trait by forwarding calls\n/// to the allocator registered with the `#[global_allocator]` attribute\n/// if there is one, or the `std` crate’s default.\n///\n/// Note: while this type is unstable, the functionality it provides can be\n/// accessed through the [free functions in `alloc`](index.html#functions).\n///\n/// [`Alloc`]: trait.Alloc.html\n#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n#[derive(Copy, Clone, Default, Debug)]\npub struct Global;\n\n/// Allocate memory with the global allocator.\n///\n/// This function forwards calls to the [`GlobalAlloc::alloc`] method\n/// of the allocator registered with the `#[global_allocator]` attribute\n/// if there is one, or the `std` crate’s default.\n///\n/// This function is expected to be deprecated in favor of the `alloc` method\n/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n///\n/// # Safety\n///\n/// See [`GlobalAlloc::alloc`].\n///\n/// [`Global`]: struct.Global.html\n/// [`Alloc`]: trait.Alloc.html\n/// [`GlobalAlloc::alloc`]: trait.GlobalAlloc.html#tymethod.alloc\n///\n/// # Examples\n///\n/// ```\n/// use std::alloc::{alloc, dealloc, Layout};\n///\n/// unsafe {\n///     let layout = Layout::new::<u16>();\n///     let ptr = alloc(layout);\n///\n///     *(ptr as *mut u16) = 42;\n///     assert_eq!(*(ptr as *mut u16), 42);\n///\n///     dealloc(ptr, layout);\n/// }\n/// ```\n#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n#[inline]\npub unsafe fn alloc(layout: Layout) -> *mut u8 {\n}\n\n/// Deallocate memory with the global allocator.\n///\n/// This function forwards calls to the [`GlobalAlloc::dealloc`] method\n/// of the allocator registered with the `#[global_allocator]` attribute\n/// if there is one, or the `std` crate’s default.\n///\n/// This function is expected to be deprecated in favor of the `dealloc` method\n/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n///\n/// # Safety\n///\n/// See [`GlobalAlloc::dealloc`].\n///\n/// [`Global`]: struct.Global.html\n/// [`Alloc`]: trait.Alloc.html\n/// [`GlobalAlloc::dealloc`]: trait.GlobalAlloc.html#tymethod.dealloc\n#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n#[inline]\npub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n}\n\n/// Reallocate memory with the global allocator.\n///\n/// This function forwards calls to the [`GlobalAlloc::realloc`] method\n/// of the allocator registered with the `#[global_allocator]` attribute\n/// if there is one, or the `std` crate’s default.\n///\n/// This function is expected to be deprecated in favor of the `realloc` method\n/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n///\n/// # Safety\n///\n/// See [`GlobalAlloc::realloc`].\n///\n/// [`Global`]: struct.Global.html\n/// [`Alloc`]: trait.Alloc.html\n/// [`GlobalAlloc::realloc`]: trait.GlobalAlloc.html#method.realloc\n#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n#[inline]\npub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n}\n\n/// Allocate zero-initialized memory with the global allocator.\n///\n/// This function forwards calls to the [`GlobalAlloc::alloc_zeroed`] method\n/// of the allocator registered with the `#[global_allocator]` attribute\n/// if there is one, or the `std` crate’s default.\n///\n/// This function is expected to be deprecated in favor of the `alloc_zeroed` method\n/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n///\n/// # Safety\n///\n/// See [`GlobalAlloc::alloc_zeroed`].\n///\n/// [`Global`]: struct.Global.html\n/// [`Alloc`]: trait.Alloc.html\n/// [`GlobalAlloc::alloc_zeroed`]: trait.GlobalAlloc.html#method.alloc_zeroed\n///\n/// # Examples\n///\n/// ```\n/// use std::alloc::{alloc_zeroed, dealloc, Layout};\n///\n/// unsafe {\n///     let layout = Layout::new::<u16>();\n///     let ptr = alloc_zeroed(layout);\n///\n///     assert_eq!(*(ptr as *mut u16), 0);\n///\n///     dealloc(ptr, layout);\n/// }\n/// ```\n#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n#[inline]\npub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n}\n\n#[unstable(feature = \"allocator_api\", issue = \"32838\")]\nunsafe impl Alloc for Global {\n}\n\n/// The allocator for unique pointers.\n// This function must not unwind. If it does, MIR codegen will fail.\n#[cfg(not(test))]\n#[lang = \"exchange_malloc\"]\n#[inline]\nunsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n}\n\n#[cfg_attr(not(test), lang = \"box_free\")]\n#[inline]\npub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n}\n\n/// Abort on memory allocation error or failure.\n///\n/// Callers of memory allocation APIs wishing to abort computation\n/// in response to an allocation error are encouraged to call this function,\n/// rather than directly invoking `panic!` or similar.\n///\n/// The default behavior of this function is to print a message to standard error\n/// and abort the process.\n/// It can be replaced with [`set_alloc_error_hook`] and [`take_alloc_error_hook`].\n///\n/// [`set_alloc_error_hook`]: ../../std/alloc/fn.set_alloc_error_hook.html\n/// [`take_alloc_error_hook`]: ../../std/alloc/fn.take_alloc_error_hook.html\n#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n#[rustc_allocator_nounwind]\npub fn handle_alloc_error(layout: Layout) -> ! {\n}\n}\n\n// Primitive types using the heaps above\n\n// Need to conditionally define the mod from `boxed.rs` to avoid\n// duplicating the lang-items when building in test cfg; but also need\n// to allow code to have `use boxed::Box;` declarations.\n#[cfg(not(test))]\npub mod boxed {\n//! A pointer type for heap allocation.\n//!\n//! [`Box<T>`], casually referred to as a 'box', provides the simplest form of\n//! heap allocation in Rust. Boxes provide ownership for this allocation, and\n//! drop their contents when they go out of scope.\n//!\n//! # Examples\n//!\n//! Move a value from the stack to the heap by creating a [`Box`]:\n//!\n//! ```\n//! let val: u8 = 5;\n//! let boxed: Box<u8> = Box::new(val);\n//! ```\n//!\n//! Move a value from a [`Box`] back to the stack by [dereferencing]:\n//!\n//! ```\n//! let boxed: Box<u8> = Box::new(5);\n//! let val: u8 = *boxed;\n//! ```\n//!\n//! Creating a recursive data structure:\n//!\n//! ```\n//! #[derive(Debug)]\n//! enum List<T> {\n//!     Cons(T, Box<List<T>>),\n//!     Nil,\n//! }\n//!\n//! let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n//! println!(\"{:?}\", list);\n//! ```\n//!\n//! This will print `Cons(1, Cons(2, Nil))`.\n//!\n//! Recursive structures must be boxed, because if the definition of `Cons`\n//! looked like this:\n//!\n//! ```compile_fail,E0072\n//! # enum List<T> {\n//! Cons(T, List<T>),\n//! # }\n//! ```\n//!\n//! It wouldn't work. This is because the size of a `List` depends on how many\n//! elements are in the list, and so we don't know how much memory to allocate\n//! for a `Cons`. By introducing a [`Box<T>`], which has a defined size, we know how\n//! big `Cons` needs to be.\n//!\n//! # Memory layout\n//!\n//! For non-zero-sized values, a [`Box`] will use the [`Global`] allocator for\n//! its allocation. It is valid to convert both ways between a [`Box`] and a\n//! raw pointer allocated with the [`Global`] allocator, given that the\n//! [`Layout`] used with the allocator is correct for the type. More precisely,\n//! a `value: *mut T` that has been allocated with the [`Global`] allocator\n//! with `Layout::for_value(&*value)` may be converted into a box using\n//! [`Box::<T>::from_raw(value)`]. Conversely, the memory backing a `value: *mut\n//! T` obtained from [`Box::<T>::into_raw`] may be deallocated using the\n//! [`Global`] allocator with [`Layout::for_value(&*value)`].\n//!\n//! So long as `T: Sized`, a `Box<T>` is guaranteed to be represented\n//! as a single pointer and is also ABI-compatible with C pointers\n//! (i.e. the C type `T*`). This means that if you have extern \"C\"\n//! Rust functions that will be called from C, you can define those\n//! Rust functions using `Box<T>` types, and use `T*` as corresponding\n//! type on the C side. As an example, consider this C header which\n//! declares functions that create and destroy some kind of `Foo`\n//! value:\n//!\n//! ```c\n//! /* C header */\n//!\n//! /* Returns ownership to the caller */\n//! struct Foo* foo_new(void);\n//!\n//! /* Takes ownership from the caller; no-op when invoked with NULL */\n//! void foo_delete(struct Foo*);\n//! ```\n//!\n//! These two functions might be implemented in Rust as follows. Here, the\n//! `struct Foo*` type from C is translated to `Box<Foo>`, which captures\n//! the ownership constraints. Note also that the nullable argument to\n//! `foo_delete` is represented in Rust as `Option<Box<Foo>>`, since `Box<Foo>`\n//! cannot be null.\n//!\n//! ```\n//! #[repr(C)]\n//! pub struct Foo;\n//!\n//! #[no_mangle]\n//! pub extern \"C\" fn foo_new() -> Box<Foo> {\n//!     Box::new(Foo)\n//! }\n//!\n//! #[no_mangle]\n//! pub extern \"C\" fn foo_delete(_: Option<Box<Foo>>) {}\n//! ```\n//!\n//! Even though `Box<T>` has the same representation and C ABI as a C pointer,\n//! this does not mean that you can convert an arbitrary `T*` into a `Box<T>`\n//! and expect things to work. `Box<T>` values will always be fully aligned,\n//! non-null pointers. Moreover, the destructor for `Box<T>` will attempt to\n//! free the value with the global allocator. In general, the best practice\n//! is to only use `Box<T>` for pointers that originated from the global\n//! allocator.\n//!\n//! **Important.** At least at present, you should avoid using\n//! `Box<T>` types for functions that are defined in C but invoked\n//! from Rust. In those cases, you should directly mirror the C types\n//! as closely as possible. Using types like `Box<T>` where the C\n//! definition is just using `T*` can lead to undefined behavior, as\n//! described in [rust-lang/unsafe-code-guidelines#198][ucg#198].\n//!\n//! [ucg#198]: https://github.com/rust-lang/unsafe-code-guidelines/issues/198\n//! [dereferencing]: ../../std/ops/trait.Deref.html\n//! [`Box`]: struct.Box.html\n//! [`Box<T>`]: struct.Box.html\n//! [`Box::<T>::from_raw(value)`]: struct.Box.html#method.from_raw\n//! [`Box::<T>::into_raw`]: struct.Box.html#method.into_raw\n//! [`Global`]: ../alloc/struct.Global.html\n//! [`Layout`]: ../alloc/struct.Layout.html\n//! [`Layout::for_value(&*value)`]: ../alloc/struct.Layout.html#method.for_value\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::any::Any;\nuse core::array::LengthAtMost32;\nuse core::borrow;\nuse core::cmp::Ordering;\nuse core::convert::{From, TryFrom};\nuse core::fmt;\nuse core::future::Future;\nuse core::hash::{Hash, Hasher};\nuse core::iter::{FromIterator, FusedIterator, Iterator};\nuse core::marker::{Unpin, Unsize};\nuse core::mem;\nuse core::ops::{\n    CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Generator, GeneratorState, Receiver,\n};\nuse core::pin::Pin;\nuse core::ptr::{self, NonNull, Unique};\nuse core::slice;\nuse core::task::{Context, Poll};\n\nuse crate::alloc::{self, Alloc, Global};\nuse crate::raw_vec::RawVec;\nuse crate::str::from_boxed_utf8_unchecked;\nuse crate::vec::Vec;\n\n/// A pointer type for heap allocation.\n///\n/// See the [module-level documentation](../../std/boxed/index.html) for more.\n#[lang = \"owned_box\"]\n#[fundamental]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Box<T: ?Sized>(Unique<T>);\n\nimpl<T> Box<T> {\n    /// Allocates memory on the heap and then places `x` into it.\n    ///\n    /// This doesn't actually allocate if `T` is zero-sized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let five = Box::new(5);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline(always)]\n    pub fn new(x: T) -> Box<T> {\n}\n\n    /// Constructs a new box with uninitialized contents.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(new_uninit)]\n    ///\n    /// let mut five = Box::<u32>::new_uninit();\n    ///\n    /// let five = unsafe {\n    ///     // Deferred initialization:\n    ///     five.as_mut_ptr().write(5);\n    ///\n    ///     five.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*five, 5)\n    /// ```\n    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n}\n\n    /// Constructs a new `Box` with uninitialized contents, with the memory\n    /// being filled with `0` bytes.\n    ///\n    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n    /// of this method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(new_uninit)]\n    ///\n    /// let zero = Box::<u32>::new_zeroed();\n    /// let zero = unsafe { zero.assume_init() };\n    ///\n    /// assert_eq!(*zero, 0)\n    /// ```\n    ///\n    /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {\n}\n\n    /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n    /// `x` will be pinned in memory and unable to be moved.\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[inline(always)]\n    pub fn pin(x: T) -> Pin<Box<T>> {\n}\n}\n\nimpl<T> Box<[T]> {\n    /// Constructs a new boxed slice with uninitialized contents.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(new_uninit)]\n    ///\n    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n    ///\n    /// let values = unsafe {\n    ///     // Deferred initialization:\n    ///     values[0].as_mut_ptr().write(1);\n    ///     values[1].as_mut_ptr().write(2);\n    ///     values[2].as_mut_ptr().write(3);\n    ///\n    ///     values.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*values, [1, 2, 3])\n    /// ```\n    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n}\n}\n\nimpl<T> Box<mem::MaybeUninit<T>> {\n    /// Converts to `Box<T>`.\n    ///\n    /// # Safety\n    ///\n    /// As with [`MaybeUninit::assume_init`],\n    /// it is up to the caller to guarantee that the value\n    /// really is in an initialized state.\n    /// Calling this when the content is not yet fully initialized\n    /// causes immediate undefined behavior.\n    ///\n    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(new_uninit)]\n    ///\n    /// let mut five = Box::<u32>::new_uninit();\n    ///\n    /// let five: Box<u32> = unsafe {\n    ///     // Deferred initialization:\n    ///     five.as_mut_ptr().write(5);\n    ///\n    ///     five.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*five, 5)\n    /// ```\n    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[inline]\n    pub unsafe fn assume_init(self) -> Box<T> {\n}\n}\n\nimpl<T> Box<[mem::MaybeUninit<T>]> {\n    /// Converts to `Box<[T]>`.\n    ///\n    /// # Safety\n    ///\n    /// As with [`MaybeUninit::assume_init`],\n    /// it is up to the caller to guarantee that the values\n    /// really are in an initialized state.\n    /// Calling this when the content is not yet fully initialized\n    /// causes immediate undefined behavior.\n    ///\n    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(new_uninit)]\n    ///\n    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n    ///\n    /// let values = unsafe {\n    ///     // Deferred initialization:\n    ///     values[0].as_mut_ptr().write(1);\n    ///     values[1].as_mut_ptr().write(2);\n    ///     values[2].as_mut_ptr().write(3);\n    ///\n    ///     values.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*values, [1, 2, 3])\n    /// ```\n    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[inline]\n    pub unsafe fn assume_init(self) -> Box<[T]> {\n}\n}\n\nimpl<T: ?Sized> Box<T> {\n    /// Constructs a box from a raw pointer.\n    ///\n    /// After calling this function, the raw pointer is owned by the\n    /// resulting `Box`. Specifically, the `Box` destructor will call\n    /// the destructor of `T` and free the allocated memory. For this\n    /// to be safe, the memory must have been allocated in accordance\n    /// with the [memory layout] used by `Box` .\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because improper use may lead to\n    /// memory problems. For example, a double-free may occur if the\n    /// function is called twice on the same raw pointer.\n    ///\n    /// # Examples\n    /// Recreate a `Box` which was previously converted to a raw pointer\n    /// using [`Box::into_raw`]:\n    /// ```\n    /// let x = Box::new(5);\n    /// let ptr = Box::into_raw(x);\n    /// let x = unsafe { Box::from_raw(ptr) };\n    /// ```\n    /// Manually create a `Box` from scratch by using the global allocator:\n    /// ```\n    /// use std::alloc::{alloc, Layout};\n    ///\n    /// unsafe {\n    ///     let ptr = alloc(Layout::new::<i32>()) as *mut i32;\n    ///     *ptr = 5;\n    ///     let x = Box::from_raw(ptr);\n    /// }\n    /// ```\n    ///\n    /// [memory layout]: index.html#memory-layout\n    /// [`Layout`]: ../alloc/struct.Layout.html\n    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n    #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n    #[inline]\n    pub unsafe fn from_raw(raw: *mut T) -> Self {\n}\n\n    /// Consumes the `Box`, returning a wrapped raw pointer.\n    ///\n    /// The pointer will be properly aligned and non-null.\n    ///\n    /// After calling this function, the caller is responsible for the\n    /// memory previously managed by the `Box`. In particular, the\n    /// caller should properly destroy `T` and release the memory, taking\n    /// into account the [memory layout] used by `Box`. The easiest way to\n    /// do this is to convert the raw pointer back into a `Box` with the\n    /// [`Box::from_raw`] function, allowing the `Box` destructor to perform\n    /// the cleanup.\n    ///\n    /// Note: this is an associated function, which means that you have\n    /// to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n    /// is so that there is no conflict with a method on the inner type.\n    ///\n    /// # Examples\n    /// Converting the raw pointer back into a `Box` with [`Box::from_raw`]\n    /// for automatic cleanup:\n    /// ```\n    /// let x = Box::new(String::from(\"Hello\"));\n    /// let ptr = Box::into_raw(x);\n    /// let x = unsafe { Box::from_raw(ptr) };\n    /// ```\n    /// Manual cleanup by explicitly running the destructor and deallocating\n    /// the memory:\n    /// ```\n    /// use std::alloc::{dealloc, Layout};\n    /// use std::ptr;\n    ///\n    /// let x = Box::new(String::from(\"Hello\"));\n    /// let p = Box::into_raw(x);\n    /// unsafe {\n    ///     ptr::drop_in_place(p);\n    ///     dealloc(p as *mut u8, Layout::new::<String>());\n    /// }\n    /// ```\n    ///\n    /// [memory layout]: index.html#memory-layout\n    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n    #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n    #[inline]\n    pub fn into_raw(b: Box<T>) -> *mut T {\n}\n\n    /// Consumes the `Box`, returning the wrapped pointer as `NonNull<T>`.\n    ///\n    /// After calling this function, the caller is responsible for the\n    /// memory previously managed by the `Box`. In particular, the\n    /// caller should properly destroy `T` and release the memory. The\n    /// easiest way to do so is to convert the `NonNull<T>` pointer\n    /// into a raw pointer and back into a `Box` with the [`Box::from_raw`]\n    /// function.\n    ///\n    /// Note: this is an associated function, which means that you have\n    /// to call it as `Box::into_raw_non_null(b)`\n    /// instead of `b.into_raw_non_null()`. This\n    /// is so that there is no conflict with a method on the inner type.\n    ///\n    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(box_into_raw_non_null)]\n    ///\n    /// let x = Box::new(5);\n    /// let ptr = Box::into_raw_non_null(x);\n    ///\n    /// // Clean up the memory by converting the NonNull pointer back\n    /// // into a Box and letting the Box be dropped.\n    /// let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n    /// ```\n    #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]\n    #[inline]\n    pub fn into_raw_non_null(b: Box<T>) -> NonNull<T> {\n}\n\n    #[unstable(feature = \"ptr_internals\", issue = \"none\", reason = \"use into_raw_non_null instead\")]\n    #[inline]\n    #[doc(hidden)]\n    pub fn into_unique(b: Box<T>) -> Unique<T> {\n}\n\n    /// Consumes and leaks the `Box`, returning a mutable reference,\n    /// `&'a mut T`. Note that the type `T` must outlive the chosen lifetime\n    /// `'a`. If the type has only static references, or none at all, then this\n    /// may be chosen to be `'static`.\n    ///\n    /// This function is mainly useful for data that lives for the remainder of\n    /// the program's life. Dropping the returned reference will cause a memory\n    /// leak. If this is not acceptable, the reference should first be wrapped\n    /// with the [`Box::from_raw`] function producing a `Box`. This `Box` can\n    /// then be dropped which will properly destroy `T` and release the\n    /// allocated memory.\n    ///\n    /// Note: this is an associated function, which means that you have\n    /// to call it as `Box::leak(b)` instead of `b.leak()`. This\n    /// is so that there is no conflict with a method on the inner type.\n    ///\n    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n    ///\n    /// # Examples\n    ///\n    /// Simple usage:\n    ///\n    /// ```\n    /// let x = Box::new(41);\n    /// let static_ref: &'static mut usize = Box::leak(x);\n    /// *static_ref += 1;\n    /// assert_eq!(*static_ref, 42);\n    /// ```\n    ///\n    /// Unsized data:\n    ///\n    /// ```\n    /// let x = vec![1, 2, 3].into_boxed_slice();\n    /// let static_ref = Box::leak(x);\n    /// static_ref[0] = 4;\n    /// assert_eq!(*static_ref, [4, 2, 3]);\n    /// ```\n    #[stable(feature = \"box_leak\", since = \"1.26.0\")]\n    #[inline]\n    pub fn leak<'a>(b: Box<T>) -> &'a mut T\n    where\n        T: 'a, // Technically not needed, but kept to be explicit.\n    {\n}\n\n    /// Converts a `Box<T>` into a `Pin<Box<T>>`\n    ///\n    /// This conversion does not allocate on the heap and happens in place.\n    ///\n    /// This is also available via [`From`].\n    #[unstable(feature = \"box_into_pin\", issue = \"62370\")]\n    pub fn into_pin(boxed: Box<T>) -> Pin<Box<T>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T: ?Sized> Drop for Box<T> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Default> Default for Box<T> {\n    /// Creates a `Box<T>`, with the `Default` value for T.\n    fn default() -> Box<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for Box<[T]> {\n    fn default() -> Box<[T]> {\n}\n}\n\n#[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\nimpl Default for Box<str> {\n    fn default() -> Box<str> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> Clone for Box<T> {\n    /// Returns a new box with a `clone()` of this box's contents.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new(5);\n    /// let y = x.clone();\n    ///\n    /// // The value is the same\n    /// assert_eq!(x, y);\n    ///\n    /// // But they are unique objects\n    /// assert_ne!(&*x as *const i32, &*y as *const i32);\n    /// ```\n    #[rustfmt::skip]\n    #[inline]\n    fn clone(&self) -> Box<T> {\n}\n\n    /// Copies `source`'s contents into `self` without creating a new allocation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new(5);\n    /// let mut y = Box::new(10);\n    /// let yp: *const i32 = &*y;\n    ///\n    /// y.clone_from(&x);\n    ///\n    /// // The value is the same\n    /// assert_eq!(x, y);\n    ///\n    /// // And no allocation occurred\n    /// assert_eq!(yp, &*y);\n    /// ```\n    #[inline]\n    fn clone_from(&mut self, source: &Box<T>) {\n}\n}\n\n#[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\nimpl Clone for Box<str> {\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + PartialEq> PartialEq for Box<T> {\n    #[inline]\n    fn eq(&self, other: &Box<T>) -> bool {\n}\n    #[inline]\n    fn ne(&self, other: &Box<T>) -> bool {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n}\n    #[inline]\n    fn lt(&self, other: &Box<T>) -> bool {\n}\n    #[inline]\n    fn le(&self, other: &Box<T>) -> bool {\n}\n    #[inline]\n    fn ge(&self, other: &Box<T>) -> bool {\n}\n    #[inline]\n    fn gt(&self, other: &Box<T>) -> bool {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Ord> Ord for Box<T> {\n    #[inline]\n    fn cmp(&self, other: &Box<T>) -> Ordering {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Eq> Eq for Box<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Hash> Hash for Box<T> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n}\n}\n\n#[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\nimpl<T: ?Sized + Hasher> Hasher for Box<T> {\n    fn finish(&self) -> u64 {\n}\n    fn write(&mut self, bytes: &[u8]) {\n}\n    fn write_u8(&mut self, i: u8) {\n}\n    fn write_u16(&mut self, i: u16) {\n}\n    fn write_u32(&mut self, i: u32) {\n}\n    fn write_u64(&mut self, i: u64) {\n}\n    fn write_u128(&mut self, i: u128) {\n}\n    fn write_usize(&mut self, i: usize) {\n}\n    fn write_i8(&mut self, i: i8) {\n}\n    fn write_i16(&mut self, i: i16) {\n}\n    fn write_i32(&mut self, i: i32) {\n}\n    fn write_i64(&mut self, i: i64) {\n}\n    fn write_i128(&mut self, i: i128) {\n}\n    fn write_isize(&mut self, i: isize) {\n}\n}\n\n#[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\nimpl<T> From<T> for Box<T> {\n    /// Converts a generic type `T` into a `Box<T>`\n    ///\n    /// The conversion allocates on the heap and moves `t`\n    /// from the stack into it.\n    ///\n    /// # Examples\n    /// ```rust\n    /// let x = 5;\n    /// let boxed = Box::new(5);\n    ///\n    /// assert_eq!(Box::from(x), boxed);\n    /// ```\n    fn from(t: T) -> Self {\n}\n}\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<T: ?Sized> From<Box<T>> for Pin<Box<T>> {\n    /// Converts a `Box<T>` into a `Pin<Box<T>>`\n    ///\n    /// This conversion does not allocate on the heap and happens in place.\n    fn from(boxed: Box<T>) -> Self {\n}\n}\n\n#[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\nimpl<T: Copy> From<&[T]> for Box<[T]> {\n    /// Converts a `&[T]` into a `Box<[T]>`\n    ///\n    /// This conversion allocates on the heap\n    /// and performs a copy of `slice`.\n    ///\n    /// # Examples\n    /// ```rust\n    /// // create a &[u8] which will be used to create a Box<[u8]>\n    /// let slice: &[u8] = &[104, 101, 108, 108, 111];\n    /// let boxed_slice: Box<[u8]> = Box::from(slice);\n    ///\n    /// println!(\"{:?}\", boxed_slice);\n    /// ```\n    fn from(slice: &[T]) -> Box<[T]> {\n}\n}\n\n#[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\nimpl From<&str> for Box<str> {\n    /// Converts a `&str` into a `Box<str>`\n    ///\n    /// This conversion allocates on the heap\n    /// and performs a copy of `s`.\n    ///\n    /// # Examples\n    /// ```rust\n    /// let boxed: Box<str> = Box::from(\"hello\");\n    /// println!(\"{}\", boxed);\n    /// ```\n    #[inline]\n    fn from(s: &str) -> Box<str> {\n}\n}\n\n#[stable(feature = \"boxed_str_conv\", since = \"1.19.0\")]\nimpl From<Box<str>> for Box<[u8]> {\n    /// Converts a `Box<str>>` into a `Box<[u8]>`\n    ///\n    /// This conversion does not allocate on the heap and happens in place.\n    ///\n    /// # Examples\n    /// ```rust\n    /// // create a Box<str> which will be used to create a Box<[u8]>\n    /// let boxed: Box<str> = Box::from(\"hello\");\n    /// let boxed_str: Box<[u8]> = Box::from(boxed);\n    ///\n    /// // create a &[u8] which will be used to create a Box<[u8]>\n    /// let slice: &[u8] = &[104, 101, 108, 108, 111];\n    /// let boxed_slice = Box::from(slice);\n    ///\n    /// assert_eq!(boxed_slice, boxed_str);\n    /// ```\n    #[inline]\n    fn from(s: Box<str>) -> Self {\n}\n}\n\n#[unstable(feature = \"boxed_slice_try_from\", issue = \"none\")]\nimpl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]>\nwhere\n    [T; N]: LengthAtMost32,\n{\n}\n\nimpl Box<dyn Any> {\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    /// Attempt to downcast the box to a concrete type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(value: Box<dyn Any>) {\n    ///     if let Ok(string) = value.downcast::<String>() {\n    ///         println!(\"String ({}): {}\", string.len(), string);\n    ///     }\n    /// }\n    ///\n    /// let my_string = \"Hello World\".to_string();\n    /// print_if_string(Box::new(my_string));\n    /// print_if_string(Box::new(0i8));\n    /// ```\n    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any>> {\n}\n}\n\nimpl Box<dyn Any + Send> {\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    /// Attempt to downcast the box to a concrete type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(value: Box<dyn Any + Send>) {\n    ///     if let Ok(string) = value.downcast::<String>() {\n    ///         println!(\"String ({}): {}\", string.len(), string);\n    ///     }\n    /// }\n    ///\n    /// let my_string = \"Hello World\".to_string();\n    /// print_if_string(Box::new(my_string));\n    /// print_if_string(Box::new(0i8));\n    /// ```\n    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any + Send>> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Display + ?Sized> fmt::Display for Box<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> fmt::Pointer for Box<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> Deref for Box<T> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> DerefMut for Box<T> {\n    fn deref_mut(&mut self) -> &mut T {\n}\n}\n\n#[unstable(feature = \"receiver_trait\", issue = \"none\")]\nimpl<T: ?Sized> Receiver for Box<T> {}}\n#[cfg(test)]\nmod boxed {\n}\npub mod borrow {\n//! A module for working with borrowed data.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::cmp::Ordering;\nuse core::hash::{Hash, Hasher};\nuse core::ops::{Add, AddAssign, Deref};\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::borrow::{Borrow, BorrowMut};\n\nuse crate::fmt;\nuse crate::string::String;\n\nuse Cow::*;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, B: ?Sized> Borrow<B> for Cow<'a, B>\nwhere\n    B: ToOwned,\n    <B as ToOwned>::Owned: 'a,\n{\n    fn borrow(&self) -> &B {\n}\n}\n\n/// A generalization of `Clone` to borrowed data.\n///\n/// Some types make it possible to go from borrowed to owned, usually by\n/// implementing the `Clone` trait. But `Clone` works only for going from `&T`\n/// to `T`. The `ToOwned` trait generalizes `Clone` to construct owned data\n/// from any borrow of a given type.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait ToOwned {\n    /// The resulting type after obtaining ownership.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    type Owned: Borrow<Self>;\n\n    /// Creates owned data from borrowed data, usually by cloning.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s: &str = \"a\";\n    /// let ss: String = s.to_owned();\n    ///\n    /// let v: &[i32] = &[1, 2];\n    /// let vv: Vec<i32> = v.to_owned();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[must_use = \"cloning is often expensive and is not expected to have side effects\"]\n    fn to_owned(&self) -> Self::Owned;\n\n    /// Uses borrowed data to replace owned data, usually by cloning.\n    ///\n    /// This is borrow-generalized version of `Clone::clone_from`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// # #![feature(toowned_clone_into)]\n    /// let mut s: String = String::new();\n    /// \"hello\".clone_into(&mut s);\n    ///\n    /// let mut v: Vec<i32> = Vec::new();\n    /// [1, 2][..].clone_into(&mut v);\n    /// ```\n    #[unstable(feature = \"toowned_clone_into\", reason = \"recently added\", issue = \"41263\")]\n    fn clone_into(&self, target: &mut Self::Owned) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ToOwned for T\nwhere\n    T: Clone,\n{\n    type Owned = T;\n    fn to_owned(&self) -> T {\n}\n\n    fn clone_into(&self, target: &mut T) {\n}\n}\n\n/// A clone-on-write smart pointer.\n///\n/// The type `Cow` is a smart pointer providing clone-on-write functionality: it\n/// can enclose and provide immutable access to borrowed data, and clone the\n/// data lazily when mutation or ownership is required. The type is designed to\n/// work with general borrowed data via the `Borrow` trait.\n///\n/// `Cow` implements `Deref`, which means that you can call\n/// non-mutating methods directly on the data it encloses. If mutation\n/// is desired, `to_mut` will obtain a mutable reference to an owned\n/// value, cloning if necessary.\n///\n/// # Examples\n///\n/// ```\n/// use std::borrow::Cow;\n///\n/// fn abs_all(input: &mut Cow<[i32]>) {\n///     for i in 0..input.len() {\n///         let v = input[i];\n///         if v < 0 {\n///             // Clones into a vector if not already owned.\n///             input.to_mut()[i] = -v;\n///         }\n///     }\n/// }\n///\n/// // No clone occurs because `input` doesn't need to be mutated.\n/// let slice = [0, 1, 2];\n/// let mut input = Cow::from(&slice[..]);\n/// abs_all(&mut input);\n///\n/// // Clone occurs because `input` needs to be mutated.\n/// let slice = [-1, 0, 1];\n/// let mut input = Cow::from(&slice[..]);\n/// abs_all(&mut input);\n///\n/// // No clone occurs because `input` is already owned.\n/// let mut input = Cow::from(vec![-1, 0, 1]);\n/// abs_all(&mut input);\n/// ```\n///\n/// Another example showing how to keep `Cow` in a struct:\n///\n/// ```\n/// use std::borrow::Cow;\n///\n/// struct Items<'a, X: 'a> where [X]: ToOwned<Owned = Vec<X>> {\n///     values: Cow<'a, [X]>,\n/// }\n///\n/// impl<'a, X: Clone + 'a> Items<'a, X> where [X]: ToOwned<Owned = Vec<X>> {\n///     fn new(v: Cow<'a, [X]>) -> Self {\n///         Items { values: v }\n///     }\n/// }\n///\n/// // Creates a container from borrowed values of a slice\n/// let readonly = [1, 2];\n/// let borrowed = Items::new((&readonly[..]).into());\n/// match borrowed {\n///     Items { values: Cow::Borrowed(b) } => println!(\"borrowed {:?}\", b),\n///     _ => panic!(\"expect borrowed value\"),\n/// }\n///\n/// let mut clone_on_write = borrowed;\n/// // Mutates the data from slice into owned vec and pushes a new value on top\n/// clone_on_write.values.to_mut().push(3);\n/// println!(\"clone_on_write = {:?}\", clone_on_write.values);\n///\n/// // The data was mutated. Let check it out.\n/// match clone_on_write {\n///     Items { values: Cow::Owned(_) } => println!(\"clone_on_write contains owned data\"),\n///     _ => panic!(\"expect owned data\"),\n/// }\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Cow<'a, B: ?Sized + 'a>\nwhere\n    B: ToOwned,\n{\n    /// Borrowed data.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Borrowed(#[stable(feature = \"rust1\", since = \"1.0.0\")] &'a B),\n\n    /// Owned data.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Owned(#[stable(feature = \"rust1\", since = \"1.0.0\")] <B as ToOwned>::Owned),\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: ?Sized + ToOwned> Clone for Cow<'_, B> {\n    fn clone(&self) -> Self {\n}\n\n    fn clone_from(&mut self, source: &Self) {\n}\n}\n\nimpl<B: ?Sized + ToOwned> Cow<'_, B> {\n    /// Returns true if the data is borrowed, i.e. if `to_mut` would require additional work.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(cow_is_borrowed)]\n    /// use std::borrow::Cow;\n    ///\n    /// let cow = Cow::Borrowed(\"moo\");\n    /// assert!(cow.is_borrowed());\n    ///\n    /// let bull: Cow<'_, str> = Cow::Owned(\"...moo?\".to_string());\n    /// assert!(!bull.is_borrowed());\n    /// ```\n    #[unstable(feature = \"cow_is_borrowed\", issue = \"65143\")]\n    pub fn is_borrowed(&self) -> bool {\n}\n\n    /// Returns true if the data is owned, i.e. if `to_mut` would be a no-op.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(cow_is_borrowed)]\n    /// use std::borrow::Cow;\n    ///\n    /// let cow: Cow<'_, str> = Cow::Owned(\"moo\".to_string());\n    /// assert!(cow.is_owned());\n    ///\n    /// let bull = Cow::Borrowed(\"...moo?\");\n    /// assert!(!bull.is_owned());\n    /// ```\n    #[unstable(feature = \"cow_is_borrowed\", issue = \"65143\")]\n    pub fn is_owned(&self) -> bool {\n}\n\n    /// Acquires a mutable reference to the owned form of the data.\n    ///\n    /// Clones the data if it is not already owned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    ///\n    /// let mut cow = Cow::Borrowed(\"foo\");\n    /// cow.to_mut().make_ascii_uppercase();\n    ///\n    /// assert_eq!(\n    ///   cow,\n    ///   Cow::Owned(String::from(\"FOO\")) as Cow<str>\n    /// );\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn to_mut(&mut self) -> &mut <B as ToOwned>::Owned {\n}\n\n    /// Extracts the owned data.\n    ///\n    /// Clones the data if it is not already owned.\n    ///\n    /// # Examples\n    ///\n    /// Calling `into_owned` on a `Cow::Borrowed` clones the underlying data\n    /// and becomes a `Cow::Owned`:\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    ///\n    /// let s = \"Hello world!\";\n    /// let cow = Cow::Borrowed(s);\n    ///\n    /// assert_eq!(\n    ///   cow.into_owned(),\n    ///   String::from(s)\n    /// );\n    /// ```\n    ///\n    /// Calling `into_owned` on a `Cow::Owned` is a no-op:\n    ///\n    /// ```\n    /// use std::borrow::Cow;\n    ///\n    /// let s = \"Hello world!\";\n    /// let cow: Cow<str> = Cow::Owned(String::from(s));\n    ///\n    /// assert_eq!(\n    ///   cow.into_owned(),\n    ///   String::from(s)\n    /// );\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_owned(self) -> <B as ToOwned>::Owned {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: ?Sized + ToOwned> Deref for Cow<'_, B> {\n    type Target = B;\n\n    fn deref(&self) -> &B {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: ?Sized> Eq for Cow<'_, B> where B: Eq + ToOwned {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: ?Sized> Ord for Cow<'_, B>\nwhere\n    B: Ord + ToOwned,\n{\n    #[inline]\n    fn cmp(&self, other: &Self) -> Ordering {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B>\nwhere\n    B: PartialEq<C> + ToOwned,\n    C: ToOwned,\n{\n    #[inline]\n    fn eq(&self, other: &Cow<'b, C>) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, B: ?Sized> PartialOrd for Cow<'a, B>\nwhere\n    B: PartialOrd + ToOwned,\n{\n    #[inline]\n    fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: ?Sized> fmt::Debug for Cow<'_, B>\nwhere\n    B: fmt::Debug + ToOwned<Owned: fmt::Debug>,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: ?Sized> fmt::Display for Cow<'_, B>\nwhere\n    B: fmt::Display + ToOwned<Owned: fmt::Display>,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"default\", since = \"1.11.0\")]\nimpl<B: ?Sized> Default for Cow<'_, B>\nwhere\n    B: ToOwned<Owned: Default>,\n{\n    /// Creates an owned Cow<'a, B> with the default value for the contained owned value.\n    fn default() -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<B: ?Sized> Hash for Cow<'_, B>\nwhere\n    B: Hash + ToOwned,\n{\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + ToOwned> AsRef<T> for Cow<'_, T> {\n    fn as_ref(&self) -> &T {\n}\n}\n\n#[stable(feature = \"cow_add\", since = \"1.14.0\")]\nimpl<'a> Add<&'a str> for Cow<'a, str> {\n    type Output = Cow<'a, str>;\n\n    #[inline]\n    fn add(mut self, rhs: &'a str) -> Self::Output {\n}\n}\n\n#[stable(feature = \"cow_add\", since = \"1.14.0\")]\nimpl<'a> Add<Cow<'a, str>> for Cow<'a, str> {\n    type Output = Cow<'a, str>;\n\n    #[inline]\n    fn add(mut self, rhs: Cow<'a, str>) -> Self::Output {\n}\n}\n\n#[stable(feature = \"cow_add\", since = \"1.14.0\")]\nimpl<'a> AddAssign<&'a str> for Cow<'a, str> {\n    fn add_assign(&mut self, rhs: &'a str) {\n}\n}\n\n#[stable(feature = \"cow_add\", since = \"1.14.0\")]\nimpl<'a> AddAssign<Cow<'a, str>> for Cow<'a, str> {\n    fn add_assign(&mut self, rhs: Cow<'a, str>) {\n}\n}\n}\npub mod collections {\n//! Collection types.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\npub mod binary_heap {\n//! A priority queue implemented with a binary heap.\n//!\n//! Insertion and popping the largest element have `O(log n)` time complexity.\n//! Checking the largest element is `O(1)`. Converting a vector to a binary heap\n//! can be done in-place, and has `O(n)` complexity. A binary heap can also be\n//! converted to a sorted vector in-place, allowing it to be used for an `O(n\n//! log n)` in-place heapsort.\n//!\n//! # Examples\n//!\n//! This is a larger example that implements [Dijkstra's algorithm][dijkstra]\n//! to solve the [shortest path problem][sssp] on a [directed graph][dir_graph].\n//! It shows how to use [`BinaryHeap`] with custom types.\n//!\n//! [dijkstra]: http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n//! [sssp]: http://en.wikipedia.org/wiki/Shortest_path_problem\n//! [dir_graph]: http://en.wikipedia.org/wiki/Directed_graph\n//! [`BinaryHeap`]: struct.BinaryHeap.html\n//!\n//! ```\n//! use std::cmp::Ordering;\n//! use std::collections::BinaryHeap;\n//! use std::usize;\n//!\n//! #[derive(Copy, Clone, Eq, PartialEq)]\n//! struct State {\n//!     cost: usize,\n//!     position: usize,\n//! }\n//!\n//! // The priority queue depends on `Ord`.\n//! // Explicitly implement the trait so the queue becomes a min-heap\n//! // instead of a max-heap.\n//! impl Ord for State {\n//!     fn cmp(&self, other: &State) -> Ordering {\n//!         // Notice that the we flip the ordering on costs.\n//!         // In case of a tie we compare positions - this step is necessary\n//!         // to make implementations of `PartialEq` and `Ord` consistent.\n//!         other.cost.cmp(&self.cost)\n//!             .then_with(|| self.position.cmp(&other.position))\n//!     }\n//! }\n//!\n//! // `PartialOrd` needs to be implemented as well.\n//! impl PartialOrd for State {\n//!     fn partial_cmp(&self, other: &State) -> Option<Ordering> {\n//!         Some(self.cmp(other))\n//!     }\n//! }\n//!\n//! // Each node is represented as an `usize`, for a shorter implementation.\n//! struct Edge {\n//!     node: usize,\n//!     cost: usize,\n//! }\n//!\n//! // Dijkstra's shortest path algorithm.\n//!\n//! // Start at `start` and use `dist` to track the current shortest distance\n//! // to each node. This implementation isn't memory-efficient as it may leave duplicate\n//! // nodes in the queue. It also uses `usize::MAX` as a sentinel value,\n//! // for a simpler implementation.\n//! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: usize, goal: usize) -> Option<usize> {\n//!     // dist[node] = current shortest distance from `start` to `node`\n//!     let mut dist: Vec<_> = (0..adj_list.len()).map(|_| usize::MAX).collect();\n//!\n//!     let mut heap = BinaryHeap::new();\n//!\n//!     // We're at `start`, with a zero cost\n//!     dist[start] = 0;\n//!     heap.push(State { cost: 0, position: start });\n//!\n//!     // Examine the frontier with lower cost nodes first (min-heap)\n//!     while let Some(State { cost, position }) = heap.pop() {\n//!         // Alternatively we could have continued to find all shortest paths\n//!         if position == goal { return Some(cost); }\n//!\n//!         // Important as we may have already found a better way\n//!         if cost > dist[position] { continue; }\n//!\n//!         // For each node we can reach, see if we can find a way with\n//!         // a lower cost going through this node\n//!         for edge in &adj_list[position] {\n//!             let next = State { cost: cost + edge.cost, position: edge.node };\n//!\n//!             // If so, add it to the frontier and continue\n//!             if next.cost < dist[next.position] {\n//!                 heap.push(next);\n//!                 // Relaxation, we have now found a better way\n//!                 dist[next.position] = next.cost;\n//!             }\n//!         }\n//!     }\n//!\n//!     // Goal not reachable\n//!     None\n//! }\n//!\n//! fn main() {\n//!     // This is the directed graph we're going to use.\n//!     // The node numbers correspond to the different states,\n//!     // and the edge weights symbolize the cost of moving\n//!     // from one node to another.\n//!     // Note that the edges are one-way.\n//!     //\n//!     //                  7\n//!     //          +-----------------+\n//!     //          |                 |\n//!     //          v   1        2    |  2\n//!     //          0 -----> 1 -----> 3 ---> 4\n//!     //          |        ^        ^      ^\n//!     //          |        | 1      |      |\n//!     //          |        |        | 3    | 1\n//!     //          +------> 2 -------+      |\n//!     //           10      |               |\n//!     //                   +---------------+\n//!     //\n//!     // The graph is represented as an adjacency list where each index,\n//!     // corresponding to a node value, has a list of outgoing edges.\n//!     // Chosen for its efficiency.\n//!     let graph = vec![\n//!         // Node 0\n//!         vec![Edge { node: 2, cost: 10 },\n//!              Edge { node: 1, cost: 1 }],\n//!         // Node 1\n//!         vec![Edge { node: 3, cost: 2 }],\n//!         // Node 2\n//!         vec![Edge { node: 1, cost: 1 },\n//!              Edge { node: 3, cost: 3 },\n//!              Edge { node: 4, cost: 1 }],\n//!         // Node 3\n//!         vec![Edge { node: 0, cost: 7 },\n//!              Edge { node: 4, cost: 2 }],\n//!         // Node 4\n//!         vec![]];\n//!\n//!     assert_eq!(shortest_path(&graph, 0, 1), Some(1));\n//!     assert_eq!(shortest_path(&graph, 0, 3), Some(3));\n//!     assert_eq!(shortest_path(&graph, 3, 0), Some(7));\n//!     assert_eq!(shortest_path(&graph, 0, 4), Some(5));\n//!     assert_eq!(shortest_path(&graph, 4, 0), None);\n//! }\n//! ```\n\n#![allow(missing_docs)]\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::fmt;\nuse core::iter::{FromIterator, FusedIterator, TrustedLen};\nuse core::mem::{size_of, swap, ManuallyDrop};\nuse core::ops::{Deref, DerefMut};\nuse core::ptr;\n\nuse crate::slice;\nuse crate::vec::{self, Vec};\n\nuse super::SpecExtend;\n\n/// A priority queue implemented with a binary heap.\n///\n/// This will be a max-heap.\n///\n/// It is a logic error for an item to be modified in such a way that the\n/// item's ordering relative to any other item, as determined by the `Ord`\n/// trait, changes while it is in the heap. This is normally only possible\n/// through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::BinaryHeap;\n///\n/// // Type inference lets us omit an explicit type signature (which\n/// // would be `BinaryHeap<i32>` in this example).\n/// let mut heap = BinaryHeap::new();\n///\n/// // We can use peek to look at the next item in the heap. In this case,\n/// // there's no items in there yet so we get None.\n/// assert_eq!(heap.peek(), None);\n///\n/// // Let's add some scores...\n/// heap.push(1);\n/// heap.push(5);\n/// heap.push(2);\n///\n/// // Now peek shows the most important item in the heap.\n/// assert_eq!(heap.peek(), Some(&5));\n///\n/// // We can check the length of a heap.\n/// assert_eq!(heap.len(), 3);\n///\n/// // We can iterate over the items in the heap, although they are returned in\n/// // a random order.\n/// for x in &heap {\n///     println!(\"{}\", x);\n/// }\n///\n/// // If we instead pop these scores, they should come back in order.\n/// assert_eq!(heap.pop(), Some(5));\n/// assert_eq!(heap.pop(), Some(2));\n/// assert_eq!(heap.pop(), Some(1));\n/// assert_eq!(heap.pop(), None);\n///\n/// // We can clear the heap of any remaining items.\n/// heap.clear();\n///\n/// // The heap should now be empty.\n/// assert!(heap.is_empty())\n/// ```\n///\n/// ## Min-heap\n///\n/// Either `std::cmp::Reverse` or a custom `Ord` implementation can be used to\n/// make `BinaryHeap` a min-heap. This makes `heap.pop()` return the smallest\n/// value instead of the greatest one.\n///\n/// ```\n/// use std::collections::BinaryHeap;\n/// use std::cmp::Reverse;\n///\n/// let mut heap = BinaryHeap::new();\n///\n/// // Wrap values in `Reverse`\n/// heap.push(Reverse(1));\n/// heap.push(Reverse(5));\n/// heap.push(Reverse(2));\n///\n/// // If we pop these scores now, they should come back in the reverse order.\n/// assert_eq!(heap.pop(), Some(Reverse(1)));\n/// assert_eq!(heap.pop(), Some(Reverse(2)));\n/// assert_eq!(heap.pop(), Some(Reverse(5)));\n/// assert_eq!(heap.pop(), None);\n/// ```\n///\n/// # Time complexity\n///\n/// | [push] | [pop]    | [peek]/[peek\\_mut] |\n/// |--------|----------|--------------------|\n/// | O(1)~  | O(log n) | O(1)               |\n///\n/// The value for `push` is an expected cost; the method documentation gives a\n/// more detailed analysis.\n///\n/// [push]: #method.push\n/// [pop]: #method.pop\n/// [peek]: #method.peek\n/// [peek\\_mut]: #method.peek_mut\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct BinaryHeap<T> {\n    data: Vec<T>,\n}\n\n/// Structure wrapping a mutable reference to the greatest item on a\n/// `BinaryHeap`.\n///\n/// This `struct` is created by the [`peek_mut`] method on [`BinaryHeap`]. See\n/// its documentation for more.\n///\n/// [`peek_mut`]: struct.BinaryHeap.html#method.peek_mut\n/// [`BinaryHeap`]: struct.BinaryHeap.html\n#[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\npub struct PeekMut<'a, T: 'a + Ord> {\n    heap: &'a mut BinaryHeap<T>,\n    sift: bool,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: Ord + fmt::Debug> fmt::Debug for PeekMut<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\nimpl<T: Ord> Drop for PeekMut<'_, T> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\nimpl<T: Ord> Deref for PeekMut<'_, T> {\n    type Target = T;\n    fn deref(&self) -> &T {\n}\n}\n\n#[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\nimpl<T: Ord> DerefMut for PeekMut<'_, T> {\n    fn deref_mut(&mut self) -> &mut T {\n}\n}\n\nimpl<'a, T: Ord> PeekMut<'a, T> {\n    /// Removes the peeked value from the heap and returns it.\n    #[stable(feature = \"binary_heap_peek_mut_pop\", since = \"1.18.0\")]\n    pub fn pop(mut this: PeekMut<'a, T>) -> T {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> Clone for BinaryHeap<T> {\n    fn clone(&self) -> Self {\n}\n\n    fn clone_from(&mut self, source: &Self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord> Default for BinaryHeap<T> {\n    /// Creates an empty `BinaryHeap<T>`.\n    #[inline]\n    fn default() -> BinaryHeap<T> {\n}\n}\n\n#[stable(feature = \"binaryheap_debug\", since = \"1.4.0\")]\nimpl<T: fmt::Debug> fmt::Debug for BinaryHeap<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<T: Ord> BinaryHeap<T> {\n    /// Creates an empty `BinaryHeap` as a max-heap.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::new();\n    /// heap.push(4);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> BinaryHeap<T> {\n}\n\n    /// Creates an empty `BinaryHeap` with a specific capacity.\n    /// This preallocates enough memory for `capacity` elements,\n    /// so that the `BinaryHeap` does not have to be reallocated\n    /// until it contains at least that many values.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::with_capacity(10);\n    /// heap.push(4);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> BinaryHeap<T> {\n}\n\n    /// Returns a mutable reference to the greatest item in the binary heap, or\n    /// `None` if it is empty.\n    ///\n    /// Note: If the `PeekMut` value is leaked, the heap may be in an\n    /// inconsistent state.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::new();\n    /// assert!(heap.peek_mut().is_none());\n    ///\n    /// heap.push(1);\n    /// heap.push(5);\n    /// heap.push(2);\n    /// {\n    ///     let mut val = heap.peek_mut().unwrap();\n    ///     *val = 0;\n    /// }\n    /// assert_eq!(heap.peek(), Some(&2));\n    /// ```\n    ///\n    /// # Time complexity\n    ///\n    /// Cost is O(1) in the worst case.\n    #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n    pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n}\n\n    /// Removes the greatest item from the binary heap and returns it, or `None` if it\n    /// is empty.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::from(vec![1, 3]);\n    ///\n    /// assert_eq!(heap.pop(), Some(3));\n    /// assert_eq!(heap.pop(), Some(1));\n    /// assert_eq!(heap.pop(), None);\n    /// ```\n    ///\n    /// # Time complexity\n    ///\n    /// The worst case cost of `pop` on a heap containing *n* elements is O(log\n    /// n).\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop(&mut self) -> Option<T> {\n}\n\n    /// Pushes an item onto the binary heap.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::new();\n    /// heap.push(3);\n    /// heap.push(5);\n    /// heap.push(1);\n    ///\n    /// assert_eq!(heap.len(), 3);\n    /// assert_eq!(heap.peek(), Some(&5));\n    /// ```\n    ///\n    /// # Time complexity\n    ///\n    /// The expected cost of `push`, averaged over every possible ordering of\n    /// the elements being pushed, and over a sufficiently large number of\n    /// pushes, is O(1). This is the most meaningful cost metric when pushing\n    /// elements that are *not* already in any sorted pattern.\n    ///\n    /// The time complexity degrades if elements are pushed in predominantly\n    /// ascending order. In the worst case, elements are pushed in ascending\n    /// sorted order and the amortized cost per push is O(log n) against a heap\n    /// containing *n* elements.\n    ///\n    /// The worst case cost of a *single* call to `push` is O(n). The worst case\n    /// occurs when capacity is exhausted and needs a resize. The resize cost\n    /// has been amortized in the previous figures.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push(&mut self, item: T) {\n}\n\n    /// Consumes the `BinaryHeap` and returns a vector in sorted\n    /// (ascending) order.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    ///\n    /// let mut heap = BinaryHeap::from(vec![1, 2, 4, 5, 7]);\n    /// heap.push(6);\n    /// heap.push(3);\n    ///\n    /// let vec = heap.into_sorted_vec();\n    /// assert_eq!(vec, [1, 2, 3, 4, 5, 6, 7]);\n    /// ```\n    #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n    pub fn into_sorted_vec(mut self) -> Vec<T> {\n}\n\n    // The implementations of sift_up and sift_down use unsafe blocks in\n    // order to move an element out of the vector (leaving behind a\n    // hole), shift along the others and move the removed element back into the\n    // vector at the final location of the hole.\n    // The `Hole` type is used to represent this, and make sure\n    // the hole is filled back at the end of its scope, even on panic.\n    // Using a hole reduces the constant factor compared to using swaps,\n    // which involves twice as many moves.\n    fn sift_up(&mut self, start: usize, pos: usize) -> usize {\n}\n\n    /// Take an element at `pos` and move it down the heap,\n    /// while its children are larger.\n    fn sift_down_range(&mut self, pos: usize, end: usize) {\n}\n\n    fn sift_down(&mut self, pos: usize) {\n}\n\n    /// Take an element at `pos` and move it all the way down the heap,\n    /// then sift it up to its position.\n    ///\n    /// Note: This is faster when the element is known to be large / should\n    /// be closer to the bottom.\n    fn sift_down_to_bottom(&mut self, mut pos: usize) {\n}\n\n    fn rebuild(&mut self) {\n}\n\n    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    ///\n    /// let v = vec![-10, 1, 2, 3, 3];\n    /// let mut a = BinaryHeap::from(v);\n    ///\n    /// let v = vec![-20, 5, 43];\n    /// let mut b = BinaryHeap::from(v);\n    ///\n    /// a.append(&mut b);\n    ///\n    /// assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n    /// assert!(b.is_empty());\n    /// ```\n    #[stable(feature = \"binary_heap_append\", since = \"1.11.0\")]\n    pub fn append(&mut self, other: &mut Self) {\n}\n\n    /// Returns an iterator which retrieves elements in heap order.\n    /// The retrieved elements are removed from the original heap.\n    /// The remaining elements will be removed on drop in heap order.\n    ///\n    /// Note:\n    /// * `.drain_sorted()` is O(n lg n); much slower than `.drain()`.\n    ///   You should use the latter for most cases.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(binary_heap_drain_sorted)]\n    /// use std::collections::BinaryHeap;\n    ///\n    /// let mut heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);\n    /// assert_eq!(heap.len(), 5);\n    ///\n    /// drop(heap.drain_sorted()); // removes all elements in heap order\n    /// assert_eq!(heap.len(), 0);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n    pub fn drain_sorted(&mut self) -> DrainSorted<'_, T> {\n}\n}\n\nimpl<T> BinaryHeap<T> {\n    /// Returns an iterator visiting all values in the underlying vector, in\n    /// arbitrary order.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4]);\n    ///\n    /// // Print 1, 2, 3, 4 in arbitrary order\n    /// for x in heap.iter() {\n    ///     println!(\"{}\", x);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, T> {\n}\n\n    /// Returns an iterator which retrieves elements in heap order.\n    /// This method consumes the original heap.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(binary_heap_into_iter_sorted)]\n    /// use std::collections::BinaryHeap;\n    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);\n    ///\n    /// assert_eq!(heap.into_iter_sorted().take(2).collect::<Vec<_>>(), vec![5, 4]);\n    /// ```\n    #[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n    pub fn into_iter_sorted(self) -> IntoIterSorted<T> {\n}\n\n    /// Returns the greatest item in the binary heap, or `None` if it is empty.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::new();\n    /// assert_eq!(heap.peek(), None);\n    ///\n    /// heap.push(1);\n    /// heap.push(5);\n    /// heap.push(2);\n    /// assert_eq!(heap.peek(), Some(&5));\n    ///\n    /// ```\n    ///\n    /// # Time complexity\n    ///\n    /// Cost is O(1) in the worst case.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn peek(&self) -> Option<&T> {\n}\n\n    /// Returns the number of elements the binary heap can hold without reallocating.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::with_capacity(100);\n    /// assert!(heap.capacity() >= 100);\n    /// heap.push(4);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n}\n\n    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n    /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it requests. Therefore\n    /// capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n    /// insertions are expected.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::new();\n    /// heap.reserve_exact(100);\n    /// assert!(heap.capacity() >= 100);\n    /// heap.push(4);\n    /// ```\n    ///\n    /// [`reserve`]: #method.reserve\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve_exact(&mut self, additional: usize) {\n}\n\n    /// Reserves capacity for at least `additional` more elements to be inserted in the\n    /// `BinaryHeap`. The collection may reserve more space to avoid frequent reallocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::new();\n    /// heap.reserve(100);\n    /// assert!(heap.capacity() >= 100);\n    /// heap.push(4);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n}\n\n    /// Discards as much additional capacity as possible.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n    ///\n    /// assert!(heap.capacity() >= 100);\n    /// heap.shrink_to_fit();\n    /// assert!(heap.capacity() == 0);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n}\n\n    /// Discards capacity with a lower bound.\n    ///\n    /// The capacity will remain at least as large as both the length\n    /// and the supplied value.\n    ///\n    /// Panics if the current capacity is smaller than the supplied\n    /// minimum capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(shrink_to)]\n    /// use std::collections::BinaryHeap;\n    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n    ///\n    /// assert!(heap.capacity() >= 100);\n    /// heap.shrink_to(10);\n    /// assert!(heap.capacity() >= 10);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n}\n\n    /// Consumes the `BinaryHeap` and returns the underlying vector\n    /// in arbitrary order.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);\n    /// let vec = heap.into_vec();\n    ///\n    /// // Will print in some order\n    /// for x in vec {\n    ///     println!(\"{}\", x);\n    /// }\n    /// ```\n    #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n    pub fn into_vec(self) -> Vec<T> {\n}\n\n    /// Returns the length of the binary heap.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let heap = BinaryHeap::from(vec![1, 3]);\n    ///\n    /// assert_eq!(heap.len(), 2);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n}\n\n    /// Checks if the binary heap is empty.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::new();\n    ///\n    /// assert!(heap.is_empty());\n    ///\n    /// heap.push(3);\n    /// heap.push(5);\n    /// heap.push(1);\n    ///\n    /// assert!(!heap.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n}\n\n    /// Clears the binary heap, returning an iterator over the removed elements.\n    ///\n    /// The elements are removed in arbitrary order.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::from(vec![1, 3]);\n    ///\n    /// assert!(!heap.is_empty());\n    ///\n    /// for x in heap.drain() {\n    ///     println!(\"{}\", x);\n    /// }\n    ///\n    /// assert!(heap.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain(&mut self) -> Drain<'_, T> {\n}\n\n    /// Drops all items from the binary heap.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BinaryHeap;\n    /// let mut heap = BinaryHeap::from(vec![1, 3]);\n    ///\n    /// assert!(!heap.is_empty());\n    ///\n    /// heap.clear();\n    ///\n    /// assert!(heap.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n}\n}\n\n/// Hole represents a hole in a slice i.e., an index without valid value\n/// (because it was moved from or duplicated).\n/// In drop, `Hole` will restore the slice by filling the hole\n/// position with the value that was originally removed.\nstruct Hole<'a, T: 'a> {\n    data: &'a mut [T],\n    elt: ManuallyDrop<T>,\n    pos: usize,\n}\n\nimpl<'a, T> Hole<'a, T> {\n    /// Create a new `Hole` at index `pos`.\n    ///\n    /// Unsafe because pos must be within the data slice.\n    #[inline]\n    unsafe fn new(data: &'a mut [T], pos: usize) -> Self {\n}\n\n    #[inline]\n    fn pos(&self) -> usize {\n}\n\n    /// Returns a reference to the element removed.\n    #[inline]\n    fn element(&self) -> &T {\n}\n\n    /// Returns a reference to the element at `index`.\n    ///\n    /// Unsafe because index must be within the data slice and not equal to pos.\n    #[inline]\n    unsafe fn get(&self, index: usize) -> &T {\n}\n\n    /// Move hole to new location\n    ///\n    /// Unsafe because index must be within the data slice and not equal to pos.\n    #[inline]\n    unsafe fn move_to(&mut self, index: usize) {\n}\n}\n\nimpl<T> Drop for Hole<'_, T> {\n    #[inline]\n    fn drop(&mut self) {\n}\n}\n\n/// An iterator over the elements of a `BinaryHeap`.\n///\n/// This `struct` is created by the [`iter`] method on [`BinaryHeap`]. See its\n/// documentation for more.\n///\n/// [`iter`]: struct.BinaryHeap.html#method.iter\n/// [`BinaryHeap`]: struct.BinaryHeap.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> {\n    iter: slice::Iter<'a, T>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Iter<'_, T> {\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn last(self) -> Option<&'a T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for Iter<'_, T> {\n    fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for Iter<'_, T> {}\n\n/// An owning iterator over the elements of a `BinaryHeap`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`BinaryHeap`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`into_iter`]: struct.BinaryHeap.html#method.into_iter\n/// [`BinaryHeap`]: struct.BinaryHeap.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Clone)]\npub struct IntoIter<T> {\n    iter: vec::IntoIter<T>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for IntoIter<T> {\n    fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for IntoIter<T> {}\n\n#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n#[derive(Clone, Debug)]\npub struct IntoIterSorted<T> {\n}\n\n#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\nimpl<T: Ord> Iterator for IntoIterSorted<T> {\n}\n\n#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\nimpl<T: Ord> ExactSizeIterator for IntoIterSorted<T> {}}\nmod btree {\npub mod map {\nuse core::borrow::Borrow;\nuse core::cmp::Ordering;\nuse core::fmt::Debug;\nuse core::hash::{Hash, Hasher};\nuse core::iter::{FromIterator, FusedIterator, Peekable};\nuse core::marker::PhantomData;\nuse core::ops::Bound::{Excluded, Included, Unbounded};\nuse core::ops::{Index, RangeBounds};\nuse core::{fmt, intrinsics, mem, ptr};\n\nuse super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\nuse super::search::{self, SearchResult::*};\n\nuse Entry::*;\nuse UnderflowResult::*;\n\n/// A map based on a B-Tree.\n///\n/// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\n/// the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal\n/// choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of\n/// comparisons necessary to find an element (log<sub>2</sub>n). However, in practice the way this\n/// is done is *very* inefficient for modern computer architectures. In particular, every element\n/// is stored in its own individually heap-allocated node. This means that every single insertion\n/// triggers a heap-allocation, and every single comparison should be a cache-miss. Since these\n/// are both notably expensive things to do in practice, we are forced to at very least reconsider\n/// the BST strategy.\n///\n/// A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing\n/// this, we reduce the number of allocations by a factor of B, and improve cache efficiency in\n/// searches. However, this does mean that searches will have to do *more* comparisons on average.\n/// The precise number of comparisons depends on the node search strategy used. For optimal cache\n/// efficiency, one could search the nodes linearly. For optimal comparisons, one could search\n/// the node using binary search. As a compromise, one could also perform a linear search\n/// that initially only checks every i<sup>th</sup> element for some choice of i.\n///\n/// Currently, our implementation simply performs naive linear search. This provides excellent\n/// performance on *small* nodes of elements which are cheap to compare. However in the future we\n/// would like to further explore choosing the optimal search strategy based on the choice of B,\n/// and possibly other factors. Using linear search, searching for a random element is expected\n/// to take O(B log<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice,\n/// however, performance is excellent.\n///\n/// It is a logic error for a key to be modified in such a way that the key's ordering relative to\n/// any other key, as determined by the [`Ord`] trait, changes while it is in the map. This is\n/// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n///\n/// [`Ord`]: ../../std/cmp/trait.Ord.html\n/// [`Cell`]: ../../std/cell/struct.Cell.html\n/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::BTreeMap;\n///\n/// // type inference lets us omit an explicit type signature (which\n/// // would be `BTreeMap<&str, &str>` in this example).\n/// let mut movie_reviews = BTreeMap::new();\n///\n/// // review some movies.\n/// movie_reviews.insert(\"Office Space\",       \"Deals with real issues in the workplace.\");\n/// movie_reviews.insert(\"Pulp Fiction\",       \"Masterpiece.\");\n/// movie_reviews.insert(\"The Godfather\",      \"Very enjoyable.\");\n/// movie_reviews.insert(\"The Blues Brothers\", \"Eye lyked it a lot.\");\n///\n/// // check for a specific one.\n/// if !movie_reviews.contains_key(\"Les Misérables\") {\n///     println!(\"We've got {} reviews, but Les Misérables ain't one.\",\n///              movie_reviews.len());\n/// }\n///\n/// // oops, this review has a lot of spelling mistakes, let's delete it.\n/// movie_reviews.remove(\"The Blues Brothers\");\n///\n/// // look up the values associated with some keys.\n/// let to_find = [\"Up!\", \"Office Space\"];\n/// for movie in &to_find {\n///     match movie_reviews.get(movie) {\n///        Some(review) => println!(\"{}: {}\", movie, review),\n///        None => println!(\"{} is unreviewed.\", movie)\n///     }\n/// }\n///\n/// // Look up the value for a key (will panic if the key is not found).\n/// println!(\"Movie review: {}\", movie_reviews[\"Office Space\"]);\n///\n/// // iterate over everything.\n/// for (movie, review) in &movie_reviews {\n///     println!(\"{}: \\\"{}\\\"\", movie, review);\n/// }\n/// ```\n///\n/// `BTreeMap` also implements an [`Entry API`](#method.entry), which allows\n/// for more complex methods of getting, setting, updating and removing keys and\n/// their values:\n///\n/// ```\n/// use std::collections::BTreeMap;\n///\n/// // type inference lets us omit an explicit type signature (which\n/// // would be `BTreeMap<&str, u8>` in this example).\n/// let mut player_stats = BTreeMap::new();\n///\n/// fn random_stat_buff() -> u8 {\n///     // could actually return some random value here - let's just return\n///     // some fixed value for now\n///     42\n/// }\n///\n/// // insert a key only if it doesn't already exist\n/// player_stats.entry(\"health\").or_insert(100);\n///\n/// // insert a key using a function that provides a new value only if it\n/// // doesn't already exist\n/// player_stats.entry(\"defence\").or_insert_with(random_stat_buff);\n///\n/// // update a key, guarding against the key possibly not being set\n/// let stat = player_stats.entry(\"attack\").or_insert(100);\n/// *stat += random_stat_buff();\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct BTreeMap<K, V> {\n    root: node::Root<K, V>,\n    length: usize,\n}\n\n#[stable(feature = \"btree_drop\", since = \"1.7.0\")]\nunsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for BTreeMap<K, V> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n    fn clone(&self) -> BTreeMap<K, V> {\n}\n}\n\nimpl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\nwhere\n    K: Borrow<Q> + Ord,\n    Q: Ord,\n{\n    type Key = K;\n\n    fn get(&self, key: &Q) -> Option<&K> {\n}\n\n    fn take(&mut self, key: &Q) -> Option<K> {\n}\n\n    fn replace(&mut self, key: K) -> Option<K> {\n}\n}\n\n/// An iterator over the entries of a `BTreeMap`.\n///\n/// This `struct` is created by the [`iter`] method on [`BTreeMap`]. See its\n/// documentation for more.\n///\n/// [`iter`]: struct.BTreeMap.html#method.iter\n/// [`BTreeMap`]: struct.BTreeMap.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, K: 'a, V: 'a> {\n    range: Range<'a, K, V>,\n    length: usize,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Iter<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A mutable iterator over the entries of a `BTreeMap`.\n///\n/// This `struct` is created by the [`iter_mut`] method on [`BTreeMap`]. See its\n/// documentation for more.\n///\n/// [`iter_mut`]: struct.BTreeMap.html#method.iter_mut\n/// [`BTreeMap`]: struct.BTreeMap.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct IterMut<'a, K: 'a, V: 'a> {\n    range: RangeMut<'a, K, V>,\n    length: usize,\n}\n\n/// An owning iterator over the entries of a `BTreeMap`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`BTreeMap`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`into_iter`]: struct.BTreeMap.html#method.into_iter\n/// [`BTreeMap`]: struct.BTreeMap.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<K, V> {\n    front: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n    back: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n    length: usize,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// An iterator over the keys of a `BTreeMap`.\n///\n/// This `struct` is created by the [`keys`] method on [`BTreeMap`]. See its\n/// documentation for more.\n///\n/// [`keys`]: struct.BTreeMap.html#method.keys\n/// [`BTreeMap`]: struct.BTreeMap.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Keys<'a, K: 'a, V: 'a> {\n    inner: Iter<'a, K, V>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<K: fmt::Debug, V> fmt::Debug for Keys<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// An iterator over the values of a `BTreeMap`.\n///\n/// This `struct` is created by the [`values`] method on [`BTreeMap`]. See its\n/// documentation for more.\n///\n/// [`values`]: struct.BTreeMap.html#method.values\n/// [`BTreeMap`]: struct.BTreeMap.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Values<'a, K: 'a, V: 'a> {\n    inner: Iter<'a, K, V>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<K, V: fmt::Debug> fmt::Debug for Values<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A mutable iterator over the values of a `BTreeMap`.\n///\n/// This `struct` is created by the [`values_mut`] method on [`BTreeMap`]. See its\n/// documentation for more.\n///\n/// [`values_mut`]: struct.BTreeMap.html#method.values_mut\n/// [`BTreeMap`]: struct.BTreeMap.html\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n#[derive(Debug)]\npub struct ValuesMut<'a, K: 'a, V: 'a> {\n    inner: IterMut<'a, K, V>,\n}\n\n/// An iterator over a sub-range of entries in a `BTreeMap`.\n///\n/// This `struct` is created by the [`range`] method on [`BTreeMap`]. See its\n/// documentation for more.\n///\n/// [`range`]: struct.BTreeMap.html#method.range\n/// [`BTreeMap`]: struct.BTreeMap.html\n#[stable(feature = \"btree_range\", since = \"1.17.0\")]\npub struct Range<'a, K: 'a, V: 'a> {\n    front: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n    back: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Range<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A mutable iterator over a sub-range of entries in a `BTreeMap`.\n///\n/// This `struct` is created by the [`range_mut`] method on [`BTreeMap`]. See its\n/// documentation for more.\n///\n/// [`range_mut`]: struct.BTreeMap.html#method.range_mut\n/// [`BTreeMap`]: struct.BTreeMap.html\n#[stable(feature = \"btree_range\", since = \"1.17.0\")]\npub struct RangeMut<'a, K: 'a, V: 'a> {\n    front: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n    back: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n\n    // Be invariant in `K` and `V`\n    _marker: PhantomData<&'a mut (K, V)>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A view into a single entry in a map, which may either be vacant or occupied.\n///\n/// This `enum` is constructed from the [`entry`] method on [`BTreeMap`].\n///\n/// [`BTreeMap`]: struct.BTreeMap.html\n/// [`entry`]: struct.BTreeMap.html#method.entry\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub enum Entry<'a, K: 'a, V: 'a> {\n    /// A vacant entry.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n\n    /// An occupied entry.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n}\n\n#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\nimpl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A view into a vacant entry in a `BTreeMap`.\n/// It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct VacantEntry<'a, K: 'a, V: 'a> {\n    key: K,\n    handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n    length: &'a mut usize,\n\n    // Be invariant in `K` and `V`\n    _marker: PhantomData<&'a mut (K, V)>,\n}\n\n#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\nimpl<K: Debug + Ord, V> Debug for VacantEntry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A view into an occupied entry in a `BTreeMap`.\n/// It is part of the [`Entry`] enum.\n///\n/// [`Entry`]: enum.Entry.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n    handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n\n    length: &'a mut usize,\n\n    // Be invariant in `K` and `V`\n    _marker: PhantomData<&'a mut (K, V)>,\n}\n\n#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\nimpl<K: Debug + Ord, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n// An iterator for merging two sorted sequences into one\nstruct MergeIter<K, V, I: Iterator<Item = (K, V)>> {\n    left: Peekable<I>,\n    right: Peekable<I>,\n}\n\nimpl<K: Ord, V> BTreeMap<K, V> {\n    /// Makes a new empty BTreeMap with a reasonable choice for B.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    ///\n    /// // entries can now be inserted into the empty map\n    /// map.insert(1, \"a\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> BTreeMap<K, V> {\n}\n\n    /// Clears the map, removing all elements.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut a = BTreeMap::new();\n    /// a.insert(1, \"a\");\n    /// a.clear();\n    /// assert!(a.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n}\n\n    /// Returns a reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.get(&1), Some(&\"a\"));\n    /// assert_eq!(map.get(&2), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>\n    where\n        K: Borrow<Q>,\n        Q: Ord,\n    {\n}\n\n    /// Returns the key-value pair corresponding to the supplied key.\n    ///\n    /// The supplied key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\n    /// assert_eq!(map.get_key_value(&2), None);\n    /// ```\n    #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n    pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n    where\n        K: Borrow<Q>,\n        Q: Ord,\n    {\n}\n\n    /// Returns the first key-value pair in the map.\n    /// The key in this pair is the minimum key in the map.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(map_first_last)]\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// assert_eq!(map.first_key_value(), None);\n    /// map.insert(1, \"b\");\n    /// map.insert(2, \"a\");\n    /// assert_eq!(map.first_key_value(), Some((&1, &\"b\")));\n    /// ```\n    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n    pub fn first_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n    where\n        T: Ord,\n        K: Borrow<T>,\n    {\n}\n\n    /// Returns the first entry in the map for in-place manipulation.\n    /// The key of this entry is the minimum key in the map.\n    ///\n    /// # Examples\n    ///\n    /// Contrived way to `clear` a map:\n    ///\n    /// ```\n    /// #![feature(map_first_last)]\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert(1, \"a\");\n    /// map.insert(2, \"b\");\n    /// while let Some(entry) = map.first_entry() {\n    ///     let (key, val) = entry.remove_entry();\n    ///     assert!(!map.contains_key(&key));\n    /// }\n    /// ```\n    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n    pub fn first_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n    where\n        T: Ord,\n        K: Borrow<T>,\n    {\n}\n\n    /// Returns the last key-value pair in the map.\n    /// The key in this pair is the maximum key in the map.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(map_first_last)]\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert(1, \"b\");\n    /// map.insert(2, \"a\");\n    /// assert_eq!(map.last_key_value(), Some((&2, &\"a\")));\n    /// ```\n    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n    pub fn last_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n    where\n        T: Ord,\n        K: Borrow<T>,\n    {\n}\n\n    /// Returns the last entry in the map for in-place manipulation.\n    /// The key of this entry is the maximum key in the map.\n    ///\n    /// # Examples\n    ///\n    /// Contrived way to `clear` a map:\n    ///\n    /// ```\n    /// #![feature(map_first_last)]\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert(1, \"a\");\n    /// map.insert(2, \"b\");\n    /// while let Some(entry) = map.last_entry() {\n    ///     let (key, val) = entry.remove_entry();\n    ///     assert!(!map.contains_key(&key));\n    /// }\n    /// ```\n    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n    pub fn last_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n    where\n        T: Ord,\n        K: Borrow<T>,\n    {\n}\n\n    /// Returns `true` if the map contains a value for the specified key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.contains_key(&1), true);\n    /// assert_eq!(map.contains_key(&2), false);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n    where\n        K: Borrow<Q>,\n        Q: Ord,\n    {\n}\n\n    /// Returns a mutable reference to the value corresponding to the key.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert(1, \"a\");\n    /// if let Some(x) = map.get_mut(&1) {\n    ///     *x = \"b\";\n    /// }\n    /// assert_eq!(map[&1], \"b\");\n    /// ```\n    // See `get` for implementation notes, this is basically a copy-paste with mut's added\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>\n    where\n        K: Borrow<Q>,\n        Q: Ord,\n    {\n}\n\n    /// Inserts a key-value pair into the map.\n    ///\n    /// If the map did not have this key present, `None` is returned.\n    ///\n    /// If the map did have this key present, the value is updated, and the old\n    /// value is returned. The key is not updated, though; this matters for\n    /// types that can be `==` without being identical. See the [module-level\n    /// documentation] for more.\n    ///\n    /// [module-level documentation]: index.html#insert-and-complex-keys\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// assert_eq!(map.insert(37, \"a\"), None);\n    /// assert_eq!(map.is_empty(), false);\n    ///\n    /// map.insert(37, \"b\");\n    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n    /// assert_eq!(map[&37], \"c\");\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n}\n\n    /// Removes a key from the map, returning the value at the key if the key\n    /// was previously in the map.\n    ///\n    /// The key may be any borrowed form of the map's key type, but the ordering\n    /// on the borrowed form *must* match the ordering on the key type.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert(1, \"a\");\n    /// assert_eq!(map.remove(&1), Some(\"a\"));\n    /// assert_eq!(map.remove(&1), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n    where\n        K: Borrow<Q>,\n        Q: Ord,\n    {\n}\n\n    /// Moves all elements from `other` into `Self`, leaving `other` empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut a = BTreeMap::new();\n    /// a.insert(1, \"a\");\n    /// a.insert(2, \"b\");\n    /// a.insert(3, \"c\");\n    ///\n    /// let mut b = BTreeMap::new();\n    /// b.insert(3, \"d\");\n    /// b.insert(4, \"e\");\n    /// b.insert(5, \"f\");\n    ///\n    /// a.append(&mut b);\n    ///\n    /// assert_eq!(a.len(), 5);\n    /// assert_eq!(b.len(), 0);\n    ///\n    /// assert_eq!(a[&1], \"a\");\n    /// assert_eq!(a[&2], \"b\");\n    /// assert_eq!(a[&3], \"d\");\n    /// assert_eq!(a[&4], \"e\");\n    /// assert_eq!(a[&5], \"f\");\n    /// ```\n    #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n    pub fn append(&mut self, other: &mut Self) {\n}\n\n    /// Constructs a double-ended iterator over a sub-range of elements in the map.\n    /// The simplest way is to use the range syntax `min..max`, thus `range(min..max)` will\n    /// yield elements from min (inclusive) to max (exclusive).\n    /// The range may also be entered as `(Bound<T>, Bound<T>)`, so for example\n    /// `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive\n    /// range from 4 to 10.\n    ///\n    /// # Panics\n    ///\n    /// Panics if range `start > end`.\n    /// Panics if range `start == end` and both bounds are `Excluded`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    /// use std::ops::Bound::Included;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert(3, \"a\");\n    /// map.insert(5, \"b\");\n    /// map.insert(8, \"c\");\n    /// for (&key, &value) in map.range((Included(&4), Included(&8))) {\n    ///     println!(\"{}: {}\", key, value);\n    /// }\n    /// assert_eq!(Some((&5, &\"b\")), map.range(4..).next());\n    /// ```\n    #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n    pub fn range<T: ?Sized, R>(&self, range: R) -> Range<'_, K, V>\n    where\n        T: Ord,\n        K: Borrow<T>,\n        R: RangeBounds<T>,\n    {\n}\n\n    /// Constructs a mutable double-ended iterator over a sub-range of elements in the map.\n    /// The simplest way is to use the range syntax `min..max`, thus `range(min..max)` will\n    /// yield elements from min (inclusive) to max (exclusive).\n    /// The range may also be entered as `(Bound<T>, Bound<T>)`, so for example\n    /// `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive\n    /// range from 4 to 10.\n    ///\n    /// # Panics\n    ///\n    /// Panics if range `start > end`.\n    /// Panics if range `start == end` and both bounds are `Excluded`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map: BTreeMap<&str, i32> = [\"Alice\", \"Bob\", \"Carol\", \"Cheryl\"]\n    ///     .iter()\n    ///     .map(|&s| (s, 0))\n    ///     .collect();\n    /// for (_, balance) in map.range_mut(\"B\"..\"Cheryl\") {\n    ///     *balance += 100;\n    /// }\n    /// for (name, balance) in &map {\n    ///     println!(\"{} => {}\", name, balance);\n    /// }\n    /// ```\n    #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n    pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<'_, K, V>\n    where\n        T: Ord,\n        K: Borrow<T>,\n        R: RangeBounds<T>,\n    {\n}\n\n    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n    ///\n    /// // count the number of occurrences of letters in the vec\n    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"] {\n    ///     *count.entry(x).or_insert(0) += 1;\n    /// }\n    ///\n    /// assert_eq!(count[\"a\"], 3);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n}\n\n    fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n}\n\n    fn fix_right_edge(&mut self) {\n}\n\n    /// Splits the collection into two at the given key. Returns everything after the given key,\n    /// including the key.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut a = BTreeMap::new();\n    /// a.insert(1, \"a\");\n    /// a.insert(2, \"b\");\n    /// a.insert(3, \"c\");\n    /// a.insert(17, \"d\");\n    /// a.insert(41, \"e\");\n    ///\n    /// let b = a.split_off(&3);\n    ///\n    /// assert_eq!(a.len(), 2);\n    /// assert_eq!(b.len(), 3);\n    ///\n    /// assert_eq!(a[&1], \"a\");\n    /// assert_eq!(a[&2], \"b\");\n    ///\n    /// assert_eq!(b[&3], \"c\");\n    /// assert_eq!(b[&17], \"d\");\n    /// assert_eq!(b[&41], \"e\");\n    /// ```\n    #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n    where\n        K: Borrow<Q>,\n    {\n}\n\n    /// Calculates the number of elements if it is incorrect.\n    fn recalc_length(&mut self) {\n}\n\n    /// Removes empty levels on the top.\n    fn fix_top(&mut self) {\n}\n\n    fn fix_right_border(&mut self) {\n}\n\n    /// The symmetric clone of `fix_right_border`.\n    fn fix_left_border(&mut self) {\n}\n\n    /// If the root node is the shared root node, allocate our own node.\n    fn ensure_root_is_owned(&mut self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K: 'a, V: 'a> IntoIterator for &'a BTreeMap<K, V> {\n    type Item = (&'a K, &'a V);\n    type IntoIter = Iter<'a, K, V>;\n\n    fn into_iter(self) -> Iter<'a, K, V> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n    type Item = (&'a K, &'a V);\n\n    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    fn last(mut self) -> Option<(&'a K, &'a V)> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Iter<'_, K, V> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K: 'a, V: 'a> DoubleEndedIterator for Iter<'a, K, V> {\n    fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for Iter<'_, K, V> {\n    fn len(&self) -> usize {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Clone for Iter<'_, K, V> {\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K: 'a, V: 'a> IntoIterator for &'a mut BTreeMap<K, V> {\n    type Item = (&'a K, &'a mut V);\n    type IntoIter = IterMut<'a, K, V>;\n\n    fn into_iter(self) -> IterMut<'a, K, V> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n    type Item = (&'a K, &'a mut V);\n\n    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K: 'a, V: 'a> DoubleEndedIterator for IterMut<'a, K, V> {\n    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for IterMut<'_, K, V> {\n    fn len(&self) -> usize {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for IterMut<'_, K, V> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> IntoIterator for BTreeMap<K, V> {\n    type Item = (K, V);\n    type IntoIter = IntoIter<K, V>;\n\n    fn into_iter(self) -> IntoIter<K, V> {\n}\n}\n\n#[stable(feature = \"btree_drop\", since = \"1.7.0\")]\nimpl<K, V> Drop for IntoIter<K, V> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Iterator for IntoIter<K, V> {\n    type Item = (K, V);\n\n    fn next(&mut self) -> Option<(K, V)> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n    fn next_back(&mut self) -> Option<(K, V)> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for IntoIter<K, V> {\n    fn len(&self) -> usize {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for IntoIter<K, V> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for Keys<'a, K, V> {\n    type Item = &'a K;\n\n    fn next(&mut self) -> Option<&'a K> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    fn last(mut self) -> Option<&'a K> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n    fn next_back(&mut self) -> Option<&'a K> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for Keys<'_, K, V> {\n    fn len(&self) -> usize {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Keys<'_, K, V> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Clone for Keys<'_, K, V> {\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> Iterator for Values<'a, K, V> {\n    type Item = &'a V;\n\n    fn next(&mut self) -> Option<&'a V> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    fn last(mut self) -> Option<&'a V> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n    fn next_back(&mut self) -> Option<&'a V> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> ExactSizeIterator for Values<'_, K, V> {\n    fn len(&self) -> usize {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Values<'_, K, V> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K, V> Clone for Values<'_, K, V> {\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"btree_range\", since = \"1.17.0\")]\nimpl<'a, K, V> Iterator for Range<'a, K, V> {\n    type Item = (&'a K, &'a V);\n\n    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n}\n\n    fn last(mut self) -> Option<(&'a K, &'a V)> {\n}\n}\n\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\nimpl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n    type Item = &'a mut V;\n\n    fn next(&mut self) -> Option<&'a mut V> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    fn last(mut self) -> Option<&'a mut V> {\n}\n}\n\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\nimpl<'a, K, V> DoubleEndedIterator for ValuesMut<'a, K, V> {\n    fn next_back(&mut self) -> Option<&'a mut V> {\n}\n}\n\n#[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\nimpl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n    fn len(&self) -> usize {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n\nimpl<'a, K, V> Range<'a, K, V> {\n    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n}\n}\n\n#[stable(feature = \"btree_range\", since = \"1.17.0\")]\nimpl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n    fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n}\n}\n\nimpl<'a, K, V> Range<'a, K, V> {\n    unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for Range<'_, K, V> {}\n\n#[stable(feature = \"btree_range\", since = \"1.17.0\")]\nimpl<K, V> Clone for Range<'_, K, V> {\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"btree_range\", since = \"1.17.0\")]\nimpl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n    type Item = (&'a K, &'a mut V);\n\n    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n}\n\n    fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n}\n}\n\nimpl<'a, K, V> RangeMut<'a, K, V> {\n    unsafe fn next_unchecked(&mut self) -> (&'a K, &'a mut V) {\n}\n}\n\n#[stable(feature = \"btree_range\", since = \"1.17.0\")]\nimpl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n\nimpl<'a, K, V> RangeMut<'a, K, V> {\n    unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a mut V) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> BTreeMap<K, V> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n    #[inline]\n    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n}\n}\n\n#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\nimpl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n    fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K: Ord, V> Default for BTreeMap<K, V> {\n    /// Creates an empty `BTreeMap<K, V>`.\n    fn default() -> BTreeMap<K, V> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n    fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n    #[inline]\n    fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n    #[inline]\n    fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<K: Ord, Q: ?Sized, V> Index<&Q> for BTreeMap<K, V>\nwhere\n    K: Borrow<Q>,\n    Q: Ord,\n{\n    type Output = V;\n\n    /// Returns a reference to the value corresponding to the supplied key.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the key is not present in the `BTreeMap`.\n    #[inline]\n    fn index(&self, key: &Q) -> &V {\n}\n}\n\nfn first_leaf_edge<BorrowType, K, V>(\n    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n}\n\nfn last_leaf_edge<BorrowType, K, V>(\n    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n}\n\nfn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n    root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n    root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n    range: R,\n) -> (\n    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n)\nwhere\n    Q: Ord,\n    K: Borrow<Q>,\n{\n}\n\n#[inline(always)]\nunsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n}\n\nimpl<K, V> BTreeMap<K, V> {\n    /// Gets an iterator over the entries of the map, sorted by key.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert(3, \"c\");\n    /// map.insert(2, \"b\");\n    /// map.insert(1, \"a\");\n    ///\n    /// for (key, value) in map.iter() {\n    ///     println!(\"{}: {}\", key, value);\n    /// }\n    ///\n    /// let (first_key, first_value) = map.iter().next().unwrap();\n    /// assert_eq!((*first_key, *first_value), (1, \"a\"));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, K, V> {\n}\n\n    /// Gets a mutable iterator over the entries of the map, sorted by key.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map = BTreeMap::new();\n    /// map.insert(\"a\", 1);\n    /// map.insert(\"b\", 2);\n    /// map.insert(\"c\", 3);\n    ///\n    /// // add 10 to the value if the key isn't \"a\"\n    /// for (key, value) in map.iter_mut() {\n    ///     if key != &\"a\" {\n    ///         *value += 10;\n    ///     }\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n}\n\n    /// Gets an iterator over the keys of the map, in sorted order.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut a = BTreeMap::new();\n    /// a.insert(2, \"b\");\n    /// a.insert(1, \"a\");\n    ///\n    /// let keys: Vec<_> = a.keys().cloned().collect();\n    /// assert_eq!(keys, [1, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn keys(&self) -> Keys<'_, K, V> {\n}\n\n    /// Gets an iterator over the values of the map, in order by key.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut a = BTreeMap::new();\n    /// a.insert(1, \"hello\");\n    /// a.insert(2, \"goodbye\");\n    ///\n    /// let values: Vec<&str> = a.values().cloned().collect();\n    /// assert_eq!(values, [\"hello\", \"goodbye\"]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn values(&self) -> Values<'_, K, V> {\n}\n\n    /// Gets a mutable iterator over the values of the map, in order by key.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut a = BTreeMap::new();\n    /// a.insert(1, String::from(\"hello\"));\n    /// a.insert(2, String::from(\"goodbye\"));\n    ///\n    /// for value in a.values_mut() {\n    ///     value.push_str(\"!\");\n    /// }\n    ///\n    /// let values: Vec<String> = a.values().cloned().collect();\n    /// assert_eq!(values, [String::from(\"hello!\"),\n    ///                     String::from(\"goodbye!\")]);\n    /// ```\n    #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n    pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {\n}\n\n    /// Returns the number of elements in the map.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut a = BTreeMap::new();\n    /// assert_eq!(a.len(), 0);\n    /// a.insert(1, \"a\");\n    /// assert_eq!(a.len(), 1);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n}\n\n    /// Returns `true` if the map contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut a = BTreeMap::new();\n    /// assert!(a.is_empty());\n    /// a.insert(1, \"a\");\n    /// assert!(!a.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n}\n}\n\nimpl<'a, K: Ord, V> Entry<'a, K, V> {\n    /// Ensures a value is in the entry by inserting the default if empty, and returns\n    /// a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// assert_eq!(map[\"poneyland\"], 12);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_insert(self, default: V) -> &'a mut V {\n}\n\n    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n    /// and returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n    /// let s = \"hoho\".to_string();\n    ///\n    /// map.entry(\"poneyland\").or_insert_with(|| s);\n    ///\n    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n}\n\n    /// Returns a reference to this entry's key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n    /// ```\n    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n    pub fn key(&self) -> &K {\n}\n\n    /// Provides in-place mutable access to an occupied entry before any\n    /// potential inserts into the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n    ///\n    /// map.entry(\"poneyland\")\n    ///    .and_modify(|e| { *e += 1 })\n    ///    .or_insert(42);\n    /// assert_eq!(map[\"poneyland\"], 42);\n    ///\n    /// map.entry(\"poneyland\")\n    ///    .and_modify(|e| { *e += 1 })\n    ///    .or_insert(42);\n    /// assert_eq!(map[\"poneyland\"], 43);\n    /// ```\n    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n    pub fn and_modify<F>(self, f: F) -> Self\n    where\n        F: FnOnce(&mut V),\n    {\n}\n}\n\nimpl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n    /// Ensures a value is in the entry by inserting the default value if empty,\n    /// and returns a mutable reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map: BTreeMap<&str, Option<usize>> = BTreeMap::new();\n    /// map.entry(\"poneyland\").or_default();\n    ///\n    /// assert_eq!(map[\"poneyland\"], None);\n    /// ```\n    pub fn or_default(self) -> &'a mut V {\n}\n}\n\nimpl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n    /// Gets a reference to the key that would be used when inserting a value\n    /// through the VacantEntry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n    /// ```\n    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n    pub fn key(&self) -> &K {\n}\n\n    /// Take ownership of the key.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    /// use std::collections::btree_map::Entry;\n    ///\n    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n    ///\n    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n    ///     v.into_key();\n    /// }\n    /// ```\n    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n    pub fn into_key(self) -> K {\n}\n\n    /// Sets the value of the entry with the `VacantEntry`'s key,\n    /// and returns a mutable reference to it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n    ///\n    /// // count the number of occurrences of letters in the vec\n    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"] {\n    ///     *count.entry(x).or_insert(0) += 1;\n    /// }\n    ///\n    /// assert_eq!(count[\"a\"], 3);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(self, value: V) -> &'a mut V {\n}\n}\n\nimpl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n    /// Gets a reference to the key in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    ///\n    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n    /// ```\n    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n    pub fn key(&self) -> &K {\n}\n\n    /// Take ownership of the key and value from the map.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    /// use std::collections::btree_map::Entry;\n    ///\n    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     // We delete the entry from the map.\n    ///     o.remove_entry();\n    /// }\n    ///\n    /// // If now try to get the value, it will panic:\n    /// // println!(\"{}\", map[\"poneyland\"]);\n    /// ```\n    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n    pub fn remove_entry(self) -> (K, V) {\n}\n\n    /// Gets a reference to the value in the entry.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    /// use std::collections::btree_map::Entry;\n    ///\n    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     assert_eq!(o.get(), &12);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get(&self) -> &V {\n}\n\n    /// Gets a mutable reference to the value in the entry.\n    ///\n    /// If you need a reference to the `OccupiedEntry` that may outlive the\n    /// destruction of the `Entry` value, see [`into_mut`].\n    ///\n    /// [`into_mut`]: #method.into_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    /// use std::collections::btree_map::Entry;\n    ///\n    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// assert_eq!(map[\"poneyland\"], 12);\n    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n    ///     *o.get_mut() += 10;\n    ///     assert_eq!(*o.get(), 22);\n    ///\n    ///     // We can use the same Entry multiple times.\n    ///     *o.get_mut() += 2;\n    /// }\n    /// assert_eq!(map[\"poneyland\"], 24);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self) -> &mut V {\n}\n\n    /// Converts the entry into a mutable reference to its value.\n    ///\n    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n    ///\n    /// [`get_mut`]: #method.get_mut\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    /// use std::collections::btree_map::Entry;\n    ///\n    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// assert_eq!(map[\"poneyland\"], 12);\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     *o.into_mut() += 10;\n    /// }\n    /// assert_eq!(map[\"poneyland\"], 22);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_mut(self) -> &'a mut V {\n}\n\n    /// Sets the value of the entry with the `OccupiedEntry`'s key,\n    /// and returns the entry's old value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    /// use std::collections::btree_map::Entry;\n    ///\n    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n    ///     assert_eq!(o.insert(15), 12);\n    /// }\n    /// assert_eq!(map[\"poneyland\"], 15);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, value: V) -> V {\n}\n\n    /// Takes the value of the entry out of the map, and returns it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeMap;\n    /// use std::collections::btree_map::Entry;\n    ///\n    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n    /// map.entry(\"poneyland\").or_insert(12);\n    ///\n    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n    ///     assert_eq!(o.remove(), 12);\n    /// }\n    /// // If we try to get \"poneyland\"'s value, it'll panic:\n    /// // println!(\"{}\", map[\"poneyland\"]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove(self) -> V {\n}\n\n    fn remove_kv(self) -> (K, V) {\n}\n}\n\nenum UnderflowResult<'a, K, V> {\n    AtRoot,\n    EmptyParent(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n    Merged(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n    Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n}\n\nfn handle_underfull_node<K, V>(\n    node: NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal>,\n) -> UnderflowResult<'_, K, V> {\n}\n\nimpl<K: Ord, V, I: Iterator<Item = (K, V)>> Iterator for MergeIter<K, V, I> {\n    type Item = (K, V);\n\n    fn next(&mut self) -> Option<(K, V)> {\n}\n}\n}\nmod node {\n// This is an attempt at an implementation following the ideal\n//\n// ```\n// struct BTreeMap<K, V> {\n//     height: usize,\n//     root: Option<Box<Node<K, V, height>>>\n// }\n//\n// struct Node<K, V, height: usize> {\n//     keys: [K; 2 * B - 1],\n//     vals: [V; 2 * B - 1],\n//     edges: if height > 0 {\n//         [Box<Node<K, V, height - 1>>; 2 * B]\n//     } else { () },\n//     parent: *const Node<K, V, height + 1>,\n//     parent_idx: u16,\n//     len: u16,\n// }\n// ```\n//\n// Since Rust doesn't actually have dependent types and polymorphic recursion,\n// we make do with lots of unsafety.\n\n// A major goal of this module is to avoid complexity by treating the tree as a generic (if\n// weirdly shaped) container and avoiding dealing with most of the B-Tree invariants. As such,\n// this module doesn't care whether the entries are sorted, which nodes can be underfull, or\n// even what underfull means. However, we do rely on a few invariants:\n//\n// - Trees must have uniform depth/height. This means that every path down to a leaf from a\n//   given node has exactly the same length.\n// - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n//   This implies that even an empty internal node has at least one edge.\n\nuse core::marker::PhantomData;\nuse core::mem::{self, MaybeUninit};\nuse core::ptr::{self, NonNull, Unique};\nuse core::slice;\n\nuse crate::alloc::{Alloc, Global, Layout};\nuse crate::boxed::Box;\n\nconst B: usize = 6;\npub const MIN_LEN: usize = B - 1;\npub const CAPACITY: usize = 2 * B - 1;\n\n/// The underlying representation of leaf nodes. Note that it is often unsafe to actually store\n/// these, since only the first `len` keys and values are assumed to be initialized. As such,\n/// these should always be put behind pointers, and specifically behind `BoxedNode` in the owned\n/// case.\n///\n/// We have a separate type for the header and rely on it matching the prefix of `LeafNode`, in\n/// order to statically allocate a single dummy node to avoid allocations. This struct is\n/// `repr(C)` to prevent them from being reordered. `LeafNode` does not just contain a\n/// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n/// Crucially, `NodeHeader` can be safely transmuted to different K and V. (This is exploited\n/// by `as_header`.)\n#[repr(C)]\nstruct NodeHeader<K, V> {\n    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n    /// This either points to an actual node or is null.\n    parent: *const InternalNode<K, V>,\n\n    /// This node's index into the parent node's `edges` array.\n    /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n    /// This is only guaranteed to be initialized when `parent` is non-null.\n    parent_idx: MaybeUninit<u16>,\n\n    /// The number of keys and values this node stores.\n    ///\n    /// This next to `parent_idx` to encourage the compiler to join `len` and\n    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n    len: u16,\n}\n#[repr(C)]\nstruct LeafNode<K, V> {\n    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n    /// This either points to an actual node or is null.\n    parent: *const InternalNode<K, V>,\n\n    /// This node's index into the parent node's `edges` array.\n    /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n    /// This is only guaranteed to be initialized when `parent` is non-null.\n    parent_idx: MaybeUninit<u16>,\n\n    /// The number of keys and values this node stores.\n    ///\n    /// This next to `parent_idx` to encourage the compiler to join `len` and\n    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n    len: u16,\n\n    /// The arrays storing the actual data of the node. Only the first `len` elements of each\n    /// array are initialized and valid.\n    keys: [MaybeUninit<K>; CAPACITY],\n    vals: [MaybeUninit<V>; CAPACITY],\n}\n\nimpl<K, V> LeafNode<K, V> {\n    /// Creates a new `LeafNode`. Unsafe because all nodes should really be hidden behind\n    /// `BoxedNode`, preventing accidental dropping of uninitialized keys and values.\n    unsafe fn new() -> Self {\n}\n}\n\nimpl<K, V> NodeHeader<K, V> {\n    fn is_shared_root(&self) -> bool {\n}\n}\n\n// We need to implement Sync here in order to make a static instance.\nunsafe impl Sync for NodeHeader<(), ()> {}\n\n// An empty node used as a placeholder for the root node, to avoid allocations.\n// We use just a header in order to save space, since no operation on an empty tree will\n// ever take a pointer past the first key.\nstatic EMPTY_ROOT_NODE: NodeHeader<(), ()> =\n    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0 };\n\n/// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n/// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n/// `InternalNode` can be directly casted to a pointer to the underlying `LeafNode` portion of the\n/// node, allowing code to act on leaf and internal nodes generically without having to even check\n/// which of the two a pointer is pointing at. This property is enabled by the use of `repr(C)`.\n#[repr(C)]\nstruct InternalNode<K, V> {\n    data: LeafNode<K, V>,\n\n    /// The pointers to the children of this node. `len + 1` of these are considered\n    /// initialized and valid.\n    edges: [MaybeUninit<BoxedNode<K, V>>; 2 * B],\n}\n\nimpl<K, V> InternalNode<K, V> {\n    /// Creates a new `InternalNode`.\n    ///\n    /// This is unsafe for two reasons. First, it returns an `InternalNode` by value, risking\n    /// dropping of uninitialized fields. Second, an invariant of internal nodes is that `len + 1`\n    /// edges are initialized and valid, meaning that even when the node is empty (having a\n    /// `len` of 0), there must be one initialized and valid edge. This function does not set up\n    /// such an edge.\n    unsafe fn new() -> Self {\n}\n}\n\n/// An owned pointer to a node. This basically is either `Box<LeafNode<K, V>>` or\n/// `Box<InternalNode<K, V>>`. However, it contains no information as to which of the two types\n/// of nodes is actually behind the box, and, partially due to this lack of information, has no\n/// destructor.\nstruct BoxedNode<K, V> {\n    ptr: Unique<LeafNode<K, V>>,\n}\n\nimpl<K, V> BoxedNode<K, V> {\n    fn from_leaf(node: Box<LeafNode<K, V>>) -> Self {\n}\n\n    fn from_internal(node: Box<InternalNode<K, V>>) -> Self {\n}\n\n    unsafe fn from_ptr(ptr: NonNull<LeafNode<K, V>>) -> Self {\n}\n\n    fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n}\n}\n\n/// An owned tree. Note that despite being owned, this does not have a destructor,\n/// and must be cleaned up manually.\npub struct Root<K, V> {\n    node: BoxedNode<K, V>,\n    height: usize,\n}\n\nunsafe impl<K: Sync, V: Sync> Sync for Root<K, V> {}\nunsafe impl<K: Send, V: Send> Send for Root<K, V> {}\n\nimpl<K, V> Root<K, V> {\n    pub fn is_shared_root(&self) -> bool {\n}\n\n    pub fn shared_empty_root() -> Self {\n}\n\n    pub fn new_leaf() -> Self {\n}\n\n    pub fn as_ref(&self) -> NodeRef<marker::Immut<'_>, K, V, marker::LeafOrInternal> {\n}\n\n    pub fn as_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal> {\n}\n\n    pub fn into_ref(self) -> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n}\n\n    /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n    /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n    pub fn push_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n}\n\n    /// Removes the root node, using its first child as the new root. This cannot be called when\n    /// the tree consists only of a leaf node. As it is intended only to be called when the root\n    /// has only one edge, no cleanup is done on any of the other children are elements of the root.\n    /// This decreases the height by 1 and is the opposite of `push_level`.\n    pub fn pop_level(&mut self) {\n}\n}\n\n// N.B. `NodeRef` is always covariant in `K` and `V`, even when the `BorrowType`\n// is `Mut`. This is technically wrong, but cannot result in any unsafety due to\n// internal use of `NodeRef` because we stay completely generic over `K` and `V`.\n// However, whenever a public type wraps `NodeRef`, make sure that it has the\n// correct variance.\n/// A reference to a node.\n///\n/// This type has a number of parameters that controls how it acts:\n/// - `BorrowType`: This can be `Immut<'a>` or `Mut<'a>` for some `'a` or `Owned`.\n///    When this is `Immut<'a>`, the `NodeRef` acts roughly like `&'a Node`,\n///    when this is `Mut<'a>`, the `NodeRef` acts roughly like `&'a mut Node`,\n///    and when this is `Owned`, the `NodeRef` acts roughly like `Box<Node>`.\n/// - `K` and `V`: These control what types of things are stored in the nodes.\n/// - `Type`: This can be `Leaf`, `Internal`, or `LeafOrInternal`. When this is\n///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n///   `NodeRef` could be pointing to either type of node.\n///   Note that in case of a leaf node, this might still be the shared root!\n///   Only turn this into a `LeafNode` reference if you know it is not the shared root!\n///   Shared references must be dereferencable *for the entire size of their pointee*,\n///   so '&LeafNode` or `&InternalNode` pointing to the shared root is undefined behavior.\n///   Turning this into a `NodeHeader` reference is always safe.\npub struct NodeRef<BorrowType, K, V, Type> {\n    height: usize,\n    node: NonNull<LeafNode<K, V>>,\n    // `root` is null unless the borrow type is `Mut`\n    root: *const Root<K, V>,\n    _marker: PhantomData<(BorrowType, Type)>,\n}\n\nimpl<'a, K: 'a, V: 'a, Type> Copy for NodeRef<marker::Immut<'a>, K, V, Type> {}\nimpl<'a, K: 'a, V: 'a, Type> Clone for NodeRef<marker::Immut<'a>, K, V, Type> {\n    fn clone(&self) -> Self {\n}\n}\n\nunsafe impl<BorrowType, K: Sync, V: Sync, Type> Sync for NodeRef<BorrowType, K, V, Type> {}\n\nunsafe impl<'a, K: Sync + 'a, V: Sync + 'a, Type> Send for NodeRef<marker::Immut<'a>, K, V, Type> {}\nunsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::Mut<'a>, K, V, Type> {}\nunsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type> {}\n\nimpl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n    fn as_internal(&self) -> &InternalNode<K, V> {\n}\n}\n\nimpl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n    fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n}\n}\n\nimpl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n    /// Finds the length of the node. This is the number of keys or values. In an\n    /// internal node, the number of edges is `len() + 1`.\n    pub fn len(&self) -> usize {\n}\n\n    /// Returns the height of this node in the whole tree. Zero height denotes the\n    /// leaf level.\n    pub fn height(&self) -> usize {\n}\n\n    /// Removes any static information about whether this node is a `Leaf` or an\n    /// `Internal` node.\n    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n}\n\n    /// Temporarily takes out another, immutable reference to the same node.\n    fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {\n}\n\n    /// Exposes the leaf \"portion\" of any leaf or internal node that is not the shared root.\n    /// If the node is a leaf, this function simply opens up its data.\n    /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n    /// (header, keys and values), and this function exposes that.\n    /// See `NodeRef` on why the node may not be a shared root.\n    unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n}\n\n    fn as_header(&self) -> &NodeHeader<K, V> {\n}\n\n    /// Returns whether the node is the shared, empty root.\n    pub fn is_shared_root(&self) -> bool {\n}\n\n    /// Borrows a view into the keys stored in the node.\n    /// The caller must ensure that the node is not the shared root.\n    pub unsafe fn keys(&self) -> &[K] {\n}\n\n    /// Borrows a view into the values stored in the node.\n    /// The caller must ensure that the node is not the shared root.\n    fn vals(&self) -> &[V] {\n}\n\n    /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n    /// node actually has a parent, where `handle` points to the edge of the parent\n    /// that points to the current node. Returns `Err(self)` if the current node has\n    /// no parent, giving back the original `NodeRef`.\n    ///\n    /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n    /// both, upon success, do nothing.\n    pub fn ascend(\n        self,\n    ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {\n}\n\n    pub fn first_edge(self) -> Handle<Self, marker::Edge> {\n}\n\n    pub fn last_edge(self) -> Handle<Self, marker::Edge> {\n}\n\n    /// Note that `self` must be nonempty.\n    pub fn first_kv(self) -> Handle<Self, marker::KV> {\n}\n\n    /// Note that `self` must be nonempty.\n    pub fn last_kv(self) -> Handle<Self, marker::KV> {\n}\n}\n\nimpl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n    /// Similar to `ascend`, gets a reference to a node's parent node, but also\n    /// deallocate the current node in the process. This is unsafe because the\n    /// current node will still be accessible despite being deallocated.\n    pub unsafe fn deallocate_and_ascend(\n        self,\n    ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n}\n}\n\nimpl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n    /// Similar to `ascend`, gets a reference to a node's parent node, but also\n    /// deallocate the current node in the process. This is unsafe because the\n    /// current node will still be accessible despite being deallocated.\n    pub unsafe fn deallocate_and_ascend(\n        self,\n    ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n}\n}\n\nimpl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n    /// Unsafely asserts to the compiler some static information about whether this\n    /// node is a `Leaf`.\n    unsafe fn cast_unchecked<NewType>(&mut self) -> NodeRef<marker::Mut<'_>, K, V, NewType> {\n}\n\n    /// Temporarily takes out another, mutable reference to the same node. Beware, as\n    /// this method is very dangerous, doubly so since it may not immediately appear\n    /// dangerous.\n    ///\n    /// Because mutable pointers can roam anywhere around the tree and can even (through\n    /// `into_root_mut`) mess with the root of the tree, the result of `reborrow_mut`\n    /// can easily be used to make the original mutable pointer dangling, or, in the case\n    /// of a reborrowed handle, out of bounds.\n    // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n    // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n    unsafe fn reborrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {\n}\n\n    /// Exposes the leaf \"portion\" of any leaf or internal node for writing.\n    /// If the node is a leaf, this function simply opens up its data.\n    /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n    /// (header, keys and values), and this function exposes that.\n    ///\n    /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n    /// This also implies you can invoke this member on the shared root, but the resulting pointer\n    /// might not be properly aligned and definitely would not allow accessing keys and values.\n    fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n}\n\n    /// The caller must ensure that the node is not the shared root.\n    fn keys_mut(&mut self) -> &mut [K] {\n}\n\n    /// The caller must ensure that the node is not the shared root.\n    fn vals_mut(&mut self) -> &mut [V] {\n}\n}\n\nimpl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n    /// The caller must ensure that the node is not the shared root.\n    unsafe fn into_key_slice(self) -> &'a [K] {\n}\n\n    /// The caller must ensure that the node is not the shared root.\n    fn into_val_slice(self) -> &'a [V] {\n}\n\n    /// The caller must ensure that the node is not the shared root.\n    fn into_slices(self) -> (&'a [K], &'a [V]) {\n}\n}\n\nimpl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n    /// Gets a mutable reference to the root itself. This is useful primarily when the\n    /// height of the tree needs to be adjusted. Never call this on a reborrowed pointer.\n    pub fn into_root_mut(self) -> &'a mut Root<K, V> {\n}\n\n    /// The caller must ensure that the node is not the shared root.\n    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n}\n\n    /// The caller must ensure that the node is not the shared root.\n    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n}\n\n    /// The caller must ensure that the node is not the shared root.\n    fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n}\n}\n\nimpl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n    /// Adds a key/value pair the end of the node.\n    pub fn push(&mut self, key: K, val: V) {\n}\n\n    /// Adds a key/value pair to the beginning of the node.\n    pub fn push_front(&mut self, key: K, val: V) {\n}\n}\n\nimpl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n    /// Adds a key/value pair and an edge to go to the right of that pair to\n    /// the end of the node.\n    pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n}\n\n    fn correct_childrens_parent_links(&mut self, first: usize, after_last: usize) {\n}\n\n    fn correct_all_childrens_parent_links(&mut self) {\n}\n\n    /// Adds a key/value pair and an edge to go to the left of that pair to\n    /// the beginning of the node.\n    pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n}\n}\n\nimpl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n    /// Removes a key/value pair from the end of this node. If this is an internal node,\n    /// also removes the edge that was to the right of that pair.\n    pub fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n}\n\n    /// Removes a key/value pair from the beginning of this node. If this is an internal node,\n    /// also removes the edge that was to the left of that pair.\n    pub fn pop_front(&mut self) -> (K, V, Option<Root<K, V>>) {\n}\n\n    /// The caller must ensure that the node is not the shared root.\n    fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n}\n}\n\nimpl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n    /// Checks whether a node is an `Internal` node or a `Leaf` node.\n    pub fn force(\n        self,\n    ) -> ForceResult<\n        NodeRef<BorrowType, K, V, marker::Leaf>,\n        NodeRef<BorrowType, K, V, marker::Internal>,\n    > {\n}\n}\n\n/// A reference to a specific key/value pair or edge within a node. The `Node` parameter\n/// must be a `NodeRef`, while the `Type` can either be `KV` (signifying a handle on a key/value\n/// pair) or `Edge` (signifying a handle on an edge).\n///\n/// Note that even `Leaf` nodes can have `Edge` handles. Instead of representing a pointer to\n/// a child node, these represent the spaces where child pointers would go between the key/value\n/// pairs. For example, in a node with length 2, there would be 3 possible edge locations - one\n/// to the left of the node, one between the two pairs, and one at the right of the node.\npub struct Handle<Node, Type> {\n    node: Node,\n    idx: usize,\n    _marker: PhantomData<Type>,\n}\n\nimpl<Node: Copy, Type> Copy for Handle<Node, Type> {}\n// We don't need the full generality of `#[derive(Clone)]`, as the only time `Node` will be\n// `Clone`able is when it is an immutable reference and therefore `Copy`.\nimpl<Node: Copy, Type> Clone for Handle<Node, Type> {\n    fn clone(&self) -> Self {\n}\n}\n\nimpl<Node, Type> Handle<Node, Type> {\n    /// Retrieves the node that contains the edge of key/value pair this handle points to.\n    pub fn into_node(self) -> Node {\n}\n}\n\nimpl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {\n    /// Creates a new handle to a key/value pair in `node`. `idx` must be less than `node.len()`.\n    pub fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n}\n\n    pub fn left_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n}\n\n    pub fn right_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n}\n}\n\nimpl<BorrowType, K, V, NodeType, HandleType> PartialEq\n    for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n{\n    fn eq(&self, other: &Self) -> bool {\n}\n}\n\nimpl<BorrowType, K, V, NodeType, HandleType>\n    Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n{\n    /// Temporarily takes out another, immutable handle on the same location.\n    pub fn reborrow(&self) -> Handle<NodeRef<marker::Immut<'_>, K, V, NodeType>, HandleType> {\n}\n}\n\nimpl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n    /// Temporarily takes out another, mutable handle on the same location. Beware, as\n    /// this method is very dangerous, doubly so since it may not immediately appear\n    /// dangerous.\n    ///\n    /// Because mutable pointers can roam anywhere around the tree and can even (through\n    /// `into_root_mut`) mess with the root of the tree, the result of `reborrow_mut`\n    /// can easily be used to make the original mutable pointer dangling, or, in the case\n    /// of a reborrowed handle, out of bounds.\n    // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n    // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n    pub unsafe fn reborrow_mut(\n        &mut self,\n    ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NodeType>, HandleType> {\n}\n}\n\nimpl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n    /// Creates a new handle to an edge in `node`. `idx` must be less than or equal to\n    /// `node.len()`.\n    pub fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {\n}\n\n    pub fn left_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n}\n\n    pub fn right_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {\n}\n}\n\nimpl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n    /// this edge. This method assumes that there is enough space in the node for the new\n    /// pair to fit.\n    ///\n    /// The returned pointer points to the inserted value.\n    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n}\n\n    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n    /// this edge. This method splits the node if there isn't enough room.\n    ///\n    /// The returned pointer points to the inserted value.\n    pub fn insert(mut self, key: K, val: V) -> (InsertResult<'a, K, V, marker::Leaf>, *mut V) {\n}\n}\n\nimpl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n    /// Fixes the parent pointer and index in the child node below this edge. This is useful\n    /// when the ordering of edges has been changed, such as in the various `insert` methods.\n    fn correct_parent_link(mut self) {\n}\n\n    /// Unsafely asserts to the compiler some static information about whether the underlying\n    /// node of this handle is a `Leaf`.\n    unsafe fn cast_unchecked<NewType>(\n        &mut self,\n    ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NewType>, marker::Edge> {\n}\n\n    /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n    /// between this edge and the key/value pair to the right of this edge. This method assumes\n    /// that there is enough space in the node for the new pair to fit.\n    fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n}\n\n    /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n    /// between this edge and the key/value pair to the right of this edge. This method splits\n    /// the node if there isn't enough room.\n    pub fn insert(\n        mut self,\n        key: K,\n        val: V,\n        edge: Root<K, V>,\n    ) -> InsertResult<'a, K, V, marker::Internal> {\n}\n}\n\nimpl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n    /// Finds the node pointed to by this edge.\n    ///\n    /// `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n    /// both, upon success, do nothing.\n    pub fn descend(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n}\n}\n\nimpl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n    pub fn into_kv(self) -> (&'a K, &'a V) {\n}\n}\n\nimpl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n    pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n}\n}\n\nimpl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n    pub fn kv_mut(&mut self) -> (&mut K, &mut V) {\n}\n}\n\nimpl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n    /// Splits the underlying node into three parts:\n    ///\n    /// - The node is truncated to only contain the key/value pairs to the right of\n    ///   this handle.\n    /// - The key and value pointed to by this handle and extracted.\n    /// - All the key/value pairs to the right of this handle are put into a newly\n    ///   allocated node.\n    pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n}\n\n    /// Removes the key/value pair pointed to by this handle and returns it, along with the edge\n    /// between the now adjacent key/value pairs (if any) to the left and right of this handle.\n    pub fn remove(\n        mut self,\n    ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n}\n}\n\nimpl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n    /// Splits the underlying node into three parts:\n    ///\n    /// - The node is truncated to only contain the edges and key/value pairs to the\n    ///   right of this handle.\n    /// - The key and value pointed to by this handle and extracted.\n    /// - All the edges and key/value pairs to the right of this handle are put into\n    ///   a newly allocated node.\n    pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n}\n\n    /// Returns `true` if it is valid to call `.merge()`, i.e., whether there is enough room in\n    /// a node to hold the combination of the nodes to the left and right of this handle along\n    /// with the key/value pair at this handle.\n    pub fn can_merge(&self) -> bool {\n}\n\n    /// Combines the node immediately to the left of this handle, the key/value pair pointed\n    /// to by this handle, and the node immediately to the right of this handle into one new\n    /// child of the underlying node, returning an edge referencing that new child.\n    ///\n    /// Assumes that this edge `.can_merge()`.\n    pub fn merge(\n        mut self,\n    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge> {\n}\n\n    /// This removes a key/value pair from the left child and places it in the key/value storage\n    /// pointed to by this handle while pushing the old key/value pair of this handle into the right\n    /// child.\n    pub fn steal_left(&mut self) {\n}\n\n    /// This removes a key/value pair from the right child and places it in the key/value storage\n    /// pointed to by this handle while pushing the old key/value pair of this handle into the left\n    /// child.\n    pub fn steal_right(&mut self) {\n}\n\n    /// This does stealing similar to `steal_left` but steals multiple elements at once.\n    pub fn bulk_steal_left(&mut self, count: usize) {\n}\n\n    /// The symmetric clone of `bulk_steal_left`.\n    pub fn bulk_steal_right(&mut self, count: usize) {\n}\n}\n\nunsafe fn move_kv<K, V>(\n    source: (*mut K, *mut V),\n    source_offset: usize,\n    dest: (*mut K, *mut V),\n    dest_offset: usize,\n    count: usize,\n) {\n}\n\n// Source and destination must have the same height.\nunsafe fn move_edges<K, V>(\n    mut source: NodeRef<marker::Mut<'_>, K, V, marker::Internal>,\n    source_offset: usize,\n    mut dest: NodeRef<marker::Mut<'_>, K, V, marker::Internal>,\n    dest_offset: usize,\n    count: usize,\n) {\n}\n\nimpl<BorrowType, K, V, HandleType>\n    Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType>\n{\n    /// Checks whether the underlying node is an `Internal` node or a `Leaf` node.\n    pub fn force(\n        self,\n    ) -> ForceResult<\n        Handle<NodeRef<BorrowType, K, V, marker::Leaf>, HandleType>,\n        Handle<NodeRef<BorrowType, K, V, marker::Internal>, HandleType>,\n    > {\n}\n}\n\nimpl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {\n    /// Move the suffix after `self` from one node to another one. `right` must be empty.\n    /// The first edge of `right` remains unchanged.\n    pub fn move_suffix(\n        &mut self,\n        right: &mut NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n    ) {\n}\n}\n\npub enum ForceResult<Leaf, Internal> {\n    Leaf(Leaf),\n    Internal(Internal),\n}\n\npub enum InsertResult<'a, K, V, Type> {\n    Fit(Handle<NodeRef<marker::Mut<'a>, K, V, Type>, marker::KV>),\n    Split(NodeRef<marker::Mut<'a>, K, V, Type>, K, V, Root<K, V>),\n}\n\npub mod marker {\n    use core::marker::PhantomData;\n\n    pub enum Leaf {}\n    pub enum Internal {}\n    pub enum LeafOrInternal {}\n\n    pub enum Owned {}\n    pub struct Immut<'a>(PhantomData<&'a ()>);\n    pub struct Mut<'a>(PhantomData<&'a mut ()>);\n\n    pub enum KV {}\n    pub enum Edge {}\n}\n\nunsafe fn slice_insert<T>(slice: &mut [T], idx: usize, val: T) {\n}\n\nunsafe fn slice_remove<T>(slice: &mut [T], idx: usize) -> T {\n}\n}\nmod search {\nuse core::borrow::Borrow;\nuse core::cmp::Ordering;\n\nuse super::node::{marker, ForceResult::*, Handle, NodeRef};\n\nuse SearchResult::*;\n\npub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n    Found(Handle<NodeRef<BorrowType, K, V, FoundType>, marker::KV>),\n    GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>),\n}\n\npub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n    mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n    key: &Q,\n) -> SearchResult<BorrowType, K, V, marker::LeafOrInternal, marker::Leaf>\nwhere\n    Q: Ord,\n    K: Borrow<Q>,\n{\n}\n\npub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n    node: NodeRef<BorrowType, K, V, Type>,\n    key: &Q,\n) -> SearchResult<BorrowType, K, V, Type, Type>\nwhere\n    Q: Ord,\n    K: Borrow<Q>,\n{\n}\n\n/// Returns the index in the node at which the key (or an equivalent) exists\n/// or could exist, and whether it exists in the node itself. If it doesn't\n/// exist in the node itself, it may exist in the subtree with that index\n/// (if the node has subtrees). If the key doesn't exist in node or subtree,\n/// the returned index is the position or subtree to insert at.\npub fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n    node: &NodeRef<BorrowType, K, V, Type>,\n    key: &Q,\n) -> (usize, bool)\nwhere\n    Q: Ord,\n    K: Borrow<Q>,\n{\n}\n}\npub mod set {\n// This is pretty much entirely stolen from TreeSet, since BTreeMap has an identical interface\n// to TreeMap\n\nuse core::borrow::Borrow;\nuse core::cmp::Ordering::{Equal, Greater, Less};\nuse core::cmp::{max, min};\nuse core::fmt::{self, Debug};\nuse core::iter::{FromIterator, FusedIterator, Peekable};\nuse core::ops::{BitAnd, BitOr, BitXor, RangeBounds, Sub};\n\nuse super::Recover;\nuse crate::collections::btree_map::{self, BTreeMap, Keys};\n\n// FIXME(conventions): implement bounded iterators\n\n/// A set based on a B-Tree.\n///\n/// See [`BTreeMap`]'s documentation for a detailed discussion of this collection's performance\n/// benefits and drawbacks.\n///\n/// It is a logic error for an item to be modified in such a way that the item's ordering relative\n/// to any other item, as determined by the [`Ord`] trait, changes while it is in the set. This is\n/// normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n///\n/// [`BTreeMap`]: struct.BTreeMap.html\n/// [`Ord`]: ../../std/cmp/trait.Ord.html\n/// [`Cell`]: ../../std/cell/struct.Cell.html\n/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n///\n/// # Examples\n///\n/// ```\n/// use std::collections::BTreeSet;\n///\n/// // Type inference lets us omit an explicit type signature (which\n/// // would be `BTreeSet<&str>` in this example).\n/// let mut books = BTreeSet::new();\n///\n/// // Add some books.\n/// books.insert(\"A Dance With Dragons\");\n/// books.insert(\"To Kill a Mockingbird\");\n/// books.insert(\"The Odyssey\");\n/// books.insert(\"The Great Gatsby\");\n///\n/// // Check for a specific one.\n/// if !books.contains(\"The Winds of Winter\") {\n///     println!(\"We have {} books, but The Winds of Winter ain't one.\",\n///              books.len());\n/// }\n///\n/// // Remove a book.\n/// books.remove(\"The Odyssey\");\n///\n/// // Iterate over everything.\n/// for book in &books {\n///     println!(\"{}\", book);\n/// }\n/// ```\n#[derive(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct BTreeSet<T> {\n    map: BTreeMap<T, ()>,\n}\n\n/// An iterator over the items of a `BTreeSet`.\n///\n/// This `struct` is created by the [`iter`] method on [`BTreeSet`].\n/// See its documentation for more.\n///\n/// [`BTreeSet`]: struct.BTreeSet.html\n/// [`iter`]: struct.BTreeSet.html#method.iter\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> {\n    iter: Keys<'a, T, ()>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// An owning iterator over the items of a `BTreeSet`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`BTreeSet`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`BTreeSet`]: struct.BTreeSet.html\n/// [`into_iter`]: struct.BTreeSet.html#method.into_iter\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct IntoIter<T> {\n    iter: btree_map::IntoIter<T, ()>,\n}\n\n/// An iterator over a sub-range of items in a `BTreeSet`.\n///\n/// This `struct` is created by the [`range`] method on [`BTreeSet`].\n/// See its documentation for more.\n///\n/// [`BTreeSet`]: struct.BTreeSet.html\n/// [`range`]: struct.BTreeSet.html#method.range\n#[derive(Debug)]\n#[stable(feature = \"btree_range\", since = \"1.17.0\")]\npub struct Range<'a, T: 'a> {\n    iter: btree_map::Range<'a, T, ()>,\n}\n\n/// Core of SymmetricDifference and Union.\n/// More efficient than btree.map.MergeIter,\n/// and crucially for SymmetricDifference, nexts() reports on both sides.\n#[derive(Clone)]\nstruct MergeIterInner<I>\nwhere\n    I: Iterator,\n    I::Item: Copy,\n{\n    a: I,\n    b: I,\n    peeked: Option<MergeIterPeeked<I>>,\n}\n\n#[derive(Copy, Clone, Debug)]\nenum MergeIterPeeked<I: Iterator> {\n    A(I::Item),\n    B(I::Item),\n}\n\nimpl<I> MergeIterInner<I>\nwhere\n    I: ExactSizeIterator + FusedIterator,\n    I::Item: Copy + Ord,\n{\n    fn new(a: I, b: I) -> Self {\n}\n\n    fn nexts(&mut self) -> (Option<I::Item>, Option<I::Item>) {\n}\n\n    fn lens(&self) -> (usize, usize) {\n}\n}\n\nimpl<I> Debug for MergeIterInner<I>\nwhere\n    I: Iterator + Debug,\n    I::Item: Copy + Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A lazy iterator producing elements in the difference of `BTreeSet`s.\n///\n/// This `struct` is created by the [`difference`] method on [`BTreeSet`].\n/// See its documentation for more.\n///\n/// [`BTreeSet`]: struct.BTreeSet.html\n/// [`difference`]: struct.BTreeSet.html#method.difference\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Difference<'a, T: 'a> {\n    inner: DifferenceInner<'a, T>,\n}\n#[derive(Debug)]\nenum DifferenceInner<'a, T: 'a> {\n    Stitch {\n        // iterate all of `self` and some of `other`, spotting matches along the way\n        self_iter: Iter<'a, T>,\n        other_iter: Peekable<Iter<'a, T>>,\n    },\n    Search {\n        // iterate `self`, look up in `other`\n        self_iter: Iter<'a, T>,\n        other_set: &'a BTreeSet<T>,\n    },\n    Iterate(Iter<'a, T>), // simply produce all values in `self`\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A lazy iterator producing elements in the symmetric difference of `BTreeSet`s.\n///\n/// This `struct` is created by the [`symmetric_difference`] method on\n/// [`BTreeSet`]. See its documentation for more.\n///\n/// [`BTreeSet`]: struct.BTreeSet.html\n/// [`symmetric_difference`]: struct.BTreeSet.html#method.symmetric_difference\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct SymmetricDifference<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A lazy iterator producing elements in the intersection of `BTreeSet`s.\n///\n/// This `struct` is created by the [`intersection`] method on [`BTreeSet`].\n/// See its documentation for more.\n///\n/// [`BTreeSet`]: struct.BTreeSet.html\n/// [`intersection`]: struct.BTreeSet.html#method.intersection\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Intersection<'a, T: 'a> {\n    inner: IntersectionInner<'a, T>,\n}\n#[derive(Debug)]\nenum IntersectionInner<'a, T: 'a> {\n    Stitch {\n        // iterate similarly sized sets jointly, spotting matches along the way\n        a: Iter<'a, T>,\n        b: Iter<'a, T>,\n    },\n    Search {\n        // iterate a small set, look up in the large set\n        small_iter: Iter<'a, T>,\n        large_set: &'a BTreeSet<T>,\n    },\n    Answer(Option<&'a T>), // return a specific value or emptiness\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// A lazy iterator producing elements in the union of `BTreeSet`s.\n///\n/// This `struct` is created by the [`union`] method on [`BTreeSet`].\n/// See its documentation for more.\n///\n/// [`BTreeSet`]: struct.BTreeSet.html\n/// [`union`]: struct.BTreeSet.html#method.union\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Union<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n// This constant is used by functions that compare two sets.\n// It estimates the relative size at which searching performs better\n// than iterating, based on the benchmarks in\n// https://github.com/ssomers/rust_bench_btreeset_intersection;\n// It's used to divide rather than multiply sizes, to rule out overflow,\n// and it's a power of two to make that division cheap.\nconst ITER_PERFORMANCE_TIPPING_SIZE_DIFF: usize = 16;\n\nimpl<T: Ord> BTreeSet<T> {\n    /// Makes a new `BTreeSet` with a reasonable choice of B.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![allow(unused_mut)]\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut set: BTreeSet<i32> = BTreeSet::new();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> BTreeSet<T> {\n}\n\n    /// Constructs a double-ended iterator over a sub-range of elements in the set.\n    /// The simplest way is to use the range syntax `min..max`, thus `range(min..max)` will\n    /// yield elements from min (inclusive) to max (exclusive).\n    /// The range may also be entered as `(Bound<T>, Bound<T>)`, so for example\n    /// `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive\n    /// range from 4 to 10.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    /// use std::ops::Bound::Included;\n    ///\n    /// let mut set = BTreeSet::new();\n    /// set.insert(3);\n    /// set.insert(5);\n    /// set.insert(8);\n    /// for &elem in set.range((Included(&4), Included(&8))) {\n    ///     println!(\"{}\", elem);\n    /// }\n    /// assert_eq!(Some(&5), set.range(4..).next());\n    /// ```\n    #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n    pub fn range<K: ?Sized, R>(&self, range: R) -> Range<'_, T>\n    where\n        K: Ord,\n        T: Borrow<K>,\n        R: RangeBounds<K>,\n    {\n}\n\n    /// Visits the values representing the difference,\n    /// i.e., the values that are in `self` but not in `other`,\n    /// in ascending order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut a = BTreeSet::new();\n    /// a.insert(1);\n    /// a.insert(2);\n    ///\n    /// let mut b = BTreeSet::new();\n    /// b.insert(2);\n    /// b.insert(3);\n    ///\n    /// let diff: Vec<_> = a.difference(&b).cloned().collect();\n    /// assert_eq!(diff, [1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n}\n\n    /// Visits the values representing the symmetric difference,\n    /// i.e., the values that are in `self` or in `other` but not in both,\n    /// in ascending order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut a = BTreeSet::new();\n    /// a.insert(1);\n    /// a.insert(2);\n    ///\n    /// let mut b = BTreeSet::new();\n    /// b.insert(2);\n    /// b.insert(3);\n    ///\n    /// let sym_diff: Vec<_> = a.symmetric_difference(&b).cloned().collect();\n    /// assert_eq!(sym_diff, [1, 3]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn symmetric_difference<'a>(\n        &'a self,\n        other: &'a BTreeSet<T>,\n    ) -> SymmetricDifference<'a, T> {\n}\n\n    /// Visits the values representing the intersection,\n    /// i.e., the values that are both in `self` and `other`,\n    /// in ascending order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut a = BTreeSet::new();\n    /// a.insert(1);\n    /// a.insert(2);\n    ///\n    /// let mut b = BTreeSet::new();\n    /// b.insert(2);\n    /// b.insert(3);\n    ///\n    /// let intersection: Vec<_> = a.intersection(&b).cloned().collect();\n    /// assert_eq!(intersection, [2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n}\n\n    /// Visits the values representing the union,\n    /// i.e., all the values in `self` or `other`, without duplicates,\n    /// in ascending order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut a = BTreeSet::new();\n    /// a.insert(1);\n    ///\n    /// let mut b = BTreeSet::new();\n    /// b.insert(2);\n    ///\n    /// let union: Vec<_> = a.union(&b).cloned().collect();\n    /// assert_eq!(union, [1, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n}\n\n    /// Clears the set, removing all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut v = BTreeSet::new();\n    /// v.insert(1);\n    /// v.clear();\n    /// assert!(v.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n}\n\n    /// Returns `true` if the set contains a value.\n    ///\n    /// The value may be any borrowed form of the set's value type,\n    /// but the ordering on the borrowed form *must* match the\n    /// ordering on the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let set: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.contains(&1), true);\n    /// assert_eq!(set.contains(&4), false);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n    where\n        T: Borrow<Q>,\n        Q: Ord,\n    {\n}\n\n    /// Returns a reference to the value in the set, if any, that is equal to the given value.\n    ///\n    /// The value may be any borrowed form of the set's value type,\n    /// but the ordering on the borrowed form *must* match the\n    /// ordering on the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let set: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.get(&2), Some(&2));\n    /// assert_eq!(set.get(&4), None);\n    /// ```\n    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n    where\n        T: Borrow<Q>,\n        Q: Ord,\n    {\n}\n\n    /// Returns `true` if `self` has no elements in common with `other`.\n    /// This is equivalent to checking for an empty intersection.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let a: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let mut b = BTreeSet::new();\n    ///\n    /// assert_eq!(a.is_disjoint(&b), true);\n    /// b.insert(4);\n    /// assert_eq!(a.is_disjoint(&b), true);\n    /// b.insert(1);\n    /// assert_eq!(a.is_disjoint(&b), false);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n}\n\n    /// Returns `true` if the set is a subset of another,\n    /// i.e., `other` contains at least all the values in `self`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let sup: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// let mut set = BTreeSet::new();\n    ///\n    /// assert_eq!(set.is_subset(&sup), true);\n    /// set.insert(2);\n    /// assert_eq!(set.is_subset(&sup), true);\n    /// set.insert(4);\n    /// assert_eq!(set.is_subset(&sup), false);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n}\n\n    /// Returns `true` if the set is a superset of another,\n    /// i.e., `self` contains at least all the values in `other`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let sub: BTreeSet<_> = [1, 2].iter().cloned().collect();\n    /// let mut set = BTreeSet::new();\n    ///\n    /// assert_eq!(set.is_superset(&sub), false);\n    ///\n    /// set.insert(0);\n    /// set.insert(1);\n    /// assert_eq!(set.is_superset(&sub), false);\n    ///\n    /// set.insert(2);\n    /// assert_eq!(set.is_superset(&sub), true);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_superset(&self, other: &BTreeSet<T>) -> bool {\n}\n\n    /// Returns a reference to the first value in the set, if any.\n    /// This value is always the minimum of all values in the set.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(map_first_last)]\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut map = BTreeSet::new();\n    /// assert_eq!(map.first(), None);\n    /// map.insert(1);\n    /// assert_eq!(map.first(), Some(&1));\n    /// map.insert(2);\n    /// assert_eq!(map.first(), Some(&1));\n    /// ```\n    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n    pub fn first(&self) -> Option<&T> {\n}\n\n    /// Returns a reference to the last value in the set, if any.\n    /// This value is always the maximum of all values in the set.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// #![feature(map_first_last)]\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut map = BTreeSet::new();\n    /// assert_eq!(map.first(), None);\n    /// map.insert(1);\n    /// assert_eq!(map.last(), Some(&1));\n    /// map.insert(2);\n    /// assert_eq!(map.last(), Some(&2));\n    /// ```\n    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n    pub fn last(&self) -> Option<&T> {\n}\n\n    /// Removes the first value from the set and returns it, if any.\n    /// The first value is always the minimum value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(map_first_last)]\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut set = BTreeSet::new();\n    ///\n    /// set.insert(1);\n    /// while let Some(n) = set.pop_first() {\n    ///     assert_eq!(n, 1);\n    /// }\n    /// assert!(set.is_empty());\n    /// ```\n    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n    pub fn pop_first(&mut self) -> Option<T> {\n}\n\n    /// Removes the last value from the set and returns it, if any.\n    /// The last value is always the maximum value in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(map_first_last)]\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut set = BTreeSet::new();\n    ///\n    /// set.insert(1);\n    /// while let Some(n) = set.pop_last() {\n    ///     assert_eq!(n, 1);\n    /// }\n    /// assert!(set.is_empty());\n    /// ```\n    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n    pub fn pop_last(&mut self) -> Option<T> {\n}\n\n    /// Adds a value to the set.\n    ///\n    /// If the set did not have this value present, `true` is returned.\n    ///\n    /// If the set did have this value present, `false` is returned, and the\n    /// entry is not updated. See the [module-level documentation] for more.\n    ///\n    /// [module-level documentation]: index.html#insert-and-complex-keys\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut set = BTreeSet::new();\n    ///\n    /// assert_eq!(set.insert(2), true);\n    /// assert_eq!(set.insert(2), false);\n    /// assert_eq!(set.len(), 1);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, value: T) -> bool {\n}\n\n    /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n    /// one. Returns the replaced value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut set = BTreeSet::new();\n    /// set.insert(Vec::<i32>::new());\n    ///\n    /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 0);\n    /// set.replace(Vec::with_capacity(10));\n    /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 10);\n    /// ```\n    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n    pub fn replace(&mut self, value: T) -> Option<T> {\n}\n\n    /// Removes a value from the set. Returns whether the value was\n    /// present in the set.\n    ///\n    /// The value may be any borrowed form of the set's value type,\n    /// but the ordering on the borrowed form *must* match the\n    /// ordering on the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut set = BTreeSet::new();\n    ///\n    /// set.insert(2);\n    /// assert_eq!(set.remove(&2), true);\n    /// assert_eq!(set.remove(&2), false);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n    where\n        T: Borrow<Q>,\n        Q: Ord,\n    {\n}\n\n    /// Removes and returns the value in the set, if any, that is equal to the given one.\n    ///\n    /// The value may be any borrowed form of the set's value type,\n    /// but the ordering on the borrowed form *must* match the\n    /// ordering on the value type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut set: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n    /// assert_eq!(set.take(&2), Some(2));\n    /// assert_eq!(set.take(&2), None);\n    /// ```\n    #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n    where\n        T: Borrow<Q>,\n        Q: Ord,\n    {\n}\n\n    /// Moves all elements from `other` into `Self`, leaving `other` empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut a = BTreeSet::new();\n    /// a.insert(1);\n    /// a.insert(2);\n    /// a.insert(3);\n    ///\n    /// let mut b = BTreeSet::new();\n    /// b.insert(3);\n    /// b.insert(4);\n    /// b.insert(5);\n    ///\n    /// a.append(&mut b);\n    ///\n    /// assert_eq!(a.len(), 5);\n    /// assert_eq!(b.len(), 0);\n    ///\n    /// assert!(a.contains(&1));\n    /// assert!(a.contains(&2));\n    /// assert!(a.contains(&3));\n    /// assert!(a.contains(&4));\n    /// assert!(a.contains(&5));\n    /// ```\n    #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n    pub fn append(&mut self, other: &mut Self) {\n}\n\n    /// Splits the collection into two at the given key. Returns everything after the given key,\n    /// including the key.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut a = BTreeSet::new();\n    /// a.insert(1);\n    /// a.insert(2);\n    /// a.insert(3);\n    /// a.insert(17);\n    /// a.insert(41);\n    ///\n    /// let b = a.split_off(&3);\n    ///\n    /// assert_eq!(a.len(), 2);\n    /// assert_eq!(b.len(), 3);\n    ///\n    /// assert!(a.contains(&1));\n    /// assert!(a.contains(&2));\n    ///\n    /// assert!(b.contains(&3));\n    /// assert!(b.contains(&17));\n    /// assert!(b.contains(&41));\n    /// ```\n    #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n    where\n        T: Borrow<Q>,\n    {\n}\n}\n\nimpl<T> BTreeSet<T> {\n    /// Gets an iterator that visits the values in the `BTreeSet` in ascending order.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let set: BTreeSet<usize> = [1, 2, 3].iter().cloned().collect();\n    /// let mut set_iter = set.iter();\n    /// assert_eq!(set_iter.next(), Some(&1));\n    /// assert_eq!(set_iter.next(), Some(&2));\n    /// assert_eq!(set_iter.next(), Some(&3));\n    /// assert_eq!(set_iter.next(), None);\n    /// ```\n    ///\n    /// Values returned by the iterator are returned in ascending order:\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let set: BTreeSet<usize> = [3, 1, 2].iter().cloned().collect();\n    /// let mut set_iter = set.iter();\n    /// assert_eq!(set_iter.next(), Some(&1));\n    /// assert_eq!(set_iter.next(), Some(&2));\n    /// assert_eq!(set_iter.next(), Some(&3));\n    /// assert_eq!(set_iter.next(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, T> {\n}\n\n    /// Returns the number of elements in the set.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut v = BTreeSet::new();\n    /// assert_eq!(v.len(), 0);\n    /// v.insert(1);\n    /// assert_eq!(v.len(), 1);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n}\n\n    /// Returns `true` if the set contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let mut v = BTreeSet::new();\n    /// assert!(v.is_empty());\n    /// v.insert(1);\n    /// assert!(!v.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord> FromIterator<T> for BTreeSet<T> {\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> BTreeSet<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> IntoIterator for BTreeSet<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Gets an iterator for moving out the `BTreeSet`'s contents.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().cloned().collect();\n    ///\n    /// let v: Vec<_> = set.into_iter().collect();\n    /// assert_eq!(v, [1, 2, 3, 4]);\n    /// ```\n    fn into_iter(self) -> IntoIter<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a BTreeSet<T> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord> Extend<T> for BTreeSet<T> {\n    #[inline]\n    fn extend<Iter: IntoIterator<Item = T>>(&mut self, iter: Iter) {\n}\n}\n\n#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\nimpl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BTreeSet<T> {\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord> Default for BTreeSet<T> {\n    /// Makes an empty `BTreeSet<T>` with a reasonable choice of B.\n    fn default() -> BTreeSet<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord + Clone> Sub<&BTreeSet<T>> for &BTreeSet<T> {\n    type Output = BTreeSet<T>;\n\n    /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let a: BTreeSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: BTreeSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let result = &a - &b;\n    /// let result_vec: Vec<_> = result.into_iter().collect();\n    /// assert_eq!(result_vec, [1, 2]);\n    /// ```\n    fn sub(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord + Clone> BitXor<&BTreeSet<T>> for &BTreeSet<T> {\n    type Output = BTreeSet<T>;\n\n    /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let a: BTreeSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: BTreeSet<_> = vec![2, 3, 4].into_iter().collect();\n    ///\n    /// let result = &a ^ &b;\n    /// let result_vec: Vec<_> = result.into_iter().collect();\n    /// assert_eq!(result_vec, [1, 4]);\n    /// ```\n    fn bitxor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord + Clone> BitAnd<&BTreeSet<T>> for &BTreeSet<T> {\n    type Output = BTreeSet<T>;\n\n    /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let a: BTreeSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: BTreeSet<_> = vec![2, 3, 4].into_iter().collect();\n    ///\n    /// let result = &a & &b;\n    /// let result_vec: Vec<_> = result.into_iter().collect();\n    /// assert_eq!(result_vec, [2, 3]);\n    /// ```\n    fn bitand(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord + Clone> BitOr<&BTreeSet<T>> for &BTreeSet<T> {\n    type Output = BTreeSet<T>;\n\n    /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::BTreeSet;\n    ///\n    /// let a: BTreeSet<_> = vec![1, 2, 3].into_iter().collect();\n    /// let b: BTreeSet<_> = vec![3, 4, 5].into_iter().collect();\n    ///\n    /// let result = &a | &b;\n    /// let result_vec: Vec<_> = result.into_iter().collect();\n    /// assert_eq!(result_vec, [1, 2, 3, 4, 5]);\n    /// ```\n    fn bitor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Debug> Debug for BTreeSet<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Iter<'_, T> {\n    fn clone(&self) -> Self {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<&'a T> {\n}\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n    fn last(mut self) -> Option<&'a T> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n    fn next_back(&mut self) -> Option<&'a T> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for Iter<'_, T> {\n    fn len(&self) -> usize {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for Iter<'_, T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n}\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    fn next_back(&mut self) -> Option<T> {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for IntoIter<T> {\n    fn len(&self) -> usize {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for IntoIter<T> {}\n\n#[stable(feature = \"btree_range\", since = \"1.17.0\")]\nimpl<T> Clone for Range<'_, T> {\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"btree_range\", since = \"1.17.0\")]\nimpl<'a, T> Iterator for Range<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<&'a T> {\n}\n\n    fn last(mut self) -> Option<&'a T> {\n}\n}\n\n#[stable(feature = \"btree_range\", since = \"1.17.0\")]\nimpl<'a, T> DoubleEndedIterator for Range<'a, T> {\n    fn next_back(&mut self) -> Option<&'a T> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for Range<'_, T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Difference<'_, T> {\n    fn clone(&self) -> Self {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: Ord> Iterator for Difference<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<&'a T> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T: Ord> FusedIterator for Difference<'_, T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for SymmetricDifference<'_, T> {\n    fn clone(&self) -> Self {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<&'a T> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T: Ord> FusedIterator for SymmetricDifference<'_, T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Intersection<'_, T> {\n    fn clone(&self) -> Self {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: Ord> Iterator for Intersection<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<&'a T> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T: Ord> FusedIterator for Intersection<'_, T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Union<'_, T> {\n    fn clone(&self) -> Self {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T: Ord> Iterator for Union<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<&'a T> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T: Ord> FusedIterator for Union<'_, T> {}\n}\n\n#[doc(hidden)]\ntrait Recover<Q: ?Sized> {\n    type Key;\n\n    fn get(&self, key: &Q) -> Option<&Self::Key>;\n    fn take(&mut self, key: &Q) -> Option<Self::Key>;\n    fn replace(&mut self, key: Self::Key) -> Option<Self::Key>;\n}\n}\npub mod linked_list {\n//! A doubly-linked list with owned nodes.\n//!\n//! The `LinkedList` allows pushing and popping elements at either end\n//! in constant time.\n//!\n//! NOTE: It is almost always better to use [`Vec`] or [`VecDeque`] because\n//! array-based containers are generally faster,\n//! more memory efficient, and make better use of CPU cache.\n//!\n//! [`Vec`]: ../../vec/struct.Vec.html\n//! [`VecDeque`]: ../vec_deque/struct.VecDeque.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::cmp::Ordering;\nuse core::fmt;\nuse core::hash::{Hash, Hasher};\nuse core::iter::{FromIterator, FusedIterator};\nuse core::marker::PhantomData;\nuse core::mem;\nuse core::ptr::NonNull;\n\nuse super::SpecExtend;\nuse crate::boxed::Box;\n\n#[cfg(test)]\nmod tests {\n}\n\n/// A doubly-linked list with owned nodes.\n///\n/// The `LinkedList` allows pushing and popping elements at either end\n/// in constant time.\n///\n/// NOTE: It is almost always better to use `Vec` or `VecDeque` because\n/// array-based containers are generally faster,\n/// more memory efficient, and make better use of CPU cache.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct LinkedList<T> {\n    head: Option<NonNull<Node<T>>>,\n    tail: Option<NonNull<Node<T>>>,\n    len: usize,\n    marker: PhantomData<Box<Node<T>>>,\n}\n\nstruct Node<T> {\n    next: Option<NonNull<Node<T>>>,\n    prev: Option<NonNull<Node<T>>>,\n    element: T,\n}\n\n/// An iterator over the elements of a `LinkedList`.\n///\n/// This `struct` is created by the [`iter`] method on [`LinkedList`]. See its\n/// documentation for more.\n///\n/// [`iter`]: struct.LinkedList.html#method.iter\n/// [`LinkedList`]: struct.LinkedList.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> {\n    head: Option<NonNull<Node<T>>>,\n    tail: Option<NonNull<Node<T>>>,\n    len: usize,\n    marker: PhantomData<&'a Node<T>>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Iter<'_, T> {\n    fn clone(&self) -> Self {\n}\n}\n\n/// A mutable iterator over the elements of a `LinkedList`.\n///\n/// This `struct` is created by the [`iter_mut`] method on [`LinkedList`]. See its\n/// documentation for more.\n///\n/// [`iter_mut`]: struct.LinkedList.html#method.iter_mut\n/// [`LinkedList`]: struct.LinkedList.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IterMut<'a, T: 'a> {\n    // We do *not* exclusively own the entire list here, references to node's `element`\n    // have been handed out by the iterator! So be careful when using this; the methods\n    // called must be aware that there can be aliasing pointers to `element`.\n    list: &'a mut LinkedList<T>,\n    head: Option<NonNull<Node<T>>>,\n    tail: Option<NonNull<Node<T>>>,\n    len: usize,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n/// An owning iterator over the elements of a `LinkedList`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`LinkedList`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`into_iter`]: struct.LinkedList.html#method.into_iter\n/// [`LinkedList`]: struct.LinkedList.html\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<T> {\n    list: LinkedList<T>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<T> Node<T> {\n    fn new(element: T) -> Self {\n}\n\n    fn into_element(self: Box<Self>) -> T {\n}\n}\n\n// private methods\nimpl<T> LinkedList<T> {\n    /// Adds the given node to the front of the list.\n    #[inline]\n    fn push_front_node(&mut self, mut node: Box<Node<T>>) {\n}\n\n    /// Removes and returns the node at the front of the list.\n    #[inline]\n    fn pop_front_node(&mut self) -> Option<Box<Node<T>>> {\n}\n\n    /// Adds the given node to the back of the list.\n    #[inline]\n    fn push_back_node(&mut self, mut node: Box<Node<T>>) {\n}\n\n    /// Removes and returns the node at the back of the list.\n    #[inline]\n    fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n}\n\n    /// Unlinks the specified node from the current list.\n    ///\n    /// Warning: this will not check that the provided node belongs to the current list.\n    ///\n    /// This method takes care not to create mutable references to `element`, to\n    /// maintain validity of aliasing pointers.\n    #[inline]\n    unsafe fn unlink_node(&mut self, mut node: NonNull<Node<T>>) {\n}\n\n    /// Splices a series of nodes between two existing nodes.\n    ///\n    /// Warning: this will not check that the provided node belongs to the two existing lists.\n    #[inline]\n    unsafe fn splice_nodes(\n        &mut self,\n        existing_prev: Option<NonNull<Node<T>>>,\n        existing_next: Option<NonNull<Node<T>>>,\n        mut splice_start: NonNull<Node<T>>,\n        mut splice_end: NonNull<Node<T>>,\n        splice_length: usize,\n    ) {\n}\n\n    /// Detaches all nodes from a linked list as a series of nodes.\n    #[inline]\n    fn detach_all_nodes(mut self) -> Option<(NonNull<Node<T>>, NonNull<Node<T>>, usize)> {\n}\n\n    #[inline]\n    unsafe fn split_off_before_node(\n        &mut self,\n        split_node: Option<NonNull<Node<T>>>,\n        at: usize,\n    ) -> Self {\n}\n\n    #[inline]\n    unsafe fn split_off_after_node(\n        &mut self,\n        split_node: Option<NonNull<Node<T>>>,\n        at: usize,\n    ) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for LinkedList<T> {\n    /// Creates an empty `LinkedList<T>`.\n    #[inline]\n    fn default() -> Self {\n}\n}\n\nimpl<T> LinkedList<T> {\n    /// Creates an empty `LinkedList`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let list: LinkedList<u32> = LinkedList::new();\n    /// ```\n    #[inline]\n    #[rustc_const_stable(feature = \"const_linked_list_new\", since = \"1.32.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn new() -> Self {\n}\n\n    /// Moves all elements from `other` to the end of the list.\n    ///\n    /// This reuses all the nodes from `other` and moves them into `self`. After\n    /// this operation, `other` becomes empty.\n    ///\n    /// This operation should compute in O(1) time and O(1) memory.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut list1 = LinkedList::new();\n    /// list1.push_back('a');\n    ///\n    /// let mut list2 = LinkedList::new();\n    /// list2.push_back('b');\n    /// list2.push_back('c');\n    ///\n    /// list1.append(&mut list2);\n    ///\n    /// let mut iter = list1.iter();\n    /// assert_eq!(iter.next(), Some(&'a'));\n    /// assert_eq!(iter.next(), Some(&'b'));\n    /// assert_eq!(iter.next(), Some(&'c'));\n    /// assert!(iter.next().is_none());\n    ///\n    /// assert!(list2.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn append(&mut self, other: &mut Self) {\n}\n\n    /// Moves all elements from `other` to the begin of the list.\n    #[unstable(feature = \"linked_list_prepend\", issue = \"none\")]\n    pub fn prepend(&mut self, other: &mut Self) {\n}\n\n    /// Provides a forward iterator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut list: LinkedList<u32> = LinkedList::new();\n    ///\n    /// list.push_back(0);\n    /// list.push_back(1);\n    /// list.push_back(2);\n    ///\n    /// let mut iter = list.iter();\n    /// assert_eq!(iter.next(), Some(&0));\n    /// assert_eq!(iter.next(), Some(&1));\n    /// assert_eq!(iter.next(), Some(&2));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, T> {\n}\n\n    /// Provides a forward iterator with mutable references.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut list: LinkedList<u32> = LinkedList::new();\n    ///\n    /// list.push_back(0);\n    /// list.push_back(1);\n    /// list.push_back(2);\n    ///\n    /// for element in list.iter_mut() {\n    ///     *element += 10;\n    /// }\n    ///\n    /// let mut iter = list.iter();\n    /// assert_eq!(iter.next(), Some(&10));\n    /// assert_eq!(iter.next(), Some(&11));\n    /// assert_eq!(iter.next(), Some(&12));\n    /// assert_eq!(iter.next(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n}\n\n    /// Provides a cursor at the front element.\n    ///\n    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n    #[inline]\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn cursor_front(&self) -> Cursor<'_, T> {\n}\n\n    /// Provides a cursor with editing operations at the front element.\n    ///\n    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n    #[inline]\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn cursor_front_mut(&mut self) -> CursorMut<'_, T> {\n}\n\n    /// Provides a cursor at the back element.\n    ///\n    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n    #[inline]\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn cursor_back(&self) -> Cursor<'_, T> {\n}\n\n    /// Provides a cursor with editing operations at the back element.\n    ///\n    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n    #[inline]\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn cursor_back_mut(&mut self) -> CursorMut<'_, T> {\n}\n\n    /// Returns `true` if the `LinkedList` is empty.\n    ///\n    /// This operation should compute in O(1) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut dl = LinkedList::new();\n    /// assert!(dl.is_empty());\n    ///\n    /// dl.push_front(\"foo\");\n    /// assert!(!dl.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n}\n\n    /// Returns the length of the `LinkedList`.\n    ///\n    /// This operation should compute in O(1) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut dl = LinkedList::new();\n    ///\n    /// dl.push_front(2);\n    /// assert_eq!(dl.len(), 1);\n    ///\n    /// dl.push_front(1);\n    /// assert_eq!(dl.len(), 2);\n    ///\n    /// dl.push_back(3);\n    /// assert_eq!(dl.len(), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n}\n\n    /// Removes all elements from the `LinkedList`.\n    ///\n    /// This operation should compute in O(n) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut dl = LinkedList::new();\n    ///\n    /// dl.push_front(2);\n    /// dl.push_front(1);\n    /// assert_eq!(dl.len(), 2);\n    /// assert_eq!(dl.front(), Some(&1));\n    ///\n    /// dl.clear();\n    /// assert_eq!(dl.len(), 0);\n    /// assert_eq!(dl.front(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n}\n\n    /// Returns `true` if the `LinkedList` contains an element equal to the\n    /// given value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut list: LinkedList<u32> = LinkedList::new();\n    ///\n    /// list.push_back(0);\n    /// list.push_back(1);\n    /// list.push_back(2);\n    ///\n    /// assert_eq!(list.contains(&0), true);\n    /// assert_eq!(list.contains(&10), false);\n    /// ```\n    #[stable(feature = \"linked_list_contains\", since = \"1.12.0\")]\n    pub fn contains(&self, x: &T) -> bool\n    where\n        T: PartialEq<T>,\n    {\n}\n\n    /// Provides a reference to the front element, or `None` if the list is\n    /// empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut dl = LinkedList::new();\n    /// assert_eq!(dl.front(), None);\n    ///\n    /// dl.push_front(1);\n    /// assert_eq!(dl.front(), Some(&1));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn front(&self) -> Option<&T> {\n}\n\n    /// Provides a mutable reference to the front element, or `None` if the list\n    /// is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut dl = LinkedList::new();\n    /// assert_eq!(dl.front(), None);\n    ///\n    /// dl.push_front(1);\n    /// assert_eq!(dl.front(), Some(&1));\n    ///\n    /// match dl.front_mut() {\n    ///     None => {},\n    ///     Some(x) => *x = 5,\n    /// }\n    /// assert_eq!(dl.front(), Some(&5));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn front_mut(&mut self) -> Option<&mut T> {\n}\n\n    /// Provides a reference to the back element, or `None` if the list is\n    /// empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut dl = LinkedList::new();\n    /// assert_eq!(dl.back(), None);\n    ///\n    /// dl.push_back(1);\n    /// assert_eq!(dl.back(), Some(&1));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn back(&self) -> Option<&T> {\n}\n\n    /// Provides a mutable reference to the back element, or `None` if the list\n    /// is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut dl = LinkedList::new();\n    /// assert_eq!(dl.back(), None);\n    ///\n    /// dl.push_back(1);\n    /// assert_eq!(dl.back(), Some(&1));\n    ///\n    /// match dl.back_mut() {\n    ///     None => {},\n    ///     Some(x) => *x = 5,\n    /// }\n    /// assert_eq!(dl.back(), Some(&5));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn back_mut(&mut self) -> Option<&mut T> {\n}\n\n    /// Adds an element first in the list.\n    ///\n    /// This operation should compute in O(1) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut dl = LinkedList::new();\n    ///\n    /// dl.push_front(2);\n    /// assert_eq!(dl.front().unwrap(), &2);\n    ///\n    /// dl.push_front(1);\n    /// assert_eq!(dl.front().unwrap(), &1);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push_front(&mut self, elt: T) {\n}\n\n    /// Removes the first element and returns it, or `None` if the list is\n    /// empty.\n    ///\n    /// This operation should compute in O(1) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut d = LinkedList::new();\n    /// assert_eq!(d.pop_front(), None);\n    ///\n    /// d.push_front(1);\n    /// d.push_front(3);\n    /// assert_eq!(d.pop_front(), Some(3));\n    /// assert_eq!(d.pop_front(), Some(1));\n    /// assert_eq!(d.pop_front(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop_front(&mut self) -> Option<T> {\n}\n\n    /// Appends an element to the back of a list.\n    ///\n    /// This operation should compute in O(1) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut d = LinkedList::new();\n    /// d.push_back(1);\n    /// d.push_back(3);\n    /// assert_eq!(3, *d.back().unwrap());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push_back(&mut self, elt: T) {\n}\n\n    /// Removes the last element from a list and returns it, or `None` if\n    /// it is empty.\n    ///\n    /// This operation should compute in O(1) time.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut d = LinkedList::new();\n    /// assert_eq!(d.pop_back(), None);\n    /// d.push_back(1);\n    /// d.push_back(3);\n    /// assert_eq!(d.pop_back(), Some(3));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop_back(&mut self) -> Option<T> {\n}\n\n    /// Splits the list into two at the given index. Returns everything after the given index,\n    /// including the index.\n    ///\n    /// This operation should compute in O(n) time.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut d = LinkedList::new();\n    ///\n    /// d.push_front(1);\n    /// d.push_front(2);\n    /// d.push_front(3);\n    ///\n    /// let mut splitted = d.split_off(2);\n    ///\n    /// assert_eq!(splitted.pop_front(), Some(1));\n    /// assert_eq!(splitted.pop_front(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn split_off(&mut self, at: usize) -> LinkedList<T> {\n}\n\n    /// Creates an iterator which uses a closure to determine if an element should be removed.\n    ///\n    /// If the closure returns true, then the element is removed and yielded.\n    /// If the closure returns false, the element will remain in the list and will not be yielded\n    /// by the iterator.\n    ///\n    /// Note that `drain_filter` lets you mutate every element in the filter closure, regardless of\n    /// whether you choose to keep or remove it.\n    ///\n    /// # Examples\n    ///\n    /// Splitting a list into evens and odds, reusing the original list:\n    ///\n    /// ```\n    /// #![feature(drain_filter)]\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut numbers: LinkedList<u32> = LinkedList::new();\n    /// numbers.extend(&[1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15]);\n    ///\n    /// let evens = numbers.drain_filter(|x| *x % 2 == 0).collect::<LinkedList<_>>();\n    /// let odds = numbers;\n    ///\n    /// assert_eq!(evens.into_iter().collect::<Vec<_>>(), vec![2, 4, 6, 8, 14]);\n    /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 9, 11, 13, 15]);\n    /// ```\n    #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F>\n    where\n        F: FnMut(&mut T) -> bool,\n    {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T> Drop for LinkedList<T> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn last(mut self) -> Option<&'a T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for Iter<'_, T> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for Iter<'_, T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn last(mut self) -> Option<&'a mut T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for IterMut<'_, T> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for IterMut<'_, T> {}\n\nimpl<T> IterMut<'_, T> {\n    /// Inserts the given element just after the element most recently returned by `.next()`.\n    /// The inserted element does not appear in the iteration.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(linked_list_extras)]\n    ///\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut list: LinkedList<_> = vec![1, 3, 4].into_iter().collect();\n    ///\n    /// {\n    ///     let mut it = list.iter_mut();\n    ///     assert_eq!(it.next().unwrap(), &1);\n    ///     // insert `2` after `1`\n    ///     it.insert_next(2);\n    /// }\n    /// {\n    ///     let vec: Vec<_> = list.into_iter().collect();\n    ///     assert_eq!(vec, [1, 2, 3, 4]);\n    /// }\n    /// ```\n    #[inline]\n    #[unstable(\n        feature = \"linked_list_extras\",\n        reason = \"this is probably better handled by a cursor type -- we'll see\",\n        issue = \"27794\"\n    )]\n    pub fn insert_next(&mut self, element: T) {\n}\n\n    /// Provides a reference to the next element, without changing the iterator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(linked_list_extras)]\n    ///\n    /// use std::collections::LinkedList;\n    ///\n    /// let mut list: LinkedList<_> = vec![1, 2, 3].into_iter().collect();\n    ///\n    /// let mut it = list.iter_mut();\n    /// assert_eq!(it.next().unwrap(), &1);\n    /// assert_eq!(it.peek_next().unwrap(), &2);\n    /// // We just peeked at 2, so it was not consumed from the iterator.\n    /// assert_eq!(it.next().unwrap(), &2);\n    /// ```\n    #[inline]\n    #[unstable(\n        feature = \"linked_list_extras\",\n        reason = \"this is probably better handled by a cursor type -- we'll see\",\n        issue = \"27794\"\n    )]\n    pub fn peek_next(&mut self) -> Option<&mut T> {\n}\n}\n\n/// A cursor over a `LinkedList`.\n///\n/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth.\n///\n/// Cursors always rest between two elements in the list, and index in a logically circular way.\n/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n/// tail of the list.\n///\n/// When created, cursors start at the front of the list, or the \"ghost\" non-element if the list is empty.\n#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\npub struct Cursor<'a, T: 'a> {\n}\n\n#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\nimpl<T: fmt::Debug> fmt::Debug for Cursor<'_, T> {\n}\n\n/// A cursor over a `LinkedList` with editing operations.\n///\n/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth, and can\n/// safely mutate the list during iteration. This is because the lifetime of its yielded\n/// references is tied to its own lifetime, instead of just the underlying list. This means\n/// cursors cannot yield multiple elements at once.\n///\n/// Cursors always rest between two elements in the list, and index in a logically circular way.\n/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n/// tail of the list.\n#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\npub struct CursorMut<'a, T: 'a> {\n}\n\n#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\nimpl<T: fmt::Debug> fmt::Debug for CursorMut<'_, T> {\n}\n\nimpl<'a, T> Cursor<'a, T> {\n    /// Returns the cursor position index within the `LinkedList`.\n    ///\n    /// This returns `None` if the cursor is currently pointing to the\n    /// \"ghost\" non-element.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn index(&self) -> Option<usize> {\n}\n\n    /// Moves the cursor to the next element of the `LinkedList`.\n    ///\n    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n    /// the first element of the `LinkedList`. If it is pointing to the last\n    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn move_next(&mut self) {\n}\n\n    /// Moves the cursor to the previous element of the `LinkedList`.\n    ///\n    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n    /// the last element of the `LinkedList`. If it is pointing to the first\n    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn move_prev(&mut self) {\n}\n\n    /// Returns a reference to the element that the cursor is currently\n    /// pointing to.\n    ///\n    /// This returns `None` if the cursor is currently pointing to the\n    /// \"ghost\" non-element.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn current(&self) -> Option<&'a T> {\n}\n\n    /// Returns a reference to the next element.\n    ///\n    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n    /// the first element of the `LinkedList`. If it is pointing to the last\n    /// element of the `LinkedList` then this returns `None`.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn peek_next(&self) -> Option<&'a T> {\n}\n\n    /// Returns a reference to the previous element.\n    ///\n    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n    /// the last element of the `LinkedList`. If it is pointing to the first\n    /// element of the `LinkedList` then this returns `None`.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn peek_prev(&self) -> Option<&'a T> {\n}\n}\n\nimpl<'a, T> CursorMut<'a, T> {\n    /// Returns the cursor position index within the `LinkedList`.\n    ///\n    /// This returns `None` if the cursor is currently pointing to the\n    /// \"ghost\" non-element.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn index(&self) -> Option<usize> {\n}\n\n    /// Moves the cursor to the next element of the `LinkedList`.\n    ///\n    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n    /// the first element of the `LinkedList`. If it is pointing to the last\n    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn move_next(&mut self) {\n}\n\n    /// Moves the cursor to the previous element of the `LinkedList`.\n    ///\n    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n    /// the last element of the `LinkedList`. If it is pointing to the first\n    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn move_prev(&mut self) {\n}\n\n    /// Returns a reference to the element that the cursor is currently\n    /// pointing to.\n    ///\n    /// This returns `None` if the cursor is currently pointing to the\n    /// \"ghost\" non-element.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn current(&mut self) -> Option<&mut T> {\n}\n\n    /// Returns a reference to the next element.\n    ///\n    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n    /// the first element of the `LinkedList`. If it is pointing to the last\n    /// element of the `LinkedList` then this returns `None`.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn peek_next(&mut self) -> Option<&mut T> {\n}\n\n    /// Returns a reference to the previous element.\n    ///\n    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n    /// the last element of the `LinkedList`. If it is pointing to the first\n    /// element of the `LinkedList` then this returns `None`.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn peek_prev(&mut self) -> Option<&mut T> {\n}\n\n    /// Returns a read-only cursor pointing to the current element.\n    ///\n    /// The lifetime of the returned `Cursor` is bound to that of the\n    /// `CursorMut`, which means it cannot outlive the `CursorMut` and that the\n    /// `CursorMut` is frozen for the lifetime of the `Cursor`.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn as_cursor<'cm>(&'cm self) -> Cursor<'cm, T> {\n}\n}\n\n// Now the list editing operations\n\nimpl<'a, T> CursorMut<'a, T> {\n    /// Inserts a new element into the `LinkedList` after the current one.\n    ///\n    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n    /// inserted at the front of the `LinkedList`.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn insert_after(&mut self, item: T) {\n}\n\n    /// Inserts a new element into the `LinkedList` before the current one.\n    ///\n    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n    /// inserted at the end of the `LinkedList`.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn insert_before(&mut self, item: T) {\n}\n\n    /// Removes the current element from the `LinkedList`.\n    ///\n    /// The element that was removed is returned, and the cursor is\n    /// moved to point to the next element in the `LinkedList`.\n    ///\n    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n    /// is removed and `None` is returned.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn remove_current(&mut self) -> Option<T> {\n}\n\n    /// Inserts the elements from the given `LinkedList` after the current one.\n    ///\n    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n    /// inserted at the start of the `LinkedList`.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn splice_after(&mut self, list: LinkedList<T>) {\n}\n\n    /// Inserts the elements from the given `LinkedList` before the current one.\n    ///\n    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n    /// inserted at the end of the `LinkedList`.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn splice_before(&mut self, list: LinkedList<T>) {\n}\n\n    /// Splits the list into two after the current element. This will return a\n    /// new list consisting of everything after the cursor, with the original\n    /// list retaining everything before.\n    ///\n    /// If the cursor is pointing at the \"ghost\" non-element then the entire contents\n    /// of the `LinkedList` are moved.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn split_after(&mut self) -> LinkedList<T> {\n}\n\n    /// Splits the list into two before the current element. This will return a\n    /// new list consisting of everything before the cursor, with the original\n    /// list retaining everything after.\n    ///\n    /// If the cursor is pointing at the \"ghost\" non-element then the entire contents\n    /// of the `LinkedList` are moved.\n    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n    pub fn split_before(&mut self) -> LinkedList<T> {\n}\n}\n\n/// An iterator produced by calling `drain_filter` on LinkedList.\n#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\npub struct DrainFilter<'a, T: 'a, F: 'a>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n}\n\n#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\nimpl<T, F> Iterator for DrainFilter<'_, T, F>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n}\n\n#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\nimpl<T, F> Drop for DrainFilter<'_, T, F>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n}\n\n#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\nimpl<T: fmt::Debug, F> fmt::Debug for DrainFilter<'_, T, F>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for IntoIter<T> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for IntoIter<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> FromIterator<T> for LinkedList<T> {\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> IntoIterator for LinkedList<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Consumes the list into an iterator yielding elements by value.\n    #[inline]\n    fn into_iter(self) -> IntoIter<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a LinkedList<T> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a mut LinkedList<T> {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Extend<T> for LinkedList<T> {\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n}\n}\n\nimpl<I: IntoIterator> SpecExtend<I> for LinkedList<I::Item> {\n    default fn spec_extend(&mut self, iter: I) {\n}\n}\n\nimpl<T> SpecExtend<LinkedList<T>> for LinkedList<T> {\n    fn spec_extend(&mut self, ref mut other: LinkedList<T>) {\n}\n}\n\n#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\nimpl<'a, T: 'a + Copy> Extend<&'a T> for LinkedList<T> {\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: PartialEq> PartialEq for LinkedList<T> {\n    fn eq(&self, other: &Self) -> bool {\n}\n\n    fn ne(&self, other: &Self) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Eq> Eq for LinkedList<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: PartialOrd> PartialOrd for LinkedList<T> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord> Ord for LinkedList<T> {\n    #[inline]\n    fn cmp(&self, other: &Self) -> Ordering {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> Clone for LinkedList<T> {\n    fn clone(&self) -> Self {\n}\n\n    fn clone_from(&mut self, other: &Self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug> fmt::Debug for LinkedList<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Hash> Hash for LinkedList<T> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n}\n}\n\n// Ensure that `LinkedList` and its read-only iterators are covariant in their type parameters.\n#[allow(dead_code)]\nfn assert_covariance() {\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Send> Send for LinkedList<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Sync for LinkedList<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Send for Iter<'_, T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Sync for Iter<'_, T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Send> Send for IterMut<'_, T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n}\npub mod vec_deque {\n//! A double-ended queue implemented with a growable ring buffer.\n//!\n//! This queue has `O(1)` amortized inserts and removals from both ends of the\n//! container. It also has `O(1)` indexing like a vector. The contained elements\n//! are not required to be copyable, and the queue will be sendable if the\n//! contained type is sendable.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::array::LengthAtMost32;\nuse core::cmp::{self, Ordering};\nuse core::fmt;\nuse core::hash::{Hash, Hasher};\nuse core::iter::{once, repeat_with, FromIterator, FusedIterator};\nuse core::mem::{self, replace};\nuse core::ops::Bound::{Excluded, Included, Unbounded};\nuse core::ops::{Index, IndexMut, RangeBounds, Try};\nuse core::ptr::{self, NonNull};\nuse core::slice;\n\nuse crate::collections::TryReserveError;\nuse crate::raw_vec::RawVec;\nuse crate::vec::Vec;\n\n#[cfg(test)]\nmod tests {\n}\n\nconst INITIAL_CAPACITY: usize = 7; // 2^3 - 1\nconst MINIMUM_CAPACITY: usize = 1; // 2 - 1\n#[cfg(target_pointer_width = \"16\")]\nconst MAXIMUM_ZST_CAPACITY: usize = 1 << (16 - 1); // Largest possible power of two\n#[cfg(target_pointer_width = \"32\")]\nconst MAXIMUM_ZST_CAPACITY: usize = 1 << (32 - 1); // Largest possible power of two\n#[cfg(target_pointer_width = \"64\")]\nconst MAXIMUM_ZST_CAPACITY: usize = 1 << (64 - 1); // Largest possible power of two\n\n/// A double-ended queue implemented with a growable ring buffer.\n///\n/// The \"default\" usage of this type as a queue is to use [`push_back`] to add to\n/// the queue, and [`pop_front`] to remove from the queue. [`extend`] and [`append`]\n/// push onto the back in this manner, and iterating over `VecDeque` goes front\n/// to back.\n///\n/// [`push_back`]: #method.push_back\n/// [`pop_front`]: #method.pop_front\n/// [`extend`]: #method.extend\n/// [`append`]: #method.append\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct VecDeque<T> {\n    // tail and head are pointers into the buffer. Tail always points\n    // to the first element that could be read, Head always points\n    // to where data should be written.\n    // If tail == head the buffer is empty. The length of the ringbuffer\n    // is defined as the distance between the two.\n    tail: usize,\n    head: usize,\n    buf: RawVec<T>,\n}\n\n/// PairSlices pairs up equal length slice parts of two deques\n///\n/// For example, given deques \"A\" and \"B\" with the following division into slices:\n///\n/// A: [0 1 2] [3 4 5]\n/// B: [a b] [c d e]\n///\n/// It produces the following sequence of matching slices:\n///\n/// ([0 1], [a b])\n/// ([2], [c])\n/// ([3 4], [d e])\n///\n/// and the uneven remainder of either A or B is skipped.\nstruct PairSlices<'a, 'b, T> {\n    a0: &'a mut [T],\n    a1: &'a mut [T],\n    b0: &'b [T],\n    b1: &'b [T],\n}\n\nimpl<'a, 'b, T> PairSlices<'a, 'b, T> {\n    fn from(to: &'a mut VecDeque<T>, from: &'b VecDeque<T>) -> Self {\n}\n\n    fn has_remainder(&self) -> bool {\n}\n\n    fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n}\n}\n\nimpl<'a, 'b, T> Iterator for PairSlices<'a, 'b, T> {\n    type Item = (&'a mut [T], &'b [T]);\n    fn next(&mut self) -> Option<Self::Item> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> Clone for VecDeque<T> {\n    fn clone(&self) -> VecDeque<T> {\n}\n\n    fn clone_from(&mut self, other: &Self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T> Drop for VecDeque<T> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for VecDeque<T> {\n    /// Creates an empty `VecDeque<T>`.\n    #[inline]\n    fn default() -> VecDeque<T> {\n}\n}\n\nimpl<T> VecDeque<T> {\n    /// Marginally more convenient\n    #[inline]\n    fn ptr(&self) -> *mut T {\n}\n\n    /// Marginally more convenient\n    #[inline]\n    fn cap(&self) -> usize {\n}\n\n    /// Turn ptr into a slice\n    #[inline]\n    unsafe fn buffer_as_slice(&self) -> &[T] {\n}\n\n    /// Turn ptr into a mut slice\n    #[inline]\n    unsafe fn buffer_as_mut_slice(&mut self) -> &mut [T] {\n}\n\n    /// Moves an element out of the buffer\n    #[inline]\n    unsafe fn buffer_read(&mut self, off: usize) -> T {\n}\n\n    /// Writes an element into the buffer, moving it.\n    #[inline]\n    unsafe fn buffer_write(&mut self, off: usize, value: T) {\n}\n\n    /// Returns `true` if the buffer is at full capacity.\n    #[inline]\n    fn is_full(&self) -> bool {\n}\n\n    /// Returns the index in the underlying buffer for a given logical element\n    /// index.\n    #[inline]\n    fn wrap_index(&self, idx: usize) -> usize {\n}\n\n    /// Returns the index in the underlying buffer for a given logical element\n    /// index + addend.\n    #[inline]\n    fn wrap_add(&self, idx: usize, addend: usize) -> usize {\n}\n\n    /// Returns the index in the underlying buffer for a given logical element\n    /// index - subtrahend.\n    #[inline]\n    fn wrap_sub(&self, idx: usize, subtrahend: usize) -> usize {\n}\n\n    /// Copies a contiguous block of memory len long from src to dst\n    #[inline]\n    unsafe fn copy(&self, dst: usize, src: usize, len: usize) {\n}\n\n    /// Copies a contiguous block of memory len long from src to dst\n    #[inline]\n    unsafe fn copy_nonoverlapping(&self, dst: usize, src: usize, len: usize) {\n}\n\n    /// Copies a potentially wrapping block of memory len long from src to dest.\n    /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n    /// most one continuous overlapping region between src and dest).\n    unsafe fn wrap_copy(&self, dst: usize, src: usize, len: usize) {\n}\n\n    /// Frobs the head and tail sections around to handle the fact that we\n    /// just reallocated. Unsafe because it trusts old_capacity.\n    #[inline]\n    unsafe fn handle_capacity_increase(&mut self, old_capacity: usize) {\n}\n}\n\nimpl<T> VecDeque<T> {\n    /// Creates an empty `VecDeque`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let vector: VecDeque<u32> = VecDeque::new();\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn new() -> VecDeque<T> {\n}\n\n    /// Creates an empty `VecDeque` with space for at least `capacity` elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let vector: VecDeque<u32> = VecDeque::with_capacity(10);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> VecDeque<T> {\n}\n\n    /// Retrieves an element in the `VecDeque` by index.\n    ///\n    /// Element at index 0 is the front of the queue.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// buf.push_back(3);\n    /// buf.push_back(4);\n    /// buf.push_back(5);\n    /// assert_eq!(buf.get(1), Some(&4));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get(&self, index: usize) -> Option<&T> {\n}\n\n    /// Retrieves an element in the `VecDeque` mutably by index.\n    ///\n    /// Element at index 0 is the front of the queue.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// buf.push_back(3);\n    /// buf.push_back(4);\n    /// buf.push_back(5);\n    /// if let Some(elem) = buf.get_mut(1) {\n    ///     *elem = 7;\n    /// }\n    ///\n    /// assert_eq!(buf[1], 7);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n}\n\n    /// Swaps elements at indices `i` and `j`.\n    ///\n    /// `i` and `j` may be equal.\n    ///\n    /// Element at index 0 is the front of the queue.\n    ///\n    /// # Panics\n    ///\n    /// Panics if either index is out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// buf.push_back(3);\n    /// buf.push_back(4);\n    /// buf.push_back(5);\n    /// assert_eq!(buf, [3, 4, 5]);\n    /// buf.swap(0, 2);\n    /// assert_eq!(buf, [5, 4, 3]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn swap(&mut self, i: usize, j: usize) {\n}\n\n    /// Returns the number of elements the `VecDeque` can hold without\n    /// reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n    /// assert!(buf.capacity() >= 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n}\n\n    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n    /// given `VecDeque`. Does nothing if the capacity is already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it requests. Therefore\n    /// capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n    /// insertions are expected.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf: VecDeque<i32> = vec![1].into_iter().collect();\n    /// buf.reserve_exact(10);\n    /// assert!(buf.capacity() >= 11);\n    /// ```\n    ///\n    /// [`reserve`]: #method.reserve\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve_exact(&mut self, additional: usize) {\n}\n\n    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n    /// `VecDeque`. The collection may reserve more space to avoid frequent reallocations.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf: VecDeque<i32> = vec![1].into_iter().collect();\n    /// buf.reserve(10);\n    /// assert!(buf.capacity() >= 11);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n}\n\n    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n    /// be inserted in the given `VecDeque<T>`. After calling `reserve_exact`,\n    /// capacity will be greater than or equal to `self.len() + additional`.\n    /// Does nothing if the capacity is already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it\n    /// requests. Therefore, capacity can not be relied upon to be precisely\n    /// minimal. Prefer `reserve` if future insertions are expected.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_reserve)]\n    /// use std::collections::TryReserveError;\n    /// use std::collections::VecDeque;\n    ///\n    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, TryReserveError> {\n    ///     let mut output = VecDeque::new();\n    ///\n    ///     // Pre-reserve the memory, exiting if we can't\n    ///     output.try_reserve_exact(data.len())?;\n    ///\n    ///     // Now we know this can't OOM in the middle of our complex work\n    ///     output.extend(data.iter().map(|&val| {\n    ///         val * 2 + 5 // very complicated\n    ///     }));\n    ///\n    ///     Ok(output)\n    /// }\n    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n    /// ```\n    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n}\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `VecDeque<T>`. The collection may reserve more space to avoid\n    /// frequent reallocations. After calling `reserve`, capacity will be\n    /// greater than or equal to `self.len() + additional`. Does nothing if\n    /// capacity is already sufficient.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_reserve)]\n    /// use std::collections::TryReserveError;\n    /// use std::collections::VecDeque;\n    ///\n    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, TryReserveError> {\n    ///     let mut output = VecDeque::new();\n    ///\n    ///     // Pre-reserve the memory, exiting if we can't\n    ///     output.try_reserve(data.len())?;\n    ///\n    ///     // Now we know this can't OOM in the middle of our complex work\n    ///     output.extend(data.iter().map(|&val| {\n    ///         val * 2 + 5 // very complicated\n    ///     }));\n    ///\n    ///     Ok(output)\n    /// }\n    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n    /// ```\n    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n}\n\n    /// Shrinks the capacity of the `VecDeque` as much as possible.\n    ///\n    /// It will drop down as close as possible to the length but the allocator may still inform the\n    /// `VecDeque` that there is space for a few more elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::with_capacity(15);\n    /// buf.extend(0..4);\n    /// assert_eq!(buf.capacity(), 15);\n    /// buf.shrink_to_fit();\n    /// assert!(buf.capacity() >= 4);\n    /// ```\n    #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n    pub fn shrink_to_fit(&mut self) {\n}\n\n    /// Shrinks the capacity of the `VecDeque` with a lower bound.\n    ///\n    /// The capacity will remain at least as large as both the length\n    /// and the supplied value.\n    ///\n    /// Panics if the current capacity is smaller than the supplied\n    /// minimum capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(shrink_to)]\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::with_capacity(15);\n    /// buf.extend(0..4);\n    /// assert_eq!(buf.capacity(), 15);\n    /// buf.shrink_to(6);\n    /// assert!(buf.capacity() >= 6);\n    /// buf.shrink_to(0);\n    /// assert!(buf.capacity() >= 4);\n    /// ```\n    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n}\n\n    /// Shortens the `VecDeque`, keeping the first `len` elements and dropping\n    /// the rest.\n    ///\n    /// If `len` is greater than the `VecDeque`'s current length, this has no\n    /// effect.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// buf.push_back(5);\n    /// buf.push_back(10);\n    /// buf.push_back(15);\n    /// assert_eq!(buf, [5, 10, 15]);\n    /// buf.truncate(1);\n    /// assert_eq!(buf, [5]);\n    /// ```\n    #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n    pub fn truncate(&mut self, len: usize) {\n}\n\n    /// Returns a front-to-back iterator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// buf.push_back(5);\n    /// buf.push_back(3);\n    /// buf.push_back(4);\n    /// let b: &[_] = &[&5, &3, &4];\n    /// let c: Vec<&i32> = buf.iter().collect();\n    /// assert_eq!(&c[..], b);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter(&self) -> Iter<'_, T> {\n}\n\n    /// Returns a front-to-back iterator that returns mutable references.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// buf.push_back(5);\n    /// buf.push_back(3);\n    /// buf.push_back(4);\n    /// for num in buf.iter_mut() {\n    ///     *num = *num - 2;\n    /// }\n    /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n    /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut i32>>()[..], b);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n}\n\n    /// Returns a pair of slices which contain, in order, the contents of the\n    /// `VecDeque`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut vector = VecDeque::new();\n    ///\n    /// vector.push_back(0);\n    /// vector.push_back(1);\n    /// vector.push_back(2);\n    ///\n    /// assert_eq!(vector.as_slices(), (&[0, 1, 2][..], &[][..]));\n    ///\n    /// vector.push_front(10);\n    /// vector.push_front(9);\n    ///\n    /// assert_eq!(vector.as_slices(), (&[9, 10][..], &[0, 1, 2][..]));\n    /// ```\n    #[inline]\n    #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n    pub fn as_slices(&self) -> (&[T], &[T]) {\n}\n\n    /// Returns a pair of slices which contain, in order, the contents of the\n    /// `VecDeque`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut vector = VecDeque::new();\n    ///\n    /// vector.push_back(0);\n    /// vector.push_back(1);\n    ///\n    /// vector.push_front(10);\n    /// vector.push_front(9);\n    ///\n    /// vector.as_mut_slices().0[0] = 42;\n    /// vector.as_mut_slices().1[0] = 24;\n    /// assert_eq!(vector.as_slices(), (&[42, 10][..], &[24, 1][..]));\n    /// ```\n    #[inline]\n    #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n    pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n}\n\n    /// Returns the number of elements in the `VecDeque`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut v = VecDeque::new();\n    /// assert_eq!(v.len(), 0);\n    /// v.push_back(1);\n    /// assert_eq!(v.len(), 1);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n}\n\n    /// Returns `true` if the `VecDeque` is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut v = VecDeque::new();\n    /// assert!(v.is_empty());\n    /// v.push_front(1);\n    /// assert!(!v.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n}\n\n    /// Creates a draining iterator that removes the specified range in the\n    /// `VecDeque` and yields the removed items.\n    ///\n    /// Note 1: The element range is removed even if the iterator is not\n    /// consumed until the end.\n    ///\n    /// Note 2: It is unspecified how many elements are removed from the deque,\n    /// if the `Drain` value is not dropped, but the borrow it holds expires\n    /// (e.g., due to `mem::forget`).\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut v: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n    /// let drained = v.drain(2..).collect::<VecDeque<_>>();\n    /// assert_eq!(drained, [3]);\n    /// assert_eq!(v, [1, 2]);\n    ///\n    /// // A full range clears all contents\n    /// v.drain(..);\n    /// assert!(v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain<R>(&mut self, range: R) -> Drain<'_, T>\n    where\n        R: RangeBounds<usize>,\n    {\n}\n\n    /// Clears the `VecDeque`, removing all values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut v = VecDeque::new();\n    /// v.push_back(1);\n    /// v.clear();\n    /// assert!(v.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn clear(&mut self) {\n}\n\n    /// Returns `true` if the `VecDeque` contains an element equal to the\n    /// given value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut vector: VecDeque<u32> = VecDeque::new();\n    ///\n    /// vector.push_back(0);\n    /// vector.push_back(1);\n    ///\n    /// assert_eq!(vector.contains(&1), true);\n    /// assert_eq!(vector.contains(&10), false);\n    /// ```\n    #[stable(feature = \"vec_deque_contains\", since = \"1.12.0\")]\n    pub fn contains(&self, x: &T) -> bool\n    where\n        T: PartialEq<T>,\n    {\n}\n\n    /// Provides a reference to the front element, or `None` if the `VecDeque` is\n    /// empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut d = VecDeque::new();\n    /// assert_eq!(d.front(), None);\n    ///\n    /// d.push_back(1);\n    /// d.push_back(2);\n    /// assert_eq!(d.front(), Some(&1));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn front(&self) -> Option<&T> {\n}\n\n    /// Provides a mutable reference to the front element, or `None` if the\n    /// `VecDeque` is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut d = VecDeque::new();\n    /// assert_eq!(d.front_mut(), None);\n    ///\n    /// d.push_back(1);\n    /// d.push_back(2);\n    /// match d.front_mut() {\n    ///     Some(x) => *x = 9,\n    ///     None => (),\n    /// }\n    /// assert_eq!(d.front(), Some(&9));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn front_mut(&mut self) -> Option<&mut T> {\n}\n\n    /// Provides a reference to the back element, or `None` if the `VecDeque` is\n    /// empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut d = VecDeque::new();\n    /// assert_eq!(d.back(), None);\n    ///\n    /// d.push_back(1);\n    /// d.push_back(2);\n    /// assert_eq!(d.back(), Some(&2));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn back(&self) -> Option<&T> {\n}\n\n    /// Provides a mutable reference to the back element, or `None` if the\n    /// `VecDeque` is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut d = VecDeque::new();\n    /// assert_eq!(d.back(), None);\n    ///\n    /// d.push_back(1);\n    /// d.push_back(2);\n    /// match d.back_mut() {\n    ///     Some(x) => *x = 9,\n    ///     None => (),\n    /// }\n    /// assert_eq!(d.back(), Some(&9));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn back_mut(&mut self) -> Option<&mut T> {\n}\n\n    /// Removes the first element and returns it, or `None` if the `VecDeque` is\n    /// empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut d = VecDeque::new();\n    /// d.push_back(1);\n    /// d.push_back(2);\n    ///\n    /// assert_eq!(d.pop_front(), Some(1));\n    /// assert_eq!(d.pop_front(), Some(2));\n    /// assert_eq!(d.pop_front(), None);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop_front(&mut self) -> Option<T> {\n}\n\n    /// Removes the last element from the `VecDeque` and returns it, or `None` if\n    /// it is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// assert_eq!(buf.pop_back(), None);\n    /// buf.push_back(1);\n    /// buf.push_back(3);\n    /// assert_eq!(buf.pop_back(), Some(3));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop_back(&mut self) -> Option<T> {\n}\n\n    /// Prepends an element to the `VecDeque`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut d = VecDeque::new();\n    /// d.push_front(1);\n    /// d.push_front(2);\n    /// assert_eq!(d.front(), Some(&2));\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push_front(&mut self, value: T) {\n}\n\n    /// Appends an element to the back of the `VecDeque`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// buf.push_back(1);\n    /// buf.push_back(3);\n    /// assert_eq!(3, *buf.back().unwrap());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push_back(&mut self, value: T) {\n}\n\n    #[inline]\n    fn is_contiguous(&self) -> bool {\n}\n\n    /// Removes an element from anywhere in the `VecDeque` and returns it,\n    /// replacing it with the first element.\n    ///\n    /// This does not preserve ordering, but is O(1).\n    ///\n    /// Returns `None` if `index` is out of bounds.\n    ///\n    /// Element at index 0 is the front of the queue.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// assert_eq!(buf.swap_remove_front(0), None);\n    /// buf.push_back(1);\n    /// buf.push_back(2);\n    /// buf.push_back(3);\n    /// assert_eq!(buf, [1, 2, 3]);\n    ///\n    /// assert_eq!(buf.swap_remove_front(2), Some(3));\n    /// assert_eq!(buf, [2, 1]);\n    /// ```\n    #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n    pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n}\n\n    /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n    /// last element.\n    ///\n    /// This does not preserve ordering, but is O(1).\n    ///\n    /// Returns `None` if `index` is out of bounds.\n    ///\n    /// Element at index 0 is the front of the queue.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// assert_eq!(buf.swap_remove_back(0), None);\n    /// buf.push_back(1);\n    /// buf.push_back(2);\n    /// buf.push_back(3);\n    /// assert_eq!(buf, [1, 2, 3]);\n    ///\n    /// assert_eq!(buf.swap_remove_back(0), Some(1));\n    /// assert_eq!(buf, [3, 2]);\n    /// ```\n    #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n    pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n}\n\n    /// Inserts an element at `index` within the `VecDeque`, shifting all elements with indices\n    /// greater than or equal to `index` towards the back.\n    ///\n    /// Element at index 0 is the front of the queue.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index` is greater than `VecDeque`'s length\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut vec_deque = VecDeque::new();\n    /// vec_deque.push_back('a');\n    /// vec_deque.push_back('b');\n    /// vec_deque.push_back('c');\n    /// assert_eq!(vec_deque, &['a', 'b', 'c']);\n    ///\n    /// vec_deque.insert(1, 'd');\n    /// assert_eq!(vec_deque, &['a', 'd', 'b', 'c']);\n    /// ```\n    #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n    pub fn insert(&mut self, index: usize, value: T) {\n}\n\n    /// Removes and returns the element at `index` from the `VecDeque`.\n    /// Whichever end is closer to the removal point will be moved to make\n    /// room, and all the affected elements will be moved to new positions.\n    /// Returns `None` if `index` is out of bounds.\n    ///\n    /// Element at index 0 is the front of the queue.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// buf.push_back(1);\n    /// buf.push_back(2);\n    /// buf.push_back(3);\n    /// assert_eq!(buf, [1, 2, 3]);\n    ///\n    /// assert_eq!(buf.remove(1), Some(2));\n    /// assert_eq!(buf, [1, 3]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove(&mut self, index: usize) -> Option<T> {\n}\n\n    /// Splits the `VecDeque` into two at the given index.\n    ///\n    /// Returns a newly allocated `VecDeque`. `self` contains elements `[0, at)`,\n    /// and the returned `VecDeque` contains elements `[at, len)`.\n    ///\n    /// Note that the capacity of `self` does not change.\n    ///\n    /// Element at index 0 is the front of the queue.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf: VecDeque<_> = vec![1,2,3].into_iter().collect();\n    /// let buf2 = buf.split_off(1);\n    /// assert_eq!(buf, [1]);\n    /// assert_eq!(buf2, [2, 3]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"split_off\", since = \"1.4.0\")]\n    pub fn split_off(&mut self, at: usize) -> Self {\n}\n\n    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new number of elements in self overflows a `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf: VecDeque<_> = vec![1, 2].into_iter().collect();\n    /// let mut buf2: VecDeque<_> = vec![3, 4].into_iter().collect();\n    /// buf.append(&mut buf2);\n    /// assert_eq!(buf, [1, 2, 3, 4]);\n    /// assert_eq!(buf2, []);\n    /// ```\n    #[inline]\n    #[stable(feature = \"append\", since = \"1.4.0\")]\n    pub fn append(&mut self, other: &mut Self) {\n}\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns false.\n    /// This method operates in place, visiting each element exactly once in the\n    /// original order, and preserves the order of the retained elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// buf.extend(1..5);\n    /// buf.retain(|&x| x % 2 == 0);\n    /// assert_eq!(buf, [2, 4]);\n    /// ```\n    ///\n    /// The exact order may be useful for tracking external state, like an index.\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// buf.extend(1..6);\n    ///\n    /// let keep = [false, true, true, false, true];\n    /// let mut i = 0;\n    /// buf.retain(|_| (keep[i], i += 1).0);\n    /// assert_eq!(buf, [2, 3, 5]);\n    /// ```\n    #[stable(feature = \"vec_deque_retain\", since = \"1.4.0\")]\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> bool,\n    {\n}\n\n    // This may panic or abort\n    #[inline]\n    fn grow_if_necessary(&mut self) {\n}\n\n    /// Modifies the `VecDeque` in-place so that `len()` is equal to `new_len`,\n    /// either by removing excess elements from the back or by appending\n    /// elements generated by calling `generator` to the back.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// buf.push_back(5);\n    /// buf.push_back(10);\n    /// buf.push_back(15);\n    /// assert_eq!(buf, [5, 10, 15]);\n    ///\n    /// buf.resize_with(5, Default::default);\n    /// assert_eq!(buf, [5, 10, 15, 0, 0]);\n    ///\n    /// buf.resize_with(2, || unreachable!());\n    /// assert_eq!(buf, [5, 10]);\n    ///\n    /// let mut state = 100;\n    /// buf.resize_with(5, || { state += 1; state });\n    /// assert_eq!(buf, [5, 10, 101, 102, 103]);\n    /// ```\n    #[stable(feature = \"vec_resize_with\", since = \"1.33.0\")]\n    pub fn resize_with(&mut self, new_len: usize, generator: impl FnMut() -> T) {\n}\n\n    /// Rotates the double-ended queue `mid` places to the left.\n    ///\n    /// Equivalently,\n    /// - Rotates item `mid` into the first position.\n    /// - Pops the first `mid` items and pushes them to the end.\n    /// - Rotates `len() - mid` places to the right.\n    ///\n    /// # Panics\n    ///\n    /// If `mid` is greater than `len()`. Note that `mid == len()`\n    /// does _not_ panic and is a no-op rotation.\n    ///\n    /// # Complexity\n    ///\n    /// Takes `O(min(mid, len() - mid))` time and no extra space.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf: VecDeque<_> = (0..10).collect();\n    ///\n    /// buf.rotate_left(3);\n    /// assert_eq!(buf, [3, 4, 5, 6, 7, 8, 9, 0, 1, 2]);\n    ///\n    /// for i in 1..10 {\n    ///     assert_eq!(i * 3 % 10, buf[0]);\n    ///     buf.rotate_left(3);\n    /// }\n    /// assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    /// ```\n    #[stable(feature = \"vecdeque_rotate\", since = \"1.36.0\")]\n    pub fn rotate_left(&mut self, mid: usize) {\n}\n\n    /// Rotates the double-ended queue `k` places to the right.\n    ///\n    /// Equivalently,\n    /// - Rotates the first item into position `k`.\n    /// - Pops the last `k` items and pushes them to the front.\n    /// - Rotates `len() - k` places to the left.\n    ///\n    /// # Panics\n    ///\n    /// If `k` is greater than `len()`. Note that `k == len()`\n    /// does _not_ panic and is a no-op rotation.\n    ///\n    /// # Complexity\n    ///\n    /// Takes `O(min(k, len() - k))` time and no extra space.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf: VecDeque<_> = (0..10).collect();\n    ///\n    /// buf.rotate_right(3);\n    /// assert_eq!(buf, [7, 8, 9, 0, 1, 2, 3, 4, 5, 6]);\n    ///\n    /// for i in 1..10 {\n    ///     assert_eq!(0, buf[i * 3 % 10]);\n    ///     buf.rotate_right(3);\n    /// }\n    /// assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    /// ```\n    #[stable(feature = \"vecdeque_rotate\", since = \"1.36.0\")]\n    pub fn rotate_right(&mut self, k: usize) {\n}\n\n    // Safety: the following two methods require that the rotation amount\n    // be less than half the length of the deque.\n    //\n    // `wrap_copy` requres that `min(x, cap() - x) + copy_len <= cap()`,\n    // but than `min` is never more than half the capacity, regardless of x,\n    // so it's sound to call here because we're calling with something\n    // less than half the length, which is never above half the capacity.\n\n    unsafe fn rotate_left_inner(&mut self, mid: usize) {\n}\n\n    unsafe fn rotate_right_inner(&mut self, k: usize) {\n}\n}\n\nimpl<T: Clone> VecDeque<T> {\n    /// Modifies the `VecDeque` in-place so that `len()` is equal to new_len,\n    /// either by removing excess elements from the back or by appending clones of `value`\n    /// to the back.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// let mut buf = VecDeque::new();\n    /// buf.push_back(5);\n    /// buf.push_back(10);\n    /// buf.push_back(15);\n    /// assert_eq!(buf, [5, 10, 15]);\n    ///\n    /// buf.resize(2, 0);\n    /// assert_eq!(buf, [5, 10]);\n    ///\n    /// buf.resize(5, 20);\n    /// assert_eq!(buf, [5, 10, 20, 20, 20]);\n    /// ```\n    #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n    pub fn resize(&mut self, new_len: usize, value: T) {\n}\n}\n\n/// Returns the index in the underlying buffer for a given logical element index.\n#[inline]\nfn wrap_index(index: usize, size: usize) -> usize {\n}\n\n/// Returns the two slices that cover the `VecDeque`'s valid range\ntrait RingSlices: Sized {\n    fn slice(self, from: usize, to: usize) -> Self;\n    fn split_at(self, i: usize) -> (Self, Self);\n\n    fn ring_slices(buf: Self, head: usize, tail: usize) -> (Self, Self) {\n        let contiguous = tail <= head;\n        if contiguous {\n            let (empty, buf) = buf.split_at(0);\n            (buf.slice(tail, head), empty)\n        } else {\n            let (mid, right) = buf.split_at(tail);\n            let (left, _) = mid.split_at(head);\n            (right, left)\n        }\n    }\n}\n\nimpl<T> RingSlices for &[T] {\n    fn slice(self, from: usize, to: usize) -> Self {\n}\n    fn split_at(self, i: usize) -> (Self, Self) {\n}\n}\n\nimpl<T> RingSlices for &mut [T] {\n    fn slice(self, from: usize, to: usize) -> Self {\n}\n    fn split_at(self, i: usize) -> (Self, Self) {\n}\n}\n\n/// Calculate the number of elements left to be read in the buffer\n#[inline]\nfn count(tail: usize, head: usize, size: usize) -> usize {\n}\n\n/// An iterator over the elements of a `VecDeque`.\n///\n/// This `struct` is created by the [`iter`] method on [`VecDeque`]. See its\n/// documentation for more.\n///\n/// [`iter`]: struct.VecDeque.html#method.iter\n/// [`VecDeque`]: struct.VecDeque.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Iter<'a, T: 'a> {\n    ring: &'a [T],\n    tail: usize,\n    head: usize,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Clone for Iter<'_, T> {\n    fn clone(&self) -> Self {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n    where\n        F: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n\n    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> R,\n        R: Try<Ok = B>,\n    {\n}\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n}\n\n    #[inline]\n    fn last(mut self) -> Option<&'a T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a T> {\n}\n\n    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n    where\n        F: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n\n    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> R,\n        R: Try<Ok = B>,\n    {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for Iter<'_, T> {\n    fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for Iter<'_, T> {}\n\n/// A mutable iterator over the elements of a `VecDeque`.\n///\n/// This `struct` is created by the [`iter_mut`] method on [`VecDeque`]. See its\n/// documentation for more.\n///\n/// [`iter_mut`]: struct.VecDeque.html#method.iter_mut\n/// [`VecDeque`]: struct.VecDeque.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IterMut<'a, T: 'a> {\n    ring: &'a mut [T],\n    tail: usize,\n    head: usize,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n\n    #[inline]\n    fn next(&mut self) -> Option<&'a mut T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n    where\n        F: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n}\n\n    #[inline]\n    fn last(mut self) -> Option<&'a mut T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<&'a mut T> {\n}\n\n    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n    where\n        F: FnMut(Acc, Self::Item) -> Acc,\n    {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for IterMut<'_, T> {\n    fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for IterMut<'_, T> {}\n\n/// An owning iterator over the elements of a `VecDeque`.\n///\n/// This `struct` is created by the [`into_iter`] method on [`VecDeque`]\n/// (provided by the `IntoIterator` trait). See its documentation for more.\n///\n/// [`into_iter`]: struct.VecDeque.html#method.into_iter\n/// [`VecDeque`]: struct.VecDeque.html\n#[derive(Clone)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<T> {\n    inner: VecDeque<T>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for IntoIter<T> {\n    fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for IntoIter<T> {}\n\n/// A draining iterator over the elements of a `VecDeque`.\n///\n/// This `struct` is created by the [`drain`] method on [`VecDeque`]. See its\n/// documentation for more.\n///\n/// [`drain`]: struct.VecDeque.html#method.drain\n/// [`VecDeque`]: struct.VecDeque.html\n#[stable(feature = \"drain\", since = \"1.6.0\")]\npub struct Drain<'a, T: 'a> {\n    after_tail: usize,\n    after_head: usize,\n    iter: Iter<'a, T>,\n    deque: NonNull<VecDeque<T>>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl<T: Sync> Sync for Drain<'_, T> {}\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl<T: Send> Send for Drain<'_, T> {}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<T> Drop for Drain<'_, T> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<T> Iterator for Drain<'_, T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<T> DoubleEndedIterator for Drain<'_, T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n}\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<T> ExactSizeIterator for Drain<'_, T> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for Drain<'_, T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: PartialEq> PartialEq for VecDeque<A> {\n    fn eq(&self, other: &VecDeque<A>) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Eq> Eq for VecDeque<A> {}\n\nmacro_rules! __impl_slice_eq1 {\n    ([$($vars:tt)*] $lhs:ty, $rhs:ty, $($constraints:tt)*) => {\n        #[stable(feature = \"vec_deque_partial_eq_slice\", since = \"1.17.0\")]\n        impl<A, B, $($vars)*> PartialEq<$rhs> for $lhs\n        where\n            A: PartialEq<B>,\n            $($constraints)*\n        {\n            fn eq(&self, other: &$rhs) -> bool {\n}\n        }\n    }\n}\n\n__impl_slice_eq1! { [] VecDeque<A>, Vec<B>, }\n__impl_slice_eq1! { [] VecDeque<A>, &[B], }\n__impl_slice_eq1! { [] VecDeque<A>, &mut [B], }\n__impl_slice_eq1! { [const N: usize] VecDeque<A>, [B; N], [B; N]: LengthAtMost32 }\n__impl_slice_eq1! { [const N: usize] VecDeque<A>, &[B; N], [B; N]: LengthAtMost32 }\n__impl_slice_eq1! { [const N: usize] VecDeque<A>, &mut [B; N], [B; N]: LengthAtMost32 }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: PartialOrd> PartialOrd for VecDeque<A> {\n    fn partial_cmp(&self, other: &VecDeque<A>) -> Option<Ordering> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Ord> Ord for VecDeque<A> {\n    #[inline]\n    fn cmp(&self, other: &VecDeque<A>) -> Ordering {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A: Hash> Hash for VecDeque<A> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> Index<usize> for VecDeque<A> {\n    type Output = A;\n\n    #[inline]\n    fn index(&self, index: usize) -> &A {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> IndexMut<usize> for VecDeque<A> {\n    #[inline]\n    fn index_mut(&mut self, index: usize) -> &mut A {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> FromIterator<A> for VecDeque<A> {\n    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> VecDeque<A> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> IntoIterator for VecDeque<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Consumes the `VecDeque` into a front-to-back iterator yielding elements by\n    /// value.\n    fn into_iter(self) -> IntoIter<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a VecDeque<T> {\n    type Item = &'a T;\n    type IntoIter = Iter<'a, T>;\n\n    fn into_iter(self) -> Iter<'a, T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n    type Item = &'a mut T;\n    type IntoIter = IterMut<'a, T>;\n\n    fn into_iter(self) -> IterMut<'a, T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<A> Extend<A> for VecDeque<A> {\n    fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T) {\n}\n}\n\n#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\nimpl<'a, T: 'a + Copy> Extend<&'a T> for VecDeque<T> {\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"vecdeque_vec_conversions\", since = \"1.10.0\")]\nimpl<T> From<Vec<T>> for VecDeque<T> {\n    /// Turn a [`Vec<T>`] into a [`VecDeque<T>`].\n    ///\n    /// [`Vec<T>`]: crate::vec::Vec\n    /// [`VecDeque<T>`]: crate::collections::VecDeque\n    ///\n    /// This avoids reallocating where possible, but the conditions for that are\n    /// strict, and subject to change, and so shouldn't be relied upon unless the\n    /// `Vec<T>` came from `From<VecDeque<T>>` and hasn't been reallocated.\n    fn from(mut other: Vec<T>) -> Self {\n}\n}\n\n#[stable(feature = \"vecdeque_vec_conversions\", since = \"1.10.0\")]\nimpl<T> From<VecDeque<T>> for Vec<T> {\n    /// Turn a [`VecDeque<T>`] into a [`Vec<T>`].\n    ///\n    /// [`Vec<T>`]: crate::vec::Vec\n    /// [`VecDeque<T>`]: crate::collections::VecDeque\n    ///\n    /// This never needs to re-allocate, but does need to do O(n) data movement if\n    /// the circular buffer doesn't happen to be at the beginning of the allocation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::VecDeque;\n    ///\n    /// // This one is O(1).\n    /// let deque: VecDeque<_> = (1..5).collect();\n    /// let ptr = deque.as_slices().0.as_ptr();\n    /// let vec = Vec::from(deque);\n    /// assert_eq!(vec, [1, 2, 3, 4]);\n    /// assert_eq!(vec.as_ptr(), ptr);\n    ///\n    /// // This one needs data rearranging.\n    /// let mut deque: VecDeque<_> = (1..5).collect();\n    /// deque.push_front(9);\n    /// deque.push_front(8);\n    /// let ptr = deque.as_slices().1.as_ptr();\n    /// let vec = Vec::from(deque);\n    /// assert_eq!(vec, [8, 9, 1, 2, 3, 4]);\n    /// assert_eq!(vec.as_ptr(), ptr);\n    /// ```\n    fn from(other: VecDeque<T>) -> Self {\n}\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod btree_map {\n    //! A map based on a B-Tree.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub use super::btree::map::*;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod btree_set {\n    //! A set based on a B-Tree.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub use super::btree::set::*;\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use binary_heap::BinaryHeap;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use btree_map::BTreeMap;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use btree_set::BTreeSet;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use linked_list::LinkedList;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use vec_deque::VecDeque;\n\nuse crate::alloc::{Layout, LayoutErr};\n\n/// The error type for `try_reserve` methods.\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\npub enum TryReserveError {\n}\n\n#[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\nimpl From<LayoutErr> for TryReserveError {\n}\n\n/// An intermediate trait for specialization of `Extend`.\n#[doc(hidden)]\ntrait SpecExtend<I: IntoIterator> {\n    /// Extends `self` with the contents of the given iterator.\n    fn spec_extend(&mut self, iter: I);\n}\n}\npub mod fmt {\n//! Utilities for formatting and printing `String`s.\n//!\n//! This module contains the runtime support for the [`format!`] syntax extension.\n//! This macro is implemented in the compiler to emit calls to this module in\n//! order to format arguments at runtime into strings.\n//!\n//! # Usage\n//!\n//! The [`format!`] macro is intended to be familiar to those coming from C's\n//! `printf`/`fprintf` functions or Python's `str.format` function.\n//!\n//! Some examples of the [`format!`] extension are:\n//!\n//! ```\n//! format!(\"Hello\");                 // => \"Hello\"\n//! format!(\"Hello, {}!\", \"world\");   // => \"Hello, world!\"\n//! format!(\"The number is {}\", 1);   // => \"The number is 1\"\n//! format!(\"{:?}\", (3, 4));          // => \"(3, 4)\"\n//! format!(\"{value}\", value=4);      // => \"4\"\n//! format!(\"{} {}\", 1, 2);           // => \"1 2\"\n//! format!(\"{:04}\", 42);             // => \"0042\" with leading zeros\n//! ```\n//!\n//! From these, you can see that the first argument is a format string. It is\n//! required by the compiler for this to be a string literal; it cannot be a\n//! variable passed in (in order to perform validity checking). The compiler\n//! will then parse the format string and determine if the list of arguments\n//! provided is suitable to pass to this format string.\n//!\n//! To convert a single value to a string, use the [`to_string`] method. This\n//! will use the [`Display`] formatting trait.\n//!\n//! ## Positional parameters\n//!\n//! Each formatting argument is allowed to specify which value argument it's\n//! referencing, and if omitted it is assumed to be \"the next argument\". For\n//! example, the format string `{} {} {}` would take three parameters, and they\n//! would be formatted in the same order as they're given. The format string\n//! `{2} {1} {0}`, however, would format arguments in reverse order.\n//!\n//! Things can get a little tricky once you start intermingling the two types of\n//! positional specifiers. The \"next argument\" specifier can be thought of as an\n//! iterator over the argument. Each time a \"next argument\" specifier is seen,\n//! the iterator advances. This leads to behavior like this:\n//!\n//! ```\n//! format!(\"{1} {} {0} {}\", 1, 2); // => \"2 1 1 2\"\n//! ```\n//!\n//! The internal iterator over the argument has not been advanced by the time\n//! the first `{}` is seen, so it prints the first argument. Then upon reaching\n//! the second `{}`, the iterator has advanced forward to the second argument.\n//! Essentially, parameters which explicitly name their argument do not affect\n//! parameters which do not name an argument in terms of positional specifiers.\n//!\n//! A format string is required to use all of its arguments, otherwise it is a\n//! compile-time error. You may refer to the same argument more than once in the\n//! format string.\n//!\n//! ## Named parameters\n//!\n//! Rust itself does not have a Python-like equivalent of named parameters to a\n//! function, but the [`format!`] macro is a syntax extension which allows it to\n//! leverage named parameters. Named parameters are listed at the end of the\n//! argument list and have the syntax:\n//!\n//! ```text\n//! identifier '=' expression\n//! ```\n//!\n//! For example, the following [`format!`] expressions all use named argument:\n//!\n//! ```\n//! format!(\"{argument}\", argument = \"test\");   // => \"test\"\n//! format!(\"{name} {}\", 1, name = 2);          // => \"2 1\"\n//! format!(\"{a} {c} {b}\", a=\"a\", b='b', c=3);  // => \"a 3 b\"\n//! ```\n//!\n//! It is not valid to put positional parameters (those without names) after\n//! arguments which have names. Like with positional parameters, it is not\n//! valid to provide named parameters that are unused by the format string.\n//!\n//! # Formatting Parameters\n//!\n//! Each argument being formatted can be transformed by a number of formatting\n//! parameters (corresponding to `format_spec` in the syntax above). These\n//! parameters affect the string representation of what's being formatted.\n//!\n//! ## Width\n//!\n//! ```\n//! // All of these print \"Hello x    !\"\n//! println!(\"Hello {:5}!\", \"x\");\n//! println!(\"Hello {:1$}!\", \"x\", 5);\n//! println!(\"Hello {1:0$}!\", 5, \"x\");\n//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n//! ```\n//!\n//! This is a parameter for the \"minimum width\" that the format should take up.\n//! If the value's string does not fill up this many characters, then the\n//! padding specified by fill/alignment will be used to take up the required\n//! space (see below).\n//!\n//! The value for the width can also be provided as a [`usize`] in the list of\n//! parameters by adding a postfix `$`, indicating that the second argument is\n//! a [`usize`] specifying the width.\n//!\n//! Referring to an argument with the dollar syntax does not affect the \"next\n//! argument\" counter, so it's usually a good idea to refer to arguments by\n//! position, or use named arguments.\n//!\n//! ## Fill/Alignment\n//!\n//! ```\n//! assert_eq!(format!(\"Hello {:<5}!\", \"x\"),  \"Hello x    !\");\n//! assert_eq!(format!(\"Hello {:-<5}!\", \"x\"), \"Hello x----!\");\n//! assert_eq!(format!(\"Hello {:^5}!\", \"x\"),  \"Hello   x  !\");\n//! assert_eq!(format!(\"Hello {:>5}!\", \"x\"),  \"Hello     x!\");\n//! ```\n//!\n//! The optional fill character and alignment is provided normally in conjunction with the\n//! [`width`](#width) parameter. It must be defined before `width`, right after the `:`.\n//! This indicates that if the value being formatted is smaller than\n//! `width` some extra characters will be printed around it.\n//! Filling comes in the following variants for different alignments:\n//!\n//! * `[fill]<` - the argument is left-aligned in `width` columns\n//! * `[fill]^` - the argument is center-aligned in `width` columns\n//! * `[fill]>` - the argument is right-aligned in `width` columns\n//!\n//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n//! left-aligned. The\n//! defaults for numeric formatters is also a space but with right-alignment. If\n//! the `0` flag (see below) is specified for numerics, then the implicit fill character is\n//! `0`.\n//!\n//! Note that alignment may not be implemented by some types. In particular, it\n//! is not generally implemented for the `Debug` trait.  A good way to ensure\n//! padding is applied is to format your input, then pad this resulting string\n//! to obtain your output:\n//!\n//! ```\n//! println!(\"Hello {:^15}!\", format!(\"{:?}\", Some(\"hi\"))); // => \"Hello   Some(\"hi\")   !\"\n//! ```\n//!\n//! ## Sign/`#`/`0`\n//!\n//! ```\n//! assert_eq!(format!(\"Hello {:+}!\", 5), \"Hello +5!\");\n//! assert_eq!(format!(\"{:#x}!\", 27), \"0x1b!\");\n//! assert_eq!(format!(\"Hello {:05}!\", 5),  \"Hello 00005!\");\n//! assert_eq!(format!(\"Hello {:05}!\", -5), \"Hello -0005!\");\n//! assert_eq!(format!(\"{:#010x}!\", 27), \"0x0000001b!\");\n//! ```\n//!\n//! These are all flags altering the behavior of the formatter.\n//!\n//! * `+` - This is intended for numeric types and indicates that the sign\n//!         should always be printed. Positive signs are never printed by\n//!         default, and the negative sign is only printed by default for the\n//!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n//!         should always be printed.\n//! * `-` - Currently not used\n//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n//!         be used. The alternate forms are:\n//!     * `#?` - pretty-print the [`Debug`] formatting\n//!     * `#x` - precedes the argument with a `0x`\n//!     * `#X` - precedes the argument with a `0x`\n//!     * `#b` - precedes the argument with a `0b`\n//!     * `#o` - precedes the argument with a `0o`\n//! * `0` - This is used to indicate for integer formats that the padding to `width` should\n//!         both be done with a `0` character as well as be sign-aware. A format\n//!         like `{:08}` would yield `00000001` for the integer `1`, while the\n//!         same format would yield `-0000001` for the integer `-1`. Notice that\n//!         the negative version has one fewer zero than the positive version.\n//!         Note that padding zeroes are always placed after the sign (if any)\n//!         and before the digits. When used together with the `#` flag, a similar\n//!         rule applies: padding zeroes are inserted after the prefix but before\n//!         the digits. The prefix is included in the total width.\n//!\n//! ## Precision\n//!\n//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n//! longer than this width, then it is truncated down to this many characters and that truncated\n//! value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n//!\n//! For integral types, this is ignored.\n//!\n//! For floating-point types, this indicates how many digits after the decimal point should be\n//! printed.\n//!\n//! There are three possible ways to specify the desired `precision`:\n//!\n//! 1. An integer `.N`:\n//!\n//!    the integer `N` itself is the precision.\n//!\n//! 2. An integer or name followed by dollar sign `.N$`:\n//!\n//!    use format *argument* `N` (which must be a `usize`) as the precision.\n//!\n//! 3. An asterisk `.*`:\n//!\n//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n//!\n//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n//!\n//! ```\n//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n//!\n//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n//!\n//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n//!\n//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n//! //                          specified in first of next two args (5)}\n//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n//!\n//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n//! //                          specified in its predecessor (5)}\n//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n//!\n//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n//! //                          in arg \"prec\" (5)}\n//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n//! ```\n//!\n//! While these:\n//!\n//! ```\n//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n//! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n//! ```\n//!\n//! print two significantly different things:\n//!\n//! ```text\n//! Hello, `1234.560` has 3 fractional digits\n//! Hello, `123` has 3 characters\n//! Hello, `     123` has 3 right-aligned characters\n//! ```\n//!\n//! # Escaping\n//!\n//! The literal characters `{` and `}` may be included in a string by preceding\n//! them with the same character. For example, the `{` character is escaped with\n//! `{{` and the `}` character is escaped with `}}`.\n//!\n//! ```\n//! assert_eq!(format!(\"Hello {{}}\"), \"Hello {}\");\n//! assert_eq!(format!(\"{{ Hello\"), \"{ Hello\");\n//! ```\n//!\n//! # Syntax\n//!\n//! To summarize, here you can find the full grammar of format strings.\n//! The syntax for the formatting language used is drawn from other languages,\n//! so it should not be too alien. Arguments are formatted with Python-like\n//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n//! `%`. The actual grammar for the formatting syntax is:\n//!\n//! ```text\n//! format_string := <text> [ maybe-format <text> ] *\n//! maybe-format := '{' '{' | '}' '}' | <format>\n//! format := '{' [ argument ] [ ':' format_spec ] '}'\n//! argument := integer | identifier\n//!\n//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n//! fill := character\n//! align := '<' | '^' | '>'\n//! sign := '+' | '-'\n//! width := count\n//! precision := count | '*'\n//! type := identifier | '?' | ''\n//! count := parameter | integer\n//! parameter := argument '$'\n//! ```\n//!\n//! # Formatting traits\n//!\n//! When requesting that an argument be formatted with a particular type, you\n//! are actually requesting that an argument ascribes to a particular trait.\n//! This allows multiple actual types to be formatted via `{:x}` (like [`i8`] as\n//! well as [`isize`]). The current mapping of types to traits is:\n//!\n//! * *nothing* ⇒ [`Display`]\n//! * `?` ⇒ [`Debug`]\n//! * `x?` ⇒ [`Debug`] with lower-case hexadecimal integers\n//! * `X?` ⇒ [`Debug`] with upper-case hexadecimal integers\n//! * `o` ⇒ [`Octal`](trait.Octal.html)\n//! * `x` ⇒ [`LowerHex`](trait.LowerHex.html)\n//! * `X` ⇒ [`UpperHex`](trait.UpperHex.html)\n//! * `p` ⇒ [`Pointer`](trait.Pointer.html)\n//! * `b` ⇒ [`Binary`]\n//! * `e` ⇒ [`LowerExp`](trait.LowerExp.html)\n//! * `E` ⇒ [`UpperExp`](trait.UpperExp.html)\n//!\n//! What this means is that any type of argument which implements the\n//! [`fmt::Binary`][`Binary`] trait can then be formatted with `{:b}`. Implementations\n//! are provided for these traits for a number of primitive types by the\n//! standard library as well. If no format is specified (as in `{}` or `{:6}`),\n//! then the format trait used is the [`Display`] trait.\n//!\n//! When implementing a format trait for your own type, you will have to\n//! implement a method of the signature:\n//!\n//! ```\n//! # #![allow(dead_code)]\n//! # use std::fmt;\n//! # struct Foo; // our custom type\n//! # impl fmt::Display for Foo {\n//! fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n//! # write!(f, \"testing, testing\")\n//! # } }\n//! ```\n//!\n//! Your type will be passed as `self` by-reference, and then the function\n//! should emit output into the `f.buf` stream. It is up to each format trait\n//! implementation to correctly adhere to the requested formatting parameters.\n//! The values of these parameters will be listed in the fields of the\n//! [`Formatter`] struct. In order to help with this, the [`Formatter`] struct also\n//! provides some helper methods.\n//!\n//! Additionally, the return value of this function is [`fmt::Result`] which is a\n//! type alias of [`Result`]`<(), `[`std::fmt::Error`]`>`. Formatting implementations\n//! should ensure that they propagate errors from the [`Formatter`] (e.g., when\n//! calling [`write!`]). However, they should never return errors spuriously. That\n//! is, a formatting implementation must and may only return an error if the\n//! passed-in [`Formatter`] returns an error. This is because, contrary to what\n//! the function signature might suggest, string formatting is an infallible\n//! operation. This function only returns a result because writing to the\n//! underlying stream might fail and it must provide a way to propagate the fact\n//! that an error has occurred back up the stack.\n//!\n//! An example of implementing the formatting traits would look\n//! like:\n//!\n//! ```\n//! use std::fmt;\n//!\n//! #[derive(Debug)]\n//! struct Vector2D {\n//!     x: isize,\n//!     y: isize,\n//! }\n//!\n//! impl fmt::Display for Vector2D {\n//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n//!         // The `f` value implements the `Write` trait, which is what the\n//!         // write! macro is expecting. Note that this formatting ignores the\n//!         // various flags provided to format strings.\n//!         write!(f, \"({}, {})\", self.x, self.y)\n//!     }\n//! }\n//!\n//! // Different traits allow different forms of output of a type. The meaning\n//! // of this format is to print the magnitude of a vector.\n//! impl fmt::Binary for Vector2D {\n//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n//!         let magnitude = (self.x * self.x + self.y * self.y) as f64;\n//!         let magnitude = magnitude.sqrt();\n//!\n//!         // Respect the formatting flags by using the helper method\n//!         // `pad_integral` on the Formatter object. See the method\n//!         // documentation for details, and the function `pad` can be used\n//!         // to pad strings.\n//!         let decimals = f.precision().unwrap_or(3);\n//!         let string = format!(\"{:.*}\", decimals, magnitude);\n//!         f.pad_integral(true, \"\", &string)\n//!     }\n//! }\n//!\n//! fn main() {\n//!     let myvector = Vector2D { x: 3, y: 4 };\n//!\n//!     println!(\"{}\", myvector);       // => \"(3, 4)\"\n//!     println!(\"{:?}\", myvector);     // => \"Vector2D {x: 3, y:4}\"\n//!     println!(\"{:10.3b}\", myvector); // => \"     5.000\"\n//! }\n//! ```\n//!\n//! ### `fmt::Display` vs `fmt::Debug`\n//!\n//! These two formatting traits have distinct purposes:\n//!\n//! - [`fmt::Display`][`Display`] implementations assert that the type can be faithfully\n//!   represented as a UTF-8 string at all times. It is **not** expected that\n//!   all types implement the [`Display`] trait.\n//! - [`fmt::Debug`][`Debug`] implementations should be implemented for **all** public types.\n//!   Output will typically represent the internal state as faithfully as possible.\n//!   The purpose of the [`Debug`] trait is to facilitate debugging Rust code. In\n//!   most cases, using `#[derive(Debug)]` is sufficient and recommended.\n//!\n//! Some examples of the output from both traits:\n//!\n//! ```\n//! assert_eq!(format!(\"{} {:?}\", 3, 4), \"3 4\");\n//! assert_eq!(format!(\"{} {:?}\", 'a', 'b'), \"a 'b'\");\n//! assert_eq!(format!(\"{} {:?}\", \"foo\\n\", \"bar\\n\"), \"foo\\n \\\"bar\\\\n\\\"\");\n//! ```\n//!\n//! # Related macros\n//!\n//! There are a number of related macros in the [`format!`] family. The ones that\n//! are currently implemented are:\n//!\n//! ```ignore (only-for-syntax-highlight)\n//! format!      // described above\n//! write!       // first argument is a &mut io::Write, the destination\n//! writeln!     // same as write but appends a newline\n//! print!       // the format string is printed to the standard output\n//! println!     // same as print but appends a newline\n//! eprint!      // the format string is printed to the standard error\n//! eprintln!    // same as eprint but appends a newline\n//! format_args! // described below.\n//! ```\n//!\n//! ### `write!`\n//!\n//! This and [`writeln!`] are two macros which are used to emit the format string\n//! to a specified stream. This is used to prevent intermediate allocations of\n//! format strings and instead directly write the output. Under the hood, this\n//! function is actually invoking the [`write_fmt`] function defined on the\n//! [`std::io::Write`] trait. Example usage is:\n//!\n//! ```\n//! # #![allow(unused_must_use)]\n//! use std::io::Write;\n//! let mut w = Vec::new();\n//! write!(&mut w, \"Hello {}!\", \"world\");\n//! ```\n//!\n//! ### `print!`\n//!\n//! This and [`println!`] emit their output to stdout. Similarly to the [`write!`]\n//! macro, the goal of these macros is to avoid intermediate allocations when\n//! printing output. Example usage is:\n//!\n//! ```\n//! print!(\"Hello {}!\", \"world\");\n//! println!(\"I have a newline {}\", \"character at the end\");\n//! ```\n//! ### `eprint!`\n//!\n//! The [`eprint!`] and [`eprintln!`] macros are identical to\n//! [`print!`] and [`println!`], respectively, except they emit their\n//! output to stderr.\n//!\n//! ### `format_args!`\n//!\n//! This is a curious macro which is used to safely pass around\n//! an opaque object describing the format string. This object\n//! does not require any heap allocations to create, and it only\n//! references information on the stack. Under the hood, all of\n//! the related macros are implemented in terms of this. First\n//! off, some example usage is:\n//!\n//! ```\n//! # #![allow(unused_must_use)]\n//! use std::fmt;\n//! use std::io::{self, Write};\n//!\n//! let mut some_writer = io::stdout();\n//! write!(&mut some_writer, \"{}\", format_args!(\"print with a {}\", \"macro\"));\n//!\n//! fn my_fmt_fn(args: fmt::Arguments) {\n//!     write!(&mut io::stdout(), \"{}\", args);\n//! }\n//! my_fmt_fn(format_args!(\", or a {} too\", \"function\"));\n//! ```\n//!\n//! The result of the [`format_args!`] macro is a value of type [`fmt::Arguments`].\n//! This structure can then be passed to the [`write`] and [`format`] functions\n//! inside this module in order to process the format string.\n//! The goal of this macro is to even further prevent intermediate allocations\n//! when dealing formatting strings.\n//!\n//! For example, a logging library could use the standard formatting syntax, but\n//! it would internally pass around this structure until it has been determined\n//! where output should go to.\n//!\n//! [`usize`]: ../../std/primitive.usize.html\n//! [`isize`]: ../../std/primitive.isize.html\n//! [`i8`]: ../../std/primitive.i8.html\n//! [`Display`]: trait.Display.html\n//! [`Binary`]: trait.Binary.html\n//! [`fmt::Result`]: type.Result.html\n//! [`Result`]: ../../std/result/enum.Result.html\n//! [`std::fmt::Error`]: struct.Error.html\n//! [`Formatter`]: struct.Formatter.html\n//! [`write!`]: ../../std/macro.write.html\n//! [`Debug`]: trait.Debug.html\n//! [`format!`]: ../../std/macro.format.html\n//! [`to_string`]: ../../std/string/trait.ToString.html\n//! [`writeln!`]: ../../std/macro.writeln.html\n//! [`write_fmt`]: ../../std/io/trait.Write.html#method.write_fmt\n//! [`std::io::Write`]: ../../std/io/trait.Write.html\n//! [`print!`]: ../../std/macro.print.html\n//! [`println!`]: ../../std/macro.println.html\n//! [`eprint!`]: ../../std/macro.eprint.html\n//! [`eprintln!`]: ../../std/macro.eprintln.html\n//! [`write!`]: ../../std/macro.write.html\n//! [`format_args!`]: ../../std/macro.format_args.html\n//! [`fmt::Arguments`]: struct.Arguments.html\n//! [`write`]: fn.write.html\n//! [`format`]: fn.format.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[unstable(feature = \"fmt_internals\", issue = \"none\")]\npub use core::fmt::rt;\n#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\npub use core::fmt::Alignment;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::fmt::Error;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::fmt::{write, ArgumentV1, Arguments};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::fmt::{Binary, Octal};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::fmt::{Debug, Display};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::fmt::{Formatter, Result, Write};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::fmt::{LowerExp, UpperExp};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::fmt::{LowerHex, Pointer, UpperHex};\n\nuse crate::string;\n\n/// The `format` function takes an [`Arguments`] struct and returns the resulting\n/// formatted string.\n///\n/// The [`Arguments`] instance can be created with the [`format_args!`] macro.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// use std::fmt;\n///\n/// let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n/// assert_eq!(s, \"Hello, world!\");\n/// ```\n///\n/// Please note that using [`format!`] might be preferable.\n/// Example:\n///\n/// ```\n/// let s = format!(\"Hello, {}!\", \"world\");\n/// assert_eq!(s, \"Hello, world!\");\n/// ```\n///\n/// [`Arguments`]: struct.Arguments.html\n/// [`format_args!`]: ../../std/macro.format_args.html\n/// [`format!`]: ../../std/macro.format.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn format(args: Arguments<'_>) -> string::String {\n}\n}\npub mod prelude {\n//! The alloc Prelude\n//!\n//! The purpose of this module is to alleviate imports of commonly-used\n//! items of the `alloc` crate by adding a glob import to the top of modules:\n//!\n//! ```\n//! # #![allow(unused_imports)]\n//! #![feature(alloc_prelude)]\n//! extern crate alloc;\n//! use alloc::prelude::v1::*;\n//! ```\n\n#![unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n\npub mod v1 {\n//! The first version of the prelude of `alloc` crate.\n//!\n//! See the [module-level documentation](../index.html) for more.\n\n#![unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n\n#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\npub use crate::borrow::ToOwned;\n#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\npub use crate::boxed::Box;\n#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\npub use crate::string::{String, ToString};\n#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\npub use crate::vec::Vec;\n}\n}\npub mod raw_vec {\n#![unstable(feature = \"raw_vec_internals\", reason = \"implementation detail\", issue = \"none\")]\n#![doc(hidden)]\n\nuse core::cmp;\nuse core::mem;\nuse core::ops::Drop;\nuse core::ptr::{self, NonNull, Unique};\nuse core::slice;\n\nuse crate::alloc::{handle_alloc_error, Alloc, AllocErr, Global, Layout};\nuse crate::boxed::Box;\nuse crate::collections::TryReserveError::{self, *};\n\n#[cfg(test)]\nmod tests {\n}\n\n/// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n/// a buffer of memory on the heap without having to worry about all the corner cases\n/// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n/// In particular:\n///\n/// * Produces `Unique::empty()` on zero-sized types.\n/// * Produces `Unique::empty()` on zero-length allocations.\n/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics).\n/// * Guards against 32-bit systems allocating more than isize::MAX bytes.\n/// * Guards against overflowing your length.\n/// * Aborts on OOM or calls `handle_alloc_error` as applicable.\n/// * Avoids freeing `Unique::empty()`.\n/// * Contains a `ptr::Unique` and thus endows the user with all related benefits.\n///\n/// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n/// free its memory, but it *won't* try to drop its contents. It is up to the user of `RawVec`\n/// to handle the actual things *stored* inside of a `RawVec`.\n///\n/// Note that a `RawVec` always forces its capacity to be `usize::MAX` for zero-sized types.\n/// This enables you to use capacity-growing logic catch the overflows in your length\n/// that might occur with zero-sized types.\n///\n/// The above means that you need to be careful when round-tripping this type with a\n/// `Box<[T]>`, since `capacity()` won't yield the length. However, `with_capacity`,\n/// `shrink_to_fit`, and `from_box` will actually set `RawVec`'s private capacity\n/// field. This allows zero-sized types to not be special-cased by consumers of\n/// this type.\n#[allow(missing_debug_implementations)]\npub struct RawVec<T, A: Alloc = Global> {\n    ptr: Unique<T>,\n    cap: usize,\n    a: A,\n}\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    /// Like `new`, but parameterized over the choice of allocator for\n    /// the returned `RawVec`.\n    pub const fn new_in(a: A) -> Self {\n}\n\n    /// Like `with_capacity`, but parameterized over the choice of\n    /// allocator for the returned `RawVec`.\n    #[inline]\n    pub fn with_capacity_in(capacity: usize, a: A) -> Self {\n}\n\n    /// Like `with_capacity_zeroed`, but parameterized over the choice\n    /// of allocator for the returned `RawVec`.\n    #[inline]\n    pub fn with_capacity_zeroed_in(capacity: usize, a: A) -> Self {\n}\n\n    fn allocate_in(capacity: usize, zeroed: bool, mut a: A) -> Self {\n}\n}\n\nimpl<T> RawVec<T, Global> {\n    /// HACK(Centril): This exists because `#[unstable]` `const fn`s needn't conform\n    /// to `min_const_fn` and so they cannot be called in `min_const_fn`s either.\n    ///\n    /// If you change `RawVec<T>::new` or dependencies, please take care to not\n    /// introduce anything that would truly violate `min_const_fn`.\n    ///\n    /// NOTE: We could avoid this hack and check conformance with some\n    /// `#[rustc_force_min_const_fn]` attribute which requires conformance\n    /// with `min_const_fn` but does not necessarily allow calling it in\n    /// `stable(...) const fn` / user code not enabling `foo` when\n    /// `#[rustc_const_unstable(feature = \"foo\", ..)]` is present.\n    pub const NEW: Self = Self::new();\n\n    /// Creates the biggest possible `RawVec` (on the system heap)\n    /// without allocating. If `T` has positive size, then this makes a\n    /// `RawVec` with capacity `0`. If `T` is zero-sized, then it makes a\n    /// `RawVec` with capacity `usize::MAX`. Useful for implementing\n    /// delayed allocation.\n    pub const fn new() -> Self {\n}\n\n    /// Creates a `RawVec` (on the system heap) with exactly the\n    /// capacity and alignment requirements for a `[T; capacity]`. This is\n    /// equivalent to calling `RawVec::new` when `capacity` is `0` or `T` is\n    /// zero-sized. Note that if `T` is zero-sized this means you will\n    /// *not* get a `RawVec` with the requested capacity.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM.\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Self {\n}\n\n    /// Like `with_capacity`, but guarantees the buffer is zeroed.\n    #[inline]\n    pub fn with_capacity_zeroed(capacity: usize) -> Self {\n}\n}\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n    ///\n    /// # Undefined Behavior\n    ///\n    /// The `ptr` must be allocated (via the given allocator `a`), and with the given `capacity`.\n    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n    /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n}\n}\n\nimpl<T> RawVec<T, Global> {\n    /// Reconstitutes a `RawVec` from a pointer and capacity.\n    ///\n    /// # Undefined Behavior\n    ///\n    /// The `ptr` must be allocated (on the system heap), and with the given `capacity`.\n    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n    /// If the `ptr` and `capacity` come from a `RawVec`, then this is guaranteed.\n    pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n}\n\n    /// Converts a `Box<[T]>` into a `RawVec<T>`.\n    pub fn from_box(mut slice: Box<[T]>) -> Self {\n}\n}\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    /// Gets a raw pointer to the start of the allocation. Note that this is\n    /// `Unique::empty()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n    /// be careful.\n    pub fn ptr(&self) -> *mut T {\n}\n\n    /// Gets the capacity of the allocation.\n    ///\n    /// This will always be `usize::MAX` if `T` is zero-sized.\n    #[inline(always)]\n    pub fn capacity(&self) -> usize {\n}\n\n    /// Returns a shared reference to the allocator backing this `RawVec`.\n    pub fn alloc(&self) -> &A {\n}\n\n    /// Returns a mutable reference to the allocator backing this `RawVec`.\n    pub fn alloc_mut(&mut self) -> &mut A {\n}\n\n    fn current_layout(&self) -> Option<Layout> {\n}\n\n    /// Doubles the size of the type's backing allocation. This is common enough\n    /// to want to do that it's easiest to just have a dedicated method. Slightly\n    /// more efficient logic can be provided for this than the general case.\n    ///\n    /// This function is ideal for when pushing elements one-at-a-time because\n    /// you don't need to incur the costs of the more general computations\n    /// reserve needs to do to guard against overflow. You do however need to\n    /// manually check if your `len == capacity`.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n    ///   all `usize::MAX` slots in your imaginary buffer.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(raw_vec_internals)]\n    /// # extern crate alloc;\n    /// # use std::ptr;\n    /// # use alloc::raw_vec::RawVec;\n    /// struct MyVec<T> {\n    ///     buf: RawVec<T>,\n    ///     len: usize,\n    /// }\n    ///\n    /// impl<T> MyVec<T> {\n    ///     pub fn push(&mut self, elem: T) {\n    ///         if self.len == self.buf.capacity() { self.buf.double(); }\n    ///         // double would have aborted or panicked if the len exceeded\n    ///         // `isize::MAX` so this is safe to do unchecked now.\n    ///         unsafe {\n    ///             ptr::write(self.buf.ptr().add(self.len), elem);\n    ///         }\n    ///         self.len += 1;\n    ///     }\n    /// }\n    /// # fn main() {\n    /// #   let mut vec = MyVec { buf: RawVec::new(), len: 0 };\n    /// #   vec.push(1);\n    /// # }\n    /// ```\n    #[inline(never)]\n    #[cold]\n    pub fn double(&mut self) {\n}\n\n    /// Attempts to double the size of the type's backing allocation in place. This is common\n    /// enough to want to do that it's easiest to just have a dedicated method. Slightly\n    /// more efficient logic can be provided for this than the general case.\n    ///\n    /// Returns `true` if the reallocation attempt has succeeded.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n    ///   all `usize::MAX` slots in your imaginary buffer.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    #[inline(never)]\n    #[cold]\n    pub fn double_in_place(&mut self) -> bool {\n}\n\n    /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n    pub fn try_reserve_exact(\n        &mut self,\n        used_capacity: usize,\n        needed_extra_capacity: usize,\n    ) -> Result<(), TryReserveError> {\n}\n\n    /// Ensures that the buffer contains at least enough space to hold\n    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already,\n    /// will reallocate the minimum possible amount of memory necessary.\n    /// Generally this will be exactly the amount of memory necessary,\n    /// but in principle the allocator is free to give back more than\n    /// we asked for.\n    ///\n    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n    /// the requested space. This is not really unsafe, but the unsafe\n    /// code *you* write that relies on the behavior of this function may break.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM.\n    pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n}\n\n    /// Calculates the buffer's new size given that it'll hold `used_capacity +\n    /// needed_extra_capacity` elements. This logic is used in amortized reserve methods.\n    /// Returns `(new_capacity, new_alloc_size)`.\n    fn amortized_new_size(\n        &self,\n        used_capacity: usize,\n        needed_extra_capacity: usize,\n    ) -> Result<usize, TryReserveError> {\n}\n\n    /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n    pub fn try_reserve(\n        &mut self,\n        used_capacity: usize,\n        needed_extra_capacity: usize,\n    ) -> Result<(), TryReserveError> {\n}\n\n    /// Ensures that the buffer contains at least enough space to hold\n    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n    /// enough capacity, will reallocate enough space plus comfortable slack\n    /// space to get amortized `O(1)` behavior. Will limit this behavior\n    /// if it would needlessly cause itself to panic.\n    ///\n    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n    /// the requested space. This is not really unsafe, but the unsafe\n    /// code *you* write that relies on the behavior of this function may break.\n    ///\n    /// This is ideal for implementing a bulk-push operation like `extend`.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(raw_vec_internals)]\n    /// # extern crate alloc;\n    /// # use std::ptr;\n    /// # use alloc::raw_vec::RawVec;\n    /// struct MyVec<T> {\n    ///     buf: RawVec<T>,\n    ///     len: usize,\n    /// }\n    ///\n    /// impl<T: Clone> MyVec<T> {\n    ///     pub fn push_all(&mut self, elems: &[T]) {\n    ///         self.buf.reserve(self.len, elems.len());\n    ///         // reserve would have aborted or panicked if the len exceeded\n    ///         // `isize::MAX` so this is safe to do unchecked now.\n    ///         for x in elems {\n    ///             unsafe {\n    ///                 ptr::write(self.buf.ptr().add(self.len), x.clone());\n    ///             }\n    ///             self.len += 1;\n    ///         }\n    ///     }\n    /// }\n    /// # fn main() {\n    /// #   let mut vector = MyVec { buf: RawVec::new(), len: 0 };\n    /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n    /// # }\n    /// ```\n    pub fn reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n}\n    /// Attempts to ensure that the buffer contains at least enough space to hold\n    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n    /// enough capacity, will reallocate in place enough space plus comfortable slack\n    /// space to get amortized `O(1)` behavior. Will limit this behaviour\n    /// if it would needlessly cause itself to panic.\n    ///\n    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n    /// the requested space. This is not really unsafe, but the unsafe\n    /// code *you* write that relies on the behavior of this function may break.\n    ///\n    /// Returns `true` if the reallocation attempt has succeeded.\n    ///\n    /// # Panics\n    ///\n    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n    /// * Panics on 32-bit platforms if the requested capacity exceeds\n    ///   `isize::MAX` bytes.\n    pub fn reserve_in_place(&mut self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n}\n\n    /// Shrinks the allocation down to the specified amount. If the given amount\n    /// is 0, actually completely deallocates.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the given amount is *larger* than the current capacity.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM.\n    pub fn shrink_to_fit(&mut self, amount: usize) {\n}\n}\n\nenum Fallibility {\n    Fallible,\n    Infallible,\n}\n\nuse Fallibility::*;\n\nenum ReserveStrategy {\n    Exact,\n    Amortized,\n}\n\nuse ReserveStrategy::*;\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    fn reserve_internal(\n        &mut self,\n        used_capacity: usize,\n        needed_extra_capacity: usize,\n        fallibility: Fallibility,\n        strategy: ReserveStrategy,\n    ) -> Result<(), TryReserveError> {\n}\n}\n\nimpl<T> RawVec<T, Global> {\n    /// Converts the entire buffer into `Box<[T]>`.\n    ///\n    /// Note that this will correctly reconstitute any `cap` changes\n    /// that may have been performed. (See description of type for details.)\n    ///\n    /// # Undefined Behavior\n    ///\n    /// All elements of `RawVec<T, Global>` must be initialized. Notice that\n    /// the rules around uninitialized boxed values are not finalized yet,\n    /// but until they are, it is advisable to avoid them.\n    pub unsafe fn into_box(self) -> Box<[T]> {\n}\n}\n\nimpl<T, A: Alloc> RawVec<T, A> {\n    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n    pub unsafe fn dealloc_buffer(&mut self) {\n}\n}\n\nunsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n    fn drop(&mut self) {\n}\n}\n\n// We need to guarantee the following:\n// * We don't ever allocate `> isize::MAX` byte-size objects.\n// * We don't overflow `usize::MAX` and actually allocate too little.\n//\n// On 64-bit we just need to check for overflow since trying to allocate\n// `> isize::MAX` bytes will surely fail. On 32-bit and 16-bit we need to add\n// an extra guard for this in case we're running on a platform which can use\n// all 4GB in user-space, e.g., PAE or x32.\n\n#[inline]\nfn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n}\n\n// One central function responsible for reporting capacity overflows. This'll\n// ensure that the code generation related to these panics is minimal as there's\n// only one location which panics rather than a bunch throughout the module.\nfn capacity_overflow() -> ! {\n}\n}\npub mod rc {\n//! Single-threaded reference-counting pointers. 'Rc' stands for 'Reference\n//! Counted'.\n//!\n//! The type [`Rc<T>`][`Rc`] provides shared ownership of a value of type `T`,\n//! allocated in the heap. Invoking [`clone`][clone] on [`Rc`] produces a new\n//! pointer to the same allocation in the heap. When the last [`Rc`] pointer to a\n//! given allocation is destroyed, the value stored in that allocation (often\n//! referred to as \"inner value\") is also dropped.\n//!\n//! Shared references in Rust disallow mutation by default, and [`Rc`]\n//! is no exception: you cannot generally obtain a mutable reference to\n//! something inside an [`Rc`]. If you need mutability, put a [`Cell`]\n//! or [`RefCell`] inside the [`Rc`]; see [an example of mutability\n//! inside an Rc][mutability].\n//!\n//! [`Rc`] uses non-atomic reference counting. This means that overhead is very\n//! low, but an [`Rc`] cannot be sent between threads, and consequently [`Rc`]\n//! does not implement [`Send`][send]. As a result, the Rust compiler\n//! will check *at compile time* that you are not sending [`Rc`]s between\n//! threads. If you need multi-threaded, atomic reference counting, use\n//! [`sync::Arc`][arc].\n//!\n//! The [`downgrade`][downgrade] method can be used to create a non-owning\n//! [`Weak`] pointer. A [`Weak`] pointer can be [`upgrade`][upgrade]d\n//! to an [`Rc`], but this will return [`None`] if the value stored in the allocation has\n//! already been dropped. In other words, `Weak` pointers do not keep the value\n//! inside the allocation alive; however, they *do* keep the allocation\n//! (the backing store for the inner value) alive.\n//!\n//! A cycle between [`Rc`] pointers will never be deallocated. For this reason,\n//! [`Weak`] is used to break cycles. For example, a tree could have strong\n//! [`Rc`] pointers from parent nodes to children, and [`Weak`] pointers from\n//! children back to their parents.\n//!\n//! `Rc<T>` automatically dereferences to `T` (via the [`Deref`] trait),\n//! so you can call `T`'s methods on a value of type [`Rc<T>`][`Rc`]. To avoid name\n//! clashes with `T`'s methods, the methods of [`Rc<T>`][`Rc`] itself are associated\n//! functions, called using function-like syntax:\n//!\n//! ```\n//! use std::rc::Rc;\n//! let my_rc = Rc::new(());\n//!\n//! Rc::downgrade(&my_rc);\n//! ```\n//!\n//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the inner value may have\n//! already been dropped.\n//!\n//! # Cloning references\n//!\n//! Creating a new reference to the same allocation as an existing reference counted pointer\n//! is done using the `Clone` trait implemented for [`Rc<T>`][`Rc`] and [`Weak<T>`][`Weak`].\n//!\n//! ```\n//! use std::rc::Rc;\n//! let foo = Rc::new(vec![1.0, 2.0, 3.0]);\n//! // The two syntaxes below are equivalent.\n//! let a = foo.clone();\n//! let b = Rc::clone(&foo);\n//! // a and b both point to the same memory location as foo.\n//! ```\n//!\n//! The `Rc::clone(&from)` syntax is the most idiomatic because it conveys more explicitly\n//! the meaning of the code. In the example above, this syntax makes it easier to see that\n//! this code is creating a new reference rather than copying the whole content of foo.\n//!\n//! # Examples\n//!\n//! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.\n//! We want to have our `Gadget`s point to their `Owner`. We can't do this with\n//! unique ownership, because more than one gadget may belong to the same\n//! `Owner`. [`Rc`] allows us to share an `Owner` between multiple `Gadget`s,\n//! and have the `Owner` remain allocated as long as any `Gadget` points at it.\n//!\n//! ```\n//! use std::rc::Rc;\n//!\n//! struct Owner {\n//!     name: String,\n//!     // ...other fields\n//! }\n//!\n//! struct Gadget {\n//!     id: i32,\n//!     owner: Rc<Owner>,\n//!     // ...other fields\n//! }\n//!\n//! fn main() {\n//!     // Create a reference-counted `Owner`.\n//!     let gadget_owner: Rc<Owner> = Rc::new(\n//!         Owner {\n//!             name: \"Gadget Man\".to_string(),\n//!         }\n//!     );\n//!\n//!     // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc<Owner>`\n//!     // gives us a new pointer to the same `Owner` allocation, incrementing\n//!     // the reference count in the process.\n//!     let gadget1 = Gadget {\n//!         id: 1,\n//!         owner: Rc::clone(&gadget_owner),\n//!     };\n//!     let gadget2 = Gadget {\n//!         id: 2,\n//!         owner: Rc::clone(&gadget_owner),\n//!     };\n//!\n//!     // Dispose of our local variable `gadget_owner`.\n//!     drop(gadget_owner);\n//!\n//!     // Despite dropping `gadget_owner`, we're still able to print out the name\n//!     // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n//!     // single `Rc<Owner>`, not the `Owner` it points to. As long as there are\n//!     // other `Rc<Owner>` pointing at the same `Owner` allocation, it will remain\n//!     // live. The field projection `gadget1.owner.name` works because\n//!     // `Rc<Owner>` automatically dereferences to `Owner`.\n//!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n//!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n//!\n//!     // At the end of the function, `gadget1` and `gadget2` are destroyed, and\n//!     // with them the last counted references to our `Owner`. Gadget Man now\n//!     // gets destroyed as well.\n//! }\n//! ```\n//!\n//! If our requirements change, and we also need to be able to traverse from\n//! `Owner` to `Gadget`, we will run into problems. An [`Rc`] pointer from `Owner`\n//! to `Gadget` introduces a cycle. This means that their\n//! reference counts can never reach 0, and the allocation will never be destroyed:\n//! a memory leak. In order to get around this, we can use [`Weak`]\n//! pointers.\n//!\n//! Rust actually makes it somewhat difficult to produce this loop in the first\n//! place. In order to end up with two values that point at each other, one of\n//! them needs to be mutable. This is difficult because [`Rc`] enforces\n//! memory safety by only giving out shared references to the value it wraps,\n//! and these don't allow direct mutation. We need to wrap the part of the\n//! value we wish to mutate in a [`RefCell`], which provides *interior\n//! mutability*: a method to achieve mutability through a shared reference.\n//! [`RefCell`] enforces Rust's borrowing rules at runtime.\n//!\n//! ```\n//! use std::rc::Rc;\n//! use std::rc::Weak;\n//! use std::cell::RefCell;\n//!\n//! struct Owner {\n//!     name: String,\n//!     gadgets: RefCell<Vec<Weak<Gadget>>>,\n//!     // ...other fields\n//! }\n//!\n//! struct Gadget {\n//!     id: i32,\n//!     owner: Rc<Owner>,\n//!     // ...other fields\n//! }\n//!\n//! fn main() {\n//!     // Create a reference-counted `Owner`. Note that we've put the `Owner`'s\n//!     // vector of `Gadget`s inside a `RefCell` so that we can mutate it through\n//!     // a shared reference.\n//!     let gadget_owner: Rc<Owner> = Rc::new(\n//!         Owner {\n//!             name: \"Gadget Man\".to_string(),\n//!             gadgets: RefCell::new(vec![]),\n//!         }\n//!     );\n//!\n//!     // Create `Gadget`s belonging to `gadget_owner`, as before.\n//!     let gadget1 = Rc::new(\n//!         Gadget {\n//!             id: 1,\n//!             owner: Rc::clone(&gadget_owner),\n//!         }\n//!     );\n//!     let gadget2 = Rc::new(\n//!         Gadget {\n//!             id: 2,\n//!             owner: Rc::clone(&gadget_owner),\n//!         }\n//!     );\n//!\n//!     // Add the `Gadget`s to their `Owner`.\n//!     {\n//!         let mut gadgets = gadget_owner.gadgets.borrow_mut();\n//!         gadgets.push(Rc::downgrade(&gadget1));\n//!         gadgets.push(Rc::downgrade(&gadget2));\n//!\n//!         // `RefCell` dynamic borrow ends here.\n//!     }\n//!\n//!     // Iterate over our `Gadget`s, printing their details out.\n//!     for gadget_weak in gadget_owner.gadgets.borrow().iter() {\n//!\n//!         // `gadget_weak` is a `Weak<Gadget>`. Since `Weak` pointers can't\n//!         // guarantee the allocation still exists, we need to call\n//!         // `upgrade`, which returns an `Option<Rc<Gadget>>`.\n//!         //\n//!         // In this case we know the allocation still exists, so we simply\n//!         // `unwrap` the `Option`. In a more complicated program, you might\n//!         // need graceful error handling for a `None` result.\n//!\n//!         let gadget = gadget_weak.upgrade().unwrap();\n//!         println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n//!     }\n//!\n//!     // At the end of the function, `gadget_owner`, `gadget1`, and `gadget2`\n//!     // are destroyed. There are now no strong (`Rc`) pointers to the\n//!     // gadgets, so they are destroyed. This zeroes the reference count on\n//!     // Gadget Man, so he gets destroyed as well.\n//! }\n//! ```\n//!\n//! [`Rc`]: struct.Rc.html\n//! [`Weak`]: struct.Weak.html\n//! [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n//! [`Cell`]: ../../std/cell/struct.Cell.html\n//! [`RefCell`]: ../../std/cell/struct.RefCell.html\n//! [send]: ../../std/marker/trait.Send.html\n//! [arc]: ../../std/sync/struct.Arc.html\n//! [`Deref`]: ../../std/ops/trait.Deref.html\n//! [downgrade]: struct.Rc.html#method.downgrade\n//! [upgrade]: struct.Weak.html#method.upgrade\n//! [`None`]: ../../std/option/enum.Option.html#variant.None\n//! [mutability]: ../../std/cell/index.html#introducing-mutability-inside-of-something-immutable\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[cfg(not(test))]\nuse crate::boxed::Box;\n#[cfg(test)]\nuse std::boxed::Box;\n\nuse core::any::Any;\nuse core::array::LengthAtMost32;\nuse core::borrow;\nuse core::cell::Cell;\nuse core::cmp::Ordering;\nuse core::convert::{From, TryFrom};\nuse core::fmt;\nuse core::hash::{Hash, Hasher};\nuse core::intrinsics::abort;\nuse core::iter;\nuse core::marker::{self, PhantomData, Unpin, Unsize};\nuse core::mem::{self, align_of, align_of_val, forget, size_of_val};\nuse core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\nuse core::pin::Pin;\nuse core::ptr::{self, NonNull};\nuse core::slice::{self, from_raw_parts_mut};\nuse core::usize;\n\nuse crate::alloc::{box_free, handle_alloc_error, Alloc, Global, Layout};\nuse crate::string::String;\nuse crate::vec::Vec;\n\n#[cfg(test)]\nmod tests {\n}\n\nstruct RcBox<T: ?Sized> {\n    strong: Cell<usize>,\n    weak: Cell<usize>,\n    value: T,\n}\n\n/// A single-threaded reference-counting pointer. 'Rc' stands for 'Reference\n/// Counted'.\n///\n/// See the [module-level documentation](./index.html) for more details.\n///\n/// The inherent methods of `Rc` are all associated functions, which means\n/// that you have to call them as e.g., [`Rc::get_mut(&mut value)`][get_mut] instead of\n/// `value.get_mut()`. This avoids conflicts with methods of the inner\n/// type `T`.\n///\n/// [get_mut]: #method.get_mut\n#[cfg_attr(not(test), lang = \"rc\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Rc<T: ?Sized> {\n    ptr: NonNull<RcBox<T>>,\n    phantom: PhantomData<RcBox<T>>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !marker::Send for Rc<T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized> !marker::Sync for Rc<T> {}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}}\npub mod slice {\n//! A dynamically-sized view into a contiguous sequence, `[T]`.\n//!\n//! *[See also the slice primitive type](../../std/primitive.slice.html).*\n//!\n//! Slices are a view into a block of memory represented as a pointer and a\n//! length.\n//!\n//! ```\n//! // slicing a Vec\n//! let vec = vec![1, 2, 3];\n//! let int_slice = &vec[..];\n//! // coercing an array to a slice\n//! let str_slice: &[&str] = &[\"one\", \"two\", \"three\"];\n//! ```\n//!\n//! Slices are either mutable or shared. The shared slice type is `&[T]`,\n//! while the mutable slice type is `&mut [T]`, where `T` represents the element\n//! type. For example, you can mutate the block of memory that a mutable slice\n//! points to:\n//!\n//! ```\n//! let x = &mut [1, 2, 3];\n//! x[1] = 7;\n//! assert_eq!(x, &[1, 7, 3]);\n//! ```\n//!\n//! Here are some of the things this module contains:\n//!\n//! ## Structs\n//!\n//! There are several structs that are useful for slices, such as [`Iter`], which\n//! represents iteration over a slice.\n//!\n//! ## Trait Implementations\n//!\n//! There are several implementations of common traits for slices. Some examples\n//! include:\n//!\n//! * [`Clone`]\n//! * [`Eq`], [`Ord`] - for slices whose element type are [`Eq`] or [`Ord`].\n//! * [`Hash`] - for slices whose element type is [`Hash`].\n//!\n//! ## Iteration\n//!\n//! The slices implement `IntoIterator`. The iterator yields references to the\n//! slice elements.\n//!\n//! ```\n//! let numbers = &[0, 1, 2];\n//! for n in numbers {\n//!     println!(\"{} is a number!\", n);\n//! }\n//! ```\n//!\n//! The mutable slice yields mutable references to the elements:\n//!\n//! ```\n//! let mut scores = [7, 8, 9];\n//! for score in &mut scores[..] {\n//!     *score += 1;\n//! }\n//! ```\n//!\n//! This iterator yields mutable references to the slice's elements, so while\n//! the element type of the slice is `i32`, the element type of the iterator is\n//! `&mut i32`.\n//!\n//! * [`.iter`] and [`.iter_mut`] are the explicit methods to return the default\n//!   iterators.\n//! * Further methods that return iterators are [`.split`], [`.splitn`],\n//!   [`.chunks`], [`.windows`] and more.\n//!\n//! [`Clone`]: ../../std/clone/trait.Clone.html\n//! [`Eq`]: ../../std/cmp/trait.Eq.html\n//! [`Ord`]: ../../std/cmp/trait.Ord.html\n//! [`Iter`]: struct.Iter.html\n//! [`Hash`]: ../../std/hash/trait.Hash.html\n//! [`.iter`]: ../../std/primitive.slice.html#method.iter\n//! [`.iter_mut`]: ../../std/primitive.slice.html#method.iter_mut\n//! [`.split`]: ../../std/primitive.slice.html#method.split\n//! [`.splitn`]: ../../std/primitive.slice.html#method.splitn\n//! [`.chunks`]: ../../std/primitive.slice.html#method.chunks\n//! [`.windows`]: ../../std/primitive.slice.html#method.windows\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n// Many of the usings in this module are only used in the test configuration.\n// It's cleaner to just turn off the unused_imports warning than to fix them.\n#![cfg_attr(test, allow(unused_imports, dead_code))]\n\nuse core::borrow::{Borrow, BorrowMut};\nuse core::cmp::Ordering::{self, Less};\nuse core::mem::{self, size_of};\nuse core::ptr;\nuse core::{u16, u32, u8};\n\nuse crate::borrow::ToOwned;\nuse crate::boxed::Box;\nuse crate::vec::Vec;\n\n#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\npub use core::slice::SliceIndex;\n#[stable(feature = \"from_ref\", since = \"1.28.0\")]\npub use core::slice::{from_mut, from_ref};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{from_raw_parts, from_raw_parts_mut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{Chunks, Windows};\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\npub use core::slice::{ChunksExact, ChunksExactMut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{ChunksMut, Split, SplitMut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{Iter, IterMut};\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\npub use core::slice::{RChunks, RChunksExact, RChunksExactMut, RChunksMut};\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\npub use core::slice::{RSplit, RSplitMut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{RSplitN, RSplitNMut, SplitN, SplitNMut};\n\n////////////////////////////////////////////////////////////////////////////////\n// Basic slice extension methods\n////////////////////////////////////////////////////////////////////////////////\n\n// HACK(japaric) needed for the implementation of `vec!` macro during testing\n// N.B., see the `hack` module in this file for more details.\n#[cfg(test)]\npub use hack::into_vec;\n\n// HACK(japaric) needed for the implementation of `Vec::clone` during testing\n// N.B., see the `hack` module in this file for more details.\n#[cfg(test)]\npub use hack::to_vec;\n\n// HACK(japaric): With cfg(test) `impl [T]` is not available, these three\n// functions are actually methods that are in `impl [T]` but not in\n// `core::slice::SliceExt` - we need to supply these functions for the\n// `test_permutations` test\nmod hack {\n    use crate::boxed::Box;\n    #[cfg(test)]\n    use crate::string::ToString;\n    use crate::vec::Vec;\n\n    pub fn into_vec<T>(b: Box<[T]>) -> Vec<T> {\n}\n\n    #[inline]\n    pub fn to_vec<T>(s: &[T]) -> Vec<T>\n    where\n        T: Clone,\n    {\n}\n}\n\n#[lang = \"slice_alloc\"]\n#[cfg(not(test))]\nimpl<T> [T] {\n    /// Sorts the slice.\n    ///\n    /// This sort is stable (i.e., does not reorder equal elements) and `O(n log n)` worst-case.\n    ///\n    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n    /// sorting and it doesn't allocate auxiliary memory.\n    /// See [`sort_unstable`](#method.sort_unstable).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is an adaptive, iterative merge sort inspired by\n    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n    /// two or more sorted sequences concatenated one after another.\n    ///\n    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n    /// non-allocating insertion sort is used instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5, 4, 1, -3, 2];\n    ///\n    /// v.sort();\n    /// assert!(v == [-5, -3, 1, 2, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sort(&mut self)\n    where\n        T: Ord,\n    {\n}\n\n    /// Sorts the slice with a comparator function.\n    ///\n    /// This sort is stable (i.e., does not reorder equal elements) and `O(n log n)` worst-case.\n    ///\n    /// The comparator function must define a total ordering for the elements in the slice. If\n    /// the ordering is not total, the order of the elements is unspecified. An order is a\n    /// total order if it is (for all `a`, `b` and `c`):\n    ///\n    /// * total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true, and\n    /// * transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n    ///\n    /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n    /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`.\n    ///\n    /// ```\n    /// let mut floats = [5f64, 4.0, 1.0, 3.0, 2.0];\n    /// floats.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    /// assert_eq!(floats, [1.0, 2.0, 3.0, 4.0, 5.0]);\n    /// ```\n    ///\n    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n    /// sorting and it doesn't allocate auxiliary memory.\n    /// See [`sort_unstable_by`](#method.sort_unstable_by).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is an adaptive, iterative merge sort inspired by\n    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n    /// two or more sorted sequences concatenated one after another.\n    ///\n    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n    /// non-allocating insertion sort is used instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [5, 4, 1, 3, 2];\n    /// v.sort_by(|a, b| a.cmp(b));\n    /// assert!(v == [1, 2, 3, 4, 5]);\n    ///\n    /// // reverse sorting\n    /// v.sort_by(|a, b| b.cmp(a));\n    /// assert!(v == [5, 4, 3, 2, 1]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sort_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n}\n\n    /// Sorts the slice with a key extraction function.\n    ///\n    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n log(m n))`\n    /// worst-case, where the key function is `O(m)`.\n    ///\n    /// For expensive key functions (e.g. functions that are not simple property accesses or\n    /// basic operations), [`sort_by_cached_key`](#method.sort_by_cached_key) is likely to be\n    /// significantly faster, as it does not recompute element keys.\n    ///\n    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n    /// sorting and it doesn't allocate auxiliary memory.\n    /// See [`sort_unstable_by_key`](#method.sort_unstable_by_key).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is an adaptive, iterative merge sort inspired by\n    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n    /// two or more sorted sequences concatenated one after another.\n    ///\n    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n    /// non-allocating insertion sort is used instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// v.sort_by_key(|k| k.abs());\n    /// assert!(v == [1, 2, -3, 4, -5]);\n    /// ```\n    #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n    #[inline]\n    pub fn sort_by_key<K, F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n}\n\n    /// Sorts the slice with a key extraction function.\n    ///\n    /// During sorting, the key function is called only once per element.\n    ///\n    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n + n log n)`\n    /// worst-case, where the key function is `O(m)`.\n    ///\n    /// For simple key functions (e.g., functions that are property accesses or\n    /// basic operations), [`sort_by_key`](#method.sort_by_key) is likely to be\n    /// faster.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n    /// which combines the fast average case of randomized quicksort with the fast worst case of\n    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n    /// deterministic behavior.\n    ///\n    /// In the worst case, the algorithm allocates temporary storage in a `Vec<(K, usize)>` the\n    /// length of the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 32, -3, 2];\n    ///\n    /// v.sort_by_cached_key(|k| k.to_string());\n    /// assert!(v == [-3, -5, 2, 32, 4]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[stable(feature = \"slice_sort_by_cached_key\", since = \"1.34.0\")]\n    #[inline]\n    pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n}\n\n    /// Copies `self` into a new `Vec`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s = [10, 40, 30];\n    /// let x = s.to_vec();\n    /// // Here, `s` and `x` can be modified independently.\n    /// ```\n    #[rustc_conversion_suggestion]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_vec(&self) -> Vec<T>\n    where\n        T: Clone,\n    {\n}\n\n    /// Converts `self` into a vector without clones or allocation.\n    ///\n    /// The resulting vector can be converted back into a box via\n    /// `Vec<T>`'s `into_boxed_slice` method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s: Box<[i32]> = Box::new([10, 40, 30]);\n    /// let x = s.into_vec();\n    /// // `s` cannot be used anymore because it has been converted into `x`.\n    ///\n    /// assert_eq!(x, vec![10, 40, 30]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn into_vec(self: Box<Self>) -> Vec<T> {\n}\n\n    /// Creates a vector by repeating a slice `n` times.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the capacity would overflow.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);\n    /// ```\n    ///\n    /// A panic upon overflow:\n    ///\n    /// ```should_panic\n    /// // this will panic at runtime\n    /// b\"0123456789abcdef\".repeat(usize::max_value());\n    /// ```\n    #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n    pub fn repeat(&self, n: usize) -> Vec<T>\n    where\n        T: Copy,\n    {\n}\n\n    /// Flattens a slice of `T` into a single value `Self::Output`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n    /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n    where\n        Self: Concat<Item>,\n    {\n}\n\n    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n    /// given separator between each.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n    /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n    /// assert_eq!([[1, 2], [3, 4]].join(&[0, 0][..]), [1, 2, 0, 0, 3, 4]);\n    /// ```\n    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n    pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n    where\n        Self: Join<Separator>,\n    {\n}\n\n    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n    /// given separator between each.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![allow(deprecated)]\n    /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n    /// assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n    pub fn connect<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n    where\n        Self: Join<Separator>,\n    {\n}\n}\n\n#[lang = \"slice_u8_alloc\"]\n#[cfg(not(test))]\nimpl [u8] {\n    /// Returns a vector containing a copy of this slice where each byte\n    /// is mapped to its ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n    ///\n    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_uppercase(&self) -> Vec<u8> {\n}\n\n    /// Returns a vector containing a copy of this slice where each byte\n    /// is mapped to its ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n    ///\n    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_lowercase(&self) -> Vec<u8> {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Extension traits for slices over specific kinds of data\n////////////////////////////////////////////////////////////////////////////////\n\n/// Helper trait for [`[T]::concat`](../../std/primitive.slice.html#method.concat).\n///\n/// Note: the `Item` type parameter is not used in this trait,\n/// but it allows impls to be more generic.\n/// Without it, we get this error:\n///\n/// ```error\n/// error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predica\n///    --> src/liballoc/slice.rs:608:6\n///     |\n/// 608 | impl<T: Clone, V: Borrow<[T]>> Concat for [V] {\n///     |      ^ unconstrained type parameter\n/// ```\n///\n/// This is because there could exist `V` types with multiple `Borrow<[_]>` impls,\n/// such that multiple `T` types would apply:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// pub struct Foo(Vec<u32>, Vec<String>);\n///\n/// impl std::borrow::Borrow<[u32]> for Foo {\n///     fn borrow(&self) -> &[u32] { &self.0 }\n/// }\n///\n/// impl std::borrow::Borrow<[String]> for Foo {\n///     fn borrow(&self) -> &[String] { &self.1 }\n/// }\n/// ```\n#[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\npub trait Concat<Item: ?Sized> {\n}\n\n/// Helper trait for [`[T]::join`](../../std/primitive.slice.html#method.join)\n#[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\npub trait Join<Separator> {\n    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n    /// The resulting type after concatenation\n    type Output;\n\n    /// Implementation of [`[T]::join`](../../std/primitive.slice.html#method.join)\n    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n    fn join(slice: &Self, sep: Separator) -> Self::Output;\n}\n\n#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\nimpl<T: Clone, V: Borrow<[T]>> Concat<T> for [V] {\n    type Output = Vec<T>;\n\n    fn concat(slice: &Self) -> Vec<T> {\n}\n}\n\n#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\nimpl<T: Clone, V: Borrow<[T]>> Join<&T> for [V] {\n}\n\n#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\nimpl<T: Clone, V: Borrow<[T]>> Join<&[T]> for [V] {\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Standard trait implementations for slices\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Borrow<[T]> for Vec<T> {\n    fn borrow(&self) -> &[T] {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> BorrowMut<[T]> for Vec<T> {\n    fn borrow_mut(&mut self) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> ToOwned for [T] {\n    type Owned = Vec<T>;\n    #[cfg(not(test))]\n    fn to_owned(&self) -> Vec<T> {\n}\n\n    #[cfg(test)]\n    fn to_owned(&self) -> Vec<T> {\n}\n\n    fn clone_into(&self, target: &mut Vec<T>) {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Sorting\n////////////////////////////////////////////////////////////////////////////////\n\n/// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n///\n/// This is the integral subroutine of insertion sort.\nfn insert_head<T, F>(v: &mut [T], is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\n/// Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `buf` as temporary storage, and\n/// stores the result into `v[..]`.\n///\n/// # Safety\n///\n/// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n/// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\nunsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n\n/// This merge sort borrows some (but not all) ideas from TimSort, which is described in detail\n/// [here](http://svn.python.org/projects/python/trunk/Objects/listsort.txt).\n///\n/// The algorithm identifies strictly descending and non-descending subsequences, which are called\n/// natural runs. There is a stack of pending runs yet to be merged. Each newly found run is pushed\n/// onto the stack, and then some pairs of adjacent runs are merged until these two invariants are\n/// satisfied:\n///\n/// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n/// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n///\n/// The invariants ensure that the total running time is `O(n log n)` worst-case.\nfn merge_sort<T, F>(v: &mut [T], mut is_less: F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n}\n}\npub mod str {\n//! Unicode string slices.\n//!\n//! *[See also the `str` primitive type](../../std/primitive.str.html).*\n//!\n//! The `&str` type is one of the two main string types, the other being `String`.\n//! Unlike its `String` counterpart, its contents are borrowed.\n//!\n//! # Basic Usage\n//!\n//! A basic string declaration of `&str` type:\n//!\n//! ```\n//! let hello_world = \"Hello, World!\";\n//! ```\n//!\n//! Here we have declared a string literal, also known as a string slice.\n//! String literals have a static lifetime, which means the string `hello_world`\n//! is guaranteed to be valid for the duration of the entire program.\n//! We can explicitly specify `hello_world`'s lifetime as well:\n//!\n//! ```\n//! let hello_world: &'static str = \"Hello, world!\";\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n// Many of the usings in this module are only used in the test configuration.\n// It's cleaner to just turn off the unused_imports warning than to fix them.\n#![allow(unused_imports)]\n\nuse core::borrow::{Borrow, BorrowMut};\nuse core::iter::FusedIterator;\nuse core::mem;\nuse core::ptr;\nuse core::str::pattern::{DoubleEndedSearcher, Pattern, ReverseSearcher, Searcher};\nuse core::unicode::conversions;\n\nuse crate::borrow::ToOwned;\nuse crate::boxed::Box;\nuse crate::slice::{Concat, Join, SliceIndex};\nuse crate::string::String;\nuse crate::vec::Vec;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::pattern;\n#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\npub use core::str::EncodeUtf16;\n#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\npub use core::str::SplitAsciiWhitespace;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::SplitWhitespace;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{from_utf8, from_utf8_mut, Bytes, CharIndices, Chars};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{from_utf8_unchecked, from_utf8_unchecked_mut, ParseBoolError};\n#[stable(feature = \"str_escape\", since = \"1.34.0\")]\npub use core::str::{EscapeDebug, EscapeDefault, EscapeUnicode};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{FromStr, Utf8Error};\n#[allow(deprecated)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{Lines, LinesAny};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{MatchIndices, RMatchIndices};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{Matches, RMatches};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{RSplit, Split};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{RSplitN, SplitN};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::str::{RSplitTerminator, SplitTerminator};\n\n/// Note: `str` in `Concat<str>` is not meaningful here.\n/// This type parameter of the trait only exists to enable another impl.\n#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\nimpl<S: Borrow<str>> Concat<str> for [S] {\n}\n\n#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\nimpl<S: Borrow<str>> Join<&str> for [S] {\n}\n\nmacro_rules! spezialize_for_lengths {\n    ($separator:expr, $target:expr, $iter:expr; $($num:expr),*) => {\n        let mut target = $target;\n        let iter = $iter;\n        let sep_bytes = $separator;\n        match $separator.len() {\n            $(\n                // loops with hardcoded sizes run much faster\n                // specialize the cases with small separator lengths\n                $num => {\n                    for s in iter {\n                        copy_slice_and_advance!(target, sep_bytes);\n                        copy_slice_and_advance!(target, s.borrow().as_ref());\n                    }\n                },\n            )*\n            _ => {\n                // arbitrary non-zero size fallback\n                for s in iter {\n                    copy_slice_and_advance!(target, sep_bytes);\n                    copy_slice_and_advance!(target, s.borrow().as_ref());\n                }\n            }\n        }\n    };\n}\n\nmacro_rules! copy_slice_and_advance {\n    ($target:expr, $bytes:expr) => {\n        let len = $bytes.len();\n        let (head, tail) = { $target }.split_at_mut(len);\n        head.copy_from_slice($bytes);\n        $target = tail;\n    };\n}\n\n// Optimized join implementation that works for both Vec<T> (T: Copy) and String's inner vec\n// Currently (2018-05-13) there is a bug with type inference and specialization (see issue #36262)\n// For this reason SliceConcat<T> is not specialized for T: Copy and SliceConcat<str> is the\n// only user of this function. It is left in place for the time when that is fixed.\n//\n// the bounds for String-join are S: Borrow<str> and for Vec-join Borrow<[T]>\n// [T] and str both impl AsRef<[T]> for some T\n// => s.borrow().as_ref() and we always have slices\nfn join_generic_copy<B, T, S>(slice: &[S], sep: &[T]) -> Vec<T>\nwhere\n    T: Copy,\n    B: AsRef<[T]> + ?Sized,\n    S: Borrow<B>,\n{\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Borrow<str> for String {\n    #[inline]\n    fn borrow(&self) -> &str {\n}\n}\n\n#[stable(feature = \"string_borrow_mut\", since = \"1.36.0\")]\nimpl BorrowMut<str> for String {\n    #[inline]\n    fn borrow_mut(&mut self) -> &mut str {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ToOwned for str {\n    type Owned = String;\n    #[inline]\n    fn to_owned(&self) -> String {\n}\n\n    fn clone_into(&self, target: &mut String) {\n}\n}\n\n/// Methods for string slices.\n#[lang = \"str_alloc\"]\n#[cfg(not(test))]\nimpl str {\n    /// Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"this is a string\";\n    /// let boxed_str = s.to_owned().into_boxed_str();\n    /// let boxed_bytes = boxed_str.into_boxed_bytes();\n    /// assert_eq!(*boxed_bytes, *s.as_bytes());\n    /// ```\n    #[stable(feature = \"str_box_extras\", since = \"1.20.0\")]\n    #[inline]\n    pub fn into_boxed_bytes(self: Box<str>) -> Box<[u8]> {\n}\n\n    /// Replaces all matches of a pattern with another string.\n    ///\n    /// `replace` creates a new [`String`], and copies the data from this string slice into it.\n    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n    /// replaces them with the replacement string slice.\n    ///\n    /// [`String`]: string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"this is old\";\n    ///\n    /// assert_eq!(\"this is new\", s.replace(\"old\", \"new\"));\n    /// ```\n    ///\n    /// When the pattern doesn't match:\n    ///\n    /// ```\n    /// let s = \"this is old\";\n    /// assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n    /// ```\n    #[must_use = \"this returns the replaced string as a new allocation, \\\n                  without modifying the original\"]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n}\n\n    /// Replaces first N matches of a pattern with another string.\n    ///\n    /// `replacen` creates a new [`String`], and copies the data from this string slice into it.\n    /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n    /// replaces them with the replacement string slice at most `count` times.\n    ///\n    /// [`String`]: string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"foo foo 123 foo\";\n    /// assert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\n    /// assert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\n    /// assert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));\n    /// ```\n    ///\n    /// When the pattern doesn't match:\n    ///\n    /// ```\n    /// let s = \"this is old\";\n    /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n    /// ```\n    #[must_use = \"this returns the replaced string as a new allocation, \\\n                  without modifying the original\"]\n    #[stable(feature = \"str_replacen\", since = \"1.16.0\")]\n    pub fn replacen<'a, P: Pattern<'a>>(&'a self, pat: P, to: &str, count: usize) -> String {\n}\n\n    /// Returns the lowercase equivalent of this string slice, as a new [`String`].\n    ///\n    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core Property\n    /// `Lowercase`.\n    ///\n    /// Since some characters can expand into multiple characters when changing\n    /// the case, this function returns a [`String`] instead of modifying the\n    /// parameter in-place.\n    ///\n    /// [`String`]: string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"HELLO\";\n    ///\n    /// assert_eq!(\"hello\", s.to_lowercase());\n    /// ```\n    ///\n    /// A tricky example, with sigma:\n    ///\n    /// ```\n    /// let sigma = \"Σ\";\n    ///\n    /// assert_eq!(\"σ\", sigma.to_lowercase());\n    ///\n    /// // but at the end of a word, it's ς, not σ:\n    /// let odysseus = \"ὈΔΥΣΣΕΎΣ\";\n    ///\n    /// assert_eq!(\"ὀδυσσεύς\", odysseus.to_lowercase());\n    /// ```\n    ///\n    /// Languages without case are not changed:\n    ///\n    /// ```\n    /// let new_year = \"农历新年\";\n    ///\n    /// assert_eq!(new_year, new_year.to_lowercase());\n    /// ```\n    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n    pub fn to_lowercase(&self) -> String {\n}\n\n    /// Returns the uppercase equivalent of this string slice, as a new [`String`].\n    ///\n    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core Property\n    /// `Uppercase`.\n    ///\n    /// Since some characters can expand into multiple characters when changing\n    /// the case, this function returns a [`String`] instead of modifying the\n    /// parameter in-place.\n    ///\n    /// [`String`]: string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = \"hello\";\n    ///\n    /// assert_eq!(\"HELLO\", s.to_uppercase());\n    /// ```\n    ///\n    /// Scripts without case are not changed:\n    ///\n    /// ```\n    /// let new_year = \"农历新年\";\n    ///\n    /// assert_eq!(new_year, new_year.to_uppercase());\n    /// ```\n    ///\n    /// One character can become multiple:\n    /// ```\n    /// let s = \"tschüß\";\n    ///\n    /// assert_eq!(\"TSCHÜSS\", s.to_uppercase());\n    /// ```\n    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n    pub fn to_uppercase(&self) -> String {\n}\n\n    /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n    ///\n    /// [`String`]: string/struct.String.html\n    /// [`Box<str>`]: boxed/struct.Box.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let string = String::from(\"birthday gift\");\n    /// let boxed_str = string.clone().into_boxed_str();\n    ///\n    /// assert_eq!(boxed_str.into_string(), string);\n    /// ```\n    #[stable(feature = \"box_str\", since = \"1.4.0\")]\n    #[inline]\n    pub fn into_string(self: Box<str>) -> String {\n}\n\n    /// Creates a new [`String`] by repeating a string `n` times.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the capacity would overflow.\n    ///\n    /// [`String`]: string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n    /// ```\n    ///\n    /// A panic upon overflow:\n    ///\n    /// ```should_panic\n    /// // this will panic at runtime\n    /// \"0123456789abcdef\".repeat(usize::max_value());\n    /// ```\n    #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n    pub fn repeat(&self, n: usize) -> String {\n}\n\n    /// Returns a copy of this string where each character is mapped to its\n    /// ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n    ///\n    /// To uppercase ASCII characters in addition to non-ASCII characters, use\n    /// [`to_uppercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s = \"Grüße, Jürgen ❤\";\n    ///\n    /// assert_eq!(\"GRüßE, JüRGEN ❤\", s.to_ascii_uppercase());\n    /// ```\n    ///\n    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n    /// [`to_uppercase`]: #method.to_uppercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_uppercase(&self) -> String {\n}\n\n    /// Returns a copy of this string where each character is mapped to its\n    /// ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n    ///\n    /// To lowercase ASCII characters in addition to non-ASCII characters, use\n    /// [`to_lowercase`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s = \"Grüße, Jürgen ❤\";\n    ///\n    /// assert_eq!(\"grüße, jürgen ❤\", s.to_ascii_lowercase());\n    /// ```\n    ///\n    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n    /// [`to_lowercase`]: #method.to_lowercase\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_lowercase(&self) -> String {\n}\n}\n\n/// Converts a boxed slice of bytes to a boxed string slice without checking\n/// that the string contains valid UTF-8.\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// let smile_utf8 = Box::new([226, 152, 186]);\n/// let smile = unsafe { std::str::from_boxed_utf8_unchecked(smile_utf8) };\n///\n/// assert_eq!(\"☺\", &*smile);\n/// ```\n#[stable(feature = \"str_box_extras\", since = \"1.20.0\")]\n#[inline]\npub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {\n}\n}\npub mod string {\n//! A UTF-8 encoded, growable string.\n//!\n//! This module contains the [`String`] type, a trait for converting\n//! [`ToString`]s, and several error types that may result from working with\n//! [`String`]s.\n//!\n//! [`ToString`]: trait.ToString.html\n//!\n//! # Examples\n//!\n//! There are multiple ways to create a new [`String`] from a string literal:\n//!\n//! ```\n//! let s = \"Hello\".to_string();\n//!\n//! let s = String::from(\"world\");\n//! let s: String = \"also this\".into();\n//! ```\n//!\n//! You can create a new [`String`] from an existing one by concatenating with\n//! `+`:\n//!\n//! [`String`]: struct.String.html\n//!\n//! ```\n//! let s = \"Hello\".to_string();\n//!\n//! let message = s + \" world!\";\n//! ```\n//!\n//! If you have a vector of valid UTF-8 bytes, you can make a [`String`] out of\n//! it. You can do the reverse too.\n//!\n//! ```\n//! let sparkle_heart = vec![240, 159, 146, 150];\n//!\n//! // We know these bytes are valid, so we'll use `unwrap()`.\n//! let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n//!\n//! assert_eq!(\"💖\", sparkle_heart);\n//!\n//! let bytes = sparkle_heart.into_bytes();\n//!\n//! assert_eq!(bytes, [240, 159, 146, 150]);\n//! ```\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::char::{decode_utf16, REPLACEMENT_CHARACTER};\nuse core::fmt;\nuse core::hash;\nuse core::iter::{FromIterator, FusedIterator};\nuse core::ops::Bound::{Excluded, Included, Unbounded};\nuse core::ops::{self, Add, AddAssign, Index, IndexMut, RangeBounds};\nuse core::ptr;\nuse core::str::{lossy, pattern::Pattern};\n\nuse crate::borrow::{Cow, ToOwned};\nuse crate::boxed::Box;\nuse crate::collections::TryReserveError;\nuse crate::str::{self, from_boxed_utf8_unchecked, Chars, FromStr, Utf8Error};\nuse crate::vec::Vec;\n\n/// A UTF-8 encoded, growable string.\n///\n/// The `String` type is the most common string type that has ownership over the\n/// contents of the string. It has a close relationship with its borrowed\n/// counterpart, the primitive [`str`].\n///\n/// [`str`]: ../../std/primitive.str.html\n///\n/// # Examples\n///\n/// You can create a `String` from a literal string with [`String::from`]:\n///\n/// ```\n/// let hello = String::from(\"Hello, world!\");\n/// ```\n///\n/// You can append a [`char`] to a `String` with the [`push`] method, and\n/// append a [`&str`] with the [`push_str`] method:\n///\n/// ```\n/// let mut hello = String::from(\"Hello, \");\n///\n/// hello.push('w');\n/// hello.push_str(\"orld!\");\n/// ```\n///\n/// [`String::from`]: #method.from\n/// [`char`]: ../../std/primitive.char.html\n/// [`push`]: #method.push\n/// [`push_str`]: #method.push_str\n///\n/// If you have a vector of UTF-8 bytes, you can create a `String` from it with\n/// the [`from_utf8`] method:\n///\n/// ```\n/// // some bytes, in a vector\n/// let sparkle_heart = vec![240, 159, 146, 150];\n///\n/// // We know these bytes are valid, so we'll use `unwrap()`.\n/// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n///\n/// assert_eq!(\"💖\", sparkle_heart);\n/// ```\n///\n/// [`from_utf8`]: #method.from_utf8\n///\n/// # UTF-8\n///\n/// `String`s are always valid UTF-8. This has a few implications, the first of\n/// which is that if you need a non-UTF-8 string, consider [`OsString`]. It is\n/// similar, but without the UTF-8 constraint. The second implication is that\n/// you cannot index into a `String`:\n///\n/// ```compile_fail,E0277\n/// let s = \"hello\";\n///\n/// println!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n/// ```\n///\n/// [`OsString`]: ../../std/ffi/struct.OsString.html\n///\n/// Indexing is intended to be a constant-time operation, but UTF-8 encoding\n/// does not allow us to do this. Furthermore, it's not clear what sort of\n/// thing the index should return: a byte, a codepoint, or a grapheme cluster.\n/// The [`bytes`] and [`chars`] methods return iterators over the first\n/// two, respectively.\n///\n/// [`bytes`]: #method.bytes\n/// [`chars`]: #method.chars\n///\n/// # Deref\n///\n/// `String`s implement [`Deref`]`<Target=str>`, and so inherit all of [`str`]'s\n/// methods. In addition, this means that you can pass a `String` to a\n/// function which takes a [`&str`] by using an ampersand (`&`):\n///\n/// ```\n/// fn takes_str(s: &str) { }\n///\n/// let s = String::from(\"Hello\");\n///\n/// takes_str(&s);\n/// ```\n///\n/// This will create a [`&str`] from the `String` and pass it in. This\n/// conversion is very inexpensive, and so generally, functions will accept\n/// [`&str`]s as arguments unless they need a `String` for some specific\n/// reason.\n///\n/// In certain cases Rust doesn't have enough information to make this\n/// conversion, known as [`Deref`] coercion. In the following example a string\n/// slice [`&'a str`][`&str`] implements the trait `TraitExample`, and the function\n/// `example_func` takes anything that implements the trait. In this case Rust\n/// would need to make two implicit conversions, which Rust doesn't have the\n/// means to do. For that reason, the following example will not compile.\n///\n/// ```compile_fail,E0277\n/// trait TraitExample {}\n///\n/// impl<'a> TraitExample for &'a str {}\n///\n/// fn example_func<A: TraitExample>(example_arg: A) {}\n///\n/// let example_string = String::from(\"example_string\");\n/// example_func(&example_string);\n/// ```\n///\n/// There are two options that would work instead. The first would be to\n/// change the line `example_func(&example_string);` to\n/// `example_func(example_string.as_str());`, using the method [`as_str()`]\n/// to explicitly extract the string slice containing the string. The second\n/// way changes `example_func(&example_string);` to\n/// `example_func(&*example_string);`. In this case we are dereferencing a\n/// `String` to a [`str`][`&str`], then referencing the [`str`][`&str`] back to\n/// [`&str`]. The second way is more idiomatic, however both work to do the\n/// conversion explicitly rather than relying on the implicit conversion.\n///\n/// # Representation\n///\n/// A `String` is made up of three components: a pointer to some bytes, a\n/// length, and a capacity. The pointer points to an internal buffer `String`\n/// uses to store its data. The length is the number of bytes currently stored\n/// in the buffer, and the capacity is the size of the buffer in bytes. As such,\n/// the length will always be less than or equal to the capacity.\n///\n/// This buffer is always stored on the heap.\n///\n/// You can look at these with the [`as_ptr`], [`len`], and [`capacity`]\n/// methods:\n///\n/// ```\n/// use std::mem;\n///\n/// let story = String::from(\"Once upon a time...\");\n///\n// FIXME Update this when vec_into_raw_parts is stabilized\n/// // Prevent automatically dropping the String's data\n/// let mut story = mem::ManuallyDrop::new(story);\n///\n/// let ptr = story.as_mut_ptr();\n/// let len = story.len();\n/// let capacity = story.capacity();\n///\n/// // story has nineteen bytes\n/// assert_eq!(19, len);\n///\n/// // We can re-build a String out of ptr, len, and capacity. This is all\n/// // unsafe because we are responsible for making sure the components are\n/// // valid:\n/// let s = unsafe { String::from_raw_parts(ptr, len, capacity) } ;\n///\n/// assert_eq!(String::from(\"Once upon a time...\"), s);\n/// ```\n///\n/// [`as_ptr`]: #method.as_ptr\n/// [`len`]: #method.len\n/// [`capacity`]: #method.capacity\n///\n/// If a `String` has enough capacity, adding elements to it will not\n/// re-allocate. For example, consider this program:\n///\n/// ```\n/// let mut s = String::new();\n///\n/// println!(\"{}\", s.capacity());\n///\n/// for _ in 0..5 {\n///     s.push_str(\"hello\");\n///     println!(\"{}\", s.capacity());\n/// }\n/// ```\n///\n/// This will output the following:\n///\n/// ```text\n/// 0\n/// 5\n/// 10\n/// 20\n/// 20\n/// 40\n/// ```\n///\n/// At first, we have no memory allocated at all, but as we append to the\n/// string, it increases its capacity appropriately. If we instead use the\n/// [`with_capacity`] method to allocate the correct capacity initially:\n///\n/// ```\n/// let mut s = String::with_capacity(25);\n///\n/// println!(\"{}\", s.capacity());\n///\n/// for _ in 0..5 {\n///     s.push_str(\"hello\");\n///     println!(\"{}\", s.capacity());\n/// }\n/// ```\n///\n/// [`with_capacity`]: #method.with_capacity\n///\n/// We end up with a different output:\n///\n/// ```text\n/// 25\n/// 25\n/// 25\n/// 25\n/// 25\n/// 25\n/// ```\n///\n/// Here, there's no need to allocate more memory inside the loop.\n///\n/// [`&str`]: ../../std/primitive.str.html\n/// [`Deref`]: ../../std/ops/trait.Deref.html\n/// [`as_str()`]: struct.String.html#method.as_str\n#[derive(PartialOrd, Eq, Ord)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct String {\n    vec: Vec<u8>,\n}\n\n/// A possible error value when converting a `String` from a UTF-8 byte vector.\n///\n/// This type is the error type for the [`from_utf8`] method on [`String`]. It\n/// is designed in such a way to carefully avoid reallocations: the\n/// [`into_bytes`] method will give back the byte vector that was used in the\n/// conversion attempt.\n///\n/// [`from_utf8`]: struct.String.html#method.from_utf8\n/// [`String`]: struct.String.html\n/// [`into_bytes`]: struct.FromUtf8Error.html#method.into_bytes\n///\n/// The [`Utf8Error`] type provided by [`std::str`] represents an error that may\n/// occur when converting a slice of [`u8`]s to a [`&str`]. In this sense, it's\n/// an analogue to `FromUtf8Error`, and you can get one from a `FromUtf8Error`\n/// through the [`utf8_error`] method.\n///\n/// [`Utf8Error`]: ../../std/str/struct.Utf8Error.html\n/// [`std::str`]: ../../std/str/index.html\n/// [`u8`]: ../../std/primitive.u8.html\n/// [`&str`]: ../../std/primitive.str.html\n/// [`utf8_error`]: #method.utf8_error\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // some invalid bytes, in a vector\n/// let bytes = vec![0, 159];\n///\n/// let value = String::from_utf8(bytes);\n///\n/// assert!(value.is_err());\n/// assert_eq!(vec![0, 159], value.unwrap_err().into_bytes());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct FromUtf8Error {\n    bytes: Vec<u8>,\n    error: Utf8Error,\n}\n\n/// A possible error value when converting a `String` from a UTF-16 byte slice.\n///\n/// This type is the error type for the [`from_utf16`] method on [`String`].\n///\n/// [`from_utf16`]: struct.String.html#method.from_utf16\n/// [`String`]: struct.String.html\n///\n/// # Examples\n///\n/// Basic usage:\n///\n/// ```\n/// // 𝄞mu<invalid>ic\n/// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n///           0xD800, 0x0069, 0x0063];\n///\n/// assert!(String::from_utf16(v).is_err());\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[derive(Debug)]\npub struct FromUtf16Error(());\n\nimpl String {\n    /// Creates a new empty `String`.\n    ///\n    /// Given that the `String` is empty, this will not allocate any initial\n    /// buffer. While that means that this initial operation is very\n    /// inexpensive, it may cause excessive allocation later when you add\n    /// data. If you have an idea of how much data the `String` will hold,\n    /// consider the [`with_capacity`] method to prevent excessive\n    /// re-allocation.\n    ///\n    /// [`with_capacity`]: #method.with_capacity\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::new();\n    /// ```\n    #[inline]\n    #[rustc_const_stable(feature = \"const_string_new\", since = \"1.32.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn new() -> String {\n}\n\n    /// Creates a new empty `String` with a particular capacity.\n    ///\n    /// `String`s have an internal buffer to hold their data. The capacity is\n    /// the length of that buffer, and can be queried with the [`capacity`]\n    /// method. This method creates an empty `String`, but one with an initial\n    /// buffer that can hold `capacity` bytes. This is useful when you may be\n    /// appending a bunch of data to the `String`, reducing the number of\n    /// reallocations it needs to do.\n    ///\n    /// [`capacity`]: #method.capacity\n    ///\n    /// If the given capacity is `0`, no allocation will occur, and this method\n    /// is identical to the [`new`] method.\n    ///\n    /// [`new`]: #method.new\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::with_capacity(10);\n    ///\n    /// // The String contains no chars, even though it has capacity for more\n    /// assert_eq!(s.len(), 0);\n    ///\n    /// // These are all done without reallocating...\n    /// let cap = s.capacity();\n    /// for _ in 0..10 {\n    ///     s.push('a');\n    /// }\n    ///\n    /// assert_eq!(s.capacity(), cap);\n    ///\n    /// // ...but this may make the vector reallocate\n    /// s.push('a');\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> String {\n}\n\n    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n    // required for this method definition, is not available. Since we don't\n    // require this method for testing purposes, I'll just stub it\n    // NB see the slice::hack module in slice.rs for more information\n    #[inline]\n    #[cfg(test)]\n    pub fn from_str(_: &str) -> String {\n}\n\n    /// Converts a vector of bytes to a `String`.\n    ///\n    /// A string ([`String`]) is made of bytes ([`u8`]), and a vector of bytes\n    /// ([`Vec<u8>`]) is made of bytes, so this function converts between the\n    /// two. Not all byte slices are valid `String`s, however: `String`\n    /// requires that it is valid UTF-8. `from_utf8()` checks to ensure that\n    /// the bytes are valid UTF-8, and then does the conversion.\n    ///\n    /// If you are sure that the byte slice is valid UTF-8, and you don't want\n    /// to incur the overhead of the validity check, there is an unsafe version\n    /// of this function, [`from_utf8_unchecked`], which has the same behavior\n    /// but skips the check.\n    ///\n    /// This method will take care to not copy the vector, for efficiency's\n    /// sake.\n    ///\n    /// If you need a [`&str`] instead of a `String`, consider\n    /// [`str::from_utf8`].\n    ///\n    /// The inverse of this method is [`into_bytes`].\n    ///\n    /// # Errors\n    ///\n    /// Returns [`Err`] if the slice is not UTF-8 with a description as to why the\n    /// provided bytes are not UTF-8. The vector you moved in is also included.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some bytes, in a vector\n    /// let sparkle_heart = vec![240, 159, 146, 150];\n    ///\n    /// // We know these bytes are valid, so we'll use `unwrap()`.\n    /// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n    ///\n    /// assert_eq!(\"💖\", sparkle_heart);\n    /// ```\n    ///\n    /// Incorrect bytes:\n    ///\n    /// ```\n    /// // some invalid bytes, in a vector\n    /// let sparkle_heart = vec![0, 159, 146, 150];\n    ///\n    /// assert!(String::from_utf8(sparkle_heart).is_err());\n    /// ```\n    ///\n    /// See the docs for [`FromUtf8Error`] for more details on what you can do\n    /// with this error.\n    ///\n    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n    /// [`String`]: struct.String.html\n    /// [`u8`]: ../../std/primitive.u8.html\n    /// [`Vec<u8>`]: ../../std/vec/struct.Vec.html\n    /// [`str::from_utf8`]: ../../std/str/fn.from_utf8.html\n    /// [`into_bytes`]: struct.String.html#method.into_bytes\n    /// [`FromUtf8Error`]: struct.FromUtf8Error.html\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n}\n\n    /// Converts a slice of bytes to a string, including invalid characters.\n    ///\n    /// Strings are made of bytes ([`u8`]), and a slice of bytes\n    /// ([`&[u8]`][byteslice]) is made of bytes, so this function converts\n    /// between the two. Not all byte slices are valid strings, however: strings\n    /// are required to be valid UTF-8. During this conversion,\n    /// `from_utf8_lossy()` will replace any invalid UTF-8 sequences with\n    /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD], which looks like this: �\n    ///\n    /// [`u8`]: ../../std/primitive.u8.html\n    /// [byteslice]: ../../std/primitive.slice.html\n    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n    ///\n    /// If you are sure that the byte slice is valid UTF-8, and you don't want\n    /// to incur the overhead of the conversion, there is an unsafe version\n    /// of this function, [`from_utf8_unchecked`], which has the same behavior\n    /// but skips the checks.\n    ///\n    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n    ///\n    /// This function returns a [`Cow<'a, str>`]. If our byte slice is invalid\n    /// UTF-8, then we need to insert the replacement characters, which will\n    /// change the size of the string, and hence, require a `String`. But if\n    /// it's already valid UTF-8, we don't need a new allocation. This return\n    /// type allows us to handle both cases.\n    ///\n    /// [`Cow<'a, str>`]: ../../std/borrow/enum.Cow.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some bytes, in a vector\n    /// let sparkle_heart = vec![240, 159, 146, 150];\n    ///\n    /// let sparkle_heart = String::from_utf8_lossy(&sparkle_heart);\n    ///\n    /// assert_eq!(\"💖\", sparkle_heart);\n    /// ```\n    ///\n    /// Incorrect bytes:\n    ///\n    /// ```\n    /// // some invalid bytes\n    /// let input = b\"Hello \\xF0\\x90\\x80World\";\n    /// let output = String::from_utf8_lossy(input);\n    ///\n    /// assert_eq!(\"Hello �World\", output);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_utf8_lossy(v: &[u8]) -> Cow<'_, str> {\n}\n\n    /// Decode a UTF-16 encoded vector `v` into a `String`, returning [`Err`]\n    /// if `v` contains any invalid data.\n    ///\n    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // 𝄞music\n    /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n    ///           0x0073, 0x0069, 0x0063];\n    /// assert_eq!(String::from(\"𝄞music\"),\n    ///            String::from_utf16(v).unwrap());\n    ///\n    /// // 𝄞mu<invalid>ic\n    /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n    ///           0xD800, 0x0069, 0x0063];\n    /// assert!(String::from_utf16(v).is_err());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_utf16(v: &[u16]) -> Result<String, FromUtf16Error> {\n}\n\n    /// Decode a UTF-16 encoded slice `v` into a `String`, replacing\n    /// invalid data with [the replacement character (`U+FFFD`)][U+FFFD].\n    ///\n    /// Unlike [`from_utf8_lossy`] which returns a [`Cow<'a, str>`],\n    /// `from_utf16_lossy` returns a `String` since the UTF-16 to UTF-8\n    /// conversion requires a memory allocation.\n    ///\n    /// [`from_utf8_lossy`]: #method.from_utf8_lossy\n    /// [`Cow<'a, str>`]: ../borrow/enum.Cow.html\n    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // 𝄞mus<invalid>ic<invalid>\n    /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n    ///           0x0073, 0xDD1E, 0x0069, 0x0063,\n    ///           0xD834];\n    ///\n    /// assert_eq!(String::from(\"𝄞mus\\u{FFFD}ic\\u{FFFD}\"),\n    ///            String::from_utf16_lossy(v));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn from_utf16_lossy(v: &[u16]) -> String {\n}\n\n    /// Decomposes a `String` into its raw components.\n    ///\n    /// Returns the raw pointer to the underlying data, the length of\n    /// the string (in bytes), and the allocated capacity of the data\n    /// (in bytes). These are the same arguments in the same order as\n    /// the arguments to [`from_raw_parts`].\n    ///\n    /// After calling this function, the caller is responsible for the\n    /// memory previously managed by the `String`. The only way to do\n    /// this is to convert the raw pointer, length, and capacity back\n    /// into a `String` with the [`from_raw_parts`] function, allowing\n    /// the destructor to perform the cleanup.\n    ///\n    /// [`from_raw_parts`]: #method.from_raw_parts\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(vec_into_raw_parts)]\n    /// let s = String::from(\"hello\");\n    ///\n    /// let (ptr, len, cap) = s.into_raw_parts();\n    ///\n    /// let rebuilt = unsafe { String::from_raw_parts(ptr, len, cap) };\n    /// assert_eq!(rebuilt, \"hello\");\n    /// ```\n    #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n    pub fn into_raw_parts(self) -> (*mut u8, usize, usize) {\n}\n\n    /// Creates a new `String` from a length, capacity, and pointer.\n    ///\n    /// # Safety\n    ///\n    /// This is highly unsafe, due to the number of invariants that aren't\n    /// checked:\n    ///\n    /// * The memory at `ptr` needs to have been previously allocated by the\n    ///   same allocator the standard library uses, with a required alignment of exactly 1.\n    /// * `length` needs to be less than or equal to `capacity`.\n    /// * `capacity` needs to be the correct value.\n    ///\n    /// Violating these may cause problems like corrupting the allocator's\n    /// internal data structures.\n    ///\n    /// The ownership of `ptr` is effectively transferred to the\n    /// `String` which may then deallocate, reallocate or change the\n    /// contents of memory pointed to by the pointer at will. Ensure\n    /// that nothing else uses the pointer after calling this\n    /// function.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// use std::mem;\n    ///\n    /// unsafe {\n    ///     let s = String::from(\"hello\");\n    ///\n    // FIXME Update this when vec_into_raw_parts is stabilized\n    ///     // Prevent automatically dropping the String's data\n    ///     let mut s = mem::ManuallyDrop::new(s);\n    ///\n    ///     let ptr = s.as_mut_ptr();\n    ///     let len = s.len();\n    ///     let capacity = s.capacity();\n    ///\n    ///     let s = String::from_raw_parts(ptr, len, capacity);\n    ///\n    ///     assert_eq!(String::from(\"hello\"), s);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_raw_parts(buf: *mut u8, length: usize, capacity: usize) -> String {\n}\n\n    /// Converts a vector of bytes to a `String` without checking that the\n    /// string contains valid UTF-8.\n    ///\n    /// See the safe version, [`from_utf8`], for more details.\n    ///\n    /// [`from_utf8`]: struct.String.html#method.from_utf8\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because it does not check that the bytes passed\n    /// to it are valid UTF-8. If this constraint is violated, it may cause\n    /// memory unsafety issues with future users of the `String`, as the rest of\n    /// the standard library assumes that `String`s are valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some bytes, in a vector\n    /// let sparkle_heart = vec![240, 159, 146, 150];\n    ///\n    /// let sparkle_heart = unsafe {\n    ///     String::from_utf8_unchecked(sparkle_heart)\n    /// };\n    ///\n    /// assert_eq!(\"💖\", sparkle_heart);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {\n}\n\n    /// Converts a `String` into a byte vector.\n    ///\n    /// This consumes the `String`, so we do not need to copy its contents.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::from(\"hello\");\n    /// let bytes = s.into_bytes();\n    ///\n    /// assert_eq!(&[104, 101, 108, 108, 111][..], &bytes[..]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_bytes(self) -> Vec<u8> {\n}\n\n    /// Extracts a string slice containing the entire `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::from(\"foo\");\n    ///\n    /// assert_eq!(\"foo\", s.as_str());\n    /// ```\n    #[inline]\n    #[stable(feature = \"string_as_str\", since = \"1.7.0\")]\n    pub fn as_str(&self) -> &str {\n}\n\n    /// Converts a `String` into a mutable string slice.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foobar\");\n    /// let s_mut_str = s.as_mut_str();\n    ///\n    /// s_mut_str.make_ascii_uppercase();\n    ///\n    /// assert_eq!(\"FOOBAR\", s_mut_str);\n    /// ```\n    #[inline]\n    #[stable(feature = \"string_as_str\", since = \"1.7.0\")]\n    pub fn as_mut_str(&mut self) -> &mut str {\n}\n\n    /// Appends a given string slice onto the end of this `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// s.push_str(\"bar\");\n    ///\n    /// assert_eq!(\"foobar\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push_str(&mut self, string: &str) {\n}\n\n    /// Returns this `String`'s capacity, in bytes.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::with_capacity(10);\n    ///\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n}\n\n    /// Ensures that this `String`'s capacity is at least `additional` bytes\n    /// larger than its length.\n    ///\n    /// The capacity may be increased by more than `additional` bytes if it\n    /// chooses, to prevent frequent reallocations.\n    ///\n    /// If you do not want this \"at least\" behavior, see the [`reserve_exact`]\n    /// method.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows [`usize`].\n    ///\n    /// [`reserve_exact`]: struct.String.html#method.reserve_exact\n    /// [`usize`]: ../../std/primitive.usize.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::new();\n    ///\n    /// s.reserve(10);\n    ///\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    ///\n    /// This may not actually increase the capacity:\n    ///\n    /// ```\n    /// let mut s = String::with_capacity(10);\n    /// s.push('a');\n    /// s.push('b');\n    ///\n    /// // s now has a length of 2 and a capacity of 10\n    /// assert_eq!(2, s.len());\n    /// assert_eq!(10, s.capacity());\n    ///\n    /// // Since we already have an extra 8 capacity, calling this...\n    /// s.reserve(8);\n    ///\n    /// // ... doesn't actually increase.\n    /// assert_eq!(10, s.capacity());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n}\n\n    /// Ensures that this `String`'s capacity is `additional` bytes\n    /// larger than its length.\n    ///\n    /// Consider using the [`reserve`] method unless you absolutely know\n    /// better than the allocator.\n    ///\n    /// [`reserve`]: #method.reserve\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::new();\n    ///\n    /// s.reserve_exact(10);\n    ///\n    /// assert!(s.capacity() >= 10);\n    /// ```\n    ///\n    /// This may not actually increase the capacity:\n    ///\n    /// ```\n    /// let mut s = String::with_capacity(10);\n    /// s.push('a');\n    /// s.push('b');\n    ///\n    /// // s now has a length of 2 and a capacity of 10\n    /// assert_eq!(2, s.len());\n    /// assert_eq!(10, s.capacity());\n    ///\n    /// // Since we already have an extra 8 capacity, calling this...\n    /// s.reserve_exact(8);\n    ///\n    /// // ... doesn't actually increase.\n    /// assert_eq!(10, s.capacity());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve_exact(&mut self, additional: usize) {\n}\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `String`. The collection may reserve more space to avoid\n    /// frequent reallocations. After calling `reserve`, capacity will be\n    /// greater than or equal to `self.len() + additional`. Does nothing if\n    /// capacity is already sufficient.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_reserve)]\n    /// use std::collections::TryReserveError;\n    ///\n    /// fn process_data(data: &str) -> Result<String, TryReserveError> {\n    ///     let mut output = String::new();\n    ///\n    ///     // Pre-reserve the memory, exiting if we can't\n    ///     output.try_reserve(data.len())?;\n    ///\n    ///     // Now we know this can't OOM in the middle of our complex work\n    ///     output.push_str(data);\n    ///\n    ///     Ok(output)\n    /// }\n    /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n    /// ```\n    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n}\n\n    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n    /// be inserted in the given `String`. After calling `reserve_exact`,\n    /// capacity will be greater than or equal to `self.len() + additional`.\n    /// Does nothing if the capacity is already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it\n    /// requests. Therefore, capacity can not be relied upon to be precisely\n    /// minimal. Prefer `reserve` if future insertions are expected.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_reserve)]\n    /// use std::collections::TryReserveError;\n    ///\n    /// fn process_data(data: &str) -> Result<String, TryReserveError> {\n    ///     let mut output = String::new();\n    ///\n    ///     // Pre-reserve the memory, exiting if we can't\n    ///     output.try_reserve(data.len())?;\n    ///\n    ///     // Now we know this can't OOM in the middle of our complex work\n    ///     output.push_str(data);\n    ///\n    ///     Ok(output)\n    /// }\n    /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n    /// ```\n    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n}\n\n    /// Shrinks the capacity of this `String` to match its length.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// s.reserve(100);\n    /// assert!(s.capacity() >= 100);\n    ///\n    /// s.shrink_to_fit();\n    /// assert_eq!(3, s.capacity());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n}\n\n    /// Shrinks the capacity of this `String` with a lower bound.\n    ///\n    /// The capacity will remain at least as large as both the length\n    /// and the supplied value.\n    ///\n    /// Panics if the current capacity is smaller than the supplied\n    /// minimum capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(shrink_to)]\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// s.reserve(100);\n    /// assert!(s.capacity() >= 100);\n    ///\n    /// s.shrink_to(10);\n    /// assert!(s.capacity() >= 10);\n    /// s.shrink_to(0);\n    /// assert!(s.capacity() >= 3);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n}\n\n    /// Appends the given [`char`] to the end of this `String`.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"abc\");\n    ///\n    /// s.push('1');\n    /// s.push('2');\n    /// s.push('3');\n    ///\n    /// assert_eq!(\"abc123\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push(&mut self, ch: char) {\n}\n\n    /// Returns a byte slice of this `String`'s contents.\n    ///\n    /// The inverse of this method is [`from_utf8`].\n    ///\n    /// [`from_utf8`]: #method.from_utf8\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::from(\"hello\");\n    ///\n    /// assert_eq!(&[104, 101, 108, 108, 111], s.as_bytes());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn as_bytes(&self) -> &[u8] {\n}\n\n    /// Shortens this `String` to the specified length.\n    ///\n    /// If `new_len` is greater than the string's current length, this has no\n    /// effect.\n    ///\n    /// Note that this method has no effect on the allocated capacity\n    /// of the string\n    ///\n    /// # Panics\n    ///\n    /// Panics if `new_len` does not lie on a [`char`] boundary.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"hello\");\n    ///\n    /// s.truncate(2);\n    ///\n    /// assert_eq!(\"he\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn truncate(&mut self, new_len: usize) {\n}\n\n    /// Removes the last character from the string buffer and returns it.\n    ///\n    /// Returns [`None`] if this `String` is empty.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// assert_eq!(s.pop(), Some('o'));\n    /// assert_eq!(s.pop(), Some('o'));\n    /// assert_eq!(s.pop(), Some('f'));\n    ///\n    /// assert_eq!(s.pop(), None);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop(&mut self) -> Option<char> {\n}\n\n    /// Removes a [`char`] from this `String` at a byte position and returns it.\n    ///\n    /// This is an `O(n)` operation, as it requires copying every element in the\n    /// buffer.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `idx` is larger than or equal to the `String`'s length,\n    /// or if it does not lie on a [`char`] boundary.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// assert_eq!(s.remove(0), 'f');\n    /// assert_eq!(s.remove(1), 'o');\n    /// assert_eq!(s.remove(0), 'o');\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove(&mut self, idx: usize) -> char {\n}\n\n    /// Retains only the characters specified by the predicate.\n    ///\n    /// In other words, remove all characters `c` such that `f(c)` returns `false`.\n    /// This method operates in place, visiting each character exactly once in the\n    /// original order, and preserves the order of the retained characters.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut s = String::from(\"f_o_ob_ar\");\n    ///\n    /// s.retain(|c| c != '_');\n    ///\n    /// assert_eq!(s, \"foobar\");\n    /// ```\n    ///\n    /// The exact order may be useful for tracking external state, like an index.\n    ///\n    /// ```\n    /// let mut s = String::from(\"abcde\");\n    /// let keep = [false, true, true, false, true];\n    /// let mut i = 0;\n    /// s.retain(|_| (keep[i], i += 1).0);\n    /// assert_eq!(s, \"bce\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"string_retain\", since = \"1.26.0\")]\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(char) -> bool,\n    {\n}\n\n    /// Inserts a character into this `String` at a byte position.\n    ///\n    /// This is an `O(n)` operation as it requires copying every element in the\n    /// buffer.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `idx` is larger than the `String`'s length, or if it does not\n    /// lie on a [`char`] boundary.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::with_capacity(3);\n    ///\n    /// s.insert(0, 'f');\n    /// s.insert(1, 'o');\n    /// s.insert(2, 'o');\n    ///\n    /// assert_eq!(\"foo\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, idx: usize, ch: char) {\n}\n\n    unsafe fn insert_bytes(&mut self, idx: usize, bytes: &[u8]) {\n}\n\n    /// Inserts a string slice into this `String` at a byte position.\n    ///\n    /// This is an `O(n)` operation as it requires copying every element in the\n    /// buffer.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `idx` is larger than the `String`'s length, or if it does not\n    /// lie on a [`char`] boundary.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"bar\");\n    ///\n    /// s.insert_str(0, \"foo\");\n    ///\n    /// assert_eq!(\"foobar\", s);\n    /// ```\n    #[inline]\n    #[stable(feature = \"insert_str\", since = \"1.16.0\")]\n    pub fn insert_str(&mut self, idx: usize, string: &str) {\n}\n\n    /// Returns a mutable reference to the contents of this `String`.\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because it does not check that the bytes passed\n    /// to it are valid UTF-8. If this constraint is violated, it may cause\n    /// memory unsafety issues with future users of the `String`, as the rest of\n    /// the standard library assumes that `String`s are valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"hello\");\n    ///\n    /// unsafe {\n    ///     let vec = s.as_mut_vec();\n    ///     assert_eq!(&[104, 101, 108, 108, 111][..], &vec[..]);\n    ///\n    ///     vec.reverse();\n    /// }\n    /// assert_eq!(s, \"olleh\");\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn as_mut_vec(&mut self) -> &mut Vec<u8> {\n}\n\n    /// Returns the length of this `String`, in bytes, not [`char`]s or\n    /// graphemes. In other words, it may not be what a human considers the\n    /// length of the string.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let a = String::from(\"foo\");\n    /// assert_eq!(a.len(), 3);\n    ///\n    /// let fancy_f = String::from(\"ƒoo\");\n    /// assert_eq!(fancy_f.len(), 4);\n    /// assert_eq!(fancy_f.chars().count(), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n}\n\n    /// Returns `true` if this `String` has a length of zero, and `false` otherwise.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut v = String::new();\n    /// assert!(v.is_empty());\n    ///\n    /// v.push('a');\n    /// assert!(!v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n}\n\n    /// Splits the string into two at the given index.\n    ///\n    /// Returns a newly allocated `String`. `self` contains bytes `[0, at)`, and\n    /// the returned `String` contains bytes `[at, len)`. `at` must be on the\n    /// boundary of a UTF-8 code point.\n    ///\n    /// Note that the capacity of `self` does not change.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at` is not on a `UTF-8` code point boundary, or if it is beyond the last\n    /// code point of the string.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # fn main() {\n    /// let mut hello = String::from(\"Hello, World!\");\n    /// let world = hello.split_off(7);\n    /// assert_eq!(hello, \"Hello, \");\n    /// assert_eq!(world, \"World!\");\n    /// # }\n    /// ```\n    #[inline]\n    #[stable(feature = \"string_split_off\", since = \"1.16.0\")]\n    pub fn split_off(&mut self, at: usize) -> String {\n}\n\n    /// Truncates this `String`, removing all contents.\n    ///\n    /// While this means the `String` will have a length of zero, it does not\n    /// touch its capacity.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"foo\");\n    ///\n    /// s.clear();\n    ///\n    /// assert!(s.is_empty());\n    /// assert_eq!(0, s.len());\n    /// assert_eq!(3, s.capacity());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n}\n\n    /// Creates a draining iterator that removes the specified range in the `String`\n    /// and yields the removed `chars`.\n    ///\n    /// Note: The element range is removed even if the iterator is not\n    /// consumed until the end.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point or end point do not lie on a [`char`]\n    /// boundary, or if they're out of bounds.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"α is alpha, β is beta\");\n    /// let beta_offset = s.find('β').unwrap_or(s.len());\n    ///\n    /// // Remove the range up until the β from the string\n    /// let t: String = s.drain(..beta_offset).collect();\n    /// assert_eq!(t, \"α is alpha, \");\n    /// assert_eq!(s, \"β is beta\");\n    ///\n    /// // A full range clears the string\n    /// s.drain(..);\n    /// assert_eq!(s, \"\");\n    /// ```\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain<R>(&mut self, range: R) -> Drain<'_>\n    where\n        R: RangeBounds<usize>,\n    {\n}\n\n    /// Removes the specified range in the string,\n    /// and replaces it with the given string.\n    /// The given string doesn't need to be the same length as the range.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point or end point do not lie on a [`char`]\n    /// boundary, or if they're out of bounds.\n    ///\n    /// [`char`]: ../../std/primitive.char.html\n    /// [`Vec::splice`]: ../../std/vec/struct.Vec.html#method.splice\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let mut s = String::from(\"α is alpha, β is beta\");\n    /// let beta_offset = s.find('β').unwrap_or(s.len());\n    ///\n    /// // Replace the range up until the β from the string\n    /// s.replace_range(..beta_offset, \"Α is capital alpha; \");\n    /// assert_eq!(s, \"Α is capital alpha; β is beta\");\n    /// ```\n    #[stable(feature = \"splice\", since = \"1.27.0\")]\n    pub fn replace_range<R>(&mut self, range: R, replace_with: &str)\n    where\n        R: RangeBounds<usize>,\n    {\n}\n\n    /// Converts this `String` into a [`Box`]`<`[`str`]`>`.\n    ///\n    /// This will drop any excess capacity.\n    ///\n    /// [`Box`]: ../../std/boxed/struct.Box.html\n    /// [`str`]: ../../std/primitive.str.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s = String::from(\"hello\");\n    ///\n    /// let b = s.into_boxed_str();\n    /// ```\n    #[stable(feature = \"box_str\", since = \"1.4.0\")]\n    #[inline]\n    pub fn into_boxed_str(self) -> Box<str> {\n}\n}\n\nimpl FromUtf8Error {\n    /// Returns a slice of [`u8`]s bytes that were attempted to convert to a `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some invalid bytes, in a vector\n    /// let bytes = vec![0, 159];\n    ///\n    /// let value = String::from_utf8(bytes);\n    ///\n    /// assert_eq!(&[0, 159], value.unwrap_err().as_bytes());\n    /// ```\n    #[stable(feature = \"from_utf8_error_as_bytes\", since = \"1.26.0\")]\n    pub fn as_bytes(&self) -> &[u8] {\n}\n\n    /// Returns the bytes that were attempted to convert to a `String`.\n    ///\n    /// This method is carefully constructed to avoid allocation. It will\n    /// consume the error, moving out the bytes, so that a copy of the bytes\n    /// does not need to be made.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some invalid bytes, in a vector\n    /// let bytes = vec![0, 159];\n    ///\n    /// let value = String::from_utf8(bytes);\n    ///\n    /// assert_eq!(vec![0, 159], value.unwrap_err().into_bytes());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_bytes(self) -> Vec<u8> {\n}\n\n    /// Fetch a `Utf8Error` to get more details about the conversion failure.\n    ///\n    /// The [`Utf8Error`] type provided by [`std::str`] represents an error that may\n    /// occur when converting a slice of [`u8`]s to a [`&str`]. In this sense, it's\n    /// an analogue to `FromUtf8Error`. See its documentation for more details\n    /// on using it.\n    ///\n    /// [`Utf8Error`]: ../../std/str/struct.Utf8Error.html\n    /// [`std::str`]: ../../std/str/index.html\n    /// [`u8`]: ../../std/primitive.u8.html\n    /// [`&str`]: ../../std/primitive.str.html\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// // some invalid bytes, in a vector\n    /// let bytes = vec![0, 159];\n    ///\n    /// let error = String::from_utf8(bytes).unwrap_err().utf8_error();\n    ///\n    /// // the first byte is invalid here\n    /// assert_eq!(1, error.valid_up_to());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn utf8_error(&self) -> Utf8Error {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for FromUtf8Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for FromUtf16Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Clone for String {\n    fn clone(&self) -> Self {\n}\n\n    fn clone_from(&mut self, source: &Self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromIterator<char> for String {\n    fn from_iter<I: IntoIterator<Item = char>>(iter: I) -> String {\n}\n}\n\n#[stable(feature = \"string_from_iter_by_ref\", since = \"1.17.0\")]\nimpl<'a> FromIterator<&'a char> for String {\n    fn from_iter<I: IntoIterator<Item = &'a char>>(iter: I) -> String {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> FromIterator<&'a str> for String {\n    fn from_iter<I: IntoIterator<Item = &'a str>>(iter: I) -> String {\n}\n}\n\n#[stable(feature = \"extend_string\", since = \"1.4.0\")]\nimpl FromIterator<String> for String {\n    fn from_iter<I: IntoIterator<Item = String>>(iter: I) -> String {\n}\n}\n\n#[stable(feature = \"herd_cows\", since = \"1.19.0\")]\nimpl<'a> FromIterator<Cow<'a, str>> for String {\n    fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> String {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Extend<char> for String {\n    fn extend<I: IntoIterator<Item = char>>(&mut self, iter: I) {\n}\n}\n\n#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\nimpl<'a> Extend<&'a char> for String {\n    fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iter: I) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> Extend<&'a str> for String {\n    fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I) {\n}\n}\n\n#[stable(feature = \"extend_string\", since = \"1.4.0\")]\nimpl Extend<String> for String {\n    fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I) {\n}\n}\n\n#[stable(feature = \"herd_cows\", since = \"1.19.0\")]\nimpl<'a> Extend<Cow<'a, str>> for String {\n    fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I) {\n}\n}\n\n/// A convenience impl that delegates to the impl for `&str`\n#[unstable(\n    feature = \"pattern\",\n    reason = \"API not fully fleshed out and ready to be stabilized\",\n    issue = \"27721\"\n)]\nimpl<'a, 'b> Pattern<'a> for &'b String {\n    type Searcher = <&'b str as Pattern<'a>>::Searcher;\n\n    fn into_searcher(self, haystack: &'a str) -> <&'b str as Pattern<'a>>::Searcher {\n}\n\n    #[inline]\n    fn is_contained_in(self, haystack: &'a str) -> bool {\n}\n\n    #[inline]\n    fn is_prefix_of(self, haystack: &'a str) -> bool {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl PartialEq for String {\n    #[inline]\n    fn eq(&self, other: &String) -> bool {\n}\n    #[inline]\n    fn ne(&self, other: &String) -> bool {\n}\n}\n\nmacro_rules! impl_eq {\n    ($lhs:ty, $rhs: ty) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[allow(unused_lifetimes)]\n        impl<'a, 'b> PartialEq<$rhs> for $lhs {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool {\n}\n            #[inline]\n            fn ne(&self, other: &$rhs) -> bool {\n}\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[allow(unused_lifetimes)]\n        impl<'a, 'b> PartialEq<$lhs> for $rhs {\n            #[inline]\n            fn eq(&self, other: &$lhs) -> bool {\n}\n            #[inline]\n            fn ne(&self, other: &$lhs) -> bool {\n}\n        }\n    };\n}\n\nimpl_eq! { String, str }\nimpl_eq! { String, &'a str }\nimpl_eq! { Cow<'a, str>, str }\nimpl_eq! { Cow<'a, str>, &'b str }\nimpl_eq! { Cow<'a, str>, String }\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Default for String {\n    /// Creates an empty `String`.\n    #[inline]\n    fn default() -> String {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Display for String {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Debug for String {\n    #[inline]\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl hash::Hash for String {\n    #[inline]\n    fn hash<H: hash::Hasher>(&self, hasher: &mut H) {\n}\n}\n\n/// Implements the `+` operator for concatenating two strings.\n///\n/// This consumes the `String` on the left-hand side and re-uses its buffer (growing it if\n/// necessary). This is done to avoid allocating a new `String` and copying the entire contents on\n/// every operation, which would lead to `O(n^2)` running time when building an `n`-byte string by\n/// repeated concatenation.\n///\n/// The string on the right-hand side is only borrowed; its contents are copied into the returned\n/// `String`.\n///\n/// # Examples\n///\n/// Concatenating two `String`s takes the first by value and borrows the second:\n///\n/// ```\n/// let a = String::from(\"hello\");\n/// let b = String::from(\" world\");\n/// let c = a + &b;\n/// // `a` is moved and can no longer be used here.\n/// ```\n///\n/// If you want to keep using the first `String`, you can clone it and append to the clone instead:\n///\n/// ```\n/// let a = String::from(\"hello\");\n/// let b = String::from(\" world\");\n/// let c = a.clone() + &b;\n/// // `a` is still valid here.\n/// ```\n///\n/// Concatenating `&str` slices can be done by converting the first to a `String`:\n///\n/// ```\n/// let a = \"hello\";\n/// let b = \" world\";\n/// let c = a.to_string() + b;\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl Add<&str> for String {\n    type Output = String;\n\n    #[inline]\n    fn add(mut self, other: &str) -> String {\n}\n}\n\n/// Implements the `+=` operator for appending to a `String`.\n///\n/// This has the same behavior as the [`push_str`][String::push_str] method.\n#[stable(feature = \"stringaddassign\", since = \"1.12.0\")]\nimpl AddAssign<&str> for String {\n    #[inline]\n    fn add_assign(&mut self, other: &str) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::Range<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::Range<usize>) -> &str {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::RangeTo<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::RangeTo<usize>) -> &str {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::RangeFrom<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n}\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Index<ops::RangeFull> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, _index: ops::RangeFull) -> &str {\n}\n}\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl ops::Index<ops::RangeInclusive<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n}\n}\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl ops::Index<ops::RangeToInclusive<usize>> for String {\n    type Output = str;\n\n    #[inline]\n    fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n}\n}\n\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::IndexMut<ops::Range<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str {\n}\n}\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::IndexMut<ops::RangeTo<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str {\n}\n}\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::IndexMut<ops::RangeFrom<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str {\n}\n}\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::IndexMut<ops::RangeFull> for String {\n    #[inline]\n    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut str {\n}\n}\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl ops::IndexMut<ops::RangeInclusive<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n}\n}\n#[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\nimpl ops::IndexMut<ops::RangeToInclusive<usize>> for String {\n    #[inline]\n    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl ops::Deref for String {\n    type Target = str;\n\n    #[inline]\n    fn deref(&self) -> &str {\n}\n}\n\n#[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\nimpl ops::DerefMut for String {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut str {\n}\n}\n\n/// An error when parsing a `String`.\n///\n/// This `enum` is slightly awkward: it will never actually exist. This error is\n/// part of the type signature of the implementation of [`FromStr`] on\n/// [`String`]. The return type of [`from_str`], requires that an error be\n/// defined, but, given that a [`String`] can always be made into a new\n/// [`String`] without error, this type will never actually be returned. As\n/// such, it is only here to satisfy said signature, and is useless otherwise.\n///\n/// [`FromStr`]: ../../std/str/trait.FromStr.html\n/// [`String`]: struct.String.html\n/// [`from_str`]: ../../std/str/trait.FromStr.html#tymethod.from_str\n#[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\npub type ParseError = core::convert::Infallible;\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl FromStr for String {\n    type Err = core::convert::Infallible;\n    #[inline]\n    fn from_str(s: &str) -> Result<String, ParseError> {\n}\n}\n\n/// A trait for converting a value to a `String`.\n///\n/// This trait is automatically implemented for any type which implements the\n/// [`Display`] trait. As such, `ToString` shouldn't be implemented directly:\n/// [`Display`] should be implemented instead, and you get the `ToString`\n/// implementation for free.\n///\n/// [`Display`]: ../../std/fmt/trait.Display.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub trait ToString {\n    /// Converts the given value to a `String`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let i = 5;\n    /// let five = String::from(\"5\");\n    ///\n    /// assert_eq!(five, i.to_string());\n    /// ```\n    #[rustc_conversion_suggestion]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    fn to_string(&self) -> String;\n}\n\n/// # Panics\n///\n/// In this implementation, the `to_string` method panics\n/// if the `Display` implementation returns an error.\n/// This indicates an incorrect `Display` implementation\n/// since `fmt::Write for String` never returns an error itself.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Display + ?Sized> ToString for T {\n    #[inline]\n    default fn to_string(&self) -> String {\n}\n}\n\n#[stable(feature = \"str_to_string_specialization\", since = \"1.9.0\")]\nimpl ToString for str {\n    #[inline]\n    fn to_string(&self) -> String {\n}\n}\n\n#[stable(feature = \"cow_str_to_string_specialization\", since = \"1.17.0\")]\nimpl ToString for Cow<'_, str> {\n    #[inline]\n    fn to_string(&self) -> String {\n}\n}\n\n#[stable(feature = \"string_to_string_specialization\", since = \"1.17.0\")]\nimpl ToString for String {\n    #[inline]\n    fn to_string(&self) -> String {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<str> for String {\n    #[inline]\n    fn as_ref(&self) -> &str {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl AsRef<[u8]> for String {\n    #[inline]\n    fn as_ref(&self) -> &[u8] {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<&str> for String {\n    #[inline]\n    fn from(s: &str) -> String {\n}\n}\n\n#[stable(feature = \"from_ref_string\", since = \"1.35.0\")]\nimpl From<&String> for String {\n    #[inline]\n    fn from(s: &String) -> String {\n}\n}\n\n// note: test pulls in libstd, which causes errors here\n#[cfg(not(test))]\n#[stable(feature = \"string_from_box\", since = \"1.18.0\")]\nimpl From<Box<str>> for String {\n    /// Converts the given boxed `str` slice to a `String`.\n    /// It is notable that the `str` slice is owned.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s1: String = String::from(\"hello world\");\n    /// let s2: Box<str> = s1.into_boxed_str();\n    /// let s3: String = String::from(s2);\n    ///\n    /// assert_eq!(\"hello world\", s3)\n    /// ```\n    fn from(s: Box<str>) -> String {\n}\n}\n\n#[stable(feature = \"box_from_str\", since = \"1.20.0\")]\nimpl From<String> for Box<str> {\n    /// Converts the given `String` to a boxed `str` slice that is owned.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s1: String = String::from(\"hello world\");\n    /// let s2: Box<str> = Box::from(s1);\n    /// let s3: String = String::from(s2);\n    ///\n    /// assert_eq!(\"hello world\", s3)\n    /// ```\n    fn from(s: String) -> Box<str> {\n}\n}\n\n#[stable(feature = \"string_from_cow_str\", since = \"1.14.0\")]\nimpl<'a> From<Cow<'a, str>> for String {\n    fn from(s: Cow<'a, str>) -> String {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<&'a str> for Cow<'a, str> {\n    #[inline]\n    fn from(s: &'a str) -> Cow<'a, str> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<String> for Cow<'a, str> {\n    #[inline]\n    fn from(s: String) -> Cow<'a, str> {\n}\n}\n\n#[stable(feature = \"cow_from_string_ref\", since = \"1.28.0\")]\nimpl<'a> From<&'a String> for Cow<'a, str> {\n    #[inline]\n    fn from(s: &'a String) -> Cow<'a, str> {\n}\n}\n\n#[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\nimpl<'a> FromIterator<char> for Cow<'a, str> {\n    fn from_iter<I: IntoIterator<Item = char>>(it: I) -> Cow<'a, str> {\n}\n}\n\n#[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\nimpl<'a, 'b> FromIterator<&'b str> for Cow<'a, str> {\n    fn from_iter<I: IntoIterator<Item = &'b str>>(it: I) -> Cow<'a, str> {\n}\n}\n\n#[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\nimpl<'a> FromIterator<String> for Cow<'a, str> {\n    fn from_iter<I: IntoIterator<Item = String>>(it: I) -> Cow<'a, str> {\n}\n}\n\n#[stable(feature = \"from_string_for_vec_u8\", since = \"1.14.0\")]\nimpl From<String> for Vec<u8> {\n    /// Converts the given `String` to a vector `Vec` that holds values of type `u8`.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// let s1 = String::from(\"hello world\");\n    /// let v1 = Vec::from(s1);\n    ///\n    /// for b in v1 {\n    ///     println!(\"{}\", b);\n    /// }\n    /// ```\n    fn from(string: String) -> Vec<u8> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl fmt::Write for String {\n    #[inline]\n    fn write_str(&mut self, s: &str) -> fmt::Result {\n}\n\n    #[inline]\n    fn write_char(&mut self, c: char) -> fmt::Result {\n}\n}\n\n/// A draining iterator for `String`.\n///\n/// This struct is created by the [`drain`] method on [`String`]. See its\n/// documentation for more.\n///\n/// [`drain`]: struct.String.html#method.drain\n/// [`String`]: struct.String.html\n#[stable(feature = \"drain\", since = \"1.6.0\")]\npub struct Drain<'a> {\n    /// Will be used as &'a mut String in the destructor\n    string: *mut String,\n    /// Start of part to remove\n    start: usize,\n    /// End of part to remove\n    end: usize,\n    /// Current remaining range to remove\n    iter: Chars<'a>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl fmt::Debug for Drain<'_> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl Sync for Drain<'_> {}\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl Send for Drain<'_> {}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl Drop for Drain<'_> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl Iterator for Drain<'_> {\n    type Item = char;\n\n    #[inline]\n    fn next(&mut self) -> Option<char> {\n}\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn last(mut self) -> Option<char> {\n}\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl DoubleEndedIterator for Drain<'_> {\n    #[inline]\n    fn next_back(&mut self) -> Option<char> {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl FusedIterator for Drain<'_> {}\n}\n#[cfg(target_has_atomic = \"ptr\")]\npub mod sync {\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n//! Thread-safe reference-counting pointers.\n//!\n//! See the [`Arc<T>`][arc] documentation for more details.\n//!\n//! [arc]: struct.Arc.html\n\nuse core::any::Any;\nuse core::array::LengthAtMost32;\nuse core::borrow;\nuse core::cmp::Ordering;\nuse core::convert::{From, TryFrom};\nuse core::fmt;\nuse core::hash::{Hash, Hasher};\nuse core::intrinsics::abort;\nuse core::iter;\nuse core::marker::{PhantomData, Unpin, Unsize};\nuse core::mem::{self, align_of, align_of_val, size_of_val};\nuse core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\nuse core::pin::Pin;\nuse core::ptr::{self, NonNull};\nuse core::slice::{self, from_raw_parts_mut};\nuse core::sync::atomic;\nuse core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\nuse core::{isize, usize};\n\nuse crate::alloc::{box_free, handle_alloc_error, Alloc, Global, Layout};\nuse crate::boxed::Box;\nuse crate::rc::is_dangling;\nuse crate::string::String;\nuse crate::vec::Vec;\n\n#[cfg(test)]\nmod tests {\n}\n\n/// A soft limit on the amount of references that may be made to an `Arc`.\n///\n/// Going above this limit will abort your program (although not\n/// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\nconst MAX_REFCOUNT: usize = (isize::MAX) as usize;\n\n/// A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically\n/// Reference Counted'.\n///\n/// The type `Arc<T>` provides shared ownership of a value of type `T`,\n/// allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n/// a new `Arc` instance, which points to the same allocation on the heap as the\n/// source `Arc`, while increasing a reference count. When the last `Arc`\n/// pointer to a given allocation is destroyed, the value stored in that allocation (often\n/// referred to as \"inner value\") is also dropped.\n///\n/// Shared references in Rust disallow mutation by default, and `Arc` is no\n/// exception: you cannot generally obtain a mutable reference to something\n/// inside an `Arc`. If you need to mutate through an `Arc`, use\n/// [`Mutex`][mutex], [`RwLock`][rwlock], or one of the [`Atomic`][atomic]\n/// types.\n///\n/// ## Thread Safety\n///\n/// Unlike [`Rc<T>`], `Arc<T>` uses atomic operations for its reference\n/// counting. This means that it is thread-safe. The disadvantage is that\n/// atomic operations are more expensive than ordinary memory accesses. If you\n/// are not sharing reference-counted allocations between threads, consider using\n/// [`Rc<T>`] for lower overhead. [`Rc<T>`] is a safe default, because the\n/// compiler will catch any attempt to send an [`Rc<T>`] between threads.\n/// However, a library might choose `Arc<T>` in order to give library consumers\n/// more flexibility.\n///\n/// `Arc<T>` will implement [`Send`] and [`Sync`] as long as the `T` implements\n/// [`Send`] and [`Sync`]. Why can't you put a non-thread-safe type `T` in an\n/// `Arc<T>` to make it thread-safe? This may be a bit counter-intuitive at\n/// first: after all, isn't the point of `Arc<T>` thread safety? The key is\n/// this: `Arc<T>` makes it thread safe to have multiple ownership of the same\n/// data, but it  doesn't add thread safety to its data. Consider\n/// `Arc<`[`RefCell<T>`]`>`. [`RefCell<T>`] isn't [`Sync`], and if `Arc<T>` was always\n/// [`Send`], `Arc<`[`RefCell<T>`]`>` would be as well. But then we'd have a problem:\n/// [`RefCell<T>`] is not thread safe; it keeps track of the borrowing count using\n/// non-atomic operations.\n///\n/// In the end, this means that you may need to pair `Arc<T>` with some sort of\n/// [`std::sync`] type, usually [`Mutex<T>`][mutex].\n///\n/// ## Breaking cycles with `Weak`\n///\n/// The [`downgrade`][downgrade] method can be used to create a non-owning\n/// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n/// to an `Arc`, but this will return [`None`] if the value stored in the allocation has\n/// already been dropped. In other words, `Weak` pointers do not keep the value\n/// inside the allocation alive; however, they *do* keep the allocation\n/// (the backing store for the value) alive.\n///\n/// A cycle between `Arc` pointers will never be deallocated. For this reason,\n/// [`Weak`][weak] is used to break cycles. For example, a tree could have\n/// strong `Arc` pointers from parent nodes to children, and [`Weak`][weak]\n/// pointers from children back to their parents.\n///\n/// # Cloning references\n///\n/// Creating a new reference from an existing reference counted pointer is done using the\n/// `Clone` trait implemented for [`Arc<T>`][arc] and [`Weak<T>`][weak].\n///\n/// ```\n/// use std::sync::Arc;\n/// let foo = Arc::new(vec![1.0, 2.0, 3.0]);\n/// // The two syntaxes below are equivalent.\n/// let a = foo.clone();\n/// let b = Arc::clone(&foo);\n/// // a, b, and foo are all Arcs that point to the same memory location\n/// ```\n///\n/// ## `Deref` behavior\n///\n/// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n/// so you can call `T`'s methods on a value of type `Arc<T>`. To avoid name\n/// clashes with `T`'s methods, the methods of `Arc<T>` itself are associated\n/// functions, called using function-like syntax:\n///\n/// ```\n/// use std::sync::Arc;\n/// let my_arc = Arc::new(());\n///\n/// Arc::downgrade(&my_arc);\n/// ```\n///\n/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the inner value may have\n/// already been dropped.\n///\n/// [arc]: struct.Arc.html\n/// [weak]: struct.Weak.html\n/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n/// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n/// [mutex]: ../../std/sync/struct.Mutex.html\n/// [rwlock]: ../../std/sync/struct.RwLock.html\n/// [atomic]: ../../std/sync/atomic/index.html\n/// [`Send`]: ../../std/marker/trait.Send.html\n/// [`Sync`]: ../../std/marker/trait.Sync.html\n/// [deref]: ../../std/ops/trait.Deref.html\n/// [downgrade]: struct.Arc.html#method.downgrade\n/// [upgrade]: struct.Weak.html#method.upgrade\n/// [`None`]: ../../std/option/enum.Option.html#variant.None\n/// [`RefCell<T>`]: ../../std/cell/struct.RefCell.html\n/// [`std::sync`]: ../../std/sync/index.html\n/// [`Arc::clone(&from)`]: #method.clone\n///\n/// # Examples\n///\n/// Sharing some immutable data between threads:\n///\n// Note that we **do not** run these tests here. The windows builders get super\n// unhappy if a thread outlives the main thread and then exits at the same time\n// (something deadlocks) so we just avoid this entirely by not running these\n// tests.\n/// ```no_run\n/// use std::sync::Arc;\n/// use std::thread;\n///\n/// let five = Arc::new(5);\n///\n/// for _ in 0..10 {\n///     let five = Arc::clone(&five);\n///\n///     thread::spawn(move || {\n///         println!(\"{:?}\", five);\n///     });\n/// }\n/// ```\n///\n/// Sharing a mutable [`AtomicUsize`]:\n///\n/// [`AtomicUsize`]: ../../std/sync/atomic/struct.AtomicUsize.html\n///\n/// ```no_run\n/// use std::sync::Arc;\n/// use std::sync::atomic::{AtomicUsize, Ordering};\n/// use std::thread;\n///\n/// let val = Arc::new(AtomicUsize::new(5));\n///\n/// for _ in 0..10 {\n///     let val = Arc::clone(&val);\n///\n///     thread::spawn(move || {\n///         let v = val.fetch_add(1, Ordering::SeqCst);\n///         println!(\"{:?}\", v);\n///     });\n/// }\n/// ```\n///\n/// See the [`rc` documentation][rc_examples] for more examples of reference\n/// counting in general.\n///\n/// [rc_examples]: ../../std/rc/index.html#examples\n#[cfg_attr(not(test), lang = \"arc\")]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct Arc<T: ?Sized> {\n    ptr: NonNull<ArcInner<T>>,\n    phantom: PhantomData<ArcInner<T>>,\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}}\n#[cfg(test)]\nmod tests {\n}\npub mod vec {\n//! A contiguous growable array type with heap-allocated contents, written\n//! `Vec<T>`.\n//!\n//! Vectors have `O(1)` indexing, amortized `O(1)` push (to the end) and\n//! `O(1)` pop (from the end).\n//!\n//! # Examples\n//!\n//! You can explicitly create a [`Vec<T>`] with [`new`]:\n//!\n//! ```\n//! let v: Vec<i32> = Vec::new();\n//! ```\n//!\n//! ...or by using the [`vec!`] macro:\n//!\n//! ```\n//! let v: Vec<i32> = vec![];\n//!\n//! let v = vec![1, 2, 3, 4, 5];\n//!\n//! let v = vec![0; 10]; // ten zeroes\n//! ```\n//!\n//! You can [`push`] values onto the end of a vector (which will grow the vector\n//! as needed):\n//!\n//! ```\n//! let mut v = vec![1, 2];\n//!\n//! v.push(3);\n//! ```\n//!\n//! Popping values works in much the same way:\n//!\n//! ```\n//! let mut v = vec![1, 2];\n//!\n//! let two = v.pop();\n//! ```\n//!\n//! Vectors also support indexing (through the [`Index`] and [`IndexMut`] traits):\n//!\n//! ```\n//! let mut v = vec![1, 2, 3];\n//! let three = v[2];\n//! v[1] = v[1] + 5;\n//! ```\n//!\n//! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n//! [`new`]: ../../std/vec/struct.Vec.html#method.new\n//! [`push`]: ../../std/vec/struct.Vec.html#method.push\n//! [`Index`]: ../../std/ops/trait.Index.html\n//! [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n//! [`vec!`]: ../../std/macro.vec.html\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::array::LengthAtMost32;\nuse core::cmp::{self, Ordering};\nuse core::fmt;\nuse core::hash::{self, Hash};\nuse core::intrinsics::{arith_offset, assume};\nuse core::iter::{FromIterator, FusedIterator, TrustedLen};\nuse core::marker::PhantomData;\nuse core::mem;\nuse core::ops::Bound::{Excluded, Included, Unbounded};\nuse core::ops::{self, Index, IndexMut, RangeBounds};\nuse core::ptr::{self, NonNull};\nuse core::slice::{self, SliceIndex};\n\nuse crate::borrow::{Cow, ToOwned};\nuse crate::boxed::Box;\nuse crate::collections::TryReserveError;\nuse crate::raw_vec::RawVec;\n\n/// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n///\n/// # Examples\n///\n/// ```\n/// let mut vec = Vec::new();\n/// vec.push(1);\n/// vec.push(2);\n///\n/// assert_eq!(vec.len(), 2);\n/// assert_eq!(vec[0], 1);\n///\n/// assert_eq!(vec.pop(), Some(2));\n/// assert_eq!(vec.len(), 1);\n///\n/// vec[0] = 7;\n/// assert_eq!(vec[0], 7);\n///\n/// vec.extend([1, 2, 3].iter().copied());\n///\n/// for x in &vec {\n///     println!(\"{}\", x);\n/// }\n/// assert_eq!(vec, [7, 1, 2, 3]);\n/// ```\n///\n/// The [`vec!`] macro is provided to make initialization more convenient:\n///\n/// ```\n/// let mut vec = vec![1, 2, 3];\n/// vec.push(4);\n/// assert_eq!(vec, [1, 2, 3, 4]);\n/// ```\n///\n/// It can also initialize each element of a `Vec<T>` with a given value.\n/// This may be more efficient than performing allocation and initialization\n/// in separate steps, especially when initializing a vector of zeros:\n///\n/// ```\n/// let vec = vec![0; 5];\n/// assert_eq!(vec, [0, 0, 0, 0, 0]);\n///\n/// // The following is equivalent, but potentially slower:\n/// let mut vec1 = Vec::with_capacity(5);\n/// vec1.resize(5, 0);\n/// ```\n///\n/// Use a `Vec<T>` as an efficient stack:\n///\n/// ```\n/// let mut stack = Vec::new();\n///\n/// stack.push(1);\n/// stack.push(2);\n/// stack.push(3);\n///\n/// while let Some(top) = stack.pop() {\n///     // Prints 3, 2, 1\n///     println!(\"{}\", top);\n/// }\n/// ```\n///\n/// # Indexing\n///\n/// The `Vec` type allows to access values by index, because it implements the\n/// [`Index`] trait. An example will be more explicit:\n///\n/// ```\n/// let v = vec![0, 2, 4, 6];\n/// println!(\"{}\", v[1]); // it will display '2'\n/// ```\n///\n/// However be careful: if you try to access an index which isn't in the `Vec`,\n/// your software will panic! You cannot do this:\n///\n/// ```should_panic\n/// let v = vec![0, 2, 4, 6];\n/// println!(\"{}\", v[6]); // it will panic!\n/// ```\n///\n/// Use [`get`] and [`get_mut`] if you want to check whether the index is in\n/// the `Vec`.\n///\n/// # Slicing\n///\n/// A `Vec` can be mutable. Slices, on the other hand, are read-only objects.\n/// To get a slice, use `&`. Example:\n///\n/// ```\n/// fn read_slice(slice: &[usize]) {\n///     // ...\n/// }\n///\n/// let v = vec![0, 1];\n/// read_slice(&v);\n///\n/// // ... and that's all!\n/// // you can also do it like this:\n/// let x : &[usize] = &v;\n/// ```\n///\n/// In Rust, it's more common to pass slices as arguments rather than vectors\n/// when you just want to provide a read access. The same goes for [`String`] and\n/// [`&str`].\n///\n/// # Capacity and reallocation\n///\n/// The capacity of a vector is the amount of space allocated for any future\n/// elements that will be added onto the vector. This is not to be confused with\n/// the *length* of a vector, which specifies the number of actual elements\n/// within the vector. If a vector's length exceeds its capacity, its capacity\n/// will automatically be increased, but its elements will have to be\n/// reallocated.\n///\n/// For example, a vector with capacity 10 and length 0 would be an empty vector\n/// with space for 10 more elements. Pushing 10 or fewer elements onto the\n/// vector will not change its capacity or cause reallocation to occur. However,\n/// if the vector's length is increased to 11, it will have to reallocate, which\n/// can be slow. For this reason, it is recommended to use [`Vec::with_capacity`]\n/// whenever possible to specify how big the vector is expected to get.\n///\n/// # Guarantees\n///\n/// Due to its incredibly fundamental nature, `Vec` makes a lot of guarantees\n/// about its design. This ensures that it's as low-overhead as possible in\n/// the general case, and can be correctly manipulated in primitive ways\n/// by unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\n/// If additional type parameters are added (e.g., to support custom allocators),\n/// overriding their defaults may change the behavior.\n///\n/// Most fundamentally, `Vec` is and always will be a (pointer, capacity, length)\n/// triplet. No more, no less. The order of these fields is completely\n/// unspecified, and you should use the appropriate methods to modify these.\n/// The pointer will never be null, so this type is null-pointer-optimized.\n///\n/// However, the pointer may not actually point to allocated memory. In particular,\n/// if you construct a `Vec` with capacity 0 via [`Vec::new`], [`vec![]`][`vec!`],\n/// [`Vec::with_capacity(0)`][`Vec::with_capacity`], or by calling [`shrink_to_fit`]\n/// on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\n/// types inside a `Vec`, it will not allocate space for them. *Note that in this case\n/// the `Vec` may not report a [`capacity`] of 0*. `Vec` will allocate if and only\n/// if [`mem::size_of::<T>`]`() * capacity() > 0`. In general, `Vec`'s allocation\n/// details are very subtle &mdash; if you intend to allocate memory using a `Vec`\n/// and use it for something else (either to pass to unsafe code, or to build your\n/// own memory-backed collection), be sure to deallocate this memory by using\n/// `from_raw_parts` to recover the `Vec` and then dropping it.\n///\n/// If a `Vec` *has* allocated memory, then the memory it points to is on the heap\n/// (as defined by the allocator Rust is configured to use by default), and its\n/// pointer points to [`len`] initialized, contiguous elements in order (what\n/// you would see if you coerced it to a slice), followed by [`capacity`]` -\n/// `[`len`] logically uninitialized, contiguous elements.\n///\n/// `Vec` will never perform a \"small optimization\" where elements are actually\n/// stored on the stack for two reasons:\n///\n/// * It would make it more difficult for unsafe code to correctly manipulate\n///   a `Vec`. The contents of a `Vec` wouldn't have a stable address if it were\n///   only moved, and it would be more difficult to determine if a `Vec` had\n///   actually allocated memory.\n///\n/// * It would penalize the general case, incurring an additional branch\n///   on every access.\n///\n/// `Vec` will never automatically shrink itself, even if completely empty. This\n/// ensures no unnecessary allocations or deallocations occur. Emptying a `Vec`\n/// and then filling it back up to the same [`len`] should incur no calls to\n/// the allocator. If you wish to free up unused memory, use\n/// [`shrink_to_fit`].\n///\n/// [`push`] and [`insert`] will never (re)allocate if the reported capacity is\n/// sufficient. [`push`] and [`insert`] *will* (re)allocate if\n/// [`len`]` == `[`capacity`]. That is, the reported capacity is completely\n/// accurate, and can be relied on. It can even be used to manually free the memory\n/// allocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\n/// when not necessary.\n///\n/// `Vec` does not guarantee any particular growth strategy when reallocating\n/// when full, nor when [`reserve`] is called. The current strategy is basic\n/// and it may prove desirable to use a non-constant growth factor. Whatever\n/// strategy is used will of course guarantee `O(1)` amortized [`push`].\n///\n/// `vec![x; n]`, `vec![a, b, c, d]`, and\n/// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`\n/// with exactly the requested capacity. If [`len`]` == `[`capacity`],\n/// (as is the case for the [`vec!`] macro), then a `Vec<T>` can be converted to\n/// and from a [`Box<[T]>`][owned slice] without reallocating or moving the elements.\n///\n/// `Vec` will not specifically overwrite any data that is removed from it,\n/// but also won't specifically preserve it. Its uninitialized memory is\n/// scratch space that it may use however it wants. It will generally just do\n/// whatever is most efficient or otherwise easy to implement. Do not rely on\n/// removed data to be erased for security purposes. Even if you drop a `Vec`, its\n/// buffer may simply be reused by another `Vec`. Even if you zero a `Vec`'s memory\n/// first, that may not actually happen because the optimizer does not consider\n/// this a side-effect that must be preserved. There is one case which we will\n/// not break, however: using `unsafe` code to write to the excess capacity,\n/// and then increasing the length to match, is always valid.\n///\n/// `Vec` does not currently guarantee the order in which elements are dropped.\n/// The order has changed in the past and may change again.\n///\n/// [`vec!`]: ../../std/macro.vec.html\n/// [`get`]: ../../std/vec/struct.Vec.html#method.get\n/// [`get_mut`]: ../../std/vec/struct.Vec.html#method.get_mut\n/// [`Index`]: ../../std/ops/trait.Index.html\n/// [`String`]: ../../std/string/struct.String.html\n/// [`&str`]: ../../std/primitive.str.html\n/// [`Vec::with_capacity`]: ../../std/vec/struct.Vec.html#method.with_capacity\n/// [`Vec::new`]: ../../std/vec/struct.Vec.html#method.new\n/// [`shrink_to_fit`]: ../../std/vec/struct.Vec.html#method.shrink_to_fit\n/// [`capacity`]: ../../std/vec/struct.Vec.html#method.capacity\n/// [`mem::size_of::<T>`]: ../../std/mem/fn.size_of.html\n/// [`len`]: ../../std/vec/struct.Vec.html#method.len\n/// [`push`]: ../../std/vec/struct.Vec.html#method.push\n/// [`insert`]: ../../std/vec/struct.Vec.html#method.insert\n/// [`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n/// [owned slice]: ../../std/boxed/struct.Box.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[cfg_attr(not(test), rustc_diagnostic_item = \"vec_type\")]\npub struct Vec<T> {\n    buf: RawVec<T>,\n    len: usize,\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Inherent methods\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Vec<T> {\n    /// Constructs a new, empty `Vec<T>`.\n    ///\n    /// The vector will not allocate until elements are pushed onto it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![allow(unused_mut)]\n    /// let mut vec: Vec<i32> = Vec::new();\n    /// ```\n    #[inline]\n    #[rustc_const_stable(feature = \"const_vec_new\", since = \"1.32.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub const fn new() -> Vec<T> {\n}\n\n    /// Constructs a new, empty `Vec<T>` with the specified capacity.\n    ///\n    /// The vector will be able to hold exactly `capacity` elements without\n    /// reallocating. If `capacity` is 0, the vector will not allocate.\n    ///\n    /// It is important to note that although the returned vector has the\n    /// *capacity* specified, the vector will have a zero *length*. For an\n    /// explanation of the difference between length and capacity, see\n    /// *[Capacity and reallocation]*.\n    ///\n    /// [Capacity and reallocation]: #capacity-and-reallocation\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    ///\n    /// // The vector contains no items, even though it has capacity for more\n    /// assert_eq!(vec.len(), 0);\n    ///\n    /// // These are all done without reallocating...\n    /// for i in 0..10 {\n    ///     vec.push(i);\n    /// }\n    ///\n    /// // ...but this may make the vector reallocate\n    /// vec.push(11);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn with_capacity(capacity: usize) -> Vec<T> {\n}\n\n    /// Decomposes a `Vec<T>` into its raw components.\n    ///\n    /// Returns the raw pointer to the underlying data, the length of\n    /// the vector (in elements), and the allocated capacity of the\n    /// data (in elements). These are the same arguments in the same\n    /// order as the arguments to [`from_raw_parts`].\n    ///\n    /// After calling this function, the caller is responsible for the\n    /// memory previously managed by the `Vec`. The only way to do\n    /// this is to convert the raw pointer, length, and capacity back\n    /// into a `Vec` with the [`from_raw_parts`] function, allowing\n    /// the destructor to perform the cleanup.\n    ///\n    /// [`from_raw_parts`]: #method.from_raw_parts\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(vec_into_raw_parts)]\n    /// let v: Vec<i32> = vec![-1, 0, 1];\n    ///\n    /// let (ptr, len, cap) = v.into_raw_parts();\n    ///\n    /// let rebuilt = unsafe {\n    ///     // We can now make changes to the components, such as\n    ///     // transmuting the raw pointer to a compatible type.\n    ///     let ptr = ptr as *mut u32;\n    ///\n    ///     Vec::from_raw_parts(ptr, len, cap)\n    /// };\n    /// assert_eq!(rebuilt, [4294967295, 0, 1]);\n    /// ```\n    #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n    pub fn into_raw_parts(self) -> (*mut T, usize, usize) {\n}\n\n    /// Creates a `Vec<T>` directly from the raw components of another vector.\n    ///\n    /// # Safety\n    ///\n    /// This is highly unsafe, due to the number of invariants that aren't\n    /// checked:\n    ///\n    /// * `ptr` needs to have been previously allocated via [`String`]/`Vec<T>`\n    ///   (at least, it's highly likely to be incorrect if it wasn't).\n    /// * `ptr`'s `T` needs to have the same size and alignment as it was allocated with.\n    /// * `length` needs to be less than or equal to `capacity`.\n    /// * `capacity` needs to be the capacity that the pointer was allocated with.\n    ///\n    /// Violating these may cause problems like corrupting the allocator's\n    /// internal data structures. For example it is **not** safe\n    /// to build a `Vec<u8>` from a pointer to a C `char` array with length `size_t`.\n    /// It's also not safe to build one from a `Vec<u16>` and its length, because\n    /// the allocator cares about the alignment, and these two types have different\n    /// alignments. The buffer was allocated with alignment 2 (for `u16`), but after\n    /// turning it into a `Vec<u8>` it'll be deallocated with alignment 1.\n    ///\n    /// The ownership of `ptr` is effectively transferred to the\n    /// `Vec<T>` which may then deallocate, reallocate or change the\n    /// contents of memory pointed to by the pointer at will. Ensure\n    /// that nothing else uses the pointer after calling this\n    /// function.\n    ///\n    /// [`String`]: ../../std/string/struct.String.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ptr;\n    /// use std::mem;\n    ///\n    /// let v = vec![1, 2, 3];\n    ///\n    // FIXME Update this when vec_into_raw_parts is stabilized\n    /// // Prevent running `v`'s destructor so we are in complete control\n    /// // of the allocation.\n    /// let mut v = mem::ManuallyDrop::new(v);\n    ///\n    /// // Pull out the various important pieces of information about `v`\n    /// let p = v.as_mut_ptr();\n    /// let len = v.len();\n    /// let cap = v.capacity();\n    ///\n    /// unsafe {\n    ///     // Overwrite memory with 4, 5, 6\n    ///     for i in 0..len as isize {\n    ///         ptr::write(p.offset(i), 4 + i);\n    ///     }\n    ///\n    ///     // Put everything back together into a Vec\n    ///     let rebuilt = Vec::from_raw_parts(p, len, cap);\n    ///     assert_eq!(rebuilt, [4, 5, 6]);\n    /// }\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -> Vec<T> {\n}\n\n    /// Returns the number of elements the vector can hold without\n    /// reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let vec: Vec<i32> = Vec::with_capacity(10);\n    /// assert_eq!(vec.capacity(), 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n}\n\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the given `Vec<T>`. The collection may reserve more space to avoid\n    /// frequent reallocations. After calling `reserve`, capacity will be\n    /// greater than or equal to `self.len() + additional`. Does nothing if\n    /// capacity is already sufficient.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.reserve(10);\n    /// assert!(vec.capacity() >= 11);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n}\n\n    /// Reserves the minimum capacity for exactly `additional` more elements to\n    /// be inserted in the given `Vec<T>`. After calling `reserve_exact`,\n    /// capacity will be greater than or equal to `self.len() + additional`.\n    /// Does nothing if the capacity is already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it\n    /// requests. Therefore, capacity can not be relied upon to be precisely\n    /// minimal. Prefer `reserve` if future insertions are expected.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity overflows `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.reserve_exact(10);\n    /// assert!(vec.capacity() >= 11);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve_exact(&mut self, additional: usize) {\n}\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `Vec<T>`. The collection may reserve more space to avoid\n    /// frequent reallocations. After calling `reserve`, capacity will be\n    /// greater than or equal to `self.len() + additional`. Does nothing if\n    /// capacity is already sufficient.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_reserve)]\n    /// use std::collections::TryReserveError;\n    ///\n    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n    ///     let mut output = Vec::new();\n    ///\n    ///     // Pre-reserve the memory, exiting if we can't\n    ///     output.try_reserve(data.len())?;\n    ///\n    ///     // Now we know this can't OOM in the middle of our complex work\n    ///     output.extend(data.iter().map(|&val| {\n    ///         val * 2 + 5 // very complicated\n    ///     }));\n    ///\n    ///     Ok(output)\n    /// }\n    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n    /// ```\n    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n}\n\n    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n    /// be inserted in the given `Vec<T>`. After calling `reserve_exact`,\n    /// capacity will be greater than or equal to `self.len() + additional`.\n    /// Does nothing if the capacity is already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it\n    /// requests. Therefore, capacity can not be relied upon to be precisely\n    /// minimal. Prefer `reserve` if future insertions are expected.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(try_reserve)]\n    /// use std::collections::TryReserveError;\n    ///\n    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n    ///     let mut output = Vec::new();\n    ///\n    ///     // Pre-reserve the memory, exiting if we can't\n    ///     output.try_reserve(data.len())?;\n    ///\n    ///     // Now we know this can't OOM in the middle of our complex work\n    ///     output.extend(data.iter().map(|&val| {\n    ///         val * 2 + 5 // very complicated\n    ///     }));\n    ///\n    ///     Ok(output)\n    /// }\n    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n    /// ```\n    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n}\n\n    /// Shrinks the capacity of the vector as much as possible.\n    ///\n    /// It will drop down as close as possible to the length but the allocator\n    /// may still inform the vector that there is space for a few more elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    /// vec.extend([1, 2, 3].iter().cloned());\n    /// assert_eq!(vec.capacity(), 10);\n    /// vec.shrink_to_fit();\n    /// assert!(vec.capacity() >= 3);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n}\n\n    /// Shrinks the capacity of the vector with a lower bound.\n    ///\n    /// The capacity will remain at least as large as both the length\n    /// and the supplied value.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the current capacity is smaller than the supplied\n    /// minimum capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(shrink_to)]\n    /// let mut vec = Vec::with_capacity(10);\n    /// vec.extend([1, 2, 3].iter().cloned());\n    /// assert_eq!(vec.capacity(), 10);\n    /// vec.shrink_to(4);\n    /// assert!(vec.capacity() >= 4);\n    /// vec.shrink_to(0);\n    /// assert!(vec.capacity() >= 3);\n    /// ```\n    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue = \"56431\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n}\n\n    /// Converts the vector into [`Box<[T]>`][owned slice].\n    ///\n    /// Note that this will drop any excess capacity.\n    ///\n    /// [owned slice]: ../../std/boxed/struct.Box.html\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = vec![1, 2, 3];\n    ///\n    /// let slice = v.into_boxed_slice();\n    /// ```\n    ///\n    /// Any excess capacity is removed:\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    /// vec.extend([1, 2, 3].iter().cloned());\n    ///\n    /// assert_eq!(vec.capacity(), 10);\n    /// let slice = vec.into_boxed_slice();\n    /// assert_eq!(slice.into_vec().capacity(), 3);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_boxed_slice(mut self) -> Box<[T]> {\n}\n\n    /// Shortens the vector, keeping the first `len` elements and dropping\n    /// the rest.\n    ///\n    /// If `len` is greater than the vector's current length, this has no\n    /// effect.\n    ///\n    /// The [`drain`] method can emulate `truncate`, but causes the excess\n    /// elements to be returned instead of dropped.\n    ///\n    /// Note that this method has no effect on the allocated capacity\n    /// of the vector.\n    ///\n    /// # Examples\n    ///\n    /// Truncating a five element vector to two elements:\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3, 4, 5];\n    /// vec.truncate(2);\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    ///\n    /// No truncation occurs when `len` is greater than the vector's current\n    /// length:\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.truncate(8);\n    /// assert_eq!(vec, [1, 2, 3]);\n    /// ```\n    ///\n    /// Truncating when `len == 0` is equivalent to calling the [`clear`]\n    /// method.\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.truncate(0);\n    /// assert_eq!(vec, []);\n    /// ```\n    ///\n    /// [`clear`]: #method.clear\n    /// [`drain`]: #method.drain\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn truncate(&mut self, len: usize) {\n}\n\n    /// Extracts a slice containing the entire vector.\n    ///\n    /// Equivalent to `&s[..]`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Write};\n    /// let buffer = vec![1, 2, 3, 5, 8];\n    /// io::sink().write(buffer.as_slice()).unwrap();\n    /// ```\n    #[inline]\n    #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n    pub fn as_slice(&self) -> &[T] {\n}\n\n    /// Extracts a mutable slice of the entire vector.\n    ///\n    /// Equivalent to `&mut s[..]`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Read};\n    /// let mut buffer = vec![0; 3];\n    /// io::repeat(0b101).read_exact(buffer.as_mut_slice()).unwrap();\n    /// ```\n    #[inline]\n    #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n}\n\n    /// Returns a raw pointer to the vector's buffer.\n    ///\n    /// The caller must ensure that the vector outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    /// Modifying the vector may cause its buffer to be reallocated,\n    /// which would also make any pointers to it invalid.\n    ///\n    /// The caller must also ensure that the memory the pointer (non-transitively) points to\n    /// is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n    /// derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = vec![1, 2, 4];\n    /// let x_ptr = x.as_ptr();\n    ///\n    /// unsafe {\n    ///     for i in 0..x.len() {\n    ///         assert_eq!(*x_ptr.add(i), 1 << i);\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`as_mut_ptr`]: #method.as_mut_ptr\n    #[stable(feature = \"vec_as_ptr\", since = \"1.37.0\")]\n    #[inline]\n    pub fn as_ptr(&self) -> *const T {\n}\n\n    /// Returns an unsafe mutable pointer to the vector's buffer.\n    ///\n    /// The caller must ensure that the vector outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    /// Modifying the vector may cause its buffer to be reallocated,\n    /// which would also make any pointers to it invalid.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// // Allocate vector big enough for 4 elements.\n    /// let size = 4;\n    /// let mut x: Vec<i32> = Vec::with_capacity(size);\n    /// let x_ptr = x.as_mut_ptr();\n    ///\n    /// // Initialize elements via raw pointer writes, then set length.\n    /// unsafe {\n    ///     for i in 0..size {\n    ///         *x_ptr.add(i) = i as i32;\n    ///     }\n    ///     x.set_len(size);\n    /// }\n    /// assert_eq!(&*x, &[0,1,2,3]);\n    /// ```\n    #[stable(feature = \"vec_as_ptr\", since = \"1.37.0\")]\n    #[inline]\n    pub fn as_mut_ptr(&mut self) -> *mut T {\n}\n\n    /// Forces the length of the vector to `new_len`.\n    ///\n    /// This is a low-level operation that maintains none of the normal\n    /// invariants of the type. Normally changing the length of a vector\n    /// is done using one of the safe operations instead, such as\n    /// [`truncate`], [`resize`], [`extend`], or [`clear`].\n    ///\n    /// [`truncate`]: #method.truncate\n    /// [`resize`]: #method.resize\n    /// [`extend`]: ../../std/iter/trait.Extend.html#tymethod.extend\n    /// [`clear`]: #method.clear\n    ///\n    /// # Safety\n    ///\n    /// - `new_len` must be less than or equal to [`capacity()`].\n    /// - The elements at `old_len..new_len` must be initialized.\n    ///\n    /// [`capacity()`]: #method.capacity\n    ///\n    /// # Examples\n    ///\n    /// This method can be useful for situations in which the vector\n    /// is serving as a buffer for other code, particularly over FFI:\n    ///\n    /// ```no_run\n    /// # #![allow(dead_code)]\n    /// # // This is just a minimal skeleton for the doc example;\n    /// # // don't use this as a starting point for a real library.\n    /// # pub struct StreamWrapper { strm: *mut std::ffi::c_void }\n    /// # const Z_OK: i32 = 0;\n    /// # extern \"C\" {\n    /// #     fn deflateGetDictionary(\n    /// #         strm: *mut std::ffi::c_void,\n    /// #         dictionary: *mut u8,\n    /// #         dictLength: *mut usize,\n    /// #     ) -> i32;\n    /// # }\n    /// # impl StreamWrapper {\n    /// pub fn get_dictionary(&self) -> Option<Vec<u8>> {\n    ///     // Per the FFI method's docs, \"32768 bytes is always enough\".\n    ///     let mut dict = Vec::with_capacity(32_768);\n    ///     let mut dict_length = 0;\n    ///     // SAFETY: When `deflateGetDictionary` returns `Z_OK`, it holds that:\n    ///     // 1. `dict_length` elements were initialized.\n    ///     // 2. `dict_length` <= the capacity (32_768)\n    ///     // which makes `set_len` safe to call.\n    ///     unsafe {\n    ///         // Make the FFI call...\n    ///         let r = deflateGetDictionary(self.strm, dict.as_mut_ptr(), &mut dict_length);\n    ///         if r == Z_OK {\n    ///             // ...and update the length to what was initialized.\n    ///             dict.set_len(dict_length);\n    ///             Some(dict)\n    ///         } else {\n    ///             None\n    ///         }\n    ///     }\n    /// }\n    /// # }\n    /// ```\n    ///\n    /// While the following example is sound, there is a memory leak since\n    /// the inner vectors were not freed prior to the `set_len` call:\n    ///\n    /// ```\n    /// let mut vec = vec![vec![1, 0, 0],\n    ///                    vec![0, 1, 0],\n    ///                    vec![0, 0, 1]];\n    /// // SAFETY:\n    /// // 1. `old_len..0` is empty so no elements need to be initialized.\n    /// // 2. `0 <= capacity` always holds whatever `capacity` is.\n    /// unsafe {\n    ///     vec.set_len(0);\n    /// }\n    /// ```\n    ///\n    /// Normally, here, one would use [`clear`] instead to correctly drop\n    /// the contents and thus not leak memory.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn set_len(&mut self, new_len: usize) {\n}\n\n    /// Removes an element from the vector and returns it.\n    ///\n    /// The removed element is replaced by the last element of the vector.\n    ///\n    /// This does not preserve ordering, but is O(1).\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index` is out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n    ///\n    /// assert_eq!(v.swap_remove(1), \"bar\");\n    /// assert_eq!(v, [\"foo\", \"qux\", \"baz\"]);\n    ///\n    /// assert_eq!(v.swap_remove(0), \"foo\");\n    /// assert_eq!(v, [\"baz\", \"qux\"]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn swap_remove(&mut self, index: usize) -> T {\n}\n\n    /// Inserts an element at position `index` within the vector, shifting all\n    /// elements after it to the right.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.insert(1, 4);\n    /// assert_eq!(vec, [1, 4, 2, 3]);\n    /// vec.insert(4, 5);\n    /// assert_eq!(vec, [1, 4, 2, 3, 5]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, index: usize, element: T) {\n}\n\n    /// Removes and returns the element at position `index` within the vector,\n    /// shifting all elements after it to the left.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index` is out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    /// assert_eq!(v.remove(1), 2);\n    /// assert_eq!(v, [1, 3]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn remove(&mut self, index: usize) -> T {\n}\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n    /// This method operates in place, visiting each element exactly once in the\n    /// original order, and preserves the order of the retained elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.retain(|&x| x % 2 == 0);\n    /// assert_eq!(vec, [2, 4]);\n    /// ```\n    ///\n    /// The exact order may be useful for tracking external state, like an index.\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3, 4, 5];\n    /// let keep = [false, true, true, false, true];\n    /// let mut i = 0;\n    /// vec.retain(|_| (keep[i], i += 1).0);\n    /// assert_eq!(vec, [2, 3, 5]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> bool,\n    {\n}\n\n    /// Removes all but the first of consecutive elements in the vector that resolve to the same\n    /// key.\n    ///\n    /// If the vector is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![10, 20, 21, 30, 20];\n    ///\n    /// vec.dedup_by_key(|i| *i / 10);\n    ///\n    /// assert_eq!(vec, [10, 20, 30, 20]);\n    /// ```\n    #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n    #[inline]\n    pub fn dedup_by_key<F, K>(&mut self, mut key: F)\n    where\n        F: FnMut(&mut T) -> K,\n        K: PartialEq,\n    {\n}\n\n    /// Removes all but the first of consecutive elements in the vector satisfying a given equality\n    /// relation.\n    ///\n    /// The `same_bucket` function is passed references to two elements from the vector and\n    /// must determine if the elements compare equal. The elements are passed in opposite order\n    /// from their order in the slice, so if `same_bucket(a, b)` returns `true`, `a` is removed.\n    ///\n    /// If the vector is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n    ///\n    /// vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n    ///\n    /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n    /// ```\n    #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n    pub fn dedup_by<F>(&mut self, same_bucket: F)\n    where\n        F: FnMut(&mut T, &mut T) -> bool,\n    {\n}\n\n    /// Appends an element to the back of a collection.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the number of elements in the vector overflows a `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2];\n    /// vec.push(3);\n    /// assert_eq!(vec, [1, 2, 3]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push(&mut self, value: T) {\n}\n\n    /// Removes the last element from a vector and returns it, or [`None`] if it\n    /// is empty.\n    ///\n    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// assert_eq!(vec.pop(), Some(3));\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop(&mut self) -> Option<T> {\n}\n\n    /// Moves all the elements of `other` into `Self`, leaving `other` empty.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the number of elements in the vector overflows a `usize`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// let mut vec2 = vec![4, 5, 6];\n    /// vec.append(&mut vec2);\n    /// assert_eq!(vec, [1, 2, 3, 4, 5, 6]);\n    /// assert_eq!(vec2, []);\n    /// ```\n    #[inline]\n    #[stable(feature = \"append\", since = \"1.4.0\")]\n    pub fn append(&mut self, other: &mut Self) {\n}\n\n    /// Appends elements to `Self` from other buffer.\n    #[inline]\n    unsafe fn append_elements(&mut self, other: *const [T]) {\n}\n\n    /// Creates a draining iterator that removes the specified range in the vector\n    /// and yields the removed items.\n    ///\n    /// Note 1: The element range is removed even if the iterator is only\n    /// partially consumed or not consumed at all.\n    ///\n    /// Note 2: It is unspecified how many elements are removed from the vector\n    /// if the `Drain` value is leaked.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    /// let u: Vec<_> = v.drain(1..).collect();\n    /// assert_eq!(v, &[1]);\n    /// assert_eq!(u, &[2, 3]);\n    ///\n    /// // A full range clears the vector\n    /// v.drain(..);\n    /// assert_eq!(v, &[]);\n    /// ```\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain<R>(&mut self, range: R) -> Drain<'_, T>\n    where\n        R: RangeBounds<usize>,\n    {\n}\n\n    /// Clears the vector, removing all values.\n    ///\n    /// Note that this method has no effect on the allocated capacity\n    /// of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    ///\n    /// v.clear();\n    ///\n    /// assert!(v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n}\n\n    /// Returns the number of elements in the vector, also referred to\n    /// as its 'length'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = vec![1, 2, 3];\n    /// assert_eq!(a.len(), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n}\n\n    /// Returns `true` if the vector contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = Vec::new();\n    /// assert!(v.is_empty());\n    ///\n    /// v.push(1);\n    /// assert!(!v.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n}\n\n    /// Splits the collection into two at the given index.\n    ///\n    /// Returns a newly allocated vector containing the elements in the range\n    /// `[at, len)`. After the call, the original vector will be left containing\n    /// the elements `[0, at)` with its previous capacity unchanged.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1,2,3];\n    /// let vec2 = vec.split_off(1);\n    /// assert_eq!(vec, [1]);\n    /// assert_eq!(vec2, [2, 3]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"split_off\", since = \"1.4.0\")]\n    pub fn split_off(&mut self, at: usize) -> Self {\n}\n\n    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n    ///\n    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n    /// difference, with each additional slot filled with the result of\n    /// calling the closure `f`. The return values from `f` will end up\n    /// in the `Vec` in the order they have been generated.\n    ///\n    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n    ///\n    /// This method uses a closure to create new values on every push. If\n    /// you'd rather [`Clone`] a given value, use [`resize`]. If you want\n    /// to use the [`Default`] trait to generate values, you can pass\n    /// [`Default::default()`] as the second argument.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.resize_with(5, Default::default);\n    /// assert_eq!(vec, [1, 2, 3, 0, 0]);\n    ///\n    /// let mut vec = vec![];\n    /// let mut p = 1;\n    /// vec.resize_with(4, || { p *= 2; p });\n    /// assert_eq!(vec, [2, 4, 8, 16]);\n    /// ```\n    ///\n    /// [`resize`]: #method.resize\n    /// [`Clone`]: ../../std/clone/trait.Clone.html\n    #[stable(feature = \"vec_resize_with\", since = \"1.33.0\")]\n    pub fn resize_with<F>(&mut self, new_len: usize, f: F)\n    where\n        F: FnMut() -> T,\n    {\n}\n\n    /// Consumes and leaks the `Vec`, returning a mutable reference to the contents,\n    /// `&'a mut [T]`. Note that the type `T` must outlive the chosen lifetime\n    /// `'a`. If the type has only static references, or none at all, then this\n    /// may be chosen to be `'static`.\n    ///\n    /// This function is similar to the `leak` function on `Box`.\n    ///\n    /// This function is mainly useful for data that lives for the remainder of\n    /// the program's life. Dropping the returned reference will cause a memory\n    /// leak.\n    ///\n    /// # Examples\n    ///\n    /// Simple usage:\n    ///\n    /// ```\n    /// #![feature(vec_leak)]\n    ///\n    /// let x = vec![1, 2, 3];\n    /// let static_ref: &'static mut [usize] = Vec::leak(x);\n    /// static_ref[0] += 1;\n    /// assert_eq!(static_ref, &[2, 2, 3]);\n    /// ```\n    #[unstable(feature = \"vec_leak\", issue = \"62195\")]\n    #[inline]\n    pub fn leak<'a>(vec: Vec<T>) -> &'a mut [T]\n    where\n        T: 'a, // Technically not needed, but kept to be explicit.\n    {\n}\n}\n\nimpl<T: Clone> Vec<T> {\n    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n    ///\n    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n    /// difference, with each additional slot filled with `value`.\n    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n    ///\n    /// This method requires [`Clone`] to be able clone the passed value. If\n    /// you need more flexibility (or want to rely on [`Default`] instead of\n    /// [`Clone`]), use [`resize_with`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![\"hello\"];\n    /// vec.resize(3, \"world\");\n    /// assert_eq!(vec, [\"hello\", \"world\", \"world\"]);\n    ///\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.resize(2, 0);\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    ///\n    /// [`Clone`]: ../../std/clone/trait.Clone.html\n    /// [`Default`]: ../../std/default/trait.Default.html\n    /// [`resize_with`]: #method.resize_with\n    #[stable(feature = \"vec_resize\", since = \"1.5.0\")]\n    pub fn resize(&mut self, new_len: usize, value: T) {\n}\n\n    /// Clones and appends all elements in a slice to the `Vec`.\n    ///\n    /// Iterates over the slice `other`, clones each element, and then appends\n    /// it to this `Vec`. The `other` vector is traversed in-order.\n    ///\n    /// Note that this function is same as [`extend`] except that it is\n    /// specialized to work with slices instead. If and when Rust gets\n    /// specialization this function will likely be deprecated (but still\n    /// available).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.extend_from_slice(&[2, 3, 4]);\n    /// assert_eq!(vec, [1, 2, 3, 4]);\n    /// ```\n    ///\n    /// [`extend`]: #method.extend\n    #[stable(feature = \"vec_extend_from_slice\", since = \"1.6.0\")]\n    pub fn extend_from_slice(&mut self, other: &[T]) {\n}\n}\n\nimpl<T: Default> Vec<T> {\n    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n    ///\n    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n    /// difference, with each additional slot filled with [`Default::default()`].\n    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n    ///\n    /// This method uses [`Default`] to create new values on every push. If\n    /// you'd rather [`Clone`] a given value, use [`resize`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![allow(deprecated)]\n    /// #![feature(vec_resize_default)]\n    ///\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.resize_default(5);\n    /// assert_eq!(vec, [1, 2, 3, 0, 0]);\n    ///\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.resize_default(2);\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    ///\n    /// [`resize`]: #method.resize\n    /// [`Default::default()`]: ../../std/default/trait.Default.html#tymethod.default\n    /// [`Default`]: ../../std/default/trait.Default.html\n    /// [`Clone`]: ../../std/clone/trait.Clone.html\n    #[unstable(feature = \"vec_resize_default\", issue = \"41758\")]\n    #[rustc_deprecated(\n        reason = \"This is moving towards being removed in favor \\\n        of `.resize_with(Default::default)`.  If you disagree, please comment \\\n        in the tracking issue.\",\n        since = \"1.33.0\"\n    )]\n    pub fn resize_default(&mut self, new_len: usize) {\n}\n}\n\n// This code generalises `extend_with_{element,default}`.\ntrait ExtendWith<T> {\n    fn next(&mut self) -> T;\n    fn last(self) -> T;\n}\n\nstruct ExtendElement<T>(T);\nimpl<T: Clone> ExtendWith<T> for ExtendElement<T> {\n    fn next(&mut self) -> T {\n}\n    fn last(self) -> T {\n}\n}\n\nstruct ExtendDefault;\nimpl<T: Default> ExtendWith<T> for ExtendDefault {\n    fn next(&mut self) -> T {\n}\n    fn last(self) -> T {\n}\n}\n\nstruct ExtendFunc<F>(F);\nimpl<T, F: FnMut() -> T> ExtendWith<T> for ExtendFunc<F> {\n    fn next(&mut self) -> T {\n}\n    fn last(mut self) -> T {\n}\n}\n\nimpl<T> Vec<T> {\n    /// Extend the vector by `n` values, using the given generator.\n    fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, mut value: E) {\n}\n}\n\n// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n//\n// The idea is: The length field in SetLenOnDrop is a local variable\n// that the optimizer will see does not alias with any stores through the Vec's data\n// pointer. This is a workaround for alias analysis issue #32155\nstruct SetLenOnDrop<'a> {\n    len: &'a mut usize,\n    local_len: usize,\n}\n\nimpl<'a> SetLenOnDrop<'a> {\n    #[inline]\n    fn new(len: &'a mut usize) -> Self {\n}\n\n    #[inline]\n    fn increment_len(&mut self, increment: usize) {\n}\n}\n\nimpl Drop for SetLenOnDrop<'_> {\n    #[inline]\n    fn drop(&mut self) {\n}\n}\n\nimpl<T: PartialEq> Vec<T> {\n    /// Removes consecutive repeated elements in the vector according to the\n    /// [`PartialEq`] trait implementation.\n    ///\n    /// If the vector is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 2, 3, 2];\n    ///\n    /// vec.dedup();\n    ///\n    /// assert_eq!(vec, [1, 2, 3, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn dedup(&mut self) {\n}\n}\n\nimpl<T> Vec<T> {\n    /// Removes the first instance of `item` from the vector if the item exists.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![feature(vec_remove_item)]\n    /// let mut vec = vec![1, 2, 3, 1];\n    ///\n    /// vec.remove_item(&1);\n    ///\n    /// assert_eq!(vec, vec![2, 3, 1]);\n    /// ```\n    #[unstable(feature = \"vec_remove_item\", reason = \"recently added\", issue = \"40062\")]\n    pub fn remove_item<V>(&mut self, item: &V) -> Option<T>\n    where\n        T: PartialEq<V>,\n    {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Internal methods and functions\n////////////////////////////////////////////////////////////////////////////////\n\n#[doc(hidden)]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n}\n\n// Specialization trait used for Vec::from_elem\ntrait SpecFromElem: Sized {\n    fn from_elem(elem: Self, n: usize) -> Vec<Self>;\n}\n\nimpl<T: Clone> SpecFromElem for T {\n    default fn from_elem(elem: Self, n: usize) -> Vec<Self> {\n}\n}\n\nimpl SpecFromElem for u8 {\n    #[inline]\n    fn from_elem(elem: u8, n: usize) -> Vec<u8> {\n}\n}\n\nimpl<T: Clone + IsZero> SpecFromElem for T {\n    #[inline]\n    fn from_elem(elem: T, n: usize) -> Vec<T> {\n}\n}\n\nunsafe trait IsZero {\n    /// Whether this value is zero\n    fn is_zero(&self) -> bool;\n}\n\nmacro_rules! impl_is_zero {\n    ($t: ty, $is_zero: expr) => {\n        unsafe impl IsZero for $t {\n            #[inline]\n            fn is_zero(&self) -> bool {\n}\n        }\n    };\n}\n\nimpl_is_zero!(i8, |x| x == 0);\nimpl_is_zero!(i16, |x| x == 0);\nimpl_is_zero!(i32, |x| x == 0);\nimpl_is_zero!(i64, |x| x == 0);\nimpl_is_zero!(i128, |x| x == 0);\nimpl_is_zero!(isize, |x| x == 0);\n\nimpl_is_zero!(u16, |x| x == 0);\nimpl_is_zero!(u32, |x| x == 0);\nimpl_is_zero!(u64, |x| x == 0);\nimpl_is_zero!(u128, |x| x == 0);\nimpl_is_zero!(usize, |x| x == 0);\n\nimpl_is_zero!(bool, |x| x == false);\nimpl_is_zero!(char, |x| x == '\\0');\n\nimpl_is_zero!(f32, |x: f32| x.to_bits() == 0);\nimpl_is_zero!(f64, |x: f64| x.to_bits() == 0);\n\nunsafe impl<T> IsZero for *const T {\n    #[inline]\n    fn is_zero(&self) -> bool {\n}\n}\n\nunsafe impl<T> IsZero for *mut T {\n    #[inline]\n    fn is_zero(&self) -> bool {\n}\n}\n\n// `Option<&T>`, `Option<&mut T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n// For fat pointers, the bytes that would be the pointer metadata in the `Some` variant\n// are padding in the `None` variant, so ignoring them and zero-initializing instead is ok.\n\nunsafe impl<T: ?Sized> IsZero for Option<&T> {\n    #[inline]\n    fn is_zero(&self) -> bool {\n}\n}\n\nunsafe impl<T: ?Sized> IsZero for Option<&mut T> {\n    #[inline]\n    fn is_zero(&self) -> bool {\n}\n}\n\nunsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n    #[inline]\n    fn is_zero(&self) -> bool {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Common trait implementations for Vec\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> Clone for Vec<T> {\n    #[cfg(not(test))]\n    fn clone(&self) -> Vec<T> {\n}\n\n    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n    // required for this method definition, is not available. Instead use the\n    // `slice::to_vec`  function which is only available with cfg(test)\n    // NB see the slice::hack module in slice.rs for more information\n    #[cfg(test)]\n    fn clone(&self) -> Vec<T> {\n}\n\n    fn clone_from(&mut self, other: &Vec<T>) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Hash> Hash for Vec<T> {\n    #[inline]\n    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"vector indices are of type `usize` or ranges of `usize`\",\n    label = \"vector indices are of type `usize` or ranges of `usize`\"\n)]\nimpl<T, I: SliceIndex<[T]>> Index<I> for Vec<T> {\n    type Output = I::Output;\n\n    #[inline]\n    fn index(&self, index: I) -> &Self::Output {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"vector indices are of type `usize` or ranges of `usize`\",\n    label = \"vector indices are of type `usize` or ranges of `usize`\"\n)]\nimpl<T, I: SliceIndex<[T]>> IndexMut<I> for Vec<T> {\n    #[inline]\n    fn index_mut(&mut self, index: I) -> &mut Self::Output {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::Deref for Vec<T> {\n    type Target = [T];\n\n    fn deref(&self) -> &[T] {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ops::DerefMut for Vec<T> {\n    fn deref_mut(&mut self) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> FromIterator<T> for Vec<T> {\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Vec<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> IntoIterator for Vec<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    /// Creates a consuming iterator, that is, one that moves each value out of\n    /// the vector (from start to end). The vector cannot be used after calling\n    /// this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n    /// for s in v.into_iter() {\n    ///     // s has type String, not &String\n    ///     println!(\"{}\", s);\n    /// }\n    /// ```\n    #[inline]\n    fn into_iter(mut self) -> IntoIter<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a Vec<T> {\n    type Item = &'a T;\n    type IntoIter = slice::Iter<'a, T>;\n\n    fn into_iter(self) -> slice::Iter<'a, T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> IntoIterator for &'a mut Vec<T> {\n    type Item = &'a mut T;\n    type IntoIter = slice::IterMut<'a, T>;\n\n    fn into_iter(self) -> slice::IterMut<'a, T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Extend<T> for Vec<T> {\n    #[inline]\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n}\n}\n\n// Specialization trait used for Vec::from_iter and Vec::extend\ntrait SpecExtend<T, I> {\n    fn from_iter(iter: I) -> Self;\n    fn spec_extend(&mut self, iter: I);\n}\n\nimpl<T, I> SpecExtend<T, I> for Vec<T>\nwhere\n    I: Iterator<Item = T>,\n{\n    default fn from_iter(mut iterator: I) -> Self {\n}\n\n    default fn spec_extend(&mut self, iter: I) {\n}\n}\n\nimpl<T, I> SpecExtend<T, I> for Vec<T>\nwhere\n    I: TrustedLen<Item = T>,\n{\n    default fn from_iter(iterator: I) -> Self {\n}\n\n    default fn spec_extend(&mut self, iterator: I) {\n}\n}\n\nimpl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n    fn from_iter(iterator: IntoIter<T>) -> Self {\n}\n\n    fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n}\n}\n\nimpl<'a, T: 'a, I> SpecExtend<&'a T, I> for Vec<T>\nwhere\n    I: Iterator<Item = &'a T>,\n    T: Clone,\n{\n    default fn from_iter(iterator: I) -> Self {\n}\n\n    default fn spec_extend(&mut self, iterator: I) {\n}\n}\n\nimpl<'a, T: 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T>\nwhere\n    T: Copy,\n{\n    fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n}\n}\n\nimpl<T> Vec<T> {\n    fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n}\n\n    /// Creates a splicing iterator that replaces the specified range in the vector\n    /// with the given `replace_with` iterator and yields the removed items.\n    /// `replace_with` does not need to be the same length as `range`.\n    ///\n    /// The element range is removed even if the iterator is not consumed until the end.\n    ///\n    /// It is unspecified how many elements are removed from the vector\n    /// if the `Splice` value is leaked.\n    ///\n    /// The input iterator `replace_with` is only consumed when the `Splice` value is dropped.\n    ///\n    /// This is optimal if:\n    ///\n    /// * The tail (elements in the vector after `range`) is empty,\n    /// * or `replace_with` yields fewer elements than `range`’s length\n    /// * or the lower bound of its `size_hint()` is exact.\n    ///\n    /// Otherwise, a temporary vector is allocated and the tail is moved twice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    /// let new = [7, 8];\n    /// let u: Vec<_> = v.splice(..2, new.iter().cloned()).collect();\n    /// assert_eq!(v, &[7, 8, 3]);\n    /// assert_eq!(u, &[1, 2]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter>\n    where\n        R: RangeBounds<usize>,\n        I: IntoIterator<Item = T>,\n    {\n}\n\n    /// Creates an iterator which uses a closure to determine if an element should be removed.\n    ///\n    /// If the closure returns true, then the element is removed and yielded.\n    /// If the closure returns false, the element will remain in the vector and will not be yielded\n    /// by the iterator.\n    ///\n    /// Using this method is equivalent to the following code:\n    ///\n    /// ```\n    /// # let some_predicate = |x: &mut i32| { *x == 2 || *x == 3 || *x == 6 };\n    /// # let mut vec = vec![1, 2, 3, 4, 5, 6];\n    /// let mut i = 0;\n    /// while i != vec.len() {\n    ///     if some_predicate(&mut vec[i]) {\n    ///         let val = vec.remove(i);\n    ///         // your code here\n    ///     } else {\n    ///         i += 1;\n    ///     }\n    /// }\n    ///\n    /// # assert_eq!(vec, vec![1, 4, 5]);\n    /// ```\n    ///\n    /// But `drain_filter` is easier to use. `drain_filter` is also more efficient,\n    /// because it can backshift the elements of the array in bulk.\n    ///\n    /// Note that `drain_filter` also lets you mutate every element in the filter closure,\n    /// regardless of whether you choose to keep or remove it.\n    ///\n    ///\n    /// # Examples\n    ///\n    /// Splitting an array into evens and odds, reusing the original allocation:\n    ///\n    /// ```\n    /// #![feature(drain_filter)]\n    /// let mut numbers = vec![1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15];\n    ///\n    /// let evens = numbers.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n    /// let odds = numbers;\n    ///\n    /// assert_eq!(evens, vec![2, 4, 6, 8, 14]);\n    /// assert_eq!(odds, vec![1, 3, 5, 9, 11, 13, 15]);\n    /// ```\n    #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F>\n    where\n        F: FnMut(&mut T) -> bool,\n    {\n}\n}\n\n/// Extend implementation that copies elements out of references before pushing them onto the Vec.\n///\n/// This implementation is specialized for slice iterators, where it uses [`copy_from_slice`] to\n/// append the entire slice at once.\n///\n/// [`copy_from_slice`]: ../../std/primitive.slice.html#method.copy_from_slice\n#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\nimpl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n}\n}\n\nmacro_rules! __impl_slice_eq1 {\n    ([$($vars:tt)*] $lhs:ty, $rhs:ty, $($constraints:tt)*) => {\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<A, B, $($vars)*> PartialEq<$rhs> for $lhs\n        where\n            A: PartialEq<B>,\n            $($constraints)*\n        {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool { }\n            #[inline]\n            fn ne(&self, other: &$rhs) -> bool { }\n        }\n    }\n}\n\n__impl_slice_eq1! { [] Vec<A>, Vec<B>, }\n__impl_slice_eq1! { [] Vec<A>, &[B], }\n__impl_slice_eq1! { [] Vec<A>, &mut [B], }\n__impl_slice_eq1! { [] Cow<'_, [A]>, &[B], A: Clone }\n__impl_slice_eq1! { [] Cow<'_, [A]>, &mut [B], A: Clone }\n__impl_slice_eq1! { [] Cow<'_, [A]>, Vec<B>, A: Clone }\n__impl_slice_eq1! { [const N: usize] Vec<A>, [B; N], [B; N]: LengthAtMost32 }\n__impl_slice_eq1! { [const N: usize] Vec<A>, &[B; N], [B; N]: LengthAtMost32 }\n\n// NOTE: some less important impls are omitted to reduce code bloat\n// FIXME(Centril): Reconsider this?\n//__impl_slice_eq1! { [const N: usize] Vec<A>, &mut [B; N], [B; N]: LengthAtMost32 }\n//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, [B; N], [B; N]: LengthAtMost32 }\n//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &[B; N], [B; N]: LengthAtMost32 }\n//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &mut [B; N], [B; N]: LengthAtMost32 }\n\n/// Implements comparison of vectors, lexicographically.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: PartialOrd> PartialOrd for Vec<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Vec<T>) -> Option<Ordering> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Eq> Eq for Vec<T> {}\n\n/// Implements ordering of vectors, lexicographically.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord> Ord for Vec<T> {\n    #[inline]\n    fn cmp(&self, other: &Vec<T>) -> Ordering {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T> Drop for Vec<T> {\n    fn drop(&mut self) {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for Vec<T> {\n    /// Creates an empty `Vec<T>`.\n    fn default() -> Vec<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug> fmt::Debug for Vec<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsRef<Vec<T>> for Vec<T> {\n    fn as_ref(&self) -> &Vec<T> {\n}\n}\n\n#[stable(feature = \"vec_as_mut\", since = \"1.5.0\")]\nimpl<T> AsMut<Vec<T>> for Vec<T> {\n    fn as_mut(&mut self) -> &mut Vec<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> AsRef<[T]> for Vec<T> {\n    fn as_ref(&self) -> &[T] {\n}\n}\n\n#[stable(feature = \"vec_as_mut\", since = \"1.5.0\")]\nimpl<T> AsMut<[T]> for Vec<T> {\n    fn as_mut(&mut self) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> From<&[T]> for Vec<T> {\n    #[cfg(not(test))]\n    fn from(s: &[T]) -> Vec<T> {\n}\n    #[cfg(test)]\n    fn from(s: &[T]) -> Vec<T> {\n}\n}\n\n#[stable(feature = \"vec_from_mut\", since = \"1.19.0\")]\nimpl<T: Clone> From<&mut [T]> for Vec<T> {\n    #[cfg(not(test))]\n    fn from(s: &mut [T]) -> Vec<T> {\n}\n    #[cfg(test)]\n    fn from(s: &mut [T]) -> Vec<T> {\n}\n}\n\n#[stable(feature = \"vec_from_cow_slice\", since = \"1.14.0\")]\nimpl<'a, T> From<Cow<'a, [T]>> for Vec<T>\nwhere\n    [T]: ToOwned<Owned = Vec<T>>,\n{\n    fn from(s: Cow<'a, [T]>) -> Vec<T> {\n}\n}\n\n// note: test pulls in libstd, which causes errors here\n#[cfg(not(test))]\n#[stable(feature = \"vec_from_box\", since = \"1.18.0\")]\nimpl<T> From<Box<[T]>> for Vec<T> {\n    fn from(s: Box<[T]>) -> Vec<T> {\n}\n}\n\n// note: test pulls in libstd, which causes errors here\n#[cfg(not(test))]\n#[stable(feature = \"box_from_vec\", since = \"1.20.0\")]\nimpl<T> From<Vec<T>> for Box<[T]> {\n    fn from(v: Vec<T>) -> Box<[T]> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<&str> for Vec<u8> {\n    fn from(s: &str) -> Vec<u8> {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Clone-on-write\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\nimpl<'a, T: Clone> From<&'a [T]> for Cow<'a, [T]> {\n    fn from(s: &'a [T]) -> Cow<'a, [T]> {\n}\n}\n\n#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\nimpl<'a, T: Clone> From<Vec<T>> for Cow<'a, [T]> {\n    fn from(v: Vec<T>) -> Cow<'a, [T]> {\n}\n}\n\n#[stable(feature = \"cow_from_vec_ref\", since = \"1.28.0\")]\nimpl<'a, T: Clone> From<&'a Vec<T>> for Cow<'a, [T]> {\n    fn from(v: &'a Vec<T>) -> Cow<'a, [T]> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T> FromIterator<T> for Cow<'a, [T]>\nwhere\n    T: Clone,\n{\n    fn from_iter<I: IntoIterator<Item = T>>(it: I) -> Cow<'a, [T]> {\n}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Iterators\n////////////////////////////////////////////////////////////////////////////////\n\n/// An iterator that moves out of a vector.\n///\n/// This `struct` is created by the `into_iter` method on [`Vec`] (provided\n/// by the [`IntoIterator`] trait).\n///\n/// [`Vec`]: struct.Vec.html\n/// [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub struct IntoIter<T> {\n    buf: NonNull<T>,\n    phantom: PhantomData<T>,\n    cap: usize,\n    ptr: *const T,\n    end: *const T,\n}\n\n#[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\nimpl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl<T> IntoIter<T> {\n    /// Returns the remaining items of this iterator as a slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let vec = vec!['a', 'b', 'c'];\n    /// let mut into_iter = vec.into_iter();\n    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n    /// let _ = into_iter.next().unwrap();\n    /// assert_eq!(into_iter.as_slice(), &['b', 'c']);\n    /// ```\n    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n    pub fn as_slice(&self) -> &[T] {\n}\n\n    /// Returns the remaining items of this iterator as a mutable slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let vec = vec!['a', 'b', 'c'];\n    /// let mut into_iter = vec.into_iter();\n    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n    /// into_iter.as_mut_slice()[2] = 'z';\n    /// assert_eq!(into_iter.next().unwrap(), 'a');\n    /// assert_eq!(into_iter.next().unwrap(), 'b');\n    /// assert_eq!(into_iter.next().unwrap(), 'z');\n    /// ```\n    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Send> Send for IntoIter<T> {}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<T: Sync> Sync for IntoIter<T> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n}\n\n    #[inline]\n    fn size_hint(&self) -> (usize, Option<usize>) {\n}\n\n    #[inline]\n    fn count(self) -> usize {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n}\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> ExactSizeIterator for IntoIter<T> {\n    fn is_empty(&self) -> bool {\n}\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T> FusedIterator for IntoIter<T> {}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T> TrustedLen for IntoIter<T> {}}\n\n#[cfg(not(test))]\nmod std {\n    pub use core::ops; // RangeFull\n}\n\n#[doc(hidden)]\n#[unstable(feature = \"liballoc_internals\", issue = \"none\", reason = \"implementation detail\")]\npub mod __export {\n}\n"],[4,"#[macro_use]\nextern crate syn;\n\nuse proc_macro::TokenStream;\nuse std::str::FromStr;\n\n/// This attribute macro generates the boilerplate required to call into the\n/// contract-specific logic from the entry-points to the Wasm module.\n///\n/// It should be added to the contract's init, handle, migrate and query implementations\n/// like this:\n/// ```\n/// # use cosmwasm_std::{\n/// #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo,\n/// #     Response, QueryResponse,\n/// # };\n/// #\n/// # type InstantiateMsg = ();\n/// # type ExecuteMsg = ();\n/// # type QueryMsg = ();\n///\n/// #[entry_point]\n/// pub fn instantiate(\n///     deps: DepsMut,\n///     env: Env,\n///     info: MessageInfo,\n///     msg: InstantiateMsg,\n/// ) -> Result<Response, StdError> {\n/// #   Ok(Default::default())\n/// }\n///\n/// #[entry_point]\n/// pub fn execute(\n///     deps: DepsMut,\n///     env: Env,\n///     info: MessageInfo,\n///     msg: ExecuteMsg,\n/// ) -> Result<Response, StdError> {\n/// #   Ok(Default::default())\n/// }\n///\n/// #[entry_point]\n/// pub fn query(\n///     deps: Deps,\n///     env: Env,\n///     msg: QueryMsg,\n/// ) -> Result<QueryResponse, StdError> {\n/// #   Ok(Default::default())\n/// }\n/// ```\n///\n/// where `InstantiateMsg`, `ExecuteMsg`, and `QueryMsg` are contract defined\n/// types that implement `DeserializeOwned + JsonSchema`.\n#[proc_macro_attribute]\npub fn entry_point(_attr: TokenStream, mut item: TokenStream) -> TokenStream {\n}\n"],[5,"mod cw_serde {\nuse syn::{parse_quote, DeriveInput};\n\npub fn cw_serde_impl(input: DeriveInput) -> DeriveInput {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod generate_api {\nuse std::collections::BTreeMap;\n\nuse proc_macro2::TokenStream;\nuse quote::quote;\nuse syn::{\n    parse::{Parse, ParseStream},\n    parse_quote, Block, ExprStruct, Ident, Path, Token,\n};\n\npub fn write_api_impl(input: Options) -> Block {\n}\n\npub fn generate_api_impl(input: &Options) -> ExprStruct {\n}\n\n#[derive(Debug)]\nenum Value {\n    Type(syn::Path),\n    Str(syn::LitStr),\n}\n\nimpl Value {\n    fn unwrap_type(self) -> syn::Path {\n}\n\n    fn unwrap_str(self) -> syn::LitStr {\n}\n}\n\nimpl Parse for Value {\n    fn parse(input: ParseStream) -> syn::parse::Result<Self> {\n}\n}\n\n#[derive(Debug)]\nstruct Pair((Ident, Value));\n\nimpl Parse for Pair {\n    fn parse(input: ParseStream) -> syn::parse::Result<Self> {\n}\n}\n\n#[derive(Debug)]\npub struct Options {\n    name: TokenStream,\n    version: TokenStream,\n    instantiate: Path,\n    execute: TokenStream,\n    query: TokenStream,\n    migrate: TokenStream,\n    sudo: TokenStream,\n    responses: TokenStream,\n}\n\nimpl Parse for Options {\n    fn parse(input: ParseStream) -> syn::parse::Result<Self> {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod query_responses {\nmod context {\nuse std::collections::HashSet;\n\nuse syn::{Ident, ItemEnum, Meta, NestedMeta};\n\nconst ATTR_PATH: &str = \"query_responses\";\n\npub struct Context {\n    /// If the enum we're trying to derive QueryResponses for collects other QueryMsgs,\n    /// setting this flag will derive the implementation appropriately, collecting all\n    /// KV pairs from the nested enums rather than expecting `#[return]` annotations.\n    pub is_nested: bool,\n    /// Disable infering the `JsonSchema` trait bound for chosen type parameters.\n    pub no_bounds_for: HashSet<Ident>,\n}\n\npub fn get_context(input: &ItemEnum) -> Context {\n}\n}\n\nuse syn::{\n    parse_quote, Expr, ExprTuple, Generics, ItemEnum, ItemImpl, Type, TypeParamBound, Variant,\n};\n\nuse self::context::Context;\n\npub fn query_responses_derive_impl(input: ItemEnum) -> ItemImpl {\n}\n\n/// Takes a list of generics from the type definition and produces a list of generics\n/// for the expanded `impl` block, adding trait bounds like `JsonSchema` as appropriate.\nfn impl_generics(ctx: &Context, generics: &Generics, bounds: &[TypeParamBound]) -> Generics {\n}\n\n/// Extract the query -> response mapping out of an enum variant.\nfn parse_query(v: Variant) -> (String, Expr) {\n}\n\n/// Extract the nested query  -> response mapping out of an enum variant.\nfn parse_subquery(v: Variant) -> Expr {\n}\n\nfn parse_tuple((q, r): (String, Expr)) -> ExprTuple {\n}\n\nfn to_snake_case(input: &str) -> String {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\n\nuse quote::ToTokens;\nuse syn::{parse_macro_input, DeriveInput, ItemEnum};\n\n#[proc_macro_derive(QueryResponses, attributes(returns, query_responses))]\npub fn query_responses_derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n}\n\n#[proc_macro]\npub fn write_api(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n}\n\n#[proc_macro]\npub fn generate_api(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n}\n\n#[proc_macro_attribute]\npub fn cw_serde(\n    _attr: proc_macro::TokenStream,\n    input: proc_macro::TokenStream,\n) -> proc_macro::TokenStream {\n}\n"],[6,"mod casing {\npub fn to_snake_case(name: &str) -> String {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod export {\n//! Export schema to file\n\nuse std::fs::write;\nuse std::path::Path;\n\nuse schemars::schema::RootSchema;\n\nuse crate::casing::to_snake_case;\n\n// Exports a schema, auto-generating filename based on the metadata title of the generated schema.\npub fn export_schema(schema: &RootSchema, out_dir: &Path) {\n}\n\n// use this if you want to override the auto-detected name of the object.\n// very useful when creating an alias for a type-alias.\npub fn export_schema_with_title(schema: &RootSchema, out_dir: &Path, title: &str) {\n}\n\n/// Writes schema to file. Overwrites existing file.\n/// Panics on any error writing out the schema.\nfn write_schema(schema: &RootSchema, out_dir: &Path, title: &str) {\n}\n}\nmod idl {\n//! The Cosmwasm IDL (Interface Description Language)\n\nuse std::collections::BTreeMap;\n\nuse schemars::schema::RootSchema;\nuse thiserror::Error;\n\n/// The version of the CosmWasm IDL.\n///\n/// Follows Semantic Versioning 2.0.0: <https://semver.org/>\n// To determine if a change is breaking, assume consumers allow unknown fields and bump accordingly.\npub const IDL_VERSION: &str = \"1.0.0\";\n\n/// Rust representation of a contract's API.\npub struct Api {\n    pub contract_name: String,\n    pub contract_version: String,\n    pub instantiate: RootSchema,\n    pub execute: Option<RootSchema>,\n    pub query: Option<RootSchema>,\n    pub migrate: Option<RootSchema>,\n    pub sudo: Option<RootSchema>,\n    /// A mapping of query variants to response types\n    pub responses: Option<BTreeMap<String, RootSchema>>,\n}\n\nimpl Api {\n    pub fn render(self) -> JsonApi {\n}\n}\n\n/// A JSON representation of a contract's API.\n#[derive(serde::Serialize)]\npub struct JsonApi {\n    contract_name: String,\n    contract_version: String,\n    idl_version: String,\n    instantiate: RootSchema,\n    execute: Option<RootSchema>,\n    query: Option<RootSchema>,\n    migrate: Option<RootSchema>,\n    sudo: Option<RootSchema>,\n    responses: Option<BTreeMap<String, RootSchema>>,\n}\n\nimpl JsonApi {\n    pub fn to_string(&self) -> Result<String, EncodeError> {\n}\n\n    pub fn to_schema_files(&self) -> Result<Vec<(String, String)>, EncodeError> {\n}\n\n    pub fn to_writer(&self, writer: impl std::io::Write) -> Result<(), EncodeError> {\n}\n}\n\n#[derive(Error, Debug)]\npub enum EncodeError {\n    #[error(\"{0}\")]\n    JsonError(#[from] serde_json::Error),\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod query_response {\nuse std::collections::{BTreeMap, BTreeSet};\n\nuse schemars::{schema::RootSchema, JsonSchema};\nuse thiserror::Error;\n\npub use cosmwasm_schema_derive::QueryResponses;\n\n/// A trait for tying QueryMsg variants (different contract queries) to their response types.\n/// This is mostly useful for the generated contracted API description when using `cargo schema`.\n///\n/// Using the derive macro is the preferred way of implementing this trait.\n///\n/// # Examples\n/// ```\n/// use cosmwasm_schema::QueryResponses;\n/// use schemars::JsonSchema;\n///\n/// #[derive(JsonSchema)]\n/// struct AccountInfo {\n///     IcqHandle: String,\n/// }\n///\n/// #[derive(JsonSchema, QueryResponses)]\n/// enum QueryMsg {\n///     #[returns(Vec<String>)]\n///     Denoms {},\n///     #[returns(AccountInfo)]\n///     AccountInfo { account: String },\n/// }\n/// ```\n///\n/// You can compose multiple queries using `#[query_responses(nested)]`. This might be useful\n/// together with `#[serde(untagged)]`. If the `nested` flag is set, no `returns` attributes\n/// are necessary on the enum variants. Instead, the response types are collected from the\n/// nested enums.\n///\n/// ```\n/// # use cosmwasm_schema::QueryResponses;\n/// # use schemars::JsonSchema;\n/// #[derive(JsonSchema, QueryResponses)]\n/// #[query_responses(nested)]\n/// #[serde(untagged)]\n/// enum QueryMsg {\n///     MsgA(QueryA),\n///     MsgB(QueryB),\n/// }\n///\n/// #[derive(JsonSchema, QueryResponses)]\n/// enum QueryA {\n///     #[returns(Vec<String>)]\n///     Denoms {},\n/// }\n///\n/// #[derive(JsonSchema, QueryResponses)]\n/// enum QueryB {\n///     #[returns(AccountInfo)]\n///     AccountInfo { account: String },\n/// }\n///\n/// # #[derive(JsonSchema)]\n/// # struct AccountInfo {\n/// #     IcqHandle: String,\n/// # }\n/// ```\npub trait QueryResponses: JsonSchema {\n    fn response_schemas() -> Result<BTreeMap<String, RootSchema>, IntegrityError> {\n}\n\n    fn response_schemas_impl() -> BTreeMap<String, RootSchema>;\n}\n\n/// Combines multiple response schemas into one. Panics if there are name collisions.\n/// Used internally in the implementation of [`QueryResponses`] when using `#[query_responses(nested)]`\npub fn combine_subqueries<const N: usize, T>(\n    subqueries: [BTreeMap<String, RootSchema>; N],\n) -> BTreeMap<String, RootSchema> {\n    let sub_count = subqueries.iter().flatten().count();\n    let map: BTreeMap<_, _> = subqueries.into_iter().flatten().collect();\n    if map.len() != sub_count {\n        panic!(\n            \"name collision in subqueries for {}\",\n            std::any::type_name::<T>()\n        )\n    }\n    map\n}\n\n#[derive(Debug, Error, PartialEq, Eq)]\npub enum IntegrityError {\n    #[error(\"the structure of the QueryMsg schema was unexpected\")]\n    InvalidQueryMsgSchema,\n    #[error(\"external reference in schema found, but they are not supported\")]\n    ExternalReference { reference: String },\n    #[error(\n        \"inconsistent queries - QueryMsg schema has {query_msg:?}, but query responses have {responses:?}\"\n    )]\n    InconsistentQueries {\n        query_msg: BTreeSet<String>,\n        responses: BTreeSet<String>,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod remove {\nuse std::{fs, io, path};\n\nfn is_regular_file(path: &path::Path) -> Result<bool, io::Error> {\n}\n\nfn is_hidden(path: &path::Path) -> bool {\n}\n\nfn is_json(path: &path::Path) -> bool {\n}\n\npub fn remove_schemas(schemas_dir: &path::Path) -> Result<(), io::Error> {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod schema_for {\n/// Generates a [`RootSchema`](crate::schemars::schema::RootSchema) for the given type using default settings.\n///\n/// The type must implement [`JsonSchema`](crate::schemars::JsonSchema).\n///\n/// The schema version is strictly `draft-07`.\n///\n/// # Example\n/// ```\n/// use cosmwasm_schema::schema_for;\n/// use schemars::JsonSchema;\n///\n/// #[derive(JsonSchema)]\n/// struct MyStruct {\n///     foo: i32,\n/// }\n///\n/// let my_schema = schema_for!(MyStruct);\n/// ```\n#[macro_export]\nmacro_rules! schema_for {\n    ($type:ty) => {\n        $crate::schemars::gen::SchemaGenerator::new($crate::schemars::gen::SchemaSettings::draft07()).into_root_schema_for::<$type>()\n    };\n    ($_:expr) => {\n        compile_error!(\"The argument to `schema_for!` is not a type.\")\n    };\n}\n}\n\npub use export::{export_schema, export_schema_with_title};\npub use idl::{Api, IDL_VERSION};\npub use query_response::{combine_subqueries, IntegrityError, QueryResponses};\npub use remove::remove_schemas;\n\n// Re-exports\n/// An attribute macro that annotates types with things they need to be properly (de)serialized\n/// for use in CosmWasm contract messages and/or responses, and also for schema generation.\n///\n/// This derives things like `serde::Serialize` or `schemars::JsonSchema`, makes sure\n/// variants are `snake_case` in the resulting JSON, and so forth.\n///\n/// # Example\n/// ```\n/// use cosmwasm_schema::{cw_serde, QueryResponses};\n///\n/// #[cw_serde]\n/// pub struct InstantiateMsg {\n///     owner: String,\n/// }\n///\n/// #[cw_serde]\n/// #[derive(QueryResponses)]\n/// pub enum QueryMsg {\n///     #[returns(Vec<String>)]\n///     Denoms {},\n///     #[returns(String)]\n///     AccountName { account: String },\n/// }\n/// ```\npub use cosmwasm_schema_derive::cw_serde;\n/// Generates an [`Api`](crate::Api) for the contract. The body describes the message\n/// types exported in the schema and allows setting contract name and version overrides.\n///\n/// The only obligatory field is `instantiate` - to set the InstantiateMsg type.\n///\n/// # Available fields\n/// See [`write_api`](crate::write_api).\n///\n/// # Example\n/// ```\n/// use cosmwasm_schema::{cw_serde, generate_api};\n///\n/// #[cw_serde]\n/// struct InstantiateMsg;\n///\n/// #[cw_serde]\n/// struct MigrateMsg;\n///\n/// let api = generate_api! {\n///     name: \"cw20\",\n///     instantiate: InstantiateMsg,\n///     migrate: MigrateMsg,\n/// }.render();\n/// ```\npub use cosmwasm_schema_derive::generate_api;\n/// Takes care of generating the interface description file for a contract. The body describes\n/// the message types included and allows setting contract name and version overrides.\n///\n/// The only obligatory field is `instantiate` - to set the InstantiateMsg type.\n///\n/// # Available fields\n/// - `name` - contract name, crate name by default\n/// - `version` - contract version, crate version by default\n/// - `instantiate` - instantiate msg type\n/// - `query` - query msg type, empty by default\n/// - `execute` - execute msg type, empty by default\n/// - `migrate` - migrate msg type, empty by default\n/// - `sudo` - sudo msg type, empty by default\n///\n/// # Example\n/// ```\n/// use cosmwasm_schema::{cw_serde, write_api};\n///\n/// #[cw_serde]\n/// struct InstantiateMsg;\n///\n/// #[cw_serde]\n/// struct MigrateMsg;\n///\n/// write_api! {\n///     name: \"cw20\",\n///     instantiate: InstantiateMsg,\n///     migrate: MigrateMsg,\n/// };\n/// ```\npub use cosmwasm_schema_derive::write_api;\n\n// For use in macro expansions\npub use schemars;\npub use serde;\n"],[7,"#![cfg_attr(feature = \"backtraces\", feature(backtrace))]\n\n// Exposed on all platforms\n\nmod addresses {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse sha2::{\n    digest::{Digest, Update},\n    Sha256,\n};\nuse std::borrow::Cow;\nuse std::fmt;\nuse std::ops::Deref;\n\nuse crate::{binary::Binary, HexBinary};\n\n/// A human readable address.\n///\n/// In Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no\n/// assumptions should be made other than being UTF-8 encoded and of reasonable length.\n///\n/// This type represents a validated address. It can be created in the following ways\n/// 1. Use `Addr::unchecked(input)`\n/// 2. Use `let checked: Addr = deps.api.addr_validate(input)?`\n/// 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?`\n/// 4. Deserialize from JSON. This must only be done from JSON that was validated before\n///    such as a contract's state. `Addr` must not be used in messages sent by the user\n///    because this would result in unvalidated instances.\n///\n/// This type is immutable. If you really need to mutate it (Really? Are you sure?), create\n/// a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String`\n/// instance.\n#[derive(\n    Serialize, Deserialize, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, JsonSchema,\n)]\npub struct Addr(String);\n\nimpl Addr {\n    /// Creates a new `Addr` instance from the given input without checking the validity\n    /// of the input. Since `Addr` must always contain valid addresses, the caller is\n    /// responsible for ensuring the input is valid.\n    ///\n    /// Use this in cases where the address was validated before or in test code.\n    /// If you see this in contract code, it should most likely be replaced with\n    /// `let checked: Addr = deps.api.addr_humanize(canonical_addr)?`.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// # use cosmwasm_std::{Addr};\n    /// let address = Addr::unchecked(\"foobar\");\n    /// assert_eq!(address, \"foobar\");\n    /// ```\n    pub fn unchecked(input: impl Into<String>) -> Addr {\n}\n\n    #[inline]\n    pub fn as_str(&self) -> &str {\n}\n\n    /// Returns the UTF-8 encoded address string as a byte array.\n    ///\n    /// This is equivalent to `address.as_str().as_bytes()`.\n    #[inline]\n    pub fn as_bytes(&self) -> &[u8] {\n}\n\n    /// Utility for explicit conversion to `String`.\n    #[inline]\n    pub fn into_string(self) -> String {\n}\n}\n\nimpl fmt::Display for Addr {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\nimpl AsRef<str> for Addr {\n    #[inline]\n    fn as_ref(&self) -> &str {\n}\n}\n\n/// Implement `Addr == &str`\nimpl PartialEq<&str> for Addr {\n    fn eq(&self, rhs: &&str) -> bool {\n}\n}\n\n/// Implement `&str == Addr`\nimpl PartialEq<Addr> for &str {\n    fn eq(&self, rhs: &Addr) -> bool {\n}\n}\n\n/// Implement `Addr == String`\nimpl PartialEq<String> for Addr {\n    fn eq(&self, rhs: &String) -> bool {\n}\n}\n\n/// Implement `String == Addr`\nimpl PartialEq<Addr> for String {\n    fn eq(&self, rhs: &Addr) -> bool {\n}\n}\n\n// Addr->String is a safe conversion.\n// However, the opposite direction is unsafe and must not be implemented.\n\nimpl From<Addr> for String {\n    fn from(addr: Addr) -> Self {\n}\n}\n\nimpl From<&Addr> for String {\n    fn from(addr: &Addr) -> Self {\n}\n}\n\nimpl From<Addr> for Cow<'_, Addr> {\n    fn from(addr: Addr) -> Self {\n}\n}\n\nimpl<'a> From<&'a Addr> for Cow<'a, Addr> {\n    fn from(addr: &'a Addr) -> Self {\n}\n}\n\n/// A blockchain address in its binary form.\n///\n/// The specific implementation is up to the underlying chain and CosmWasm as well as\n/// contracts should not make assumptions on that data. In Ethereum for example, an\n/// `Addr` would contain a user visible address like 0x14d3cc818735723ab86eaf9502376e847a64ddad\n/// and the corresponding `CanonicalAddr` would store the 20 bytes 0x14, 0xD3, ..., 0xAD.\n/// In Cosmos, the bech32 format is used for `Addr`s and the `CanonicalAddr` holds the\n/// encoded bech32 data without the checksum. Typical sizes are 20 bytes for externally\n/// owned addresses and 32 bytes for module addresses (such as x/wasm contract addresses).\n/// That being said, a chain might decide to use any size other than 20 or 32 bytes.\n///\n/// The safe way to obtain a valid `CanonicalAddr` is using `Api::addr_canonicalize`. In\n/// addition to that there are many unsafe ways to convert any binary data into an instance.\n/// So the type shoud be treated as a marker to express the intended data type, not as\n/// a validity guarantee of any sort.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, Hash, JsonSchema)]\npub struct CanonicalAddr(pub Binary);\n\n/// Implement `CanonicalAddr == Binary`\nimpl PartialEq<Binary> for CanonicalAddr {\n    fn eq(&self, rhs: &Binary) -> bool {\n}\n}\n\n/// Implement `Binary == CanonicalAddr`\nimpl PartialEq<CanonicalAddr> for Binary {\n    fn eq(&self, rhs: &CanonicalAddr) -> bool {\n}\n}\n\n/// Implement `CanonicalAddr == HexBinary`\nimpl PartialEq<HexBinary> for CanonicalAddr {\n    fn eq(&self, rhs: &HexBinary) -> bool {\n}\n}\n\n/// Implement `HexBinary == CanonicalAddr`\nimpl PartialEq<CanonicalAddr> for HexBinary {\n    fn eq(&self, rhs: &CanonicalAddr) -> bool {\n}\n}\n\nimpl From<&[u8]> for CanonicalAddr {\n    fn from(source: &[u8]) -> Self {\n}\n}\n\n// Array reference\nimpl<const LENGTH: usize> From<&[u8; LENGTH]> for CanonicalAddr {\n    fn from(source: &[u8; LENGTH]) -> Self {\n}\n}\n\n// Owned array\nimpl<const LENGTH: usize> From<[u8; LENGTH]> for CanonicalAddr {\n    fn from(source: [u8; LENGTH]) -> Self {\n}\n}\n\n// Owned vector -> CanonicalAddr\nimpl From<Vec<u8>> for CanonicalAddr {\n    fn from(source: Vec<u8>) -> Self {\n}\n}\n\n// CanonicalAddr -> Owned vector\nimpl From<CanonicalAddr> for Vec<u8> {\n    fn from(source: CanonicalAddr) -> Vec<u8> {\n}\n}\n\n// Owned Binary -> CanonicalAddr\nimpl From<Binary> for CanonicalAddr {\n    fn from(source: Binary) -> Self {\n}\n}\n\n// CanonicalAddr -> Owned Binary\nimpl From<CanonicalAddr> for Binary {\n    fn from(source: CanonicalAddr) -> Binary {\n}\n}\n\n// Owned HexBinary -> CanonicalAddr\nimpl From<HexBinary> for CanonicalAddr {\n    fn from(source: HexBinary) -> Self {\n}\n}\n\n// CanonicalAddr -> Owned HexBinary\nimpl From<CanonicalAddr> for HexBinary {\n    fn from(source: CanonicalAddr) -> HexBinary {\n}\n}\n\n/// Just like Vec<u8>, CanonicalAddr is a smart pointer to [u8].\n/// This implements `*canonical_address` for us and allows us to\n/// do `&*canonical_address`, returning a `&[u8]` from a `&CanonicalAddr`.\n/// With [deref coercions](https://doc.rust-lang.org/1.22.1/book/first-edition/deref-coercions.html#deref-coercions),\n/// this allows us to use `&canonical_address` whenever a `&[u8]` is required.\nimpl Deref for CanonicalAddr {\n    type Target = [u8];\n\n    fn deref(&self) -> &Self::Target {\n}\n}\n\nimpl CanonicalAddr {\n    pub fn as_slice(&self) -> &[u8] {\n}\n}\n\nimpl fmt::Display for CanonicalAddr {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\n#[derive(Debug)]\npub enum Instantiate2AddressError {\n    /// Checksum must be 32 bytes\n    InvalidChecksumLength,\n    /// Salt must be between 1 and 64 bytes\n    InvalidSaltLength,\n}\n\n/// Creates a contract address using the predictable address format introduced with\n/// wasmd 0.29. When using instantiate2, this is a way to precompute the address.\n/// When using instantiate, the contract address will use a different algorithm and\n/// cannot be pre-computed as it contains inputs from the chain's state at the time of\n/// message execution.\n///\n/// The predicable address format of instantiate2 is stable. But bear in mind this is\n/// a powerful tool that requires multiple software components to work together smoothly.\n/// It should be used carefully and tested thoroughly to avoid the loss of funds.\n///\n/// This method operates on [`CanonicalAddr`] to be implemented without chain interaction.\n/// The typical usage looks like this:\n///\n/// ```\n/// # use cosmwasm_std::{\n/// #     HexBinary,\n/// #     Storage, Api, Querier, DepsMut, Deps, entry_point, Env, StdError, MessageInfo,\n/// #     Response, QueryResponse,\n/// # };\n/// # type ExecuteMsg = ();\n/// use cosmwasm_std::instantiate2_address;\n///\n/// #[entry_point]\n/// pub fn execute(\n///     deps: DepsMut,\n///     env: Env,\n///     info: MessageInfo,\n///     msg: ExecuteMsg,\n/// ) -> Result<Response, StdError> {\n///     let canonical_creator = deps.api.addr_canonicalize(env.contract.address.as_str())?;\n///     let checksum = HexBinary::from_hex(\"9af782a3a1bcbcd22dbb6a45c751551d9af782a3a1bcbcd22dbb6a45c751551d\")?;\n///     let salt = b\"instance 1231\";\n///     let canonical_addr = instantiate2_address(&checksum, &canonical_creator, salt, None)\n///         .map_err(|_| StdError::generic_err(\"Could not calculate addr\"))?;\n///     let addr = deps.api.addr_humanize(&canonical_addr)?;\n///\n/// #   Ok(Default::default())\n/// }\n/// ```\npub fn instantiate2_address(\n    checksum: &[u8],\n    creator: &CanonicalAddr,\n    salt: &[u8],\n    msg: Option<&[u8]>,\n) -> Result<CanonicalAddr, Instantiate2AddressError> {\n}\n\n/// The \"Basic Address\" Hash from\n/// https://github.com/cosmos/cosmos-sdk/blob/v0.45.8/docs/architecture/adr-028-public-key-addresses.md\nfn hash(ty: &str, key: &[u8]) -> Vec<u8> {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod assertions {\n//! A module containing an assertion framework for CosmWasm contracts.\n//! The methods in here never panic but return errors instead.\n\n/// Quick check for a guard. If the condition (first argument) is false,\n/// then return the second argument `x` wrapped in `Err(x)`.\n///\n/// ```\n/// # enum ContractError {\n/// #     DelegatePerm {},\n/// # }\n/// #\n/// # struct Permissions {\n/// #     delegate: bool,\n/// # }\n/// #\n/// # fn body() -> Result<(), ContractError> {\n/// # let permissions = Permissions { delegate: true };\n/// use cosmwasm_std::ensure;\n/// ensure!(permissions.delegate, ContractError::DelegatePerm {});\n///\n/// // is the same as\n///\n/// if !permissions.delegate {\n///   return Err(ContractError::DelegatePerm {});\n/// }\n/// # Ok(())\n/// # }\n/// ```\n#[macro_export]\nmacro_rules! ensure {\n    ($cond:expr, $e:expr) => {\n        if !($cond) {\n            return Err(std::convert::From::from($e));\n        }\n    };\n}\n\n/// Quick check for a guard. Like `assert_eq!`, but rather than panic,\n/// it returns the third argument `x` wrapped in `Err(x)`.\n///\n/// ```\n/// # use cosmwasm_std::{MessageInfo, Addr};\n/// #\n/// # enum ContractError {\n/// #     Unauthorized {},\n/// # }\n/// # struct Config {\n/// #     admin: String,\n/// # }\n/// #\n/// # fn body() -> Result<(), ContractError> {\n/// # let info = MessageInfo { sender: Addr::unchecked(\"foo\"), funds: Vec::new() };\n/// # let cfg = Config { admin: \"foo\".to_string() };\n/// use cosmwasm_std::ensure_eq;\n///\n/// ensure_eq!(info.sender, cfg.admin, ContractError::Unauthorized {});\n///\n/// // is the same as\n///\n/// if info.sender != cfg.admin {\n///   return Err(ContractError::Unauthorized {});\n/// }\n/// # Ok(())\n/// # }\n/// ```\n#[macro_export]\nmacro_rules! ensure_eq {\n    ($a:expr, $b:expr, $e:expr) => {\n        // Not implemented via `ensure!` because the caller would have to import both macros.\n        if !($a == $b) {\n            return Err(std::convert::From::from($e));\n        }\n    };\n}\n\n/// Quick check for a guard. Like `assert_ne!`, but rather than panic,\n/// it returns the third argument `x` wrapped in Err(x).\n///\n/// ```\n/// # enum ContractError {\n/// #     NotAVoter {},\n/// # }\n/// #\n/// # fn body() -> Result<(), ContractError> {\n/// # let voting_power = 123;\n/// use cosmwasm_std::ensure_ne;\n///\n/// ensure_ne!(voting_power, 0, ContractError::NotAVoter {});\n///\n/// // is the same as\n///\n/// if voting_power != 0 {\n///   return Err(ContractError::NotAVoter {});\n/// }\n/// # Ok(())\n/// # }\n/// ```\n#[macro_export]\nmacro_rules! ensure_ne {\n    ($a:expr, $b:expr, $e:expr) => {\n        // Not implemented via `ensure!` because the caller would have to import both macros.\n        if !($a != $b) {\n            return Err(std::convert::From::from($e));\n        }\n    };\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod binary {\nuse std::fmt;\nuse std::ops::Deref;\n\nuse schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\n\nuse crate::errors::{StdError, StdResult};\n\n/// Binary is a wrapper around Vec<u8> to add base64 de/serialization\n/// with serde. It also adds some helper methods to help encode inline.\n///\n/// This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>.\n/// See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.\n#[derive(Clone, Default, PartialEq, Eq, Hash, PartialOrd, Ord, JsonSchema)]\npub struct Binary(#[schemars(with = \"String\")] pub Vec<u8>);\n\nimpl Binary {\n    /// take an (untrusted) string and decode it into bytes.\n    /// fails if it is not valid base64\n    pub fn from_base64(encoded: &str) -> StdResult<Self> {\n}\n\n    /// encode to base64 string (guaranteed to be success as we control the data inside).\n    /// this returns normalized form (with trailing = if needed)\n    pub fn to_base64(&self) -> String {\n}\n\n    pub fn as_slice(&self) -> &[u8] {\n}\n\n    /// Copies content into fixed-sized array.\n    ///\n    /// # Examples\n    ///\n    /// Copy to array of explicit length\n    ///\n    /// ```\n    /// # use cosmwasm_std::Binary;\n    /// let binary = Binary::from(&[0xfb, 0x1f, 0x37]);\n    /// let array: [u8; 3] = binary.to_array().unwrap();\n    /// assert_eq!(array, [0xfb, 0x1f, 0x37]);\n    /// ```\n    ///\n    /// Copy to integer\n    ///\n    /// ```\n    /// # use cosmwasm_std::Binary;\n    /// let binary = Binary::from(&[0x8b, 0x67, 0x64, 0x84, 0xb5, 0xfb, 0x1f, 0x37]);\n    /// let num = u64::from_be_bytes(binary.to_array().unwrap());\n    /// assert_eq!(num, 10045108015024774967);\n    /// ```\n    pub fn to_array<const LENGTH: usize>(&self) -> StdResult<[u8; LENGTH]> {\n}\n}\n\nimpl fmt::Display for Binary {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\nimpl fmt::Debug for Binary {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl From<&[u8]> for Binary {\n    fn from(binary: &[u8]) -> Self {\n}\n}\n\n/// Just like Vec<u8>, Binary is a smart pointer to [u8].\n/// This implements `*binary` for us and allows us to\n/// do `&*binary`, returning a `&[u8]` from a `&Binary`.\n/// With [deref coercions](https://doc.rust-lang.org/1.22.1/book/first-edition/deref-coercions.html#deref-coercions),\n/// this allows us to use `&binary` whenever a `&[u8]` is required.\nimpl Deref for Binary {\n    type Target = [u8];\n\n    fn deref(&self) -> &Self::Target {\n}\n}\n\n// Reference\nimpl<const LENGTH: usize> From<&[u8; LENGTH]> for Binary {\n    fn from(source: &[u8; LENGTH]) -> Self {\n}\n}\n\n// Owned\nimpl<const LENGTH: usize> From<[u8; LENGTH]> for Binary {\n    fn from(source: [u8; LENGTH]) -> Self {\n}\n}\n\nimpl From<Vec<u8>> for Binary {\n    fn from(vec: Vec<u8>) -> Self {\n}\n}\n\nimpl From<Binary> for Vec<u8> {\n    fn from(original: Binary) -> Vec<u8> {\n}\n}\n\n/// Implement `encoding::Binary == std::vec::Vec<u8>`\nimpl PartialEq<Vec<u8>> for Binary {\n    fn eq(&self, rhs: &Vec<u8>) -> bool {\n}\n}\n\n/// Implement `std::vec::Vec<u8> == encoding::Binary`\nimpl PartialEq<Binary> for Vec<u8> {\n    fn eq(&self, rhs: &Binary) -> bool {\n}\n}\n\n/// Implement `Binary == &[u8]`\nimpl PartialEq<&[u8]> for Binary {\n    fn eq(&self, rhs: &&[u8]) -> bool {\n}\n}\n\n/// Implement `&[u8] == Binary`\nimpl PartialEq<Binary> for &[u8] {\n    fn eq(&self, rhs: &Binary) -> bool {\n}\n}\n\n/// Implement `Binary == &[u8; LENGTH]`\nimpl<const LENGTH: usize> PartialEq<&[u8; LENGTH]> for Binary {\n    fn eq(&self, rhs: &&[u8; LENGTH]) -> bool {\n}\n}\n\n/// Implement `&[u8; LENGTH] == Binary`\nimpl<const LENGTH: usize> PartialEq<Binary> for &[u8; LENGTH] {\n    fn eq(&self, rhs: &Binary) -> bool {\n}\n}\n\n/// Implement `Binary == [u8; LENGTH]`\nimpl<const LENGTH: usize> PartialEq<[u8; LENGTH]> for Binary {\n    fn eq(&self, rhs: &[u8; LENGTH]) -> bool {\n}\n}\n\n/// Implement `[u8; LENGTH] == Binary`\nimpl<const LENGTH: usize> PartialEq<Binary> for [u8; LENGTH] {\n    fn eq(&self, rhs: &Binary) -> bool {\n}\n}\n\n/// Serializes as a base64 string\nimpl Serialize for Binary {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n}\n}\n\n/// Deserializes as a base64 string\nimpl<'de> Deserialize<'de> for Binary {\n    fn deserialize<D>(deserializer: D) -> Result<Binary, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n}\n}\n\nstruct Base64Visitor;\n\nimpl<'de> de::Visitor<'de> for Base64Visitor {\n    type Value = Binary;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n}\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: de::Error,\n    {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod coin {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\nuse crate::math::Uint128;\n\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq, JsonSchema)]\npub struct Coin {\n    pub denom: String,\n    pub amount: Uint128,\n}\n\nimpl Coin {\n    pub fn new(amount: u128, denom: impl Into<String>) -> Self {\n}\n}\n\nimpl fmt::Display for Coin {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\n/// A shortcut constructor for a set of one denomination of coins\n///\n/// # Examples\n///\n/// ```\n/// # use cosmwasm_std::{coins, BankMsg, CosmosMsg, Response, SubMsg};\n/// # use cosmwasm_std::testing::{mock_env, mock_info};\n/// # let env = mock_env();\n/// # let info = mock_info(\"sender\", &[]);\n/// let tip = coins(123, \"ucosm\");\n///\n/// let mut response: Response = Default::default();\n/// response.messages = vec![SubMsg::new(BankMsg::Send {\n///   to_address: info.sender.into(),\n///   amount: tip,\n/// })];\n/// ```\npub fn coins(amount: u128, denom: impl Into<String>) -> Vec<Coin> {\n}\n\n/// A shorthand constructor for Coin\n///\n/// # Examples\n///\n/// ```\n/// # use cosmwasm_std::{coin, BankMsg, CosmosMsg, Response, SubMsg};\n/// # use cosmwasm_std::testing::{mock_env, mock_info};\n/// # let env = mock_env();\n/// # let info = mock_info(\"sender\", &[]);\n/// let tip = vec![\n///     coin(123, \"ucosm\"),\n///     coin(24, \"ustake\"),\n/// ];\n///\n/// let mut response: Response = Default::default();\n/// response.messages = vec![SubMsg::new(BankMsg::Send {\n///     to_address: info.sender.into(),\n///     amount: tip,\n/// })];\n/// ```\npub fn coin(amount: u128, denom: impl Into<String>) -> Coin {\n}\n\n/// has_coins returns true if the list of coins has at least the required amount\npub fn has_coins(coins: &[Coin], required: &Coin) -> bool {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod conversion {\n/// Converts an input of type usize to u32.\n///\n/// On 32 bit platforms such as wasm32 this is just a safe cast.\n/// On other platforms the conversion panics for values larger than\n/// `u32::MAX`.\n#[inline]\npub fn force_to_u32(input: usize) -> u32 {\n}\n}\nmod deps {\nuse std::marker::PhantomData;\n\nuse crate::query::CustomQuery;\nuse crate::results::Empty;\nuse crate::traits::{Api, Querier, Storage};\nuse crate::QuerierWrapper;\n\n/// Holds all external dependencies of the contract.\n/// Designed to allow easy dependency injection at runtime.\n/// This cannot be copied or cloned since it would behave differently\n/// for mock storages and a bridge storage in the VM.\npub struct OwnedDeps<S: Storage, A: Api, Q: Querier, C: CustomQuery = Empty> {\n    pub storage: S,\n    pub api: A,\n    pub querier: Q,\n    pub custom_query_type: PhantomData<C>,\n}\n\npub struct DepsMut<'a, C: CustomQuery = Empty> {\n    pub storage: &'a mut dyn Storage,\n    pub api: &'a dyn Api,\n    pub querier: QuerierWrapper<'a, C>,\n}\n\n#[derive(Clone)]\npub struct Deps<'a, C: CustomQuery = Empty> {\n    pub storage: &'a dyn Storage,\n    pub api: &'a dyn Api,\n    pub querier: QuerierWrapper<'a, C>,\n}\n\n// Use custom implementation on order to implement Copy in case `C` is not `Copy`.\n// See \"There is a small difference between the two: the derive strategy will also\n// place a Copy bound on type parameters, which isn’t always desired.\"\n// https://doc.rust-lang.org/std/marker/trait.Copy.html\nimpl<'a, C: CustomQuery> Copy for Deps<'a, C> {}\n\nimpl<S: Storage, A: Api, Q: Querier, C: CustomQuery> OwnedDeps<S, A, Q, C> {\n    pub fn as_ref(&'_ self) -> Deps<'_, C> {\n}\n\n    pub fn as_mut(&'_ mut self) -> DepsMut<'_, C> {\n}\n}\n\nimpl<'a, C: CustomQuery> DepsMut<'a, C> {\n    pub fn as_ref(&'_ self) -> Deps<'_, C> {\n}\n\n    pub fn branch(&'_ mut self) -> DepsMut<'_, C> {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod errors {\nmod recover_pubkey_error {\n#[cfg(not(target_arch = \"wasm32\"))]\nuse cosmwasm_crypto::CryptoError;\n#[cfg(feature = \"backtraces\")]\nuse std::backtrace::Backtrace;\nuse std::fmt::Debug;\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum RecoverPubkeyError {\n    #[error(\"Invalid hash format\")]\n    InvalidHashFormat,\n    #[error(\"Invalid signature format\")]\n    InvalidSignatureFormat,\n    #[error(\"Invalid recovery parameter. Supported values: 0 and 1.\")]\n    InvalidRecoveryParam,\n    #[error(\"Unknown error: {error_code}\")]\n    UnknownErr {\n        error_code: u32,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n}\n\nimpl RecoverPubkeyError {\n    pub fn unknown_err(error_code: u32) -> Self {\n}\n}\n\nimpl PartialEq<RecoverPubkeyError> for RecoverPubkeyError {\n    fn eq(&self, rhs: &RecoverPubkeyError) -> bool {\n}\n}\n\n#[cfg(not(target_arch = \"wasm32\"))]\nimpl From<CryptoError> for RecoverPubkeyError {\n    fn from(original: CryptoError) -> Self {\n}\n}\n}\nmod std_error {\n#[cfg(feature = \"backtraces\")]\nuse std::backtrace::Backtrace;\nuse std::fmt;\nuse thiserror::Error;\n\nuse crate::errors::{RecoverPubkeyError, VerificationError};\n\n/// Structured error type for init, execute and query.\n///\n/// This can be serialized and passed over the Wasm/VM boundary, which allows us to use structured\n/// error types in e.g. integration tests. In that process backtraces are stripped off.\n///\n/// The prefix \"Std\" means \"the standard error within the standard library\". This is not the only\n/// result/error type in cosmwasm-std.\n///\n/// When new cases are added, they should describe the problem rather than what was attempted (e.g.\n/// InvalidBase64 is preferred over Base64DecodingErr). In the long run this allows us to get rid of\n/// the duplication in \"StdError::FooErr\".\n///\n/// Checklist for adding a new error:\n/// - Add enum case\n/// - Add creator function in std_error_helpers.rs\n#[derive(Error, Debug)]\npub enum StdError {\n    #[error(\"Verification error: {source}\")]\n    VerificationErr {\n        source: VerificationError,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Recover pubkey error: {source}\")]\n    RecoverPubkeyErr {\n        source: RecoverPubkeyError,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    /// Whenever there is no specific error type available\n    #[error(\"Generic error: {msg}\")]\n    GenericErr {\n        msg: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Invalid Base64 string: {msg}\")]\n    InvalidBase64 {\n        msg: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Invalid data size: expected={expected} actual={actual}\")]\n    InvalidDataSize {\n        expected: u64,\n        actual: u64,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Invalid hex string: {msg}\")]\n    InvalidHex {\n        msg: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    /// Whenever UTF-8 bytes cannot be decoded into a unicode string, e.g. in String::from_utf8 or str::from_utf8.\n    #[error(\"Cannot decode UTF8 bytes into string: {msg}\")]\n    InvalidUtf8 {\n        msg: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"{kind} not found\")]\n    NotFound {\n        kind: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Error parsing into type {target_type}: {msg}\")]\n    ParseErr {\n        /// the target type that was attempted\n        target_type: String,\n        msg: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Error serializing type {source_type}: {msg}\")]\n    SerializeErr {\n        /// the source type that was attempted\n        source_type: String,\n        msg: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Overflow: {source}\")]\n    Overflow {\n        source: OverflowError,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Divide by zero: {source}\")]\n    DivideByZero {\n        source: DivideByZeroError,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Conversion error: \")]\n    ConversionOverflow {\n        #[from]\n        source: ConversionOverflowError,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n}\n\nimpl StdError {\n    pub fn verification_err(source: VerificationError) -> Self {\n}\n\n    pub fn recover_pubkey_err(source: RecoverPubkeyError) -> Self {\n}\n\n    pub fn generic_err(msg: impl Into<String>) -> Self {\n}\n\n    pub fn invalid_base64(msg: impl ToString) -> Self {\n}\n\n    pub fn invalid_data_size(expected: usize, actual: usize) -> Self {\n}\n\n    pub fn invalid_hex(msg: impl ToString) -> Self {\n}\n\n    pub fn invalid_utf8(msg: impl ToString) -> Self {\n}\n\n    pub fn not_found(kind: impl Into<String>) -> Self {\n}\n\n    pub fn parse_err(target: impl Into<String>, msg: impl ToString) -> Self {\n}\n\n    pub fn serialize_err(source: impl Into<String>, msg: impl ToString) -> Self {\n}\n\n    pub fn overflow(source: OverflowError) -> Self {\n}\n\n    pub fn divide_by_zero(source: DivideByZeroError) -> Self {\n}\n}\n\nimpl PartialEq<StdError> for StdError {\n    fn eq(&self, rhs: &StdError) -> bool {\n}\n}\n\nimpl From<std::str::Utf8Error> for StdError {\n    fn from(source: std::str::Utf8Error) -> Self {\n}\n}\n\nimpl From<std::string::FromUtf8Error> for StdError {\n    fn from(source: std::string::FromUtf8Error) -> Self {\n}\n}\n\nimpl From<VerificationError> for StdError {\n    fn from(source: VerificationError) -> Self {\n}\n}\n\nimpl From<RecoverPubkeyError> for StdError {\n    fn from(source: RecoverPubkeyError) -> Self {\n}\n}\n\nimpl From<OverflowError> for StdError {\n    fn from(source: OverflowError) -> Self {\n}\n}\n\nimpl From<DivideByZeroError> for StdError {\n    fn from(source: DivideByZeroError) -> Self {\n}\n}\n\n/// The return type for init, execute and query. Since the error type cannot be serialized to JSON,\n/// this is only available within the contract and its unit tests.\n///\n/// The prefix \"Std\" means \"the standard result within the standard library\". This is not the only\n/// result/error type in cosmwasm-std.\npub type StdResult<T> = core::result::Result<T, StdError>;\n\n#[derive(Error, Debug, PartialEq, Eq)]\npub enum OverflowOperation {\n    Add,\n    Sub,\n    Mul,\n    Pow,\n    Shr,\n    Shl,\n}\n\nimpl fmt::Display for OverflowOperation {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\n#[derive(Error, Debug, PartialEq, Eq)]\n#[error(\"Cannot {operation} with {operand1} and {operand2}\")]\npub struct OverflowError {\n    pub operation: OverflowOperation,\n    pub operand1: String,\n    pub operand2: String,\n}\n\nimpl OverflowError {\n    pub fn new(\n        operation: OverflowOperation,\n        operand1: impl ToString,\n        operand2: impl ToString,\n    ) -> Self {\n}\n}\n\n/// The error returned by [`TryFrom`] conversions that overflow, for example\n/// when converting from [`Uint256`] to [`Uint128`].\n///\n/// [`TryFrom`]: std::convert::TryFrom\n/// [`Uint256`]: crate::Uint256\n/// [`Uint128`]: crate::Uint128\n#[derive(Error, Debug, PartialEq, Eq)]\n#[error(\"Error converting {source_type} to {target_type} for {value}\")]\npub struct ConversionOverflowError {\n    pub source_type: &'static str,\n    pub target_type: &'static str,\n    pub value: String,\n}\n\nimpl ConversionOverflowError {\n    pub fn new(\n        source_type: &'static str,\n        target_type: &'static str,\n        value: impl Into<String>,\n    ) -> Self {\n}\n}\n\n#[derive(Error, Debug, PartialEq, Eq)]\n#[error(\"Cannot devide {operand} by zero\")]\npub struct DivideByZeroError {\n    pub operand: String,\n}\n\nimpl DivideByZeroError {\n    pub fn new(operand: impl ToString) -> Self {\n}\n}\n\n#[derive(Error, Debug, PartialEq, Eq)]\npub enum CheckedMultiplyRatioError {\n    #[error(\"Denominator must not be zero\")]\n    DivideByZero,\n\n    #[error(\"Multiplication overflow\")]\n    Overflow,\n}\n\n#[derive(Error, Debug, PartialEq, Eq)]\npub enum CheckedFromRatioError {\n    #[error(\"Denominator must not be zero\")]\n    DivideByZero,\n\n    #[error(\"Overflow\")]\n    Overflow,\n}\n\n#[derive(Error, Debug, PartialEq, Eq)]\n#[error(\"Round up operation failed because of overflow\")]\npub struct RoundUpOverflowError;\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod system_error {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::Binary;\n\n/// SystemError is used for errors inside the VM and is API friendly (i.e. serializable).\n///\n/// This is used on return values for Querier as a nested result: Result<StdResult<T>, SystemError>\n/// The first wrap (SystemError) will trigger if the contract address doesn't exist,\n/// the QueryRequest is malformated, etc. The second wrap will be an error message from\n/// the contract itself.\n///\n/// Such errors are only created by the VM. The error type is defined in the standard library, to ensure\n/// the contract understands the error format without creating a dependency on cosmwasm-vm.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\n#[non_exhaustive]\npub enum SystemError {\n    InvalidRequest {\n        error: String,\n        request: Binary,\n    },\n    InvalidResponse {\n        error: String,\n        response: Binary,\n    },\n    NoSuchContract {\n        /// The address that was attempted to query\n        addr: String,\n    },\n    Unknown {},\n    UnsupportedRequest {\n        kind: String,\n    },\n}\n\nimpl std::error::Error for SystemError {}\n\nimpl std::fmt::Display for SystemError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n}\n}\n}\nmod verification_error {\n#[cfg(feature = \"backtraces\")]\nuse std::backtrace::Backtrace;\nuse std::fmt::Debug;\nuse thiserror::Error;\n\n#[cfg(not(target_arch = \"wasm32\"))]\nuse cosmwasm_crypto::CryptoError;\n\n#[derive(Error, Debug)]\npub enum VerificationError {\n    #[error(\"Batch error\")]\n    BatchErr,\n    #[error(\"Generic error\")]\n    GenericErr,\n    #[error(\"Invalid hash format\")]\n    InvalidHashFormat,\n    #[error(\"Invalid signature format\")]\n    InvalidSignatureFormat,\n    #[error(\"Invalid public key format\")]\n    InvalidPubkeyFormat,\n    #[error(\"Invalid recovery parameter. Supported values: 0 and 1.\")]\n    InvalidRecoveryParam,\n    #[error(\"Unknown error: {error_code}\")]\n    UnknownErr {\n        error_code: u32,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n}\n\nimpl VerificationError {\n    pub fn unknown_err(error_code: u32) -> Self {\n}\n}\n\nimpl PartialEq<VerificationError> for VerificationError {\n    fn eq(&self, rhs: &VerificationError) -> bool {\n}\n}\n\n#[cfg(not(target_arch = \"wasm32\"))]\nimpl From<CryptoError> for VerificationError {\n    fn from(original: CryptoError) -> Self {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\n\npub use recover_pubkey_error::RecoverPubkeyError;\npub use std_error::{\n    CheckedFromRatioError, CheckedMultiplyRatioError, ConversionOverflowError, DivideByZeroError,\n    OverflowError, OverflowOperation, RoundUpOverflowError, StdError, StdResult,\n};\npub use system_error::SystemError;\npub use verification_error::VerificationError;\n}\nmod hex_binary {\nuse std::fmt;\nuse std::ops::Deref;\n\nuse schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\n\nuse crate::{Binary, StdError, StdResult};\n\n/// This is a wrapper around Vec<u8> to add hex de/serialization\n/// with serde. It also adds some helper methods to help encode inline.\n///\n/// This is similar to `cosmwasm_std::Binary` but uses hex.\n/// See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.\n#[derive(Clone, Default, PartialEq, Eq, Hash, PartialOrd, Ord, JsonSchema)]\npub struct HexBinary(#[schemars(with = \"String\")] Vec<u8>);\n\nimpl HexBinary {\n    pub fn from_hex(input: &str) -> StdResult<Self> {\n}\n\n    pub fn to_hex(&self) -> String {\n}\n\n    pub fn as_slice(&self) -> &[u8] {\n}\n\n    /// Copies content into fixed-sized array.\n    ///\n    /// # Examples\n    ///\n    /// Copy to array of explicit length\n    ///\n    /// ```\n    /// # use cosmwasm_std::HexBinary;\n    /// let data = HexBinary::from(&[0xfb, 0x1f, 0x37]);\n    /// let array: [u8; 3] = data.to_array().unwrap();\n    /// assert_eq!(array, [0xfb, 0x1f, 0x37]);\n    /// ```\n    ///\n    /// Copy to integer\n    ///\n    /// ```\n    /// # use cosmwasm_std::HexBinary;\n    /// let data = HexBinary::from(&[0x8b, 0x67, 0x64, 0x84, 0xb5, 0xfb, 0x1f, 0x37]);\n    /// let num = u64::from_be_bytes(data.to_array().unwrap());\n    /// assert_eq!(num, 10045108015024774967);\n    /// ```\n    pub fn to_array<const LENGTH: usize>(&self) -> StdResult<[u8; LENGTH]> {\n}\n}\n\nimpl fmt::Display for HexBinary {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\nimpl fmt::Debug for HexBinary {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\nimpl From<&[u8]> for HexBinary {\n    fn from(binary: &[u8]) -> Self {\n}\n}\n\n/// Just like Vec<u8>, HexBinary is a smart pointer to [u8].\n/// This implements `*data` for us and allows us to\n/// do `&*data`, returning a `&[u8]` from a `&HexBinary`.\n/// With [deref coercions](https://doc.rust-lang.org/1.22.1/book/first-edition/deref-coercions.html#deref-coercions),\n/// this allows us to use `&data` whenever a `&[u8]` is required.\nimpl Deref for HexBinary {\n    type Target = [u8];\n\n    fn deref(&self) -> &Self::Target {\n}\n}\n\n// Reference\nimpl<const LENGTH: usize> From<&[u8; LENGTH]> for HexBinary {\n    fn from(source: &[u8; LENGTH]) -> Self {\n}\n}\n\n// Owned\nimpl<const LENGTH: usize> From<[u8; LENGTH]> for HexBinary {\n    fn from(source: [u8; LENGTH]) -> Self {\n}\n}\n\nimpl From<Vec<u8>> for HexBinary {\n    fn from(vec: Vec<u8>) -> Self {\n}\n}\n\nimpl From<HexBinary> for Vec<u8> {\n    fn from(original: HexBinary) -> Vec<u8> {\n}\n}\n\nimpl From<Binary> for HexBinary {\n    fn from(original: Binary) -> Self {\n}\n}\n\nimpl From<HexBinary> for Binary {\n    fn from(original: HexBinary) -> Binary {\n}\n}\n\n/// Implement `HexBinary == std::vec::Vec<u8>`\nimpl PartialEq<Vec<u8>> for HexBinary {\n    fn eq(&self, rhs: &Vec<u8>) -> bool {\n}\n}\n\n/// Implement `std::vec::Vec<u8> == HexBinary`\nimpl PartialEq<HexBinary> for Vec<u8> {\n    fn eq(&self, rhs: &HexBinary) -> bool {\n}\n}\n\n/// Implement `HexBinary == &[u8]`\nimpl PartialEq<&[u8]> for HexBinary {\n    fn eq(&self, rhs: &&[u8]) -> bool {\n}\n}\n\n/// Implement `&[u8] == HexBinary`\nimpl PartialEq<HexBinary> for &[u8] {\n    fn eq(&self, rhs: &HexBinary) -> bool {\n}\n}\n\n/// Implement `HexBinary == [u8; LENGTH]`\nimpl<const LENGTH: usize> PartialEq<[u8; LENGTH]> for HexBinary {\n    fn eq(&self, rhs: &[u8; LENGTH]) -> bool {\n}\n}\n\n/// Implement `[u8; LENGTH] == HexBinary`\nimpl<const LENGTH: usize> PartialEq<HexBinary> for [u8; LENGTH] {\n    fn eq(&self, rhs: &HexBinary) -> bool {\n}\n}\n\n/// Implement `HexBinary == &[u8; LENGTH]`\nimpl<const LENGTH: usize> PartialEq<&[u8; LENGTH]> for HexBinary {\n    fn eq(&self, rhs: &&[u8; LENGTH]) -> bool {\n}\n}\n\n/// Implement `&[u8; LENGTH] == HexBinary`\nimpl<const LENGTH: usize> PartialEq<HexBinary> for &[u8; LENGTH] {\n    fn eq(&self, rhs: &HexBinary) -> bool {\n}\n}\n\n/// Serializes as a hex string\nimpl Serialize for HexBinary {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n}\n}\n\n/// Deserializes as a hex string\nimpl<'de> Deserialize<'de> for HexBinary {\n    fn deserialize<D>(deserializer: D) -> Result<HexBinary, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n}\n}\n\nstruct HexVisitor;\n\nimpl<'de> de::Visitor<'de> for HexVisitor {\n    type Value = HexBinary;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n}\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: de::Error,\n    {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod ibc {\n#![cfg(feature = \"stargate\")]\n// The CosmosMsg variants are defined in results/cosmos_msg.rs\n// The rest of the IBC related functionality is defined here\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::cmp::{Ord, Ordering, PartialOrd};\n\n#[cfg(feature = \"ibc3\")]\nuse crate::addresses::Addr;\nuse crate::binary::Binary;\nuse crate::coin::Coin;\nuse crate::errors::StdResult;\nuse crate::results::{Attribute, CosmosMsg, Empty, Event, SubMsg};\nuse crate::serde::to_binary;\nuse crate::timestamp::Timestamp;\n\n/// These are messages in the IBC lifecycle. Only usable by IBC-enabled contracts\n/// (contracts that directly speak the IBC protocol via 6 entry points)\n#[non_exhaustive]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum IbcMsg {\n    /// Sends bank tokens owned by the contract to the given address on another chain.\n    /// The channel must already be established between the ibctransfer module on this chain\n    /// and a matching module on the remote chain.\n    /// We cannot select the port_id, this is whatever the local chain has bound the ibctransfer\n    /// module to.\n    Transfer {\n        /// exisiting channel to send the tokens over\n        channel_id: String,\n        /// address on the remote chain to receive these tokens\n        to_address: String,\n        /// packet data only supports one coin\n        /// https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/applications/transfer/v1/transfer.proto#L11-L20\n        amount: Coin,\n        /// when packet times out, measured on remote chain\n        timeout: IbcTimeout,\n    },\n    /// Sends an IBC packet with given data over the existing channel.\n    /// Data should be encoded in a format defined by the channel version,\n    /// and the module on the other side should know how to parse this.\n    SendPacket {\n        channel_id: String,\n        data: Binary,\n        /// when packet times out, measured on remote chain\n        timeout: IbcTimeout,\n    },\n    /// This will close an existing channel that is owned by this contract.\n    /// Port is auto-assigned to the contract's IBC port\n    CloseChannel { channel_id: String },\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct IbcEndpoint {\n    pub port_id: String,\n    pub channel_id: String,\n}\n\n/// In IBC each package must set at least one type of timeout:\n/// the timestamp or the block height. Using this rather complex enum instead of\n/// two timeout fields we ensure that at least one timeout is set.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct IbcTimeout {\n    // use private fields to enforce the use of constructors, which ensure that at least one is set\n    block: Option<IbcTimeoutBlock>,\n    timestamp: Option<Timestamp>,\n}\n\nimpl IbcTimeout {\n    pub fn with_block(block: IbcTimeoutBlock) -> Self {\n}\n\n    pub fn with_timestamp(timestamp: Timestamp) -> Self {\n}\n\n    pub fn with_both(block: IbcTimeoutBlock, timestamp: Timestamp) -> Self {\n}\n\n    pub fn block(&self) -> Option<IbcTimeoutBlock> {\n}\n\n    pub fn timestamp(&self) -> Option<Timestamp> {\n}\n}\n\nimpl From<Timestamp> for IbcTimeout {\n    fn from(timestamp: Timestamp) -> IbcTimeout {\n}\n}\n\nimpl From<IbcTimeoutBlock> for IbcTimeout {\n    fn from(original: IbcTimeoutBlock) -> IbcTimeout {\n}\n}\n\n// These are various messages used in the callbacks\n\n/// IbcChannel defines all information on a channel.\n/// This is generally used in the hand-shake process, but can be queried directly.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[non_exhaustive]\npub struct IbcChannel {\n    pub endpoint: IbcEndpoint,\n    pub counterparty_endpoint: IbcEndpoint,\n    pub order: IbcOrder,\n    /// Note: in ibcv3 this may be \"\", in the IbcOpenChannel handshake messages\n    pub version: String,\n    /// The connection upon which this channel was created. If this is a multi-hop\n    /// channel, we only expose the first hop.\n    pub connection_id: String,\n}\n\nimpl IbcChannel {\n    /// Construct a new IbcChannel.\n    pub fn new(\n        endpoint: IbcEndpoint,\n        counterparty_endpoint: IbcEndpoint,\n        order: IbcOrder,\n        version: impl Into<String>,\n        connection_id: impl Into<String>,\n    ) -> Self {\n}\n}\n\n/// IbcOrder defines if a channel is ORDERED or UNORDERED\n/// Values come from https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/ibc/core/channel/v1/channel.proto#L69-L80\n/// Naming comes from the protobuf files and go translations.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub enum IbcOrder {\n    #[serde(rename = \"ORDER_UNORDERED\")]\n    Unordered,\n    #[serde(rename = \"ORDER_ORDERED\")]\n    Ordered,\n}\n\n/// IBCTimeoutHeight Height is a monotonically increasing data type\n/// that can be compared against another Height for the purposes of updating and\n/// freezing clients.\n/// Ordering is (revision_number, timeout_height)\n#[derive(Serialize, Deserialize, Copy, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct IbcTimeoutBlock {\n    /// the version that the client is currently on\n    /// (eg. after reseting the chain this could increment 1 as height drops to 0)\n    pub revision: u64,\n    /// block height after which the packet times out.\n    /// the height within the given revision\n    pub height: u64,\n}\n\nimpl IbcTimeoutBlock {\n    pub fn is_zero(&self) -> bool {\n}\n}\n\nimpl PartialOrd for IbcTimeoutBlock {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n}\n}\n\nimpl Ord for IbcTimeoutBlock {\n    fn cmp(&self, other: &Self) -> Ordering {\n}\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[non_exhaustive]\npub struct IbcPacket {\n    /// The raw data sent from the other side in the packet\n    pub data: Binary,\n    /// identifies the channel and port on the sending chain.\n    pub src: IbcEndpoint,\n    /// identifies the channel and port on the receiving chain.\n    pub dest: IbcEndpoint,\n    /// The sequence number of the packet on the given channel\n    pub sequence: u64,\n    pub timeout: IbcTimeout,\n}\n\nimpl IbcPacket {\n    /// Construct a new IbcPacket.\n    pub fn new(\n        data: impl Into<Binary>,\n        src: IbcEndpoint,\n        dest: IbcEndpoint,\n        sequence: u64,\n        timeout: IbcTimeout,\n    ) -> Self {\n}\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[non_exhaustive]\npub struct IbcAcknowledgement {\n    pub data: Binary,\n    // we may add more info here in the future (meta-data from the acknowledgement)\n    // there have been proposals to extend this type in core ibc for future versions\n}\n\nimpl IbcAcknowledgement {\n    pub fn new(data: impl Into<Binary>) -> Self {\n}\n\n    pub fn encode_json(data: &impl Serialize) -> StdResult<Self> {\n}\n}\n\n/// The message that is passed into `ibc_channel_open`\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum IbcChannelOpenMsg {\n    /// The ChanOpenInit step from https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#channel-lifecycle-management\n    OpenInit { channel: IbcChannel },\n    /// The ChanOpenTry step from https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#channel-lifecycle-management\n    OpenTry {\n        channel: IbcChannel,\n        counterparty_version: String,\n    },\n}\n\nimpl IbcChannelOpenMsg {\n    pub fn new_init(channel: IbcChannel) -> Self {\n}\n\n    pub fn new_try(channel: IbcChannel, counterparty_version: impl Into<String>) -> Self {\n}\n\n    pub fn channel(&self) -> &IbcChannel {\n}\n\n    pub fn counterparty_version(&self) -> Option<&str> {\n}\n}\n\nimpl From<IbcChannelOpenMsg> for IbcChannel {\n    fn from(msg: IbcChannelOpenMsg) -> IbcChannel {\n}\n}\n\n/// Note that this serializes as \"null\".\n#[cfg(not(feature = \"ibc3\"))]\npub type IbcChannelOpenResponse = ();\n/// This serializes either as \"null\" or a JSON object.\n#[cfg(feature = \"ibc3\")]\npub type IbcChannelOpenResponse = Option<Ibc3ChannelOpenResponse>;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct Ibc3ChannelOpenResponse {\n    /// We can set the channel version to a different one than we were called with\n    pub version: String,\n}\n\n/// The message that is passed into `ibc_channel_connect`\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum IbcChannelConnectMsg {\n    /// The ChanOpenAck step from https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#channel-lifecycle-management\n    OpenAck {\n        channel: IbcChannel,\n        counterparty_version: String,\n    },\n    /// The ChanOpenConfirm step from https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#channel-lifecycle-management\n    OpenConfirm { channel: IbcChannel },\n}\n\nimpl IbcChannelConnectMsg {\n    pub fn new_ack(channel: IbcChannel, counterparty_version: impl Into<String>) -> Self {\n}\n\n    pub fn new_confirm(channel: IbcChannel) -> Self {\n}\n\n    pub fn channel(&self) -> &IbcChannel {\n}\n\n    pub fn counterparty_version(&self) -> Option<&str> {\n}\n}\n\nimpl From<IbcChannelConnectMsg> for IbcChannel {\n    fn from(msg: IbcChannelConnectMsg) -> IbcChannel {\n}\n}\n\n/// The message that is passed into `ibc_channel_close`\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum IbcChannelCloseMsg {\n    /// The ChanCloseInit step from https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#channel-lifecycle-management\n    CloseInit { channel: IbcChannel },\n    /// The ChanCloseConfirm step from https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#channel-lifecycle-management\n    CloseConfirm { channel: IbcChannel }, // pub channel: IbcChannel,\n}\n\nimpl IbcChannelCloseMsg {\n    pub fn new_init(channel: IbcChannel) -> Self {\n}\n\n    pub fn new_confirm(channel: IbcChannel) -> Self {\n}\n\n    pub fn channel(&self) -> &IbcChannel {\n}\n}\n\nimpl From<IbcChannelCloseMsg> for IbcChannel {\n    fn from(msg: IbcChannelCloseMsg) -> IbcChannel {\n}\n}\n\n/// The message that is passed into `ibc_packet_receive`\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[non_exhaustive]\npub struct IbcPacketReceiveMsg {\n    pub packet: IbcPacket,\n    #[cfg(feature = \"ibc3\")]\n    pub relayer: Addr,\n}\n\nimpl IbcPacketReceiveMsg {\n    #[cfg(not(feature = \"ibc3\"))]\n    pub fn new(packet: IbcPacket) -> Self {\n}\n\n    #[cfg(feature = \"ibc3\")]\n    pub fn new(packet: IbcPacket, relayer: Addr) -> Self {\n}\n}\n\n/// The message that is passed into `ibc_packet_ack`\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[non_exhaustive]\npub struct IbcPacketAckMsg {\n    pub acknowledgement: IbcAcknowledgement,\n    pub original_packet: IbcPacket,\n    #[cfg(feature = \"ibc3\")]\n    pub relayer: Addr,\n}\n\nimpl IbcPacketAckMsg {\n    #[cfg(not(feature = \"ibc3\"))]\n    pub fn new(acknowledgement: IbcAcknowledgement, original_packet: IbcPacket) -> Self {\n}\n\n    #[cfg(feature = \"ibc3\")]\n    pub fn new(\n        acknowledgement: IbcAcknowledgement,\n        original_packet: IbcPacket,\n        relayer: Addr,\n    ) -> Self {\n}\n}\n\n/// The message that is passed into `ibc_packet_timeout`\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[non_exhaustive]\npub struct IbcPacketTimeoutMsg {\n    pub packet: IbcPacket,\n    #[cfg(feature = \"ibc3\")]\n    pub relayer: Addr,\n}\n\nimpl IbcPacketTimeoutMsg {\n    #[cfg(not(feature = \"ibc3\"))]\n    pub fn new(packet: IbcPacket) -> Self {\n}\n\n    #[cfg(feature = \"ibc3\")]\n    pub fn new(packet: IbcPacket, relayer: Addr) -> Self {\n}\n}\n\n/// This is the return value for the majority of the ibc handlers.\n/// That are able to dispatch messages / events on their own,\n/// but have no meaningful return value to the calling code.\n///\n/// Callbacks that have return values (like receive_packet)\n/// or that cannot redispatch messages (like the handshake callbacks)\n/// will use other Response types\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[non_exhaustive]\npub struct IbcBasicResponse<T = Empty> {\n    /// Optional list of messages to pass. These will be executed in order.\n    /// If the ReplyOn member is set, they will invoke this contract's `reply` entry point\n    /// after execution. Otherwise, they act like \"fire and forget\".\n    /// Use `SubMsg::new` to create messages with the older \"fire and forget\" semantics.\n    pub messages: Vec<SubMsg<T>>,\n    /// The attributes that will be emitted as part of a `wasm` event.\n    ///\n    /// More info about events (and their attributes) can be found in [*Cosmos SDK* docs].\n    ///\n    /// [*Cosmos SDK* docs]: https://docs.cosmos.network/v0.42/core/events.html\n    pub attributes: Vec<Attribute>,\n    /// Extra, custom events separate from the main `wasm` one. These will have\n    /// `wasm-` prepended to the type.\n    ///\n    /// More info about events can be found in [*Cosmos SDK* docs].\n    ///\n    /// [*Cosmos SDK* docs]: https://docs.cosmos.network/v0.42/core/events.html\n    pub events: Vec<Event>,\n}\n\n// Custom imlementation in order to implement it for all `T`, even if `T` is not `Default`.\nimpl<T> Default for IbcBasicResponse<T> {\n    fn default() -> Self {\n}\n}\n\nimpl<T> IbcBasicResponse<T> {\n    pub fn new() -> Self {\n}\n\n    /// Add an attribute included in the main `wasm` event.\n    pub fn add_attribute(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {\n}\n\n    /// This creates a \"fire and forget\" message, by using `SubMsg::new()` to wrap it,\n    /// and adds it to the list of messages to process.\n    pub fn add_message(mut self, msg: impl Into<CosmosMsg<T>>) -> Self {\n}\n\n    /// This takes an explicit SubMsg (creates via eg. `reply_on_error`)\n    /// and adds it to the list of messages to process.\n    pub fn add_submessage(mut self, msg: SubMsg<T>) -> Self {\n}\n\n    /// Adds an extra event to the response, separate from the main `wasm` event\n    /// that is always created.\n    ///\n    /// The `wasm-` prefix will be appended by the runtime to the provided type\n    /// of event.\n    pub fn add_event(mut self, event: Event) -> Self {\n}\n\n    /// Bulk add attributes included in the main `wasm` event.\n    ///\n    /// Anything that can be turned into an iterator and yields something\n    /// that can be converted into an `Attribute` is accepted.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use cosmwasm_std::{attr, IbcBasicResponse};\n    ///\n    /// let attrs = vec![\n    ///     (\"action\", \"reaction\"),\n    ///     (\"answer\", \"42\"),\n    ///     (\"another\", \"attribute\"),\n    /// ];\n    /// let res: IbcBasicResponse = IbcBasicResponse::new().add_attributes(attrs.clone());\n    /// assert_eq!(res.attributes, attrs);\n    /// ```\n    pub fn add_attributes<A: Into<Attribute>>(\n        mut self,\n        attrs: impl IntoIterator<Item = A>,\n    ) -> Self {\n}\n\n    /// Bulk add \"fire and forget\" messages to the list of messages to process.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use cosmwasm_std::{CosmosMsg, IbcBasicResponse};\n    ///\n    /// fn make_response_with_msgs(msgs: Vec<CosmosMsg>) -> IbcBasicResponse {\n    ///     IbcBasicResponse::new().add_messages(msgs)\n    /// }\n    /// ```\n    pub fn add_messages<M: Into<CosmosMsg<T>>>(self, msgs: impl IntoIterator<Item = M>) -> Self {\n}\n\n    /// Bulk add explicit SubMsg structs to the list of messages to process.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use cosmwasm_std::{SubMsg, IbcBasicResponse};\n    ///\n    /// fn make_response_with_submsgs(msgs: Vec<SubMsg>) -> IbcBasicResponse {\n    ///     IbcBasicResponse::new().add_submessages(msgs)\n    /// }\n    /// ```\n    pub fn add_submessages(mut self, msgs: impl IntoIterator<Item = SubMsg<T>>) -> Self {\n}\n\n    /// Bulk add custom events to the response. These are separate from the main\n    /// `wasm` event.\n    ///\n    /// The `wasm-` prefix will be appended by the runtime to the provided types\n    /// of events.\n    pub fn add_events(mut self, events: impl IntoIterator<Item = Event>) -> Self {\n}\n}\n\n// This defines the return value on packet response processing.\n// This \"success\" case should be returned even in application-level errors,\n// Where the acknowledgement bytes contain an encoded error message to be returned to\n// the calling chain. (Returning ContractResult::Err will abort processing of this packet\n// and not inform the calling chain).\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[non_exhaustive]\npub struct IbcReceiveResponse<T = Empty> {\n    /// The bytes we return to the contract that sent the packet.\n    /// This may represent a success or error of exection\n    pub acknowledgement: Binary,\n    /// Optional list of messages to pass. These will be executed in order.\n    /// If the ReplyOn member is set, they will invoke this contract's `reply` entry point\n    /// after execution. Otherwise, they act like \"fire and forget\".\n    /// Use `call` or `msg.into()` to create messages with the older \"fire and forget\" semantics.\n    pub messages: Vec<SubMsg<T>>,\n    /// The attributes that will be emitted as part of a \"wasm\" event.\n    ///\n    /// More info about events (and their attributes) can be found in [*Cosmos SDK* docs].\n    ///\n    /// [*Cosmos SDK* docs]: https://docs.cosmos.network/v0.42/core/events.html\n    pub attributes: Vec<Attribute>,\n    /// Extra, custom events separate from the main `wasm` one. These will have\n    /// `wasm-` prepended to the type.\n    ///\n    /// More info about events can be found in [*Cosmos SDK* docs].\n    ///\n    /// [*Cosmos SDK* docs]: https://docs.cosmos.network/v0.42/core/events.html\n    pub events: Vec<Event>,\n}\n\n// Custom imlementation in order to implement it for all `T`, even if `T` is not `Default`.\nimpl<T> Default for IbcReceiveResponse<T> {\n    fn default() -> Self {\n}\n}\n\nimpl<T> IbcReceiveResponse<T> {\n    pub fn new() -> Self {\n}\n\n    /// Set the acknowledgement for this response.\n    pub fn set_ack(mut self, ack: impl Into<Binary>) -> Self {\n}\n\n    /// Add an attribute included in the main `wasm` event.\n    pub fn add_attribute(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {\n}\n\n    /// This creates a \"fire and forget\" message, by using `SubMsg::new()` to wrap it,\n    /// and adds it to the list of messages to process.\n    pub fn add_message(mut self, msg: impl Into<CosmosMsg<T>>) -> Self {\n}\n\n    /// This takes an explicit SubMsg (creates via eg. `reply_on_error`)\n    /// and adds it to the list of messages to process.\n    pub fn add_submessage(mut self, msg: SubMsg<T>) -> Self {\n}\n\n    /// Adds an extra event to the response, separate from the main `wasm` event\n    /// that is always created.\n    ///\n    /// The `wasm-` prefix will be appended by the runtime to the provided type\n    /// of event.\n    pub fn add_event(mut self, event: Event) -> Self {\n}\n\n    /// Bulk add attributes included in the main `wasm` event.\n    ///\n    /// Anything that can be turned into an iterator and yields something\n    /// that can be converted into an `Attribute` is accepted.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use cosmwasm_std::{attr, IbcReceiveResponse};\n    ///\n    /// let attrs = vec![\n    ///     (\"action\", \"reaction\"),\n    ///     (\"answer\", \"42\"),\n    ///     (\"another\", \"attribute\"),\n    /// ];\n    /// let res: IbcReceiveResponse = IbcReceiveResponse::new().add_attributes(attrs.clone());\n    /// assert_eq!(res.attributes, attrs);\n    /// ```\n    pub fn add_attributes<A: Into<Attribute>>(\n        mut self,\n        attrs: impl IntoIterator<Item = A>,\n    ) -> Self {\n}\n\n    /// Bulk add \"fire and forget\" messages to the list of messages to process.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use cosmwasm_std::{CosmosMsg, IbcReceiveResponse};\n    ///\n    /// fn make_response_with_msgs(msgs: Vec<CosmosMsg>) -> IbcReceiveResponse {\n    ///     IbcReceiveResponse::new().add_messages(msgs)\n    /// }\n    /// ```\n    pub fn add_messages<M: Into<CosmosMsg<T>>>(self, msgs: impl IntoIterator<Item = M>) -> Self {\n}\n\n    /// Bulk add explicit SubMsg structs to the list of messages to process.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use cosmwasm_std::{SubMsg, IbcReceiveResponse};\n    ///\n    /// fn make_response_with_submsgs(msgs: Vec<SubMsg>) -> IbcReceiveResponse {\n    ///     IbcReceiveResponse::new().add_submessages(msgs)\n    /// }\n    /// ```\n    pub fn add_submessages(mut self, msgs: impl IntoIterator<Item = SubMsg<T>>) -> Self {\n}\n\n    /// Bulk add custom events to the response. These are separate from the main\n    /// `wasm` event.\n    ///\n    /// The `wasm-` prefix will be appended by the runtime to the provided types\n    /// of events.\n    pub fn add_events(mut self, events: impl IntoIterator<Item = Event>) -> Self {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod import_helpers {\n/// Returns the four most significant bytes\n#[allow(dead_code)] // only used in Wasm builds\n#[inline]\npub fn from_high_half(data: u64) -> u32 {\n}\n\n/// Returns the four least significant bytes\n#[allow(dead_code)] // only used in Wasm builds\n#[inline]\npub fn from_low_half(data: u64) -> u32 {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\n#[cfg(feature = \"iterator\")]\nmod iterator {\nuse crate::errors::StdError;\n\n/// A record of a key-value storage that is created through an iterator API.\n/// The first element (key) is always raw binary data. The second element\n/// (value) is binary by default but can be changed to a custom type. This\n/// allows contracts to reuse the type when deserializing database records.\npub type Record<V = Vec<u8>> = (Vec<u8>, V);\n\n#[derive(Copy, Clone)]\n// We assign these to integers to provide a stable API for passing over FFI (to wasm and Go)\npub enum Order {\n    Ascending = 1,\n    Descending = 2,\n}\n\nimpl TryFrom<i32> for Order {\n    type Error = StdError;\n\n    fn try_from(value: i32) -> Result<Self, Self::Error> {\n}\n}\n\nimpl From<Order> for i32 {\n    fn from(original: Order) -> i32 {\n}\n}\n}\nmod math {\nmod decimal {\nuse forward_ref::{forward_ref_binop, forward_ref_op_assign};\nuse schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::cmp::Ordering;\nuse std::fmt::{self, Write};\nuse std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Rem, RemAssign, Sub, SubAssign};\nuse std::str::FromStr;\nuse thiserror::Error;\n\nuse crate::errors::{\n    CheckedFromRatioError, CheckedMultiplyRatioError, DivideByZeroError, OverflowError,\n    OverflowOperation, RoundUpOverflowError, StdError,\n};\n\nuse super::Fraction;\nuse super::Isqrt;\nuse super::{Uint128, Uint256};\n\n/// A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n///\n/// The greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Decimal(#[schemars(with = \"String\")] Uint128);\n\n#[derive(Error, Debug, PartialEq, Eq)]\n#[error(\"Decimal range exceeded\")]\npub struct DecimalRangeExceeded;\n\nimpl Decimal {\n    const DECIMAL_FRACTIONAL: Uint128 = Uint128::new(1_000_000_000_000_000_000u128); // 1*10**18\n    const DECIMAL_FRACTIONAL_SQUARED: Uint128 =\n        Uint128::new(1_000_000_000_000_000_000_000_000_000_000_000_000u128); // (1*10**18)**2 = 1*10**36\n\n    /// The number of decimal places. Since decimal types are fixed-point rather than\n    /// floating-point, this is a constant.\n    pub const DECIMAL_PLACES: u32 = 18; // This needs to be an even number.\n    /// The largest value that can be represented by this decimal type.\n    pub const MAX: Self = Self(Uint128::MAX);\n    /// The smallest value that can be represented by this decimal type.\n    pub const MIN: Self = Self(Uint128::MIN);\n\n    /// Creates a Decimal(value)\n    /// This is equivalent to `Decimal::from_atomics(value, 18)` but usable in a const context.\n    pub const fn new(value: Uint128) -> Self {\n}\n\n    /// Creates a Decimal(Uint128(value))\n    /// This is equivalent to `Decimal::from_atomics(value, 18)` but usable in a const context.\n    pub const fn raw(value: u128) -> Self {\n}\n\n    /// Create a 1.0 Decimal\n    #[inline]\n    pub const fn one() -> Self {\n}\n\n    /// Create a 0.0 Decimal\n    #[inline]\n    pub const fn zero() -> Self {\n}\n\n    /// Convert x% into Decimal\n    pub fn percent(x: u64) -> Self {\n}\n\n    /// Convert permille (x/1000) into Decimal\n    pub fn permille(x: u64) -> Self {\n}\n\n    /// Creates a decimal from a number of atomic units and the number\n    /// of decimal places. The inputs will be converted internally to form\n    /// a decimal with 18 decimal places. So the input 123 and 2 will create\n    /// the decimal 1.23.\n    ///\n    /// Using 18 decimal places is slightly more efficient than other values\n    /// as no internal conversion is necessary.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// # use cosmwasm_std::{Decimal, Uint128};\n    /// let a = Decimal::from_atomics(Uint128::new(1234), 3).unwrap();\n    /// assert_eq!(a.to_string(), \"1.234\");\n    ///\n    /// let a = Decimal::from_atomics(1234u128, 0).unwrap();\n    /// assert_eq!(a.to_string(), \"1234\");\n    ///\n    /// let a = Decimal::from_atomics(1u64, 18).unwrap();\n    /// assert_eq!(a.to_string(), \"0.000000000000000001\");\n    /// ```\n    pub fn from_atomics(\n        atomics: impl Into<Uint128>,\n        decimal_places: u32,\n    ) -> Result<Self, DecimalRangeExceeded> {\n}\n\n    /// Returns the ratio (numerator / denominator) as a Decimal\n    pub fn from_ratio(numerator: impl Into<Uint128>, denominator: impl Into<Uint128>) -> Self {\n}\n\n    /// Returns the ratio (numerator / denominator) as a Decimal\n    pub fn checked_from_ratio(\n        numerator: impl Into<Uint128>,\n        denominator: impl Into<Uint128>,\n    ) -> Result<Self, CheckedFromRatioError> {\n}\n\n    pub const fn is_zero(&self) -> bool {\n}\n\n    /// A decimal is an integer of atomic units plus a number that specifies the\n    /// position of the decimal dot. So any decimal can be expressed as two numbers.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// # use cosmwasm_std::{Decimal, Uint128};\n    /// # use std::str::FromStr;\n    /// // Value with whole and fractional part\n    /// let a = Decimal::from_str(\"1.234\").unwrap();\n    /// assert_eq!(a.decimal_places(), 18);\n    /// assert_eq!(a.atomics(), Uint128::new(1234000000000000000));\n    ///\n    /// // Smallest possible value\n    /// let b = Decimal::from_str(\"0.000000000000000001\").unwrap();\n    /// assert_eq!(b.decimal_places(), 18);\n    /// assert_eq!(b.atomics(), Uint128::new(1));\n    /// ```\n    #[inline]\n    pub const fn atomics(&self) -> Uint128 {\n}\n\n    /// The number of decimal places. This is a constant value for now\n    /// but this could potentially change as the type evolves.\n    ///\n    /// See also [`Decimal::atomics()`].\n    #[inline]\n    pub const fn decimal_places(&self) -> u32 {\n}\n\n    /// Rounds value down after decimal places.\n    pub fn floor(&self) -> Self {\n}\n\n    /// Rounds value up after decimal places. Panics on overflow.\n    pub fn ceil(&self) -> Self {\n}\n\n    /// Rounds value up after decimal places. Returns OverflowError on overflow.\n    pub fn checked_ceil(&self) -> Result<Self, RoundUpOverflowError> {\n}\n\n    pub fn checked_add(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_sub(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    /// Multiplies one `Decimal` by another, returning an `OverflowError` if an overflow occurred.\n    pub fn checked_mul(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    /// Raises a value to the power of `exp`, panics if an overflow occurred.\n    pub fn pow(self, exp: u32) -> Self {\n}\n\n    /// Raises a value to the power of `exp`, returning an `OverflowError` if an overflow occurred.\n    pub fn checked_pow(self, exp: u32) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_div(self, other: Self) -> Result<Self, CheckedFromRatioError> {\n}\n\n    pub fn checked_rem(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    /// Returns the approximate square root as a Decimal.\n    ///\n    /// This should not overflow or panic.\n    pub fn sqrt(&self) -> Self {\n}\n\n    /// Lower precision means more aggressive rounding, but less risk of overflow.\n    /// Precision *must* be a number between 0 and 9 (inclusive).\n    ///\n    /// Returns `None` if the internal multiplication overflows.\n    fn sqrt_with_precision(&self, precision: u32) -> Option<Self> {\n}\n\n    pub const fn abs_diff(self, other: Self) -> Self {\n}\n\n    pub fn saturating_add(self, other: Self) -> Self {\n}\n\n    pub fn saturating_sub(self, other: Self) -> Self {\n}\n\n    pub fn saturating_mul(self, other: Self) -> Self {\n}\n\n    pub fn saturating_pow(self, exp: u32) -> Self {\n}\n}\n\nimpl Fraction<Uint128> for Decimal {\n    #[inline]\n    fn numerator(&self) -> Uint128 {\n}\n\n    #[inline]\n    fn denominator(&self) -> Uint128 {\n}\n\n    /// Returns the multiplicative inverse `1/d` for decimal `d`.\n    ///\n    /// If `d` is zero, none is returned.\n    fn inv(&self) -> Option<Self> {\n}\n}\n\nimpl FromStr for Decimal {\n    type Err = StdError;\n\n    /// Converts the decimal string to a Decimal\n    /// Possible inputs: \"1.23\", \"1\", \"000012\", \"1.123000000\"\n    /// Disallowed: \"\", \".23\"\n    ///\n    /// This never performs any kind of rounding.\n    /// More than DECIMAL_PLACES fractional digits, even zeros, result in an error.\n    fn from_str(input: &str) -> Result<Self, Self::Err> {\n}\n}\n\nimpl fmt::Display for Decimal {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\nimpl Add for Decimal {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Add, add for Decimal, Decimal);\n\nimpl AddAssign for Decimal {\n    fn add_assign(&mut self, rhs: Decimal) {\n}\n}\nforward_ref_op_assign!(impl AddAssign, add_assign for Decimal, Decimal);\n\nimpl Sub for Decimal {\n    type Output = Self;\n\n    fn sub(self, other: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Sub, sub for Decimal, Decimal);\n\nimpl SubAssign for Decimal {\n    fn sub_assign(&mut self, rhs: Decimal) {\n}\n}\nforward_ref_op_assign!(impl SubAssign, sub_assign for Decimal, Decimal);\n\nimpl Mul for Decimal {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, other: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Mul, mul for Decimal, Decimal);\n\nimpl MulAssign for Decimal {\n    fn mul_assign(&mut self, rhs: Decimal) {\n}\n}\nforward_ref_op_assign!(impl MulAssign, mul_assign for Decimal, Decimal);\n\n/// Both d*u and u*d with d: Decimal and u: Uint128 returns an Uint128. There is no\n/// specific reason for this decision other than the initial use cases we have. If you\n/// need a Decimal result for the same calculation, use Decimal(d*u) or Decimal(u*d).\nimpl Mul<Decimal> for Uint128 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Decimal) -> Self::Output {\n}\n}\n\nimpl Mul<Uint128> for Decimal {\n    type Output = Uint128;\n\n    fn mul(self, rhs: Uint128) -> Self::Output {\n}\n}\n\nimpl Div for Decimal {\n    type Output = Self;\n\n    fn div(self, other: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Div, div for Decimal, Decimal);\n\nimpl DivAssign for Decimal {\n    fn div_assign(&mut self, rhs: Decimal) {\n}\n}\nforward_ref_op_assign!(impl DivAssign, div_assign for Decimal, Decimal);\n\nimpl Div<Uint128> for Decimal {\n    type Output = Self;\n\n    fn div(self, rhs: Uint128) -> Self::Output {\n}\n}\n\nimpl DivAssign<Uint128> for Decimal {\n    fn div_assign(&mut self, rhs: Uint128) {\n}\n}\n\nimpl Rem for Decimal {\n    type Output = Self;\n\n    /// # Panics\n    ///\n    /// This operation will panic if `rhs` is zero\n    #[inline]\n    fn rem(self, rhs: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Rem, rem for Decimal, Decimal);\n\nimpl RemAssign<Decimal> for Decimal {\n    fn rem_assign(&mut self, rhs: Decimal) {\n}\n}\nforward_ref_op_assign!(impl RemAssign, rem_assign for Decimal, Decimal);\n\nimpl<A> std::iter::Sum<A> for Decimal\nwhere\n    Self: Add<A, Output = Self>,\n{\n    fn sum<I: Iterator<Item = A>>(iter: I) -> Self {\n}\n}\n\n/// Serializes as a decimal string\nimpl Serialize for Decimal {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n}\n}\n\n/// Deserializes as a base64 string\nimpl<'de> Deserialize<'de> for Decimal {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n}\n}\n\nstruct DecimalVisitor;\n\nimpl<'de> de::Visitor<'de> for DecimalVisitor {\n    type Value = Decimal;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n}\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: de::Error,\n    {\n}\n    }\n}\n\nimpl PartialEq<&Decimal> for Decimal {\n    fn eq(&self, rhs: &&Decimal) -> bool {\n}\n}\n\nimpl PartialEq<Decimal> for &Decimal {\n    fn eq(&self, rhs: &Decimal) -> bool {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod decimal256 {\nuse forward_ref::{forward_ref_binop, forward_ref_op_assign};\nuse schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::cmp::Ordering;\nuse std::fmt::{self, Write};\nuse std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Rem, RemAssign, Sub, SubAssign};\nuse std::str::FromStr;\nuse thiserror::Error;\n\nuse crate::errors::{\n    CheckedFromRatioError, CheckedMultiplyRatioError, DivideByZeroError, OverflowError,\n    OverflowOperation, RoundUpOverflowError, StdError,\n};\nuse crate::{Decimal, Uint512};\n\nuse super::Fraction;\nuse super::Isqrt;\nuse super::Uint256;\n\n/// A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n///\n/// The greatest possible value that can be represented is\n/// 115792089237316195423570985008687907853269984665640564039457.584007913129639935\n/// (which is (2^256 - 1) / 10^18)\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Decimal256(#[schemars(with = \"String\")] Uint256);\n\n#[derive(Error, Debug, PartialEq, Eq)]\n#[error(\"Decimal256 range exceeded\")]\npub struct Decimal256RangeExceeded;\n\nimpl Decimal256 {\n    const DECIMAL_FRACTIONAL: Uint256 = // 1*10**18\n        Uint256::from_be_bytes([\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 224, 182,\n            179, 167, 100, 0, 0,\n        ]);\n    const DECIMAL_FRACTIONAL_SQUARED: Uint256 = // 1*10**36\n        Uint256::from_be_bytes([\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 151, 206, 123, 201, 7, 21, 179,\n            75, 159, 16, 0, 0, 0, 0,\n        ]);\n\n    /// The number of decimal places. Since decimal types are fixed-point rather than\n    /// floating-point, this is a constant.\n    pub const DECIMAL_PLACES: u32 = 18;\n    /// The largest value that can be represented by this decimal type.\n    pub const MAX: Self = Self(Uint256::MAX);\n    /// The smallest value that can be represented by this decimal type.\n    pub const MIN: Self = Self(Uint256::MIN);\n\n    /// Creates a Decimal256 from Uint256\n    /// This is equivalent to `Decimal256::from_atomics(value, 18)` but usable in a const context.\n    pub const fn new(value: Uint256) -> Self {\n}\n\n    /// Creates a Decimal256 from u128\n    /// This is equivalent to `Decimal256::from_atomics(value, 18)` but usable in a const context.\n    pub const fn raw(value: u128) -> Self {\n}\n\n    /// Create a 1.0 Decimal256\n    #[inline]\n    pub const fn one() -> Self {\n}\n\n    /// Create a 0.0 Decimal256\n    #[inline]\n    pub const fn zero() -> Self {\n}\n\n    /// Convert x% into Decimal256\n    pub fn percent(x: u64) -> Self {\n}\n\n    /// Convert permille (x/1000) into Decimal256\n    pub fn permille(x: u64) -> Self {\n}\n\n    /// Creates a decimal from a number of atomic units and the number\n    /// of decimal places. The inputs will be converted internally to form\n    /// a decimal with 18 decimal places. So the input 123 and 2 will create\n    /// the decimal 1.23.\n    ///\n    /// Using 18 decimal places is slightly more efficient than other values\n    /// as no internal conversion is necessary.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// # use cosmwasm_std::{Decimal256, Uint256};\n    /// let a = Decimal256::from_atomics(1234u64, 3).unwrap();\n    /// assert_eq!(a.to_string(), \"1.234\");\n    ///\n    /// let a = Decimal256::from_atomics(1234u128, 0).unwrap();\n    /// assert_eq!(a.to_string(), \"1234\");\n    ///\n    /// let a = Decimal256::from_atomics(1u64, 18).unwrap();\n    /// assert_eq!(a.to_string(), \"0.000000000000000001\");\n    ///\n    /// let a = Decimal256::from_atomics(Uint256::MAX, 18).unwrap();\n    /// assert_eq!(a, Decimal256::MAX);\n    /// ```\n    pub fn from_atomics(\n        atomics: impl Into<Uint256>,\n        decimal_places: u32,\n    ) -> Result<Self, Decimal256RangeExceeded> {\n}\n\n    /// Returns the ratio (numerator / denominator) as a Decimal256\n    pub fn from_ratio(numerator: impl Into<Uint256>, denominator: impl Into<Uint256>) -> Self {\n}\n\n    /// Returns the ratio (numerator / denominator) as a Decimal256\n    pub fn checked_from_ratio(\n        numerator: impl Into<Uint256>,\n        denominator: impl Into<Uint256>,\n    ) -> Result<Self, CheckedFromRatioError> {\n}\n\n    pub const fn is_zero(&self) -> bool {\n}\n\n    /// A decimal is an integer of atomic units plus a number that specifies the\n    /// position of the decimal dot. So any decimal can be expressed as two numbers.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// # use cosmwasm_std::{Decimal256, Uint256};\n    /// # use std::str::FromStr;\n    /// // Value with whole and fractional part\n    /// let a = Decimal256::from_str(\"1.234\").unwrap();\n    /// assert_eq!(a.decimal_places(), 18);\n    /// assert_eq!(a.atomics(), Uint256::from(1234000000000000000u128));\n    ///\n    /// // Smallest possible value\n    /// let b = Decimal256::from_str(\"0.000000000000000001\").unwrap();\n    /// assert_eq!(b.decimal_places(), 18);\n    /// assert_eq!(b.atomics(), Uint256::from(1u128));\n    /// ```\n    #[inline]\n    pub const fn atomics(&self) -> Uint256 {\n}\n\n    /// The number of decimal places. This is a constant value for now\n    /// but this could potentially change as the type evolves.\n    ///\n    /// See also [`Decimal256::atomics()`].\n    #[inline]\n    pub const fn decimal_places(&self) -> u32 {\n}\n\n    /// Rounds value down after decimal places.\n    pub fn floor(&self) -> Self {\n}\n\n    /// Rounds value up after decimal places. Panics on overflow.\n    pub fn ceil(&self) -> Self {\n}\n\n    /// Rounds value up after decimal places. Returns OverflowError on overflow.\n    pub fn checked_ceil(&self) -> Result<Self, RoundUpOverflowError> {\n}\n\n    pub fn checked_add(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_sub(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    /// Multiplies one `Decimal256` by another, returning an `OverflowError` if an overflow occurred.\n    pub fn checked_mul(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    /// Raises a value to the power of `exp`, panics if an overflow occurred.\n    pub fn pow(self, exp: u32) -> Self {\n}\n\n    /// Raises a value to the power of `exp`, returning an `OverflowError` if an overflow occurred.\n    pub fn checked_pow(self, exp: u32) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_div(self, other: Self) -> Result<Self, CheckedFromRatioError> {\n}\n\n    pub fn checked_rem(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    /// Returns the approximate square root as a Decimal256.\n    ///\n    /// This should not overflow or panic.\n    pub fn sqrt(&self) -> Self {\n}\n\n    /// Lower precision means more aggressive rounding, but less risk of overflow.\n    /// Precision *must* be a number between 0 and 9 (inclusive).\n    ///\n    /// Returns `None` if the internal multiplication overflows.\n    fn sqrt_with_precision(&self, precision: u32) -> Option<Self> {\n}\n\n    pub fn abs_diff(self, other: Self) -> Self {\n}\n\n    pub fn saturating_add(self, other: Self) -> Self {\n}\n\n    pub fn saturating_sub(self, other: Self) -> Self {\n}\n\n    pub fn saturating_mul(self, other: Self) -> Self {\n}\n\n    pub fn saturating_pow(self, exp: u32) -> Self {\n}\n}\n\nimpl Fraction<Uint256> for Decimal256 {\n    #[inline]\n    fn numerator(&self) -> Uint256 {\n}\n\n    #[inline]\n    fn denominator(&self) -> Uint256 {\n}\n\n    /// Returns the multiplicative inverse `1/d` for decimal `d`.\n    ///\n    /// If `d` is zero, none is returned.\n    fn inv(&self) -> Option<Self> {\n}\n}\n\nimpl From<Decimal> for Decimal256 {\n    fn from(input: Decimal) -> Self {\n}\n}\n\nimpl FromStr for Decimal256 {\n    type Err = StdError;\n\n    /// Converts the decimal string to a Decimal256\n    /// Possible inputs: \"1.23\", \"1\", \"000012\", \"1.123000000\"\n    /// Disallowed: \"\", \".23\"\n    ///\n    /// This never performs any kind of rounding.\n    /// More than DECIMAL_PLACES fractional digits, even zeros, result in an error.\n    fn from_str(input: &str) -> Result<Self, Self::Err> {\n}\n}\n\nimpl fmt::Display for Decimal256 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\nimpl Add for Decimal256 {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Add, add for Decimal256, Decimal256);\n\nimpl AddAssign for Decimal256 {\n    fn add_assign(&mut self, rhs: Decimal256) {\n}\n}\nforward_ref_op_assign!(impl AddAssign, add_assign for Decimal256, Decimal256);\n\nimpl Sub for Decimal256 {\n    type Output = Self;\n\n    fn sub(self, other: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Sub, sub for Decimal256, Decimal256);\n\nimpl SubAssign for Decimal256 {\n    fn sub_assign(&mut self, rhs: Decimal256) {\n}\n}\nforward_ref_op_assign!(impl SubAssign, sub_assign for Decimal256, Decimal256);\n\nimpl Mul for Decimal256 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, other: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Mul, mul for Decimal256, Decimal256);\n\nimpl MulAssign for Decimal256 {\n    fn mul_assign(&mut self, rhs: Self) {\n}\n}\nforward_ref_op_assign!(impl MulAssign, mul_assign for Decimal256, Decimal256);\n\n/// Both d*u and u*d with d: Decimal256 and u: Uint256 returns an Uint256. There is no\n/// specific reason for this decision other than the initial use cases we have. If you\n/// need a Decimal256 result for the same calculation, use Decimal256(d*u) or Decimal256(u*d).\nimpl Mul<Decimal256> for Uint256 {\n    type Output = Self;\n\n    #[allow(clippy::suspicious_arithmetic_impl)]\n    fn mul(self, rhs: Decimal256) -> Self::Output {\n}\n}\n\nimpl Mul<Uint256> for Decimal256 {\n    type Output = Uint256;\n\n    fn mul(self, rhs: Uint256) -> Self::Output {\n}\n}\n\nimpl Div for Decimal256 {\n    type Output = Self;\n\n    fn div(self, other: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Div, div for Decimal256, Decimal256);\n\nimpl DivAssign for Decimal256 {\n    fn div_assign(&mut self, rhs: Decimal256) {\n}\n}\nforward_ref_op_assign!(impl DivAssign, div_assign for Decimal256, Decimal256);\n\nimpl Div<Uint256> for Decimal256 {\n    type Output = Self;\n\n    fn div(self, rhs: Uint256) -> Self::Output {\n}\n}\n\nimpl DivAssign<Uint256> for Decimal256 {\n    fn div_assign(&mut self, rhs: Uint256) {\n}\n}\n\nimpl Rem for Decimal256 {\n    type Output = Self;\n\n    /// # Panics\n    ///\n    /// This operation will panic if `rhs` is zero\n    #[inline]\n    fn rem(self, rhs: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Rem, rem for Decimal256, Decimal256);\n\nimpl RemAssign<Decimal256> for Decimal256 {\n    fn rem_assign(&mut self, rhs: Decimal256) {\n}\n}\nforward_ref_op_assign!(impl RemAssign, rem_assign for Decimal256, Decimal256);\n\nimpl<A> std::iter::Sum<A> for Decimal256\nwhere\n    Self: Add<A, Output = Self>,\n{\n    fn sum<I: Iterator<Item = A>>(iter: I) -> Self {\n}\n}\n\n/// Serializes as a decimal string\nimpl Serialize for Decimal256 {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n}\n}\n\n/// Deserializes as a base64 string\nimpl<'de> Deserialize<'de> for Decimal256 {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n}\n}\n\nstruct Decimal256Visitor;\n\nimpl<'de> de::Visitor<'de> for Decimal256Visitor {\n    type Value = Decimal256;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n}\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: de::Error,\n    {\n}\n    }\n}\n\nimpl PartialEq<&Decimal256> for Decimal256 {\n    fn eq(&self, rhs: &&Decimal256) -> bool {\n}\n}\n\nimpl PartialEq<Decimal256> for &Decimal256 {\n    fn eq(&self, rhs: &Decimal256) -> bool {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod fraction {\n/// A fraction `p`/`q` with integers `p` and `q`.\n///\n/// `p` is called the numerator and `q` is called the denominator.\npub trait Fraction<T>: Sized {\n    /// Returns the numerator `p`\n    fn numerator(&self) -> T;\n    /// Returns the denominator `q`\n    fn denominator(&self) -> T;\n\n    /// Returns the multiplicative inverse `q/p` for fraction `p/q`.\n    ///\n    /// If `p` is zero, None is returned.\n    fn inv(&self) -> Option<Self>;\n}\n}\nmod isqrt {\nuse std::{cmp, ops};\n\nuse crate::{Uint128, Uint256, Uint512, Uint64};\n\n/// A trait for calculating the\n/// [integer square root](https://en.wikipedia.org/wiki/Integer_square_root).\npub trait Isqrt {\n    /// The [integer square root](https://en.wikipedia.org/wiki/Integer_square_root).\n    fn isqrt(self) -> Self;\n}\n\nimpl<I> Isqrt for I\nwhere\n    I: Unsigned\n        + ops::Add<I, Output = I>\n        + ops::Div<I, Output = I>\n        + ops::Shr<u32, Output = I>\n        + cmp::PartialOrd\n        + Copy\n        + From<u8>,\n{\n    /// Algorithm adapted from\n    /// [Wikipedia](https://en.wikipedia.org/wiki/Integer_square_root#Example_implementation_in_C).\n    fn isqrt(self) -> Self {\n}\n}\n\n/// Marker trait for types that represent unsigned integers.\npub trait Unsigned {}\nimpl Unsigned for u8 {}\nimpl Unsigned for u16 {}\nimpl Unsigned for u32 {}\nimpl Unsigned for u64 {}\nimpl Unsigned for u128 {}\nimpl Unsigned for Uint64 {}\nimpl Unsigned for Uint128 {}\nimpl Unsigned for Uint256 {}\nimpl Unsigned for Uint512 {}\nimpl Unsigned for usize {}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod uint128 {\nuse forward_ref::{forward_ref_binop, forward_ref_op_assign};\nuse schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::fmt::{self};\nuse std::ops::{\n    Add, AddAssign, Div, DivAssign, Mul, MulAssign, Rem, RemAssign, Shr, ShrAssign, Sub, SubAssign,\n};\nuse std::str::FromStr;\n\nuse crate::errors::{\n    CheckedMultiplyRatioError, DivideByZeroError, OverflowError, OverflowOperation, StdError,\n};\nuse crate::{ConversionOverflowError, Uint256, Uint64};\n\n/// A thin wrapper around u128 that is using strings for JSON encoding/decoding,\n/// such that the full u128 range can be used for clients that convert JSON numbers to floats,\n/// like JavaScript and jq.\n///\n/// # Examples\n///\n/// Use `from` to create instances of this and `u128` to get the value out:\n///\n/// ```\n/// # use cosmwasm_std::Uint128;\n/// let a = Uint128::from(123u128);\n/// assert_eq!(a.u128(), 123);\n///\n/// let b = Uint128::from(42u64);\n/// assert_eq!(b.u128(), 42);\n///\n/// let c = Uint128::from(70u32);\n/// assert_eq!(c.u128(), 70);\n/// ```\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Uint128(#[schemars(with = \"String\")] u128);\n\nimpl Uint128 {\n    pub const MAX: Self = Self(u128::MAX);\n    pub const MIN: Self = Self(u128::MIN);\n\n    /// Creates a Uint128(value).\n    ///\n    /// This method is less flexible than `from` but can be called in a const context.\n    pub const fn new(value: u128) -> Self {\n}\n\n    /// Creates a Uint128(0)\n    #[inline]\n    pub const fn zero() -> Self {\n}\n\n    /// Creates a Uint128(1)\n    #[inline]\n    pub const fn one() -> Self {\n}\n\n    /// Returns a copy of the internal data\n    pub const fn u128(&self) -> u128 {\n}\n\n    /// Returns a copy of the number as big endian bytes.\n    pub const fn to_be_bytes(self) -> [u8; 16] {\n}\n\n    /// Returns a copy of the number as little endian bytes.\n    pub const fn to_le_bytes(self) -> [u8; 16] {\n}\n\n    pub const fn is_zero(&self) -> bool {\n}\n\n    pub fn pow(self, exp: u32) -> Self {\n}\n\n    /// Returns `self * numerator / denominator`.\n    ///\n    /// Due to the nature of the integer division involved, the result is always floored.\n    /// E.g. 5 * 99/100 = 4.\n    pub fn multiply_ratio<A: Into<u128>, B: Into<u128>>(\n        &self,\n        numerator: A,\n        denominator: B,\n    ) -> Uint128 {\n}\n\n    /// Returns `self * numerator / denominator`.\n    ///\n    /// Due to the nature of the integer division involved, the result is always floored.\n    /// E.g. 5 * 99/100 = 4.\n    pub fn checked_multiply_ratio<A: Into<u128>, B: Into<u128>>(\n        &self,\n        numerator: A,\n        denominator: B,\n    ) -> Result<Uint128, CheckedMultiplyRatioError> {\n}\n\n    /// Multiplies two u128 values without overflow, producing an\n    /// [`Uint256`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use cosmwasm_std::Uint128;\n    ///\n    /// let a = Uint128::MAX;\n    /// let result = a.full_mul(2u32);\n    /// assert_eq!(result.to_string(), \"680564733841876926926749214863536422910\");\n    /// ```\n    pub fn full_mul(self, rhs: impl Into<u128>) -> Uint256 {\n}\n\n    pub fn checked_add(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_sub(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_mul(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_pow(self, exp: u32) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_div(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    pub fn checked_div_euclid(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    pub fn checked_rem(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    #[inline]\n    pub fn wrapping_add(self, other: Self) -> Self {\n}\n\n    #[inline]\n    pub fn wrapping_sub(self, other: Self) -> Self {\n}\n\n    #[inline]\n    pub fn wrapping_mul(self, other: Self) -> Self {\n}\n\n    #[inline]\n    pub fn wrapping_pow(self, other: u32) -> Self {\n}\n\n    pub fn saturating_add(self, other: Self) -> Self {\n}\n\n    pub fn saturating_sub(self, other: Self) -> Self {\n}\n\n    pub fn saturating_mul(self, other: Self) -> Self {\n}\n\n    pub fn saturating_pow(self, exp: u32) -> Self {\n}\n\n    pub const fn abs_diff(self, other: Self) -> Self {\n}\n}\n\n// `From<u{128,64,32,16,8}>` is implemented manually instead of\n// using `impl<T: Into<u128>> From<T> for Uint128` because\n// of the conflict with `TryFrom<&str>` as described here\n// https://stackoverflow.com/questions/63136970/how-do-i-work-around-the-upstream-crates-may-add-a-new-impl-of-trait-error\n\nimpl From<Uint64> for Uint128 {\n    fn from(val: Uint64) -> Self {\n}\n}\n\nimpl From<u128> for Uint128 {\n    fn from(val: u128) -> Self {\n}\n}\n\nimpl From<u64> for Uint128 {\n    fn from(val: u64) -> Self {\n}\n}\n\nimpl From<u32> for Uint128 {\n    fn from(val: u32) -> Self {\n}\n}\n\nimpl From<u16> for Uint128 {\n    fn from(val: u16) -> Self {\n}\n}\n\nimpl From<u8> for Uint128 {\n    fn from(val: u8) -> Self {\n}\n}\n\nimpl TryFrom<Uint128> for Uint64 {\n    type Error = ConversionOverflowError;\n\n    fn try_from(value: Uint128) -> Result<Self, Self::Error> {\n}\n}\n\nimpl TryFrom<&str> for Uint128 {\n    type Error = StdError;\n\n    fn try_from(val: &str) -> Result<Self, Self::Error> {\n}\n}\n\nimpl FromStr for Uint128 {\n    type Err = StdError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n}\n}\n\nimpl From<Uint128> for String {\n    fn from(original: Uint128) -> Self {\n}\n}\n\nimpl From<Uint128> for u128 {\n    fn from(original: Uint128) -> Self {\n}\n}\n\nimpl fmt::Display for Uint128 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\nimpl Add<Uint128> for Uint128 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self {\n}\n}\n\nimpl<'a> Add<&'a Uint128> for Uint128 {\n    type Output = Self;\n\n    fn add(self, rhs: &'a Uint128) -> Self {\n}\n}\n\nimpl Sub<Uint128> for Uint128 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Sub, sub for Uint128, Uint128);\n\nimpl SubAssign<Uint128> for Uint128 {\n    fn sub_assign(&mut self, rhs: Uint128) {\n}\n}\nforward_ref_op_assign!(impl SubAssign, sub_assign for Uint128, Uint128);\n\nimpl Mul<Uint128> for Uint128 {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -> Self::Output {\n}\n}\nforward_ref_binop!(impl Mul, mul for Uint128, Uint128);\n\nimpl MulAssign<Uint128> for Uint128 {\n    fn mul_assign(&mut self, rhs: Self) {\n}\n}\nforward_ref_op_assign!(impl MulAssign, mul_assign for Uint128, Uint128);\n\nimpl Div<Uint128> for Uint128 {\n    type Output = Self;\n\n    fn div(self, rhs: Self) -> Self::Output {\n}\n}\n\nimpl<'a> Div<&'a Uint128> for Uint128 {\n    type Output = Self;\n\n    fn div(self, rhs: &'a Uint128) -> Self::Output {\n}\n}\n\nimpl Shr<u32> for Uint128 {\n    type Output = Self;\n\n    fn shr(self, rhs: u32) -> Self::Output {\n}\n}\n\nimpl<'a> Shr<&'a u32> for Uint128 {\n    type Output = Self;\n\n    fn shr(self, rhs: &'a u32) -> Self::Output {\n}\n}\n\nimpl AddAssign<Uint128> for Uint128 {\n    fn add_assign(&mut self, rhs: Uint128) {\n}\n}\n\nimpl<'a> AddAssign<&'a Uint128> for Uint128 {\n    fn add_assign(&mut self, rhs: &'a Uint128) {\n}\n}\n\nimpl DivAssign<Uint128> for Uint128 {\n    fn div_assign(&mut self, rhs: Self) {\n}\n}\n\nimpl<'a> DivAssign<&'a Uint128> for Uint128 {\n    fn div_assign(&mut self, rhs: &'a Uint128) {\n}\n}\n\nimpl Rem for Uint128 {\n    type Output = Self;\n\n    /// # Panics\n    ///\n    /// This operation will panic if `rhs` is zero.\n    #[inline]\n    fn rem(self, rhs: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Rem, rem for Uint128, Uint128);\n\nimpl RemAssign<Uint128> for Uint128 {\n    fn rem_assign(&mut self, rhs: Uint128) {\n}\n}\nforward_ref_op_assign!(impl RemAssign, rem_assign for Uint128, Uint128);\n\nimpl ShrAssign<u32> for Uint128 {\n    fn shr_assign(&mut self, rhs: u32) {\n}\n}\n\nimpl<'a> ShrAssign<&'a u32> for Uint128 {\n    fn shr_assign(&mut self, rhs: &'a u32) {\n}\n}\n\nimpl Serialize for Uint128 {\n    /// Serializes as an integer string using base 10\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n}\n}\n\nimpl<'de> Deserialize<'de> for Uint128 {\n    /// Deserialized from an integer string using base 10\n    fn deserialize<D>(deserializer: D) -> Result<Uint128, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n}\n}\n\nstruct Uint128Visitor;\n\nimpl<'de> de::Visitor<'de> for Uint128Visitor {\n    type Value = Uint128;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n}\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: de::Error,\n    {\n}\n    }\n}\n\nimpl<A> std::iter::Sum<A> for Uint128\nwhere\n    Self: Add<A, Output = Self>,\n{\n    fn sum<I: Iterator<Item = A>>(iter: I) -> Self {\n}\n}\n\nimpl PartialEq<&Uint128> for Uint128 {\n    fn eq(&self, rhs: &&Uint128) -> bool {\n}\n}\n\nimpl PartialEq<Uint128> for &Uint128 {\n    fn eq(&self, rhs: &Uint128) -> bool {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod uint256 {\nuse forward_ref::{forward_ref_binop, forward_ref_op_assign};\nuse schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::fmt;\nuse std::ops::{\n    Add, AddAssign, Div, DivAssign, Mul, MulAssign, Rem, RemAssign, Shl, Shr, ShrAssign, Sub,\n    SubAssign,\n};\nuse std::str::FromStr;\n\nuse crate::errors::{\n    CheckedMultiplyRatioError, ConversionOverflowError, DivideByZeroError, OverflowError,\n    OverflowOperation, StdError,\n};\nuse crate::{Uint128, Uint512, Uint64};\n\n/// This module is purely a workaround that lets us ignore lints for all the code\n/// the `construct_uint!` macro generates.\n#[allow(clippy::all)]\nmod uints {\n    uint::construct_uint! {\n        pub struct U256(4);\n    }\n}\n\n/// Used internally - we don't want to leak this type since we might change\n/// the implementation in the future.\nuse uints::U256;\n\n/// An implementation of u256 that is using strings for JSON encoding/decoding,\n/// such that the full u256 range can be used for clients that convert JSON numbers to floats,\n/// like JavaScript and jq.\n///\n/// # Examples\n///\n/// Use `from` to create instances out of primitive uint types or `new` to provide big\n/// endian bytes:\n///\n/// ```\n/// # use cosmwasm_std::Uint256;\n/// let a = Uint256::from(258u128);\n/// let b = Uint256::new([\n///     0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,\n///     0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,\n///     0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,\n///     0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 2u8,\n/// ]);\n/// assert_eq!(a, b);\n/// ```\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Uint256(#[schemars(with = \"String\")] U256);\n\nimpl Uint256 {\n    pub const MAX: Uint256 = Uint256(U256::MAX);\n    pub const MIN: Uint256 = Uint256(U256::zero());\n\n    /// Creates a Uint256(value) from a big endian representation. It's just an alias for\n    /// [`Uint256::from_be_bytes`].\n    ///\n    /// This method is less flexible than `from` but can be called in a const context.\n    pub const fn new(value: [u8; 32]) -> Self {\n}\n\n    /// Creates a Uint256(0)\n    #[inline]\n    pub const fn zero() -> Self {\n}\n\n    /// Creates a Uint256(1)\n    #[inline]\n    pub const fn one() -> Self {\n}\n\n    pub const fn from_be_bytes(data: [u8; 32]) -> Self {\n}\n\n    pub const fn from_le_bytes(data: [u8; 32]) -> Self {\n}\n\n    /// A conversion from `u128` that, unlike the one provided by the `From` trait,\n    /// can be used in a `const` context.\n    pub const fn from_u128(num: u128) -> Self {\n}\n\n    /// A conversion from `Uint128` that, unlike the one provided by the `From` trait,\n    /// can be used in a `const` context.\n    pub const fn from_uint128(num: Uint128) -> Self {\n}\n\n    /// Returns a copy of the number as big endian bytes.\n    pub const fn to_be_bytes(self) -> [u8; 32] {\n}\n\n    /// Returns a copy of the number as little endian bytes.\n    pub const fn to_le_bytes(self) -> [u8; 32] {\n}\n\n    pub const fn is_zero(&self) -> bool {\n}\n\n    pub fn pow(self, exp: u32) -> Self {\n}\n\n    /// Returns `self * numerator / denominator`.\n    ///\n    /// Due to the nature of the integer division involved, the result is always floored.\n    /// E.g. 5 * 99/100 = 4.\n    pub fn multiply_ratio<A: Into<Uint256>, B: Into<Uint256>>(\n        &self,\n        numerator: A,\n        denominator: B,\n    ) -> Uint256 {\n}\n\n    /// Returns `self * numerator / denominator`.\n    ///\n    /// Due to the nature of the integer division involved, the result is always floored.\n    /// E.g. 5 * 99/100 = 4.\n    pub fn checked_multiply_ratio<A: Into<Uint256>, B: Into<Uint256>>(\n        &self,\n        numerator: A,\n        denominator: B,\n    ) -> Result<Uint256, CheckedMultiplyRatioError> {\n}\n\n    /// Multiplies two u256 values without overflow, producing an\n    /// [`Uint512`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use cosmwasm_std::Uint256;\n    ///\n    /// let a = Uint256::MAX;\n    /// let result = a.full_mul(2u32);\n    /// assert_eq!(\n    ///     result.to_string(),\n    ///     \"231584178474632390847141970017375815706539969331281128078915168015826259279870\",\n    /// );\n    /// ```\n    pub fn full_mul(self, rhs: impl Into<Uint256>) -> Uint512 {\n}\n\n    pub fn checked_add(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_sub(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_mul(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_pow(self, exp: u32) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_div(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    pub fn checked_div_euclid(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    pub fn checked_rem(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    pub fn checked_shr(self, other: u32) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_shl(self, other: u32) -> Result<Self, OverflowError> {\n}\n\n    #[inline]\n    pub fn wrapping_add(self, other: Self) -> Self {\n}\n\n    #[inline]\n    pub fn wrapping_sub(self, other: Self) -> Self {\n}\n\n    #[inline]\n    pub fn wrapping_mul(self, other: Self) -> Self {\n}\n\n    #[inline]\n    pub fn wrapping_pow(self, other: u32) -> Self {\n}\n\n    pub fn saturating_add(self, other: Self) -> Self {\n}\n\n    pub fn saturating_sub(self, other: Self) -> Self {\n}\n\n    pub fn saturating_mul(self, other: Self) -> Self {\n}\n\n    pub fn saturating_pow(self, exp: u32) -> Self {\n}\n\n    pub fn abs_diff(self, other: Self) -> Self {\n}\n}\n\nimpl From<Uint128> for Uint256 {\n    fn from(val: Uint128) -> Self {\n}\n}\n\nimpl From<Uint64> for Uint256 {\n    fn from(val: Uint64) -> Self {\n}\n}\n\nimpl From<u128> for Uint256 {\n    fn from(val: u128) -> Self {\n}\n}\n\nimpl From<u64> for Uint256 {\n    fn from(val: u64) -> Self {\n}\n}\n\nimpl From<u32> for Uint256 {\n    fn from(val: u32) -> Self {\n}\n}\n\nimpl From<u16> for Uint256 {\n    fn from(val: u16) -> Self {\n}\n}\n\nimpl From<u8> for Uint256 {\n    fn from(val: u8) -> Self {\n}\n}\n\nimpl TryFrom<Uint256> for Uint128 {\n    type Error = ConversionOverflowError;\n\n    fn try_from(value: Uint256) -> Result<Self, Self::Error> {\n}\n}\n\nimpl TryFrom<&str> for Uint256 {\n    type Error = StdError;\n\n    fn try_from(val: &str) -> Result<Self, Self::Error> {\n}\n}\n\nimpl FromStr for Uint256 {\n    type Err = StdError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n}\n}\n\nimpl From<Uint256> for String {\n    fn from(original: Uint256) -> Self {\n}\n}\n\nimpl fmt::Display for Uint256 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\nimpl Add<Uint256> for Uint256 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self {\n}\n}\n\nimpl<'a> Add<&'a Uint256> for Uint256 {\n    type Output = Self;\n\n    fn add(self, rhs: &'a Uint256) -> Self {\n}\n}\n\nimpl Sub<Uint256> for Uint256 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Sub, sub for Uint256, Uint256);\n\nimpl SubAssign<Uint256> for Uint256 {\n    fn sub_assign(&mut self, rhs: Uint256) {\n}\n}\nforward_ref_op_assign!(impl SubAssign, sub_assign for Uint256, Uint256);\n\nimpl Div<Uint256> for Uint256 {\n    type Output = Self;\n\n    fn div(self, rhs: Self) -> Self::Output {\n}\n}\n\nimpl<'a> Div<&'a Uint256> for Uint256 {\n    type Output = Self;\n\n    fn div(self, rhs: &'a Uint256) -> Self::Output {\n}\n}\n\nimpl Rem for Uint256 {\n    type Output = Self;\n\n    /// # Panics\n    ///\n    /// This operation will panic if `rhs` is zero.\n    #[inline]\n    fn rem(self, rhs: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Rem, rem for Uint256, Uint256);\n\nimpl RemAssign<Uint256> for Uint256 {\n    fn rem_assign(&mut self, rhs: Uint256) {\n}\n}\nforward_ref_op_assign!(impl RemAssign, rem_assign for Uint256, Uint256);\n\nimpl Mul<Uint256> for Uint256 {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -> Self::Output {\n}\n}\nforward_ref_binop!(impl Mul, mul for Uint256, Uint256);\n\nimpl MulAssign<Uint256> for Uint256 {\n    fn mul_assign(&mut self, rhs: Self) {\n}\n}\nforward_ref_op_assign!(impl MulAssign, mul_assign for Uint256, Uint256);\n\nimpl Shr<u32> for Uint256 {\n    type Output = Self;\n\n    fn shr(self, rhs: u32) -> Self::Output {\n}\n}\n\nimpl<'a> Shr<&'a u32> for Uint256 {\n    type Output = Self;\n\n    fn shr(self, rhs: &'a u32) -> Self::Output {\n}\n}\n\nimpl Shl<u32> for Uint256 {\n    type Output = Self;\n\n    fn shl(self, rhs: u32) -> Self::Output {\n}\n}\n\nimpl<'a> Shl<&'a u32> for Uint256 {\n    type Output = Self;\n\n    fn shl(self, rhs: &'a u32) -> Self::Output {\n}\n}\n\nimpl AddAssign<Uint256> for Uint256 {\n    fn add_assign(&mut self, rhs: Uint256) {\n}\n}\n\nimpl<'a> AddAssign<&'a Uint256> for Uint256 {\n    fn add_assign(&mut self, rhs: &'a Uint256) {\n}\n}\n\nimpl DivAssign<Uint256> for Uint256 {\n    fn div_assign(&mut self, rhs: Self) {\n}\n}\n\nimpl<'a> DivAssign<&'a Uint256> for Uint256 {\n    fn div_assign(&mut self, rhs: &'a Uint256) {\n}\n}\n\nimpl ShrAssign<u32> for Uint256 {\n    fn shr_assign(&mut self, rhs: u32) {\n}\n}\n\nimpl<'a> ShrAssign<&'a u32> for Uint256 {\n    fn shr_assign(&mut self, rhs: &'a u32) {\n}\n}\n\nimpl Serialize for Uint256 {\n    /// Serializes as an integer string using base 10\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n}\n}\n\nimpl<'de> Deserialize<'de> for Uint256 {\n    /// Deserialized from an integer string using base 10\n    fn deserialize<D>(deserializer: D) -> Result<Uint256, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n}\n}\n\nstruct Uint256Visitor;\n\nimpl<'de> de::Visitor<'de> for Uint256Visitor {\n    type Value = Uint256;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n}\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: de::Error,\n    {\n}' - {}\", v, e)))\n    }\n}\n\nimpl<A> std::iter::Sum<A> for Uint256\nwhere\n    Self: Add<A, Output = Self>,\n{\n    fn sum<I: Iterator<Item = A>>(iter: I) -> Self {\n}\n}\n\nimpl PartialEq<&Uint256> for Uint256 {\n    fn eq(&self, rhs: &&Uint256) -> bool {\n}\n}\n\nimpl PartialEq<Uint256> for &Uint256 {\n    fn eq(&self, rhs: &Uint256) -> bool {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod uint512 {\nuse forward_ref::{forward_ref_binop, forward_ref_op_assign};\nuse schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::fmt;\nuse std::ops::{\n    Add, AddAssign, Div, DivAssign, Mul, MulAssign, Rem, RemAssign, Shr, ShrAssign, Sub, SubAssign,\n};\nuse std::str::FromStr;\n\nuse crate::errors::{\n    ConversionOverflowError, DivideByZeroError, OverflowError, OverflowOperation, StdError,\n};\nuse crate::{Uint128, Uint256, Uint64};\n\n/// This module is purely a workaround that lets us ignore lints for all the code\n/// the `construct_uint!` macro generates.\n#[allow(clippy::all)]\nmod uints {\n    uint::construct_uint! {\n        pub struct U512(8);\n    }\n}\n\n/// Used internally - we don't want to leak this type since we might change\n/// the implementation in the future.\nuse uints::U512;\n\n/// An implementation of u512 that is using strings for JSON encoding/decoding,\n/// such that the full u512 range can be used for clients that convert JSON numbers to floats,\n/// like JavaScript and jq.\n///\n/// # Examples\n///\n/// Use `from` to create instances out of primitive uint types or `new` to provide big\n/// endian bytes:\n///\n/// ```\n/// # use cosmwasm_std::Uint512;\n/// let a = Uint512::from(258u128);\n/// let b = Uint512::new([\n///     0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,\n///     0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,\n///     0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,\n///     0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,\n///     0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,\n///     0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,\n///     0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8,\n///     0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 1u8, 2u8,\n/// ]);\n/// assert_eq!(a, b);\n/// ```\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Uint512(#[schemars(with = \"String\")] U512);\n\nimpl Uint512 {\n    pub const MAX: Uint512 = Uint512(U512::MAX);\n    pub const MIN: Uint512 = Uint512(U512::zero());\n\n    /// Creates a Uint512(value) from a big endian representation. It's just an alias for\n    /// `from_big_endian`.\n    pub const fn new(value: [u8; 64]) -> Self {\n}\n\n    /// Creates a Uint512(0)\n    #[inline]\n    pub const fn zero() -> Self {\n}\n\n    /// Creates a Uint512(1)\n    #[inline]\n    pub const fn one() -> Self {\n}\n\n    pub const fn from_be_bytes(data: [u8; 64]) -> Self {\n}\n\n    pub const fn from_le_bytes(data: [u8; 64]) -> Self {\n}\n\n    /// A conversion from `Uint256` that, unlike the one provided by the `From` trait,\n    /// can be used in a `const` context.\n    pub const fn from_uint256(num: Uint256) -> Self {\n}\n\n    /// Returns a copy of the number as big endian bytes.\n    pub const fn to_be_bytes(self) -> [u8; 64] {\n}\n\n    /// Returns a copy of the number as little endian bytes.\n    pub const fn to_le_bytes(self) -> [u8; 64] {\n}\n\n    pub const fn is_zero(&self) -> bool {\n}\n\n    pub fn pow(self, exp: u32) -> Self {\n}\n\n    pub fn checked_add(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_sub(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_mul(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_pow(self, exp: u32) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_div(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    pub fn checked_div_euclid(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    pub fn checked_rem(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    pub fn checked_shr(self, other: u32) -> Result<Self, OverflowError> {\n}\n\n    #[inline]\n    pub fn wrapping_add(self, other: Self) -> Self {\n}\n\n    #[inline]\n    pub fn wrapping_sub(self, other: Self) -> Self {\n}\n\n    #[inline]\n    pub fn wrapping_mul(self, other: Self) -> Self {\n}\n\n    #[inline]\n    pub fn wrapping_pow(self, other: u32) -> Self {\n}\n\n    pub fn saturating_add(self, other: Self) -> Self {\n}\n\n    pub fn saturating_sub(self, other: Self) -> Self {\n}\n\n    pub fn saturating_mul(self, other: Self) -> Self {\n}\n\n    pub fn saturating_pow(self, exp: u32) -> Self {\n}\n\n    pub fn abs_diff(self, other: Self) -> Self {\n}\n}\n\nimpl From<Uint256> for Uint512 {\n    fn from(val: Uint256) -> Self {\n}\n}\n\nimpl From<Uint128> for Uint512 {\n    fn from(val: Uint128) -> Self {\n}\n}\n\nimpl From<Uint64> for Uint512 {\n    fn from(val: Uint64) -> Self {\n}\n}\n\nimpl From<u128> for Uint512 {\n    fn from(val: u128) -> Self {\n}\n}\n\nimpl From<u64> for Uint512 {\n    fn from(val: u64) -> Self {\n}\n}\n\nimpl From<u32> for Uint512 {\n    fn from(val: u32) -> Self {\n}\n}\n\nimpl From<u16> for Uint512 {\n    fn from(val: u16) -> Self {\n}\n}\n\nimpl From<u8> for Uint512 {\n    fn from(val: u8) -> Self {\n}\n}\n\nimpl TryFrom<Uint512> for Uint256 {\n    type Error = ConversionOverflowError;\n\n    fn try_from(value: Uint512) -> Result<Self, Self::Error> {\n}\n}\n\nimpl TryFrom<Uint512> for Uint128 {\n    type Error = ConversionOverflowError;\n\n    fn try_from(value: Uint512) -> Result<Self, Self::Error> {\n}\n}\n\nimpl TryFrom<&str> for Uint512 {\n    type Error = StdError;\n\n    fn try_from(val: &str) -> Result<Self, Self::Error> {\n}\n}\n\nimpl FromStr for Uint512 {\n    type Err = StdError;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n}\n}\n\nimpl From<Uint512> for String {\n    fn from(original: Uint512) -> Self {\n}\n}\n\nimpl fmt::Display for Uint512 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\nimpl Add<Uint512> for Uint512 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self {\n}\n}\n\nimpl<'a> Add<&'a Uint512> for Uint512 {\n    type Output = Self;\n\n    fn add(self, rhs: &'a Uint512) -> Self {\n}\n}\n\nimpl Sub<Uint512> for Uint512 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Sub, sub for Uint512, Uint512);\n\nimpl SubAssign<Uint512> for Uint512 {\n    fn sub_assign(&mut self, rhs: Uint512) {\n}\n}\nforward_ref_op_assign!(impl SubAssign, sub_assign for Uint512, Uint512);\n\nimpl Div<Uint512> for Uint512 {\n    type Output = Self;\n\n    fn div(self, rhs: Self) -> Self::Output {\n}\n}\n\nimpl<'a> Div<&'a Uint512> for Uint512 {\n    type Output = Self;\n\n    fn div(self, rhs: &'a Uint512) -> Self::Output {\n}\n}\n\nimpl Rem for Uint512 {\n    type Output = Self;\n\n    /// # Panics\n    ///\n    /// This operation will panic if `rhs` is zero.\n    #[inline]\n    fn rem(self, rhs: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Rem, rem for Uint512, Uint512);\n\nimpl RemAssign<Uint512> for Uint512 {\n    fn rem_assign(&mut self, rhs: Uint512) {\n}\n}\nforward_ref_op_assign!(impl RemAssign, rem_assign for Uint512, Uint512);\n\nimpl Mul<Uint512> for Uint512 {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -> Self::Output {\n}\n}\nforward_ref_binop!(impl Mul, mul for Uint512, Uint512);\n\nimpl MulAssign<Uint512> for Uint512 {\n    fn mul_assign(&mut self, rhs: Self) {\n}\n}\nforward_ref_op_assign!(impl MulAssign, mul_assign for Uint512, Uint512);\n\nimpl Shr<u32> for Uint512 {\n    type Output = Self;\n\n    fn shr(self, rhs: u32) -> Self::Output {\n}\n}\n\nimpl<'a> Shr<&'a u32> for Uint512 {\n    type Output = Self;\n\n    fn shr(self, rhs: &'a u32) -> Self::Output {\n}\n}\n\nimpl AddAssign<Uint512> for Uint512 {\n    fn add_assign(&mut self, rhs: Uint512) {\n}\n}\n\nimpl<'a> AddAssign<&'a Uint512> for Uint512 {\n    fn add_assign(&mut self, rhs: &'a Uint512) {\n}\n}\n\nimpl DivAssign<Uint512> for Uint512 {\n    fn div_assign(&mut self, rhs: Self) {\n}\n}\n\nimpl<'a> DivAssign<&'a Uint512> for Uint512 {\n    fn div_assign(&mut self, rhs: &'a Uint512) {\n}\n}\n\nimpl ShrAssign<u32> for Uint512 {\n    fn shr_assign(&mut self, rhs: u32) {\n}\n}\n\nimpl<'a> ShrAssign<&'a u32> for Uint512 {\n    fn shr_assign(&mut self, rhs: &'a u32) {\n}\n}\n\nimpl Serialize for Uint512 {\n    /// Serializes as an integer string using base 10\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n}\n}\n\nimpl<'de> Deserialize<'de> for Uint512 {\n    /// Deserialized from an integer string using base 10\n    fn deserialize<D>(deserializer: D) -> Result<Uint512, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n}\n}\n\nstruct Uint512Visitor;\n\nimpl<'de> de::Visitor<'de> for Uint512Visitor {\n    type Value = Uint512;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n}\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: de::Error,\n    {\n}' - {}\", v, e)))\n    }\n}\n\nimpl<A> std::iter::Sum<A> for Uint512\nwhere\n    Self: Add<A, Output = Self>,\n{\n    fn sum<I: Iterator<Item = A>>(iter: I) -> Self {\n}\n}\n\nimpl PartialEq<&Uint512> for Uint512 {\n    fn eq(&self, rhs: &&Uint512) -> bool {\n}\n}\n\nimpl PartialEq<Uint512> for &Uint512 {\n    fn eq(&self, rhs: &Uint512) -> bool {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod uint64 {\nuse forward_ref::{forward_ref_binop, forward_ref_op_assign};\nuse schemars::JsonSchema;\nuse serde::{de, ser, Deserialize, Deserializer, Serialize};\nuse std::fmt::{self};\nuse std::ops::{\n    Add, AddAssign, Div, DivAssign, Mul, MulAssign, Rem, RemAssign, Shr, ShrAssign, Sub, SubAssign,\n};\n\nuse crate::errors::{\n    CheckedMultiplyRatioError, DivideByZeroError, OverflowError, OverflowOperation, StdError,\n};\nuse crate::Uint128;\n\n/// A thin wrapper around u64 that is using strings for JSON encoding/decoding,\n/// such that the full u64 range can be used for clients that convert JSON numbers to floats,\n/// like JavaScript and jq.\n///\n/// # Examples\n///\n/// Use `from` to create instances of this and `u64` to get the value out:\n///\n/// ```\n/// # use cosmwasm_std::Uint64;\n/// let a = Uint64::from(42u64);\n/// assert_eq!(a.u64(), 42);\n///\n/// let b = Uint64::from(70u32);\n/// assert_eq!(b.u64(), 70);\n/// ```\n#[derive(Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema)]\npub struct Uint64(#[schemars(with = \"String\")] u64);\n\nimpl Uint64 {\n    pub const MAX: Self = Self(u64::MAX);\n    pub const MIN: Self = Self(u64::MIN);\n\n    /// Creates a Uint64(value).\n    ///\n    /// This method is less flexible than `from` but can be called in a const context.\n    pub const fn new(value: u64) -> Self {\n}\n\n    /// Creates a Uint64(0)\n    #[inline]\n    pub const fn zero() -> Self {\n}\n\n    /// Creates a Uint64(1)\n    #[inline]\n    pub const fn one() -> Self {\n}\n\n    /// Returns a copy of the internal data\n    pub const fn u64(&self) -> u64 {\n}\n\n    /// Returns a copy of the number as big endian bytes.\n    pub const fn to_be_bytes(self) -> [u8; 8] {\n}\n\n    /// Returns a copy of the number as little endian bytes.\n    pub const fn to_le_bytes(self) -> [u8; 8] {\n}\n\n    pub const fn is_zero(&self) -> bool {\n}\n\n    pub fn pow(self, exp: u32) -> Self {\n}\n\n    /// Returns `self * numerator / denominator`.\n    ///\n    /// Due to the nature of the integer division involved, the result is always floored.\n    /// E.g. 5 * 99/100 = 4.\n    pub fn multiply_ratio<A: Into<u64>, B: Into<u64>>(\n        &self,\n        numerator: A,\n        denominator: B,\n    ) -> Uint64 {\n}\n\n    /// Returns `self * numerator / denominator`.\n    ///\n    /// Due to the nature of the integer division involved, the result is always floored.\n    /// E.g. 5 * 99/100 = 4.\n    pub fn checked_multiply_ratio<A: Into<u64>, B: Into<u64>>(\n        &self,\n        numerator: A,\n        denominator: B,\n    ) -> Result<Uint64, CheckedMultiplyRatioError> {\n}\n\n    /// Multiplies two `Uint64`/`u64` values without overflow, producing an\n    /// [`Uint128`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use cosmwasm_std::Uint64;\n    ///\n    /// let a = Uint64::MAX;\n    /// let result = a.full_mul(2u32);\n    /// assert_eq!(result.to_string(), \"36893488147419103230\");\n    /// ```\n    pub fn full_mul(self, rhs: impl Into<u64>) -> Uint128 {\n}\n\n    pub fn checked_add(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_sub(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_mul(self, other: Self) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_pow(self, exp: u32) -> Result<Self, OverflowError> {\n}\n\n    pub fn checked_div(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    pub fn checked_div_euclid(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    pub fn checked_rem(self, other: Self) -> Result<Self, DivideByZeroError> {\n}\n\n    #[inline]\n    pub fn wrapping_add(self, other: Self) -> Self {\n}\n\n    #[inline]\n    pub fn wrapping_sub(self, other: Self) -> Self {\n}\n\n    #[inline]\n    pub fn wrapping_mul(self, other: Self) -> Self {\n}\n\n    #[inline]\n    pub fn wrapping_pow(self, other: u32) -> Self {\n}\n\n    pub fn saturating_add(self, other: Self) -> Self {\n}\n\n    pub fn saturating_sub(self, other: Self) -> Self {\n}\n\n    pub fn saturating_mul(self, other: Self) -> Self {\n}\n\n    pub fn saturating_pow(self, exp: u32) -> Self {\n}\n\n    pub const fn abs_diff(self, other: Self) -> Self {\n}\n}\n\n// `From<u{128,64,32,16,8}>` is implemented manually instead of\n// using `impl<T: Into<u64>> From<T> for Uint64` because\n// of the conflict with `TryFrom<&str>` as described here\n// https://stackoverflow.com/questions/63136970/how-do-i-work-around-the-upstream-crates-may-add-a-new-impl-of-trait-error\n\nimpl From<u64> for Uint64 {\n    fn from(val: u64) -> Self {\n}\n}\n\nimpl From<u32> for Uint64 {\n    fn from(val: u32) -> Self {\n}\n}\n\nimpl From<u16> for Uint64 {\n    fn from(val: u16) -> Self {\n}\n}\n\nimpl From<u8> for Uint64 {\n    fn from(val: u8) -> Self {\n}\n}\n\nimpl TryFrom<&str> for Uint64 {\n    type Error = StdError;\n\n    fn try_from(val: &str) -> Result<Self, Self::Error> {\n}\n}\n\nimpl From<Uint64> for String {\n    fn from(original: Uint64) -> Self {\n}\n}\n\nimpl From<Uint64> for u64 {\n    fn from(original: Uint64) -> Self {\n}\n}\n\nimpl fmt::Display for Uint64 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\nimpl Add<Uint64> for Uint64 {\n    type Output = Self;\n\n    fn add(self, rhs: Self) -> Self {\n}\n}\n\nimpl<'a> Add<&'a Uint64> for Uint64 {\n    type Output = Self;\n\n    fn add(self, rhs: &'a Uint64) -> Self {\n}\n}\n\nimpl Sub<Uint64> for Uint64 {\n    type Output = Self;\n\n    fn sub(self, rhs: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Sub, sub for Uint64, Uint64);\n\nimpl SubAssign<Uint64> for Uint64 {\n    fn sub_assign(&mut self, rhs: Uint64) {\n}\n}\nforward_ref_op_assign!(impl SubAssign, sub_assign for Uint64, Uint64);\n\nimpl Mul<Uint64> for Uint64 {\n    type Output = Self;\n\n    fn mul(self, rhs: Self) -> Self::Output {\n}\n}\nforward_ref_binop!(impl Mul, mul for Uint64, Uint64);\n\nimpl MulAssign<Uint64> for Uint64 {\n    fn mul_assign(&mut self, rhs: Self) {\n}\n}\nforward_ref_op_assign!(impl MulAssign, mul_assign for Uint64, Uint64);\n\nimpl Div<Uint64> for Uint64 {\n    type Output = Self;\n\n    fn div(self, rhs: Self) -> Self::Output {\n}\n}\n\nimpl<'a> Div<&'a Uint64> for Uint64 {\n    type Output = Self;\n\n    fn div(self, rhs: &'a Uint64) -> Self::Output {\n}\n}\n\nimpl Rem for Uint64 {\n    type Output = Self;\n\n    /// # Panics\n    ///\n    /// This operation will panic if `rhs` is zero.\n    #[inline]\n    fn rem(self, rhs: Self) -> Self {\n}\n}\nforward_ref_binop!(impl Rem, rem for Uint64, Uint64);\n\nimpl RemAssign<Uint64> for Uint64 {\n    fn rem_assign(&mut self, rhs: Uint64) {\n}\n}\nforward_ref_op_assign!(impl RemAssign, rem_assign for Uint64, Uint64);\n\nimpl Shr<u32> for Uint64 {\n    type Output = Self;\n\n    fn shr(self, rhs: u32) -> Self::Output {\n}\n}\n\nimpl<'a> Shr<&'a u32> for Uint64 {\n    type Output = Self;\n\n    fn shr(self, rhs: &'a u32) -> Self::Output {\n}\n}\n\nimpl AddAssign<Uint64> for Uint64 {\n    fn add_assign(&mut self, rhs: Uint64) {\n}\n}\n\nimpl<'a> AddAssign<&'a Uint64> for Uint64 {\n    fn add_assign(&mut self, rhs: &'a Uint64) {\n}\n}\n\nimpl DivAssign<Uint64> for Uint64 {\n    fn div_assign(&mut self, rhs: Self) {\n}\n}\n\nimpl<'a> DivAssign<&'a Uint64> for Uint64 {\n    fn div_assign(&mut self, rhs: &'a Uint64) {\n}\n}\n\nimpl ShrAssign<u32> for Uint64 {\n    fn shr_assign(&mut self, rhs: u32) {\n}\n}\n\nimpl<'a> ShrAssign<&'a u32> for Uint64 {\n    fn shr_assign(&mut self, rhs: &'a u32) {\n}\n}\n\nimpl Serialize for Uint64 {\n    /// Serializes as an integer string using base 10\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: ser::Serializer,\n    {\n}\n}\n\nimpl<'de> Deserialize<'de> for Uint64 {\n    /// Deserialized from an integer string using base 10\n    fn deserialize<D>(deserializer: D) -> Result<Uint64, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n}\n}\n\nstruct Uint64Visitor;\n\nimpl<'de> de::Visitor<'de> for Uint64Visitor {\n    type Value = Uint64;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n}\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: de::Error,\n    {\n}\n    }\n}\n\nimpl<A> std::iter::Sum<A> for Uint64\nwhere\n    Self: Add<A, Output = Self>,\n{\n    fn sum<I: Iterator<Item = A>>(iter: I) -> Self {\n}\n}\n\nimpl PartialEq<&Uint64> for Uint64 {\n    fn eq(&self, rhs: &&Uint64) -> bool {\n}\n}\n\nimpl PartialEq<Uint64> for &Uint64 {\n    fn eq(&self, rhs: &Uint64) -> bool {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\n\npub use decimal::{Decimal, DecimalRangeExceeded};\npub use decimal256::{Decimal256, Decimal256RangeExceeded};\npub use fraction::Fraction;\npub use isqrt::Isqrt;\npub use uint128::Uint128;\npub use uint256::Uint256;\npub use uint512::Uint512;\npub use uint64::Uint64;\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod panic {\n/// Installs a panic handler that aborts the contract execution\n/// and sends the panic message and location to the host.\n///\n/// This overrides any previous panic handler. See <https://doc.rust-lang.org/std/panic/fn.set_hook.html>\n/// for details.\n#[cfg(all(feature = \"abort\", target_arch = \"wasm32\"))]\npub fn install_panic_handler() {\n}\n}\nmod query {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n#[cfg(feature = \"stargate\")]\nuse crate::Binary;\nuse crate::Empty;\n\nmod bank {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::Coin;\n\n#[non_exhaustive]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum BankQuery {\n    /// This calls into the native bank module for querying the total supply of one denomination.\n    /// It does the same as the SupplyOf call in Cosmos SDK's RPC API.\n    /// Return value is of type SupplyResponse.\n    #[cfg(feature = \"cosmwasm_1_1\")]\n    Supply { denom: String },\n    /// This calls into the native bank module for one denomination\n    /// Return value is BalanceResponse\n    Balance { address: String, denom: String },\n    /// This calls into the native bank module for all denominations.\n    /// Note that this may be much more expensive than Balance and should be avoided if possible.\n    /// Return value is AllBalanceResponse.\n    AllBalances { address: String },\n}\n\n#[cfg(feature = \"cosmwasm_1_1\")]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\n#[non_exhaustive]\npub struct SupplyResponse {\n    /// Always returns a Coin with the requested denom.\n    /// This will be of zero amount if the denom does not exist.\n    pub amount: Coin,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct BalanceResponse {\n    /// Always returns a Coin with the requested denom.\n    /// This may be of 0 amount if no such funds.\n    pub amount: Coin,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct AllBalanceResponse {\n    /// Returns all non-zero coins held by this account.\n    pub amount: Vec<Coin>,\n}\n}\nmod ibc {\n#![cfg(feature = \"stargate\")]\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::ibc::IbcChannel;\n\n/// These are queries to the various IBC modules to see the state of the contract's\n/// IBC connection. These will return errors if the contract is not \"ibc enabled\"\n#[non_exhaustive]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum IbcQuery {\n    /// Gets the Port ID the current contract is bound to.\n    ///\n    /// Returns a `PortIdResponse`.\n    PortId {},\n    /// Lists all channels that are bound to a given port.\n    /// If `port_id` is omitted, this list all channels bound to the contract's port.\n    ///\n    /// Returns a `ListChannelsResponse`.\n    ListChannels { port_id: Option<String> },\n    /// Lists all information for a (portID, channelID) pair.\n    /// If port_id is omitted, it will default to the contract's own channel.\n    /// (To save a PortId{} call)\n    ///\n    /// Returns a `ChannelResponse`.\n    Channel {\n        channel_id: String,\n        port_id: Option<String>,\n    },\n    // TODO: Add more\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct PortIdResponse {\n    pub port_id: String,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct ListChannelsResponse {\n    pub channels: Vec<IbcChannel>,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct ChannelResponse {\n    pub channel: Option<IbcChannel>,\n}\n}\nmod staking {\n#![cfg(feature = \"staking\")]\n\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{Addr, Coin, Decimal};\n\n#[non_exhaustive]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum StakingQuery {\n    /// Returns the denomination that can be bonded (if there are multiple native tokens on the chain)\n    BondedDenom {},\n    /// AllDelegations will return all delegations by the delegator\n    AllDelegations { delegator: String },\n    /// Delegation will return more detailed info on a particular\n    /// delegation, defined by delegator/validator pair\n    Delegation {\n        delegator: String,\n        validator: String,\n    },\n    /// Returns all validators in the currently active validator set.\n    ///\n    /// The query response type is `AllValidatorsResponse`.\n    AllValidators {},\n    /// Returns the validator at the given address. Returns None if the validator is\n    /// not part of the currently active validator set.\n    ///\n    /// The query response type is `ValidatorResponse`.\n    Validator {\n        /// The validator's address (e.g. (e.g. cosmosvaloper1...))\n        address: String,\n    },\n}\n\n/// BondedDenomResponse is data format returned from StakingRequest::BondedDenom query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct BondedDenomResponse {\n    pub denom: String,\n}\n\n/// DelegationsResponse is data format returned from StakingRequest::AllDelegations query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct AllDelegationsResponse {\n    pub delegations: Vec<Delegation>,\n}\n\n/// Delegation is basic (cheap to query) data about a delegation.\n///\n/// Instances are created in the querier.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct Delegation {\n    pub delegator: Addr,\n    /// A validator address (e.g. cosmosvaloper1...)\n    pub validator: String,\n    /// How much we have locked in the delegation\n    pub amount: Coin,\n}\n\nimpl From<FullDelegation> for Delegation {\n    fn from(full: FullDelegation) -> Self {\n}\n}\n\n/// DelegationResponse is data format returned from StakingRequest::Delegation query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub struct DelegationResponse {\n    pub delegation: Option<FullDelegation>,\n}\n\n/// FullDelegation is all the info on the delegation, some (like accumulated_reward and can_redelegate)\n/// is expensive to query.\n///\n/// Instances are created in the querier.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct FullDelegation {\n    pub delegator: Addr,\n    /// A validator address (e.g. cosmosvaloper1...)\n    pub validator: String,\n    /// How much we have locked in the delegation\n    pub amount: Coin,\n    /// can_redelegate captures how much can be immediately redelegated.\n    /// 0 is no redelegation and can_redelegate == amount is redelegate all\n    /// but there are many places between the two\n    pub can_redelegate: Coin,\n    /// How much we can currently withdraw\n    pub accumulated_rewards: Vec<Coin>,\n}\n\n/// The data format returned from StakingRequest::AllValidators query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct AllValidatorsResponse {\n    pub validators: Vec<Validator>,\n}\n\n/// The data format returned from StakingRequest::Validator query\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct ValidatorResponse {\n    pub validator: Option<Validator>,\n}\n\n/// Instances are created in the querier.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct Validator {\n    /// A validator address (e.g. cosmosvaloper1...)\n    pub address: String,\n    pub commission: Decimal,\n    pub max_commission: Decimal,\n    /// TODO: what units are these (in terms of time)?\n    pub max_change_rate: Decimal,\n}\n}\nmod wasm {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::Binary;\n\n#[non_exhaustive]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum WasmQuery {\n    /// this queries the public API of another contract at a known address (with known ABI)\n    /// Return value is whatever the contract returns (caller should know), wrapped in a\n    /// ContractResult that is JSON encoded.\n    Smart {\n        contract_addr: String,\n        /// msg is the json-encoded QueryMsg struct\n        msg: Binary,\n    },\n    /// this queries the raw kv-store of the contract.\n    /// returns the raw, unparsed data stored at that key, which may be an empty vector if not present\n    Raw {\n        contract_addr: String,\n        /// Key is the raw key used in the contracts Storage\n        key: Binary,\n    },\n    /// returns a ContractInfoResponse with metadata on the contract from the runtime\n    ContractInfo { contract_addr: String },\n}\n\n#[non_exhaustive]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct ContractInfoResponse {\n    pub code_id: u64,\n    /// address that instantiated this contract\n    pub creator: String,\n    /// admin who can run migrations (if any)\n    pub admin: Option<String>,\n    /// if set, the contract is pinned to the cache, and thus uses less gas when called\n    pub pinned: bool,\n    /// set if this contract has bound an IBC port\n    pub ibc_port: Option<String>,\n}\n\nimpl ContractInfoResponse {\n    /// Convenience constructor for tests / mocks\n    #[doc(hidden)]\n    pub fn new(code_id: u64, creator: impl Into<String>) -> Self {\n}\n}\n}\n\n#[cfg(feature = \"cosmwasm_1_1\")]\npub use bank::SupplyResponse;\npub use bank::{AllBalanceResponse, BalanceResponse, BankQuery};\n#[cfg(feature = \"stargate\")]\npub use ibc::{ChannelResponse, IbcQuery, ListChannelsResponse, PortIdResponse};\n#[cfg(feature = \"staking\")]\npub use staking::{\n    AllDelegationsResponse, AllValidatorsResponse, BondedDenomResponse, Delegation,\n    DelegationResponse, FullDelegation, StakingQuery, Validator, ValidatorResponse,\n};\npub use wasm::{ContractInfoResponse, WasmQuery};\n\n#[non_exhaustive]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum QueryRequest<C> {\n    Bank(BankQuery),\n    Custom(C),\n    #[cfg(feature = \"staking\")]\n    Staking(StakingQuery),\n    /// A Stargate query is encoded the same way as abci_query, with path and protobuf encoded request data.\n    /// The format is defined in [ADR-21](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-021-protobuf-query-encoding.md).\n    /// The response is protobuf encoded data directly without a JSON response wrapper.\n    /// The caller is responsible for compiling the proper protobuf definitions for both requests and responses.\n    #[cfg(feature = \"stargate\")]\n    Stargate {\n        /// this is the fully qualified service path used for routing,\n        /// eg. custom/cosmos_sdk.x.bank.v1.Query/QueryBalance\n        path: String,\n        /// this is the expected protobuf message type (not any), binary encoded\n        data: Binary,\n    },\n    #[cfg(feature = \"stargate\")]\n    Ibc(IbcQuery),\n    Wasm(WasmQuery),\n}\n\n/// A trait that is required to avoid conflicts with other query types like BankQuery and WasmQuery\n/// in generic implementations.\n/// You need to implement it in your custom query type.\n///\n/// # Examples\n///\n/// ```\n/// # use cosmwasm_std::CustomQuery;\n/// # use schemars::JsonSchema;\n/// # use serde::{Deserialize, Serialize};\n/// #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n/// #[serde(rename_all = \"snake_case\")]\n/// pub enum MyCustomQuery {\n///     Ping {},\n///     Capitalized { text: String },\n/// }\n///\n/// impl CustomQuery for MyCustomQuery {}\n/// ```\npub trait CustomQuery: Serialize + Clone {}\n// We require `Clone` because `Clone` in `QueryRequest<C>` is only derived for\n// `C: Clone` and we want consistent behaviour for all `QueryRequest<C>`\n\nimpl CustomQuery for Empty {}\n\nimpl<C: CustomQuery> From<BankQuery> for QueryRequest<C> {\n    fn from(msg: BankQuery) -> Self {\n}\n}\n\nimpl<C: CustomQuery> From<C> for QueryRequest<C> {\n    fn from(msg: C) -> Self {\n}\n}\n\n#[cfg(feature = \"staking\")]\nimpl<C: CustomQuery> From<StakingQuery> for QueryRequest<C> {\n    fn from(msg: StakingQuery) -> Self {\n}\n}\n\nimpl<C: CustomQuery> From<WasmQuery> for QueryRequest<C> {\n    fn from(msg: WasmQuery) -> Self {\n}\n}\n\n#[cfg(feature = \"stargate\")]\nimpl<C: CustomQuery> From<IbcQuery> for QueryRequest<C> {\n    fn from(msg: IbcQuery) -> Self {\n}\n}\n}\nmod results {\n//! This module contains the messages that are sent from the contract to the VM as an execution result\n\nmod contract_result {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// This is the final result type that is created and serialized in a contract for\n/// every init/execute/migrate call. The VM then deserializes this type to distinguish\n/// between successful and failed executions.\n///\n/// We use a custom type here instead of Rust's Result because we want to be able to\n/// define the serialization, which is a public interface. Every language that compiles\n/// to Wasm and runs in the ComsWasm VM needs to create the same JSON representation.\n///\n/// # Examples\n///\n/// Success:\n///\n/// ```\n/// # use cosmwasm_std::{to_vec, ContractResult, Response};\n/// let response: Response = Response::default();\n/// let result: ContractResult<Response> = ContractResult::Ok(response);\n/// assert_eq!(to_vec(&result).unwrap(), br#\"{\"ok\":{\"messages\":[],\"attributes\":[],\"events\":[],\"data\":null}}\"#);\n/// ```\n///\n/// Failure:\n///\n/// ```\n/// # use cosmwasm_std::{to_vec, ContractResult, Response};\n/// let error_msg = String::from(\"Something went wrong\");\n/// let result: ContractResult<Response> = ContractResult::Err(error_msg);\n/// assert_eq!(to_vec(&result).unwrap(), br#\"{\"error\":\"Something went wrong\"}\"#);\n/// ```\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ContractResult<S> {\n    Ok(S),\n    /// An error type that every custom error created by contract developers can be converted to.\n    /// This could potientially have more structure, but String is the easiest.\n    #[serde(rename = \"error\")]\n    Err(String),\n}\n\n// Implementations here mimic the Result API and should be implemented via a conversion to Result\n// to ensure API consistency\nimpl<S> ContractResult<S> {\n    /// Converts a `ContractResult<S>` to a `Result<S, String>` as a convenient way\n    /// to access the full Result API.\n    pub fn into_result(self) -> Result<S, String> {\n}\n\n    pub fn unwrap(self) -> S {\n}\n\n    pub fn is_ok(&self) -> bool {\n}\n\n    pub fn is_err(&self) -> bool {\n}\n}\n\nimpl<S: fmt::Debug> ContractResult<S> {\n    pub fn unwrap_err(self) -> String {\n}\n}\n\nimpl<S, E: ToString> From<Result<S, E>> for ContractResult<S> {\n    fn from(original: Result<S, E>) -> ContractResult<S> {\n}\n}\n\nimpl<S> From<ContractResult<S>> for Result<S, String> {\n    fn from(original: ContractResult<S>) -> Result<S, String> {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod cosmos_msg {\nuse derivative::Derivative;\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\nuse crate::binary::Binary;\nuse crate::coin::Coin;\nuse crate::errors::StdResult;\n#[cfg(feature = \"stargate\")]\nuse crate::ibc::IbcMsg;\nuse crate::serde::to_binary;\n#[cfg(all(feature = \"stargate\", feature = \"cosmwasm_1_2\"))]\nuse crate::Decimal;\n\nuse super::Empty;\n\n/// Like CustomQuery for better type clarity.\n/// Also makes it shorter to use as a trait bound.\npub trait CustomMsg: Serialize + Clone + fmt::Debug + PartialEq + JsonSchema {}\n\nimpl CustomMsg for Empty {}\n\n#[non_exhaustive]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\n// See https://github.com/serde-rs/serde/issues/1296 why we cannot add De-Serialize trait bounds to T\npub enum CosmosMsg<T = Empty> {\n    Bank(BankMsg),\n    // by default we use RawMsg, but a contract can override that\n    // to call into more app-specific code (whatever they define)\n    Custom(T),\n    #[cfg(feature = \"staking\")]\n    Staking(StakingMsg),\n    #[cfg(feature = \"staking\")]\n    Distribution(DistributionMsg),\n    /// A Stargate message encoded the same way as a protobuf [Any](https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/any.proto).\n    /// This is the same structure as messages in `TxBody` from [ADR-020](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-020-protobuf-transaction-encoding.md)\n    #[cfg(feature = \"stargate\")]\n    Stargate {\n        type_url: String,\n        value: Binary,\n    },\n    #[cfg(feature = \"stargate\")]\n    Ibc(IbcMsg),\n    Wasm(WasmMsg),\n    #[cfg(feature = \"stargate\")]\n    Gov(GovMsg),\n}\n\n/// The message types of the bank module.\n///\n/// See https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto\n#[non_exhaustive]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum BankMsg {\n    /// Sends native tokens from the contract to the given address.\n    ///\n    /// This is translated to a [MsgSend](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/bank/v1beta1/tx.proto#L19-L28).\n    /// `from_address` is automatically filled with the current contract's address.\n    Send {\n        to_address: String,\n        amount: Vec<Coin>,\n    },\n    /// This will burn the given coins from the contract's account.\n    /// There is no Cosmos SDK message that performs this, but it can be done by calling the bank keeper.\n    /// Important if a contract controls significant token supply that must be retired.\n    Burn { amount: Vec<Coin> },\n}\n\n/// The message types of the staking module.\n///\n/// See https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto\n#[cfg(feature = \"staking\")]\n#[non_exhaustive]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum StakingMsg {\n    /// This is translated to a [MsgDelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L81-L90).\n    /// `delegator_address` is automatically filled with the current contract's address.\n    Delegate { validator: String, amount: Coin },\n    /// This is translated to a [MsgUndelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L112-L121).\n    /// `delegator_address` is automatically filled with the current contract's address.\n    Undelegate { validator: String, amount: Coin },\n    /// This is translated to a [MsgBeginRedelegate](https://github.com/cosmos/cosmos-sdk/blob/v0.40.0/proto/cosmos/staking/v1beta1/tx.proto#L95-L105).\n    /// `delegator_address` is automatically filled with the current contract's address.\n    Redelegate {\n        src_validator: String,\n        dst_validator: String,\n        amount: Coin,\n    },\n}\n\n/// The message types of the distribution module.\n///\n/// See https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto\n#[cfg(feature = \"staking\")]\n#[non_exhaustive]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum DistributionMsg {\n    /// This is translated to a [MsgSetWithdrawAddress](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L29-L37).\n    /// `delegator_address` is automatically filled with the current contract's address.\n    SetWithdrawAddress {\n        /// The `withdraw_address`\n        address: String,\n    },\n    /// This is translated to a [[MsgWithdrawDelegatorReward](https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/proto/cosmos/distribution/v1beta1/tx.proto#L42-L50).\n    /// `delegator_address` is automatically filled with the current contract's address.\n    WithdrawDelegatorReward {\n        /// The `validator_address`\n        validator: String,\n    },\n}\n\nfn binary_to_string(data: &Binary, fmt: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n}\n\n/// The message types of the wasm module.\n///\n/// See https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto\n#[non_exhaustive]\n#[derive(Serialize, Deserialize, Clone, Derivative, PartialEq, Eq, JsonSchema)]\n#[derivative(Debug)]\n#[serde(rename_all = \"snake_case\")]\npub enum WasmMsg {\n    /// Dispatches a call to another contract at a known address (with known ABI).\n    ///\n    /// This is translated to a [MsgExecuteContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L68-L78).\n    /// `sender` is automatically filled with the current contract's address.\n    Execute {\n        contract_addr: String,\n        /// msg is the json-encoded ExecuteMsg struct (as raw Binary)\n        #[derivative(Debug(format_with = \"binary_to_string\"))]\n        msg: Binary,\n        funds: Vec<Coin>,\n    },\n    /// Instantiates a new contracts from previously uploaded Wasm code.\n    ///\n    /// This is translated to a [MsgInstantiateContract](https://github.com/CosmWasm/wasmd/blob/v0.16.0-alpha1/x/wasm/internal/types/tx.proto#L47-L61).\n    /// `sender` is automatically filled with the current contract's address.\n    Instantiate {\n        admin: Option<String>,\n        code_id: u64,\n        /// msg is the JSON-encoded InstantiateMsg struct (as raw Binary)\n        #[derivative(Debug(format_with = \"binary_to_string\"))]\n        msg: Binary,\n        funds: Vec<Coin>,\n        /// A human-readbale label for the contract\n        label: String,\n    },\n    /// Migrates a given contracts to use new wasm code. Passes a MigrateMsg to allow us to\n    /// customize behavior.\n    ///\n    /// Only the contract admin (as defined in wasmd), if any, is able to make this call.\n    ///\n    /// This is translated to a [MsgMigrateContract](https://github.com/CosmWasm/wasmd/blob/v0.14.0/x/wasm/internal/types/tx.proto#L86-L96).\n    /// `sender` is automatically filled with the current contract's address.\n    Migrate {\n        contract_addr: String,\n        /// the code_id of the new logic to place in the given contract\n        new_code_id: u64,\n        /// msg is the json-encoded MigrateMsg struct that will be passed to the new code\n        #[derivative(Debug(format_with = \"binary_to_string\"))]\n        msg: Binary,\n    },\n    /// Sets a new admin (for migrate) on the given contract.\n    /// Fails if this contract is not currently admin of the target contract.\n    UpdateAdmin {\n        contract_addr: String,\n        admin: String,\n    },\n    /// Clears the admin on the given contract, so no more migration possible.\n    /// Fails if this contract is not currently admin of the target contract.\n    ClearAdmin { contract_addr: String },\n}\n\n#[cfg(feature = \"stargate\")]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum GovMsg {\n    /// This maps directly to [MsgVote](https://github.com/cosmos/cosmos-sdk/blob/v0.42.5/proto/cosmos/gov/v1beta1/tx.proto#L46-L56) in the Cosmos SDK with voter set to the contract address.\n    Vote { proposal_id: u64, vote: VoteOption },\n    /// This maps directly to [MsgVoteWeighted](https://github.com/cosmos/cosmos-sdk/blob/v0.45.8/proto/cosmos/gov/v1beta1/tx.proto#L66-L78) in the Cosmos SDK with voter set to the contract address.\n    #[cfg(feature = \"cosmwasm_1_2\")]\n    VoteWeighted {\n        proposal_id: u64,\n        vote: WeightedVoteOption,\n    },\n}\n\n#[cfg(feature = \"stargate\")]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum VoteOption {\n    Yes,\n    No,\n    Abstain,\n    NoWithVeto,\n}\n\n#[cfg(all(feature = \"stargate\", feature = \"cosmwasm_1_2\"))]\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct WeightedVoteOption {\n    option: VoteOption,\n    weight: Decimal,\n}\n\n/// Shortcut helper as the construction of WasmMsg::Instantiate can be quite verbose in contract code.\n///\n/// When using this, `admin` is always unset. If you need more flexibility, create the message directly.\npub fn wasm_instantiate(\n    code_id: u64,\n    msg: &impl Serialize,\n    funds: Vec<Coin>,\n    label: String,\n) -> StdResult<WasmMsg> {\n}\n\n/// Shortcut helper as the construction of WasmMsg::Instantiate can be quite verbose in contract code\npub fn wasm_execute(\n    contract_addr: impl Into<String>,\n    msg: &impl Serialize,\n    funds: Vec<Coin>,\n) -> StdResult<WasmMsg> {\n}\n\nimpl<T> From<BankMsg> for CosmosMsg<T> {\n    fn from(msg: BankMsg) -> Self {\n}\n}\n\n#[cfg(feature = \"staking\")]\nimpl<T> From<StakingMsg> for CosmosMsg<T> {\n    fn from(msg: StakingMsg) -> Self {\n}\n}\n\n#[cfg(feature = \"staking\")]\nimpl<T> From<DistributionMsg> for CosmosMsg<T> {\n    fn from(msg: DistributionMsg) -> Self {\n}\n}\n\nimpl<T> From<WasmMsg> for CosmosMsg<T> {\n    fn from(msg: WasmMsg) -> Self {\n}\n}\n\n#[cfg(feature = \"stargate\")]\nimpl<T> From<IbcMsg> for CosmosMsg<T> {\n    fn from(msg: IbcMsg) -> Self {\n}\n}\n\n#[cfg(feature = \"stargate\")]\nimpl<T> From<GovMsg> for CosmosMsg<T> {\n    fn from(msg: GovMsg) -> Self {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod empty {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n/// An empty struct that serves as a placeholder in different places,\n/// such as contracts that don't set a custom message.\n///\n/// It is designed to be expressable in correct JSON and JSON Schema but\n/// contains no meaningful data. Previously we used enums without cases,\n/// but those cannot represented as valid JSON Schema (https://github.com/CosmWasm/cosmwasm/issues/451)\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema, Default)]\npub struct Empty {}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod events {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\n/// A full [*Cosmos SDK* event].\n///\n/// This version uses string attributes (similar to [*Cosmos SDK* StringEvent]),\n/// which then get magically converted to bytes for Tendermint somewhere between\n/// the Rust-Go interface, JSON deserialization and the `NewEvent` call in Cosmos SDK.\n///\n/// [*Cosmos SDK* event]: https://docs.cosmos.network/main/core/events.html\n/// [*Cosmos SDK* StringEvent]: https://github.com/cosmos/cosmos-sdk/blob/v0.42.5/proto/cosmos/base/abci/v1beta1/abci.proto#L56-L70\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[non_exhaustive]\npub struct Event {\n    /// The event type. This is renamed to \"ty\" because \"type\" is reserved in Rust. This sucks, we know.\n    #[serde(rename = \"type\")]\n    pub ty: String,\n    /// The attributes to be included in the event.\n    ///\n    /// You can learn more about these from [*Cosmos SDK* docs].\n    ///\n    /// [*Cosmos SDK* docs]: https://docs.cosmos.network/main/core/events.html\n    pub attributes: Vec<Attribute>,\n}\n\nimpl Event {\n    /// Create a new event with the given type and an empty list of attributes.\n    pub fn new(ty: impl Into<String>) -> Self {\n}\n\n    /// Add an attribute to the event.\n    pub fn add_attribute(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {\n}\n\n    /// Bulk add attributes to the event.\n    ///\n    /// Anything that can be turned into an iterator and yields something\n    /// that can be converted into an `Attribute` is accepted.\n    pub fn add_attributes<A: Into<Attribute>>(\n        mut self,\n        attrs: impl IntoIterator<Item = A>,\n    ) -> Self {\n}\n}\n\n/// An key value pair that is used in the context of event attributes in logs\n#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq, JsonSchema)]\npub struct Attribute {\n    pub key: String,\n    pub value: String,\n}\n\nimpl Attribute {\n    /// Creates a new Attribute. `attr` is just an alias for this.\n    pub fn new(key: impl Into<String>, value: impl Into<String>) -> Self {\n}\n}\n\nimpl<K: Into<String>, V: Into<String>> From<(K, V)> for Attribute {\n    fn from((k, v): (K, V)) -> Self {\n}\n}\n\nimpl<K: AsRef<str>, V: AsRef<str>> PartialEq<(K, V)> for Attribute {\n    fn eq(&self, (k, v): &(K, V)) -> bool {\n}\n}\n\nimpl<K: AsRef<str>, V: AsRef<str>> PartialEq<Attribute> for (K, V) {\n    fn eq(&self, attr: &Attribute) -> bool {\n}\n}\n\nimpl<K: AsRef<str>, V: AsRef<str>> PartialEq<(K, V)> for &Attribute {\n    fn eq(&self, (k, v): &(K, V)) -> bool {\n}\n}\n\nimpl<K: AsRef<str>, V: AsRef<str>> PartialEq<&Attribute> for (K, V) {\n    fn eq(&self, attr: &&Attribute) -> bool {\n}\n}\n\nimpl PartialEq<Attribute> for &Attribute {\n    fn eq(&self, rhs: &Attribute) -> bool {\n}\n}\n\nimpl PartialEq<&Attribute> for Attribute {\n    fn eq(&self, rhs: &&Attribute) -> bool {\n}\n}\n\n/// Creates a new Attribute. `Attribute::new` is an alias for this.\n#[inline]\npub fn attr(key: impl Into<String>, value: impl Into<String>) -> Attribute {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod query {\nuse crate::binary::Binary;\n\npub type QueryResponse = Binary;\n}\nmod response {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::Binary;\n\nuse super::{Attribute, CosmosMsg, Empty, Event, SubMsg};\n\n/// A response of a contract entry point, such as `instantiate`, `execute` or `migrate`.\n///\n/// This type can be constructed directly at the end of the call. Alternatively a\n/// mutable response instance can be created early in the contract's logic and\n/// incrementally be updated.\n///\n/// ## Examples\n///\n/// Direct:\n///\n/// ```\n/// # use cosmwasm_std::{Binary, DepsMut, Env, MessageInfo};\n/// # type InstantiateMsg = ();\n/// #\n/// use cosmwasm_std::{attr, Response, StdResult};\n///\n/// pub fn instantiate(\n///     deps: DepsMut,\n///     _env: Env,\n///     _info: MessageInfo,\n///     msg: InstantiateMsg,\n/// ) -> StdResult<Response> {\n///     // ...\n///\n///     Ok(Response::new().add_attribute(\"action\", \"instantiate\"))\n/// }\n/// ```\n///\n/// Mutating:\n///\n/// ```\n/// # use cosmwasm_std::{coins, BankMsg, Binary, DepsMut, Env, MessageInfo, SubMsg};\n/// # type InstantiateMsg = ();\n/// # type MyError = ();\n/// #\n/// use cosmwasm_std::Response;\n///\n/// pub fn instantiate(\n///     deps: DepsMut,\n///     _env: Env,\n///     info: MessageInfo,\n///     msg: InstantiateMsg,\n/// ) -> Result<Response, MyError> {\n///     let mut response = Response::new()\n///         .add_attribute(\"Let the\", \"hacking begin\")\n///         .add_message(BankMsg::Send {\n///             to_address: String::from(\"recipient\"),\n///             amount: coins(128, \"uint\"),\n///         })\n///         .add_attribute(\"foo\", \"bar\")\n///         .set_data(b\"the result data\");\n///     Ok(response)\n/// }\n/// ```\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[non_exhaustive]\npub struct Response<T = Empty> {\n    /// Optional list of messages to pass. These will be executed in order.\n    /// If the ReplyOn variant matches the result (Always, Success on Ok, Error on Err),\n    /// the runtime will invoke this contract's `reply` entry point\n    /// after execution. Otherwise, they act like \"fire and forget\".\n    /// Use `SubMsg::new` to create messages with the older \"fire and forget\" semantics.\n    pub messages: Vec<SubMsg<T>>,\n    /// The attributes that will be emitted as part of a \"wasm\" event.\n    ///\n    /// More info about events (and their attributes) can be found in [*Cosmos SDK* docs].\n    ///\n    /// [*Cosmos SDK* docs]: https://docs.cosmos.network/main/core/events.html\n    pub attributes: Vec<Attribute>,\n    /// Extra, custom events separate from the main `wasm` one. These will have\n    /// `wasm-` prepended to the type.\n    ///\n    /// More info about events can be found in [*Cosmos SDK* docs].\n    ///\n    /// [*Cosmos SDK* docs]: https://docs.cosmos.network/main/core/events.html\n    pub events: Vec<Event>,\n    /// The binary payload to include in the response.\n    pub data: Option<Binary>,\n}\n\nimpl<T> Default for Response<T> {\n    fn default() -> Self {\n}\n}\n\nimpl<T> Response<T> {\n    pub fn new() -> Self {\n}\n\n    /// Add an attribute included in the main `wasm` event.\n    ///\n    /// For working with optional values or optional attributes, see [`add_attributes`][Self::add_attributes].\n    pub fn add_attribute(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {\n}\n\n    /// This creates a \"fire and forget\" message, by using `SubMsg::new()` to wrap it,\n    /// and adds it to the list of messages to process.\n    pub fn add_message(mut self, msg: impl Into<CosmosMsg<T>>) -> Self {\n}\n\n    /// This takes an explicit SubMsg (creates via eg. `reply_on_error`)\n    /// and adds it to the list of messages to process.\n    pub fn add_submessage(mut self, msg: SubMsg<T>) -> Self {\n}\n\n    /// Adds an extra event to the response, separate from the main `wasm` event\n    /// that is always created.\n    ///\n    /// The `wasm-` prefix will be appended by the runtime to the provided type\n    /// of event.\n    pub fn add_event(mut self, event: Event) -> Self {\n}\n\n    /// Bulk add attributes included in the main `wasm` event.\n    ///\n    /// Anything that can be turned into an iterator and yields something\n    /// that can be converted into an `Attribute` is accepted.\n    ///\n    /// ## Examples\n    ///\n    /// Adding a list of attributes using the pair notation for key and value:\n    ///\n    /// ```\n    /// use cosmwasm_std::Response;\n    ///\n    /// let attrs = vec![\n    ///     (\"action\", \"reaction\"),\n    ///     (\"answer\", \"42\"),\n    ///     (\"another\", \"attribute\"),\n    /// ];\n    /// let res: Response = Response::new().add_attributes(attrs.clone());\n    /// assert_eq!(res.attributes, attrs);\n    /// ```\n    ///\n    /// Adding an optional value as an optional attribute by turning it into a list of 0 or 1 elements:\n    ///\n    /// ```\n    /// use cosmwasm_std::{Attribute, Response};\n    ///\n    /// // Some value\n    /// let value: Option<String> = Some(\"sarah\".to_string());\n    /// let attribute: Option<Attribute> = value.map(|v| Attribute::new(\"winner\", v));\n    /// let res: Response = Response::new().add_attributes(attribute);\n    /// assert_eq!(res.attributes, [Attribute {\n    ///     key: \"winner\".to_string(),\n    ///     value: \"sarah\".to_string(),\n    /// }]);\n    ///\n    /// // No value\n    /// let value: Option<String> = None;\n    /// let attribute: Option<Attribute> = value.map(|v| Attribute::new(\"winner\", v));\n    /// let res: Response = Response::new().add_attributes(attribute);\n    /// assert_eq!(res.attributes.len(), 0);\n    /// ```\n    pub fn add_attributes<A: Into<Attribute>>(\n        mut self,\n        attrs: impl IntoIterator<Item = A>,\n    ) -> Self {\n}\n\n    /// Bulk add \"fire and forget\" messages to the list of messages to process.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use cosmwasm_std::{CosmosMsg, Response};\n    ///\n    /// fn make_response_with_msgs(msgs: Vec<CosmosMsg>) -> Response {\n    ///     Response::new().add_messages(msgs)\n    /// }\n    /// ```\n    pub fn add_messages<M: Into<CosmosMsg<T>>>(self, msgs: impl IntoIterator<Item = M>) -> Self {\n}\n\n    /// Bulk add explicit SubMsg structs to the list of messages to process.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// use cosmwasm_std::{SubMsg, Response};\n    ///\n    /// fn make_response_with_submsgs(msgs: Vec<SubMsg>) -> Response {\n    ///     Response::new().add_submessages(msgs)\n    /// }\n    /// ```\n    pub fn add_submessages(mut self, msgs: impl IntoIterator<Item = SubMsg<T>>) -> Self {\n}\n\n    /// Bulk add custom events to the response. These are separate from the main\n    /// `wasm` event.\n    ///\n    /// The `wasm-` prefix will be appended by the runtime to the provided types\n    /// of events.\n    pub fn add_events(mut self, events: impl IntoIterator<Item = Event>) -> Self {\n}\n\n    /// Set the binary data included in the response.\n    pub fn set_data(mut self, data: impl Into<Binary>) -> Self {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod submessages {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::Binary;\n\nuse super::{CosmosMsg, Empty, Event};\n\n/// Use this to define when the contract gets a response callback.\n/// If you only need it for errors or success you can select just those in order\n/// to save gas.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum ReplyOn {\n    /// Always perform a callback after SubMsg is processed\n    Always,\n    /// Only callback if SubMsg returned an error, no callback on success case\n    Error,\n    /// Only callback if SubMsg was successful, no callback on error case\n    Success,\n    /// Never make a callback - this is like the original CosmosMsg semantics\n    Never,\n}\n\n/// A submessage that will guarantee a `reply` call on success or error, depending on\n/// the `reply_on` setting. If you do not need to process the result, use regular messages instead.\n///\n/// Note: On error the submessage execution will revert any partial state changes due to this message,\n/// but not revert any state changes in the calling contract. If this is required, it must be done\n/// manually in the `reply` entry point.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct SubMsg<T = Empty> {\n    /// An arbitrary ID chosen by the contract.\n    /// This is typically used to match `Reply`s in the `reply` entry point to the submessage.\n    pub id: u64,\n    pub msg: CosmosMsg<T>,\n    /// Gas limit measured in [Cosmos SDK gas](https://github.com/CosmWasm/cosmwasm/blob/main/docs/GAS.md).\n    pub gas_limit: Option<u64>,\n    pub reply_on: ReplyOn,\n}\n\n/// This is used for cases when we use ReplyOn::Never and the id doesn't matter\npub const UNUSED_MSG_ID: u64 = 0;\n\nimpl<T> SubMsg<T> {\n    /// new creates a \"fire and forget\" message with the pre-0.14 semantics\n    pub fn new(msg: impl Into<CosmosMsg<T>>) -> Self {\n}\n\n    /// create a `SubMsg` that will provide a `reply` with the given id if the message returns `Ok`\n    pub fn reply_on_success(msg: impl Into<CosmosMsg<T>>, id: u64) -> Self {\n}\n\n    /// create a `SubMsg` that will provide a `reply` with the given id if the message returns `Err`\n    pub fn reply_on_error(msg: impl Into<CosmosMsg<T>>, id: u64) -> Self {\n}\n\n    /// create a `SubMsg` that will always provide a `reply` with the given id\n    pub fn reply_always(msg: impl Into<CosmosMsg<T>>, id: u64) -> Self {\n}\n\n    /// Add a gas limit to the message.\n    /// This gas limit measured in [Cosmos SDK gas](https://github.com/CosmWasm/cosmwasm/blob/main/docs/GAS.md).\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// # use cosmwasm_std::{coins, BankMsg, ReplyOn, SubMsg};\n    /// # let msg = BankMsg::Send { to_address: String::from(\"you\"), amount: coins(1015, \"earth\") };\n    /// let sub_msg: SubMsg = SubMsg::reply_always(msg, 1234).with_gas_limit(60_000);\n    /// assert_eq!(sub_msg.id, 1234);\n    /// assert_eq!(sub_msg.gas_limit, Some(60_000));\n    /// assert_eq!(sub_msg.reply_on, ReplyOn::Always);\n    /// ```\n    pub fn with_gas_limit(mut self, limit: u64) -> Self {\n}\n\n    fn reply_on(msg: CosmosMsg<T>, id: u64, reply_on: ReplyOn) -> Self {\n}\n}\n\n/// The result object returned to `reply`. We always get the ID from the submessage\n/// back and then must handle success and error cases ourselves.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct Reply {\n    /// The ID that the contract set when emitting the `SubMsg`.\n    /// Use this to identify which submessage triggered the `reply`.\n    pub id: u64,\n    pub result: SubMsgResult,\n}\n\n/// This is the result type that is returned from a sub message execution.\n///\n/// We use a custom type here instead of Rust's Result because we want to be able to\n/// define the serialization, which is a public interface. Every language that compiles\n/// to Wasm and runs in the ComsWasm VM needs to create the same JSON representation.\n///\n/// Until version 1.0.0-beta5, `ContractResult<SubMsgResponse>` was used instead\n/// of this type. Once serialized, the two types are the same. However, in the Rust type\n/// system we want different types for clarity and documenation reasons.\n///\n/// # Examples\n///\n/// Success:\n///\n/// ```\n/// # use cosmwasm_std::{to_vec, Binary, Event, SubMsgResponse, SubMsgResult};\n/// let response = SubMsgResponse {\n///     data: Some(Binary::from_base64(\"MTIzCg==\").unwrap()),\n///     events: vec![Event::new(\"wasm\").add_attribute(\"fo\", \"ba\")],\n/// };\n/// let result: SubMsgResult = SubMsgResult::Ok(response);\n/// assert_eq!(to_vec(&result).unwrap(), br#\"{\"ok\":{\"events\":[{\"type\":\"wasm\",\"attributes\":[{\"key\":\"fo\",\"value\":\"ba\"}]}],\"data\":\"MTIzCg==\"}}\"#);\n/// ```\n///\n/// Failure:\n///\n/// ```\n/// # use cosmwasm_std::{to_vec, SubMsgResult, Response};\n/// let error_msg = String::from(\"Something went wrong\");\n/// let result = SubMsgResult::Err(error_msg);\n/// assert_eq!(to_vec(&result).unwrap(), br#\"{\"error\":\"Something went wrong\"}\"#);\n/// ```\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum SubMsgResult {\n    Ok(SubMsgResponse),\n    /// An error type that every custom error created by contract developers can be converted to.\n    /// This could potientially have more structure, but String is the easiest.\n    #[serde(rename = \"error\")]\n    Err(String),\n}\n\n// Implementations here mimic the Result API and should be implemented via a conversion to Result\n// to ensure API consistency\nimpl SubMsgResult {\n    /// Converts a `SubMsgResult<S>` to a `Result<S, String>` as a convenient way\n    /// to access the full Result API.\n    pub fn into_result(self) -> Result<SubMsgResponse, String> {\n}\n\n    pub fn unwrap(self) -> SubMsgResponse {\n}\n\n    pub fn unwrap_err(self) -> String {\n}\n\n    pub fn is_ok(&self) -> bool {\n}\n\n    pub fn is_err(&self) -> bool {\n}\n}\n\nimpl<E: ToString> From<Result<SubMsgResponse, E>> for SubMsgResult {\n    fn from(original: Result<SubMsgResponse, E>) -> SubMsgResult {\n}\n}\n\nimpl From<SubMsgResult> for Result<SubMsgResponse, String> {\n    fn from(original: SubMsgResult) -> Result<SubMsgResponse, String> {\n}\n}\n\n/// The information we get back from a successful sub message execution,\n/// with full Cosmos SDK events.\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct SubMsgResponse {\n    pub events: Vec<Event>,\n    pub data: Option<Binary>,\n}\n\n#[deprecated(note = \"Renamed to SubMsgResponse\")]\npub type SubMsgExecutionResponse = SubMsgResponse;\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod system_result {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\nuse super::super::errors::SystemError;\n\n/// This is the outer result type returned by a querier to the contract.\n///\n/// We use a custom type here instead of Rust's Result because we want to be able to\n/// define the serialization, which is a public interface. Every language that compiles\n/// to Wasm and runs in the ComsWasm VM needs to create the same JSON representation.\n///\n/// # Examples\n///\n/// Success:\n///\n/// ```\n/// # use cosmwasm_std::{to_vec, Binary, ContractResult, SystemResult};\n/// let data = Binary::from(b\"hello, world\");\n/// let result = SystemResult::Ok(ContractResult::Ok(data));\n/// assert_eq!(to_vec(&result).unwrap(), br#\"{\"ok\":{\"ok\":\"aGVsbG8sIHdvcmxk\"}}\"#);\n/// ```\n///\n/// Failure:\n///\n/// ```\n/// # use cosmwasm_std::{to_vec, Binary, ContractResult, SystemResult, SystemError};\n/// let error = SystemError::Unknown {};\n/// let result: SystemResult<Binary> = SystemResult::Err(error);\n/// assert_eq!(to_vec(&result).unwrap(), br#\"{\"error\":{\"unknown\":{}}}\"#);\n/// ```\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\n#[serde(rename_all = \"snake_case\")]\npub enum SystemResult<S> {\n    Ok(S),\n    #[serde(rename = \"error\")]\n    Err(SystemError),\n}\n\n// Implementations here mimic the Result API and should be implemented via a conversion to Result\n// to ensure API consistency\nimpl<S> SystemResult<S> {\n    /// Converts a `ContractResult<S>` to a `Result<S, SystemError>` as a convenient way\n    /// to access the full Result API.\n    pub fn into_result(self) -> Result<S, SystemError> {\n}\n\n    pub fn unwrap(self) -> S {\n}\n}\n\nimpl<S: fmt::Debug> SystemResult<S> {\n    pub fn unwrap_err(self) -> SystemError {\n}\n}\n\nimpl<S> From<Result<S, SystemError>> for SystemResult<S> {\n    fn from(original: Result<S, SystemError>) -> SystemResult<S> {\n}\n}\n\nimpl<S> From<SystemResult<S>> for Result<S, SystemError> {\n    fn from(original: SystemResult<S>) -> Result<S, SystemError> {\n}\n}\n}\n\npub use contract_result::ContractResult;\n#[cfg(all(feature = \"stargate\", feature = \"cosmwasm_1_2\"))]\npub use cosmos_msg::WeightedVoteOption;\npub use cosmos_msg::{wasm_execute, wasm_instantiate, BankMsg, CosmosMsg, CustomMsg, WasmMsg};\n#[cfg(feature = \"staking\")]\npub use cosmos_msg::{DistributionMsg, StakingMsg};\n#[cfg(feature = \"stargate\")]\npub use cosmos_msg::{GovMsg, VoteOption};\npub use empty::Empty;\npub use events::{attr, Attribute, Event};\npub use query::QueryResponse;\npub use response::Response;\n#[allow(deprecated)]\npub use submessages::SubMsgExecutionResponse;\npub use submessages::{Reply, ReplyOn, SubMsg, SubMsgResponse, SubMsgResult};\npub use system_result::SystemResult;\n}\nmod sections {\nuse crate::conversion::force_to_u32;\n\n/// A sections decoder for the special case of two elements\n#[allow(dead_code)] // used in Wasm and tests only\npub fn decode_sections2(data: Vec<u8>) -> (Vec<u8>, Vec<u8>) {\n}\n\n/// Encodes multiple sections of data into one vector.\n///\n/// Each section is suffixed by a section length encoded as big endian uint32.\n/// Using suffixes instead of prefixes allows reading sections in reverse order,\n/// such that the first element does not need to be re-allocated if the contract's\n/// data structure supports truncation (such as a Rust vector).\n///\n/// The resulting data looks like this:\n///\n/// ```ignore\n/// section1 || section1_len || section2 || section2_len || section3 || section3_len || …\n/// ```\n#[allow(dead_code)] // used in Wasm and tests only\npub fn encode_sections(sections: &[&[u8]]) -> Vec<u8> {\n}\n\n/// Splits data into the last section (\"tail\") and the rest.\n/// The tail's length information is cut off, such that it is ready to use.\n/// The rest is basically unparsed and contails the lengths of the remaining sections.\n///\n/// While the tail is copied into a new vector, the rest is only truncated such that\n/// no re-allocation is necessary.\n///\n/// If `data` contains one section only, `data` is moved into the tail entirely\nfn split_tail(data: Vec<u8>) -> (Vec<u8>, Vec<u8>) {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod serde {\n// This file simply re-exports some methods from serde_json\n// The reason is two fold:\n// 1. To easily ensure that all calling libraries use the same version (minimize code size)\n// 2. To allow us to switch out to eg. serde-json-core more easily\nuse serde::{de::DeserializeOwned, Serialize};\nuse std::any::type_name;\n\nuse crate::binary::Binary;\nuse crate::errors::{StdError, StdResult};\n\npub fn from_slice<T: DeserializeOwned>(value: &[u8]) -> StdResult<T> {\n}\n\npub fn from_binary<T: DeserializeOwned>(value: &Binary) -> StdResult<T> {\n}\n\npub fn to_vec<T>(data: &T) -> StdResult<Vec<u8>>\nwhere\n    T: Serialize + ?Sized,\n{\n}\n\npub fn to_binary<T>(data: &T) -> StdResult<Binary>\nwhere\n    T: Serialize + ?Sized,\n{\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod storage {\nuse std::collections::BTreeMap;\nuse std::fmt;\n#[cfg(feature = \"iterator\")]\nuse std::iter;\n#[cfg(feature = \"iterator\")]\nuse std::ops::{Bound, RangeBounds};\n\n#[cfg(feature = \"iterator\")]\nuse crate::iterator::{Order, Record};\nuse crate::traits::Storage;\n\n#[derive(Default)]\npub struct MemoryStorage {\n    data: BTreeMap<Vec<u8>, Vec<u8>>,\n}\n\nimpl MemoryStorage {\n    pub fn new() -> Self {\n}\n}\n\nimpl Storage for MemoryStorage {\n    fn get(&self, key: &[u8]) -> Option<Vec<u8>> {\n}\n\n    fn set(&mut self, key: &[u8], value: &[u8]) {\n}\n\n    fn remove(&mut self, key: &[u8]) {\n}\n\n    #[cfg(feature = \"iterator\")]\n    /// range allows iteration over a set of keys, either forwards or backwards\n    /// uses standard rust range notation, and eg db.range(b\"foo\"..b\"bar\") also works reverse\n    fn range<'a>(\n        &'a self,\n        start: Option<&[u8]>,\n        end: Option<&[u8]>,\n        order: Order,\n    ) -> Box<dyn Iterator<Item = Record> + 'a> {\n}\n}\n\n/// This debug implementation is made for inspecting storages in unit testing.\n/// It is made for human readability only and the output can change at any time.\nimpl fmt::Debug for MemoryStorage {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n}\n}\n\n#[cfg(feature = \"iterator\")]\nfn range_bounds(start: Option<&[u8]>, end: Option<&[u8]>) -> impl RangeBounds<Vec<u8>> {\n}\n\n#[cfg(feature = \"iterator\")]\n/// The BTreeMap specific key-value pair reference type, as returned by BTreeMap<Vec<u8>, Vec<u8>>::range.\n/// This is internal as it can change any time if the map implementation is swapped out.\ntype BTreeMapRecordRef<'a> = (&'a Vec<u8>, &'a Vec<u8>);\n\n#[cfg(feature = \"iterator\")]\nfn clone_item(item_ref: BTreeMapRecordRef) -> Record {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod timestamp {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\nuse crate::math::Uint64;\n\n/// A point in time in nanosecond precision.\n///\n/// This type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n///\n/// ## Examples\n///\n/// ```\n/// # use cosmwasm_std::Timestamp;\n/// let ts = Timestamp::from_nanos(1_000_000_202);\n/// assert_eq!(ts.nanos(), 1_000_000_202);\n/// assert_eq!(ts.seconds(), 1);\n/// assert_eq!(ts.subsec_nanos(), 202);\n///\n/// let ts = ts.plus_seconds(2);\n/// assert_eq!(ts.nanos(), 3_000_000_202);\n/// assert_eq!(ts.seconds(), 3);\n/// assert_eq!(ts.subsec_nanos(), 202);\n/// ```\n#[derive(\n    Serialize, Deserialize, Copy, Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord, JsonSchema,\n)]\npub struct Timestamp(Uint64);\n\nimpl Timestamp {\n    /// Creates a timestamp from nanoseconds since epoch\n    pub const fn from_nanos(nanos_since_epoch: u64) -> Self {\n}\n\n    /// Creates a timestamp from seconds since epoch\n    pub const fn from_seconds(seconds_since_epoch: u64) -> Self {\n}\n\n    pub const fn plus_seconds(&self, addition: u64) -> Timestamp {\n}\n\n    pub const fn plus_nanos(&self, addition: u64) -> Timestamp {\n}\n\n    pub const fn minus_seconds(&self, subtrahend: u64) -> Timestamp {\n}\n\n    pub const fn minus_nanos(&self, subtrahend: u64) -> Timestamp {\n}\n\n    /// Returns nanoseconds since epoch\n    #[inline]\n    pub fn nanos(&self) -> u64 {\n}\n\n    /// Returns seconds since epoch (truncate nanoseconds)\n    #[inline]\n    pub fn seconds(&self) -> u64 {\n}\n\n    /// Returns nanoseconds since the last whole second (the remainder truncated\n    /// by `seconds()`)\n    #[inline]\n    pub fn subsec_nanos(&self) -> u64 {\n}\n}\n\nimpl fmt::Display for Timestamp {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod traits {\nuse serde::{de::DeserializeOwned, Serialize};\nuse std::marker::PhantomData;\nuse std::ops::Deref;\n\nuse crate::addresses::{Addr, CanonicalAddr};\nuse crate::binary::Binary;\nuse crate::coin::Coin;\nuse crate::errors::{RecoverPubkeyError, StdError, StdResult, VerificationError};\n#[cfg(feature = \"iterator\")]\nuse crate::iterator::{Order, Record};\n#[cfg(feature = \"cosmwasm_1_1\")]\nuse crate::query::SupplyResponse;\nuse crate::query::{\n    AllBalanceResponse, BalanceResponse, BankQuery, CustomQuery, QueryRequest, WasmQuery,\n};\n#[cfg(feature = \"staking\")]\nuse crate::query::{\n    AllDelegationsResponse, AllValidatorsResponse, BondedDenomResponse, Delegation,\n    DelegationResponse, FullDelegation, StakingQuery, Validator, ValidatorResponse,\n};\nuse crate::results::{ContractResult, Empty, SystemResult};\nuse crate::serde::{from_binary, to_binary, to_vec};\nuse crate::ContractInfoResponse;\n\n/// Storage provides read and write access to a persistent storage.\n/// If you only want to provide read access, provide `&Storage`\npub trait Storage {\n    /// Returns None when key does not exist.\n    /// Returns Some(Vec<u8>) when key exists.\n    ///\n    /// Note: Support for differentiating between a non-existent key and a key with empty value\n    /// is not great yet and might not be possible in all backends. But we're trying to get there.\n    fn get(&self, key: &[u8]) -> Option<Vec<u8>>;\n\n    #[cfg(feature = \"iterator\")]\n    /// Allows iteration over a set of key/value pairs, either forwards or backwards.\n    ///\n    /// The bound `start` is inclusive and `end` is exclusive.\n    ///\n    /// If `start` is lexicographically greater than or equal to `end`, an empty range is described, mo matter of the order.\n    fn range<'a>(\n        &'a self,\n        start: Option<&[u8]>,\n        end: Option<&[u8]>,\n        order: Order,\n    ) -> Box<dyn Iterator<Item = Record> + 'a>;\n\n    fn set(&mut self, key: &[u8], value: &[u8]);\n\n    /// Removes a database entry at `key`.\n    ///\n    /// The current interface does not allow to differentiate between a key that existed\n    /// before and one that didn't exist. See https://github.com/CosmWasm/cosmwasm/issues/290\n    fn remove(&mut self, key: &[u8]);\n}\n\n/// Api are callbacks to system functions implemented outside of the wasm modules.\n/// Currently it just supports address conversion but we could add eg. crypto functions here.\n///\n/// This is a trait to allow mocks in the test code. Its members have a read-only\n/// reference to the Api instance to allow accessing configuration.\n/// Implementations must not have mutable state, such that an instance can freely\n/// be copied and shared between threads without affecting the behaviour.\n/// Given an Api instance, all members should return the same value when called with the same\n/// arguments. In particular this means the result must not depend in the state of the chain.\n/// If you need to access chaim state, you probably want to use the Querier.\n/// Side effects (such as logging) are allowed.\n///\n/// We can use feature flags to opt-in to non-essential methods\n/// for backwards compatibility in systems that don't have them all.\npub trait Api {\n    /// Takes a human readable address and validates if it is valid.\n    /// If it the validation succeeds, a `Addr` containing the same data as the input is returned.\n    ///\n    /// This validation checks two things:\n    /// 1. The address is valid in the sense that it can be converted to a canonical representation by the backend.\n    /// 2. The address is normalized, i.e. `humanize(canonicalize(input)) == input`.\n    ///\n    /// Check #2 is typically needed for upper/lower case representations of the same\n    /// address that are both valid according to #1. This way we ensure uniqueness\n    /// of the human readable address. Clients should perform the normalization before sending\n    /// the addresses to the CosmWasm stack. But please note that the definition of normalized\n    /// depends on the backend.\n    ///\n    /// ## Examples\n    ///\n    /// ```\n    /// # use cosmwasm_std::{Api, Addr};\n    /// # use cosmwasm_std::testing::MockApi;\n    /// # let api = MockApi::default();\n    /// let input = \"what-users-provide\";\n    /// let validated: Addr = api.addr_validate(input).unwrap();\n    /// assert_eq!(validated, input);\n    /// ```\n    fn addr_validate(&self, human: &str) -> StdResult<Addr>;\n\n    /// Takes a human readable address and returns a canonical binary representation of it.\n    /// This can be used when a compact representation is needed.\n    ///\n    /// Please note that the length of the resulting address is defined by the chain and\n    /// can vary from address to address. On Cosmos chains 20 and 32 bytes are typically used.\n    /// But that might change. So your contract should not make assumptions on the size.\n    fn addr_canonicalize(&self, human: &str) -> StdResult<CanonicalAddr>;\n\n    /// Takes a canonical address and returns a human readble address.\n    /// This is the inverse of [`addr_canonicalize`].\n    ///\n    /// [`addr_canonicalize`]: Api::addr_canonicalize\n    fn addr_humanize(&self, canonical: &CanonicalAddr) -> StdResult<Addr>;\n\n    fn secp256k1_verify(\n        &self,\n        message_hash: &[u8],\n        signature: &[u8],\n        public_key: &[u8],\n    ) -> Result<bool, VerificationError>;\n\n    fn groth16_verify(\n        &self,\n        input: &[u8],\n        proof: &[u8],\n        vk: &[u8],\n    ) -> Result<bool, VerificationError>;\n\n    fn poseidon_hash(&self, inputs: &[&[u8]]) -> StdResult<Vec<u8>>;\n\n    fn curve_hash(&self, input: &[u8]) -> StdResult<Vec<u8>>;\n\n    fn secp256k1_recover_pubkey(\n        &self,\n        message_hash: &[u8],\n        signature: &[u8],\n        recovery_param: u8,\n    ) -> Result<Vec<u8>, RecoverPubkeyError>;\n\n    fn ed25519_verify(\n        &self,\n        message: &[u8],\n        signature: &[u8],\n        public_key: &[u8],\n    ) -> Result<bool, VerificationError>;\n\n    fn ed25519_batch_verify(\n        &self,\n        messages: &[&[u8]],\n        signatures: &[&[u8]],\n        public_keys: &[&[u8]],\n    ) -> Result<bool, VerificationError>;\n\n    /// Emits a debugging message that is handled depending on the environment (typically printed to console or ignored).\n    /// Those messages are not persisted to chain.\n    fn debug(&self, message: &str);\n}\n\n/// A short-hand alias for the two-level query result (1. accessing the contract, 2. executing query in the contract)\npub type QuerierResult = SystemResult<ContractResult<Binary>>;\n\npub trait Querier {\n    /// raw_query is all that must be implemented for the Querier.\n    /// This allows us to pass through binary queries from one level to another without\n    /// knowing the custom format, or we can decode it, with the knowledge of the allowed\n    /// types. People using the querier probably want one of the simpler auto-generated\n    /// helper methods\n    fn raw_query(&self, bin_request: &[u8]) -> QuerierResult;\n}\n\n#[derive(Clone)]\npub struct QuerierWrapper<'a, C: CustomQuery = Empty> {\n    querier: &'a dyn Querier,\n    custom_query_type: PhantomData<C>,\n}\n\n// Use custom implementation on order to implement Copy in case `C` is not `Copy`.\n// See \"There is a small difference between the two: the derive strategy will also\n// place a Copy bound on type parameters, which isn’t always desired.\"\n// https://doc.rust-lang.org/std/marker/trait.Copy.html\nimpl<'a, C: CustomQuery> Copy for QuerierWrapper<'a, C> {}\n\n/// This allows us to use self.raw_query to access the querier.\n/// It also allows external callers to access the querier easily.\nimpl<'a, C: CustomQuery> Deref for QuerierWrapper<'a, C> {\n    type Target = dyn Querier + 'a;\n\n    fn deref(&self) -> &Self::Target {\n}\n}\n\nimpl<'a, C: CustomQuery> QuerierWrapper<'a, C> {\n    pub fn new(querier: &'a dyn Querier) -> Self {\n}\n\n    /// Makes the query and parses the response.\n    ///\n    /// Any error (System Error, Error or called contract, or Parse Error) are flattened into\n    /// one level. Only use this if you don't need to check the SystemError\n    /// eg. If you don't differentiate between contract missing and contract returned error\n    pub fn query<U: DeserializeOwned>(&self, request: &QueryRequest<C>) -> StdResult<U> {\n}\n\n    #[cfg(feature = \"cosmwasm_1_1\")]\n    pub fn query_supply(&self, denom: impl Into<String>) -> StdResult<Coin> {\n}\n\n    pub fn query_balance(\n        &self,\n        address: impl Into<String>,\n        denom: impl Into<String>,\n    ) -> StdResult<Coin> {\n}\n\n    pub fn query_all_balances(&self, address: impl Into<String>) -> StdResult<Vec<Coin>> {\n}\n\n    // this queries another wasm contract. You should know a priori the proper types for T and U\n    // (response and request) based on the contract API\n    pub fn query_wasm_smart<T: DeserializeOwned>(\n        &self,\n        contract_addr: impl Into<String>,\n        msg: &impl Serialize,\n    ) -> StdResult<T> {\n}\n\n    // this queries the raw storage from another wasm contract.\n    // you must know the exact layout and are implementation dependent\n    // (not tied to an interface like query_wasm_smart)\n    // that said, if you are building a few contracts together, this is a much cheaper approach\n    //\n    // Similar return value to Storage.get(). Returns Some(val) or None if the data is there.\n    // It only returns error on some runtime issue, not on any data cases.\n    pub fn query_wasm_raw(\n        &self,\n        contract_addr: impl Into<String>,\n        key: impl Into<Binary>,\n    ) -> StdResult<Option<Vec<u8>>> {\n}\n\n    /// Given a contract address, query information about that contract.\n    pub fn query_wasm_contract_info(\n        &self,\n        contract_addr: impl Into<String>,\n    ) -> StdResult<ContractInfoResponse> {\n}\n\n    #[cfg(feature = \"staking\")]\n    pub fn query_all_validators(&self) -> StdResult<Vec<Validator>> {\n}\n\n    #[cfg(feature = \"staking\")]\n    pub fn query_validator(&self, address: impl Into<String>) -> StdResult<Option<Validator>> {\n}\n\n    #[cfg(feature = \"staking\")]\n    pub fn query_bonded_denom(&self) -> StdResult<String> {\n}\n\n    #[cfg(feature = \"staking\")]\n    pub fn query_all_delegations(\n        &self,\n        delegator: impl Into<String>,\n    ) -> StdResult<Vec<Delegation>> {\n}\n\n    #[cfg(feature = \"staking\")]\n    pub fn query_delegation(\n        &self,\n        delegator: impl Into<String>,\n        validator: impl Into<String>,\n    ) -> StdResult<Option<FullDelegation>> {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod types {\nuse schemars::JsonSchema;\nuse serde::{Deserialize, Serialize};\n\nuse crate::addresses::Addr;\nuse crate::coin::Coin;\nuse crate::timestamp::Timestamp;\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct Env {\n    pub block: BlockInfo,\n    /// Information on the transaction this message was executed in.\n    /// The field is unset when the `MsgExecuteContract`/`MsgInstantiateContract`/`MsgMigrateContract`\n    /// is not executed as part of a transaction.\n    pub transaction: Option<TransactionInfo>,\n    pub contract: ContractInfo,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct TransactionInfo {\n    /// The position of this transaction in the block. The first\n    /// transaction has index 0.\n    ///\n    /// This allows you to get a unique transaction indentifier in this chain\n    /// using the pair (`env.block.height`, `env.transaction.index`).\n    ///\n    pub index: u32,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct BlockInfo {\n    /// The height of a block is the number of blocks preceding it in the blockchain.\n    pub height: u64,\n    /// Absolute time of the block creation in seconds since the UNIX epoch (00:00:00 on 1970-01-01 UTC).\n    ///\n    /// The source of this is the [BFT Time in Tendermint](https://github.com/tendermint/tendermint/blob/58dc1726/spec/consensus/bft-time.md),\n    /// which has the same nanosecond precision as the `Timestamp` type.\n    ///\n    /// # Examples\n    ///\n    /// Using chrono:\n    ///\n    /// ```\n    /// # use cosmwasm_std::{Addr, BlockInfo, ContractInfo, Env, MessageInfo, Timestamp, TransactionInfo};\n    /// # let env = Env {\n    /// #     block: BlockInfo {\n    /// #         height: 12_345,\n    /// #         time: Timestamp::from_nanos(1_571_797_419_879_305_533),\n    /// #         chain_id: \"cosmos-testnet-14002\".to_string(),\n    /// #     },\n    /// #     transaction: Some(TransactionInfo { index: 3 }),\n    /// #     contract: ContractInfo {\n    /// #         address: Addr::unchecked(\"contract\"),\n    /// #     },\n    /// # };\n    /// # extern crate chrono;\n    /// use chrono::NaiveDateTime;\n    /// let seconds = env.block.time.seconds();\n    /// let nsecs = env.block.time.subsec_nanos();\n    /// let dt = NaiveDateTime::from_timestamp(seconds as i64, nsecs as u32);\n    /// ```\n    ///\n    /// Creating a simple millisecond-precision timestamp (as used in JavaScript):\n    ///\n    /// ```\n    /// # use cosmwasm_std::{Addr, BlockInfo, ContractInfo, Env, MessageInfo, Timestamp, TransactionInfo};\n    /// # let env = Env {\n    /// #     block: BlockInfo {\n    /// #         height: 12_345,\n    /// #         time: Timestamp::from_nanos(1_571_797_419_879_305_533),\n    /// #         chain_id: \"cosmos-testnet-14002\".to_string(),\n    /// #     },\n    /// #     transaction: Some(TransactionInfo { index: 3 }),\n    /// #     contract: ContractInfo {\n    /// #         address: Addr::unchecked(\"contract\"),\n    /// #     },\n    /// # };\n    /// let millis = env.block.time.nanos() / 1_000_000;\n    /// ```\n    pub time: Timestamp,\n    pub chain_id: String,\n}\n\n/// Additional information from [MsgInstantiateContract] and [MsgExecuteContract], which is passed\n/// along with the contract execution message into the `instantiate` and `execute` entry points.\n///\n/// It contains the essential info for authorization - identity of the call, and payment.\n///\n/// [MsgInstantiateContract]: https://github.com/CosmWasm/wasmd/blob/v0.15.0/x/wasm/internal/types/tx.proto#L47-L61\n/// [MsgExecuteContract]: https://github.com/CosmWasm/wasmd/blob/v0.15.0/x/wasm/internal/types/tx.proto#L68-L78\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]\npub struct MessageInfo {\n    /// The `sender` field from `MsgInstantiateContract` and `MsgExecuteContract`.\n    /// You can think of this as the address that initiated the action (i.e. the message). What that\n    /// means exactly heavily depends on the application.\n    ///\n    /// The x/wasm module ensures that the sender address signed the transaction or\n    /// is otherwise authorized to send the message.\n    ///\n    /// Additional signers of the transaction that are either needed for other messages or contain unnecessary\n    /// signatures are not propagated into the contract.\n    pub sender: Addr,\n    /// The funds that are sent to the contract as part of `MsgInstantiateContract`\n    /// or `MsgExecuteContract`. The transfer is processed in bank before the contract\n    /// is executed such that the new balance is visible during contract execution.\n    pub funds: Vec<Coin>,\n}\n\n#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, JsonSchema)]\npub struct ContractInfo {\n    pub address: Addr,\n}\n}\n\npub use crate::addresses::{instantiate2_address, Addr, CanonicalAddr};\npub use crate::binary::Binary;\npub use crate::coin::{coin, coins, has_coins, Coin};\npub use crate::deps::{Deps, DepsMut, OwnedDeps};\npub use crate::errors::{\n    CheckedFromRatioError, CheckedMultiplyRatioError, ConversionOverflowError, DivideByZeroError,\n    OverflowError, OverflowOperation, RecoverPubkeyError, StdError, StdResult, SystemError,\n    VerificationError,\n};\npub use crate::hex_binary::HexBinary;\n#[cfg(feature = \"stargate\")]\npub use crate::ibc::{\n    Ibc3ChannelOpenResponse, IbcAcknowledgement, IbcBasicResponse, IbcChannel, IbcChannelCloseMsg,\n    IbcChannelConnectMsg, IbcChannelOpenMsg, IbcChannelOpenResponse, IbcEndpoint, IbcMsg, IbcOrder,\n    IbcPacket, IbcPacketAckMsg, IbcPacketReceiveMsg, IbcPacketTimeoutMsg, IbcReceiveResponse,\n    IbcTimeout, IbcTimeoutBlock,\n};\n#[cfg(feature = \"iterator\")]\npub use crate::iterator::{Order, Record};\npub use crate::math::{\n    Decimal, Decimal256, Decimal256RangeExceeded, DecimalRangeExceeded, Fraction, Isqrt, Uint128,\n    Uint256, Uint512, Uint64,\n};\n#[cfg(feature = \"cosmwasm_1_1\")]\npub use crate::query::SupplyResponse;\npub use crate::query::{\n    AllBalanceResponse, BalanceResponse, BankQuery, ContractInfoResponse, CustomQuery,\n    QueryRequest, WasmQuery,\n};\n#[cfg(feature = \"staking\")]\npub use crate::query::{\n    AllDelegationsResponse, AllValidatorsResponse, BondedDenomResponse, Delegation,\n    DelegationResponse, FullDelegation, StakingQuery, Validator, ValidatorResponse,\n};\n#[cfg(feature = \"stargate\")]\npub use crate::query::{ChannelResponse, IbcQuery, ListChannelsResponse, PortIdResponse};\n#[allow(deprecated)]\npub use crate::results::SubMsgExecutionResponse;\n#[cfg(all(feature = \"stargate\", feature = \"cosmwasm_1_2\"))]\npub use crate::results::WeightedVoteOption;\npub use crate::results::{\n    attr, wasm_execute, wasm_instantiate, Attribute, BankMsg, ContractResult, CosmosMsg, CustomMsg,\n    Empty, Event, QueryResponse, Reply, ReplyOn, Response, SubMsg, SubMsgResponse, SubMsgResult,\n    SystemResult, WasmMsg,\n};\n#[cfg(feature = \"staking\")]\npub use crate::results::{DistributionMsg, StakingMsg};\n#[cfg(feature = \"stargate\")]\npub use crate::results::{GovMsg, VoteOption};\npub use crate::serde::{from_binary, from_slice, to_binary, to_vec};\npub use crate::storage::MemoryStorage;\npub use crate::timestamp::Timestamp;\npub use crate::traits::{Api, Querier, QuerierResult, QuerierWrapper, Storage};\npub use crate::types::{BlockInfo, ContractInfo, Env, MessageInfo, TransactionInfo};\n\n// Exposed in wasm build only\n\n#[cfg(target_arch = \"wasm32\")]\nmod exports {\n//! exports exposes the public wasm API\n//!\n//! interface_version_8, allocate and deallocate turn into Wasm exports\n//! as soon as cosmwasm_std is `use`d in the contract, even privately.\n//!\n//! `do_execute`, `do_instantiate`, `do_migrate`, `do_query`, `do_reply`\n//! and `do_sudo` should be wrapped with a extern \"C\" entry point including\n//! the contract-specific function pointer. This is done via the `#[entry_point]`\n//! macro attribute from cosmwasm-derive.\nuse std::marker::PhantomData;\nuse std::vec::Vec;\n\nuse serde::de::DeserializeOwned;\n\nuse crate::deps::OwnedDeps;\n#[cfg(feature = \"stargate\")]\nuse crate::ibc::{\n    IbcBasicResponse, IbcChannelCloseMsg, IbcChannelConnectMsg, IbcChannelOpenMsg,\n    IbcChannelOpenResponse, IbcPacketAckMsg, IbcPacketReceiveMsg, IbcPacketTimeoutMsg,\n    IbcReceiveResponse,\n};\nuse crate::imports::{ExternalApi, ExternalQuerier, ExternalStorage};\nuse crate::memory::{alloc, consume_region, release_buffer, Region};\n#[cfg(feature = \"abort\")]\nuse crate::panic::install_panic_handler;\nuse crate::query::CustomQuery;\nuse crate::results::{ContractResult, QueryResponse, Reply, Response};\nuse crate::serde::{from_slice, to_vec};\nuse crate::types::Env;\nuse crate::{CustomMsg, Deps, DepsMut, MessageInfo};\n\n#[cfg(feature = \"iterator\")]\n#[no_mangle]\nextern \"C\" fn requires_iterator() -> () {}}\n#[cfg(target_arch = \"wasm32\")]\nmod imports {\nuse std::vec::Vec;\n\nuse crate::addresses::{Addr, CanonicalAddr};\nuse crate::errors::{RecoverPubkeyError, StdError, StdResult, SystemError, VerificationError};\nuse crate::import_helpers::{from_high_half, from_low_half};\nuse crate::memory::{alloc, build_region, consume_region, Region};\nuse crate::results::SystemResult;\n#[cfg(feature = \"iterator\")]\nuse crate::sections::decode_sections2;\nuse crate::sections::encode_sections;\nuse crate::serde::from_slice;\nuse crate::traits::{Api, Querier, QuerierResult, Storage};\n#[cfg(feature = \"iterator\")]\nuse crate::{\n    iterator::{Order, Record},\n    memory::get_optional_region_address,\n};\n\n/// An upper bound for typical canonical address lengths (e.g. 20 in Cosmos SDK/Ethereum or 32 in Nano/Substrate)\nconst CANONICAL_ADDRESS_BUFFER_LENGTH: usize = 64;\n/// An upper bound for typical human readable address formats (e.g. 42 for Ethereum hex addresses or 90 for bech32)\nconst HUMAN_ADDRESS_BUFFER_LENGTH: usize = 90;\n\n// This interface will compile into required Wasm imports.\n// A complete documentation those functions is available in the VM that provides them:\n// https://github.com/CosmWasm/cosmwasm/blob/v1.0.0-beta/packages/vm/src/instance.rs#L89-L206\nextern \"C\" {\n}\n\n/// A stateless convenience wrapper around database imports provided by the VM.\n/// This cannot be cloned as it would not copy any data. If you need to clone this, it indicates a flaw in your logic.\npub struct ExternalStorage {}\n\nimpl ExternalStorage {\n    pub fn new() -> ExternalStorage {\n}\n}\n\nimpl Storage for ExternalStorage {\n    fn get(&self, key: &[u8]) -> Option<Vec<u8>> {\n}\n\n    fn set(&mut self, key: &[u8], value: &[u8]) {\n}\n\n    fn remove(&mut self, key: &[u8]) {\n}\n\n    #[cfg(feature = \"iterator\")]\n    fn range(\n        &self,\n        start: Option<&[u8]>,\n        end: Option<&[u8]>,\n        order: Order,\n    ) -> Box<dyn Iterator<Item = Record>> {\n}\n}\n\n#[cfg(feature = \"iterator\")]\n/// ExternalIterator makes a call out to next.\n/// We use the pointer to differentiate between multiple open iterators.\nstruct ExternalIterator {\n    iterator_id: u32,\n}\n\n#[cfg(feature = \"iterator\")]\nimpl Iterator for ExternalIterator {\n    type Item = Record;\n\n    fn next(&mut self) -> Option<Self::Item> {\n}\n}\n\n/// A stateless convenience wrapper around imports provided by the VM\n#[derive(Copy, Clone)]\npub struct ExternalApi {}\n\nimpl ExternalApi {\n    pub fn new() -> ExternalApi {\n}\n}\n\nimpl Api for ExternalApi {\n    fn addr_validate(&self, input: &str) -> StdResult<Addr> {\n}\n\n    fn addr_canonicalize(&self, input: &str) -> StdResult<CanonicalAddr> {\n}\n\n    fn addr_humanize(&self, canonical: &CanonicalAddr) -> StdResult<Addr> {\n}\n\n    fn secp256k1_verify(\n        &self,\n        message_hash: &[u8],\n        signature: &[u8],\n        public_key: &[u8],\n    ) -> Result<bool, VerificationError> {\n}\n\n    fn groth16_verify(\n        &self,\n        input: &[u8],\n        proof: &[u8],\n        vk: &[u8],\n    ) -> Result<bool, VerificationError> {\n}\n\n    fn poseidon_hash(&self, inputs: &[&[u8]]) -> StdResult<Vec<u8>> {\n}\n\n    fn curve_hash(&self, input: &[u8]) -> StdResult<Vec<u8>> {\n}\n\n    fn secp256k1_recover_pubkey(\n        &self,\n        message_hash: &[u8],\n        signature: &[u8],\n        recover_param: u8,\n    ) -> Result<Vec<u8>, RecoverPubkeyError> {\n}\n\n    fn ed25519_verify(\n        &self,\n        message: &[u8],\n        signature: &[u8],\n        public_key: &[u8],\n    ) -> Result<bool, VerificationError> {\n}\n\n    fn ed25519_batch_verify(\n        &self,\n        messages: &[&[u8]],\n        signatures: &[&[u8]],\n        public_keys: &[&[u8]],\n    ) -> Result<bool, VerificationError> {\n}\n\n    fn debug(&self, message: &str) {\n}\n}\n\n/// Takes a pointer to a Region and reads the data into a String.\n/// This is for trusted string sources only.\nunsafe fn consume_string_region_written_by_vm(from: *mut Region) -> String {\n}\n\n/// A stateless convenience wrapper around imports provided by the VM\npub struct ExternalQuerier {}\n\nimpl ExternalQuerier {\n    pub fn new() -> ExternalQuerier {\n}\n}\n\nimpl Querier for ExternalQuerier {\n    fn raw_query(&self, bin_request: &[u8]) -> QuerierResult {\n}\n}\n\n#[cfg(feature = \"abort\")]\npub fn handle_panic(message: &str) {\n}\n}\n#[cfg(target_arch = \"wasm32\")]\nmod memory {\nuse std::mem;\nuse std::vec::Vec;\n\n/// Describes some data allocated in Wasm's linear memory.\n/// A pointer to an instance of this can be returned over FFI boundaries.\n///\n/// This struct is crate internal since the cosmwasm-vm defines the same type independently.\n#[repr(C)]\npub struct Region {\n    /// The beginning of the region expressed as bytes from the beginning of the linear memory\n    pub offset: u32,\n    /// The number of bytes available in this region\n    pub capacity: u32,\n    /// The number of bytes used in this region\n    pub length: u32,\n}\n\n/// Creates a memory region of capacity `size` and length 0. Returns a pointer to the Region.\n/// This is the same as the `allocate` export, but designed to be called internally.\npub fn alloc(size: usize) -> *mut Region {\n}\n\n/// Similar to alloc, but instead of creating a new vector it consumes an existing one and returns\n/// a pointer to the Region (preventing the memory from being freed until explicitly called later).\n///\n/// The resulting Region has capacity = length, i.e. the buffer's capacity is ignored.\npub fn release_buffer(buffer: Vec<u8>) -> *mut Region {\n}\n\n/// Return the data referenced by the Region and\n/// deallocates the Region (and the vector when finished).\n/// Warning: only use this when you are sure the caller will never use (or free) the Region later\n///\n/// # Safety\n///\n/// The ptr must refer to a valid Region, which was previously returned by alloc,\n/// and not yet deallocated. This call will deallocate the Region and return an owner vector\n/// to the caller containing the referenced data.\n///\n/// Naturally, calling this function twice on the same pointer will double deallocate data\n/// and lead to a crash. Make sure to call it exactly once (either consuming the input in\n/// the wasm code OR deallocating the buffer from the caller).\npub unsafe fn consume_region(ptr: *mut Region) -> Vec<u8> {\n}\n\n/// Returns a box of a Region, which can be sent over a call to extern\n/// note that this DOES NOT take ownership of the data, and we MUST NOT consume_region\n/// the resulting data.\n/// The Box must be dropped (with scope), but not the data\npub fn build_region(data: &[u8]) -> Box<Region> {\n}\n\nfn build_region_from_components(offset: u32, capacity: u32, length: u32) -> Box<Region> {\n}\n\n/// Returns the address of the optional Region as an offset in linear memory,\n/// or zero if not present\n#[cfg(feature = \"iterator\")]\npub fn get_optional_region_address(region: &Option<&Box<Region>>) -> u32 {\n}\n}\n\n#[cfg(target_arch = \"wasm32\")]\npub use crate::exports::{do_execute, do_instantiate, do_migrate, do_query, do_reply, do_sudo};\n#[cfg(all(feature = \"stargate\", target_arch = \"wasm32\"))]\npub use crate::exports::{\n    do_ibc_channel_close, do_ibc_channel_connect, do_ibc_channel_open, do_ibc_packet_ack,\n    do_ibc_packet_receive, do_ibc_packet_timeout,\n};\n#[cfg(target_arch = \"wasm32\")]\npub use crate::imports::{ExternalApi, ExternalQuerier, ExternalStorage};\n\n// Exposed for testing only\n// Both unit tests and integration tests are compiled to native code, so everything in here does not need to compile to Wasm.\n#[cfg(not(target_arch = \"wasm32\"))]\npub mod testing {\n#![cfg(not(target_arch = \"wasm32\"))]\n\n// Exposed for testing only\n// Both unit tests and integration tests are compiled to native code, so everything in here does not need to compile to Wasm.\n\nmod assertions {\nuse crate::{Decimal, Uint128};\nuse std::str::FromStr as _;\n\n/// Asserts that two expressions are approximately equal to each other.\n///\n/// The `max_rel_diff` argument defines the maximum relative difference\n/// of the `left` and `right` values.\n///\n/// On panic, this macro will print the values of the arguments and\n/// the actual relative difference.\n///\n/// Like [`assert_eq!`], this macro has a second form, where a custom\n/// panic message can be provided.\n#[macro_export]\nmacro_rules! assert_approx_eq {\n    ($left:expr, $right:expr, $max_rel_diff:expr $(,)?) => {{\n        $crate::testing::assert_approx_eq_impl($left, $right, $max_rel_diff, None);\n    }};\n    ($left:expr, $right:expr, $max_rel_diff:expr, $($args:tt)+) => {{\n        $crate::testing::assert_approx_eq_impl($left, $right, $max_rel_diff, Some(format!($($args)*)));\n    }};\n}\n\n/// Implementation for the [`cosmwasm_std::assert_approx_eq`] macro. This does not provide any\n/// stability guarantees and may change any time.\n#[track_caller]\n#[doc(hidden)]\npub fn assert_approx_eq_impl<U: Into<Uint128>>(\n    left: U,\n    right: U,\n    max_rel_diff: &str,\n    panic_msg: Option<String>,\n) {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod mock {\nuse cosmwasm_crypto::Poseidon;\nuse serde::de::DeserializeOwned;\n#[cfg(feature = \"stargate\")]\nuse serde::Serialize;\nuse std::collections::HashMap;\nuse std::marker::PhantomData;\n\nuse crate::addresses::{Addr, CanonicalAddr};\nuse crate::binary::Binary;\nuse crate::coin::Coin;\nuse crate::deps::OwnedDeps;\nuse crate::errors::{RecoverPubkeyError, StdError, StdResult, SystemError, VerificationError};\n#[cfg(feature = \"stargate\")]\nuse crate::ibc::{\n    IbcAcknowledgement, IbcChannel, IbcChannelCloseMsg, IbcChannelConnectMsg, IbcChannelOpenMsg,\n    IbcEndpoint, IbcOrder, IbcPacket, IbcPacketAckMsg, IbcPacketReceiveMsg, IbcPacketTimeoutMsg,\n    IbcTimeoutBlock,\n};\nuse crate::math::Uint128;\n#[cfg(feature = \"cosmwasm_1_1\")]\nuse crate::query::SupplyResponse;\nuse crate::query::{\n    AllBalanceResponse, BalanceResponse, BankQuery, CustomQuery, QueryRequest, WasmQuery,\n};\n#[cfg(feature = \"staking\")]\nuse crate::query::{\n    AllDelegationsResponse, AllValidatorsResponse, BondedDenomResponse, DelegationResponse,\n    FullDelegation, StakingQuery, Validator, ValidatorResponse,\n};\nuse crate::results::{ContractResult, Empty, SystemResult};\nuse crate::serde::{from_slice, to_binary};\nuse crate::storage::MemoryStorage;\nuse crate::timestamp::Timestamp;\nuse crate::traits::{Api, Querier, QuerierResult};\nuse crate::types::{BlockInfo, ContractInfo, Env, MessageInfo, TransactionInfo};\nuse crate::Attribute;\n\npub const MOCK_CONTRACT_ADDR: &str = \"cosmos2contract\";\n\n/// Creates all external requirements that can be injected for unit tests.\n///\n/// See also [`mock_dependencies_with_balance`] and [`mock_dependencies_with_balances`]\n/// if you want to start with some initial balances.\npub fn mock_dependencies() -> OwnedDeps<MockStorage, MockApi, MockQuerier, Empty> {\n}\n\n/// Creates all external requirements that can be injected for unit tests.\n///\n/// It sets the given balance for the contract itself, nothing else.\npub fn mock_dependencies_with_balance(\n    contract_balance: &[Coin],\n) -> OwnedDeps<MockStorage, MockApi, MockQuerier, Empty> {\n}\n\n/// Initializes the querier along with the mock_dependencies.\n/// Sets all balances provided (you must explicitly set contract balance if desired).\npub fn mock_dependencies_with_balances(\n    balances: &[(&str, &[Coin])],\n) -> OwnedDeps<MockStorage, MockApi, MockQuerier> {\n}\n\n// Use MemoryStorage implementation (which is valid in non-testcode)\n// We can later make simplifications here if needed\npub type MockStorage = MemoryStorage;\n\n/// Length of canonical addresses created with this API. Contracts should not make any assumtions\n/// what this value is.\n/// The value here must be restorable with `SHUFFLES_ENCODE` + `SHUFFLES_DECODE` in-shuffles.\nconst CANONICAL_LENGTH: usize = 54;\n\nconst SHUFFLES_ENCODE: usize = 18;\nconst SHUFFLES_DECODE: usize = 2;\n\n// MockPrecompiles zero pads all human addresses to make them fit the canonical_length\n// it trims off zeros for the reverse operation.\n// not really smart, but allows us to see a difference (and consistent length for canonical adddresses)\n#[derive(Clone)]\npub struct MockApi {\n    /// Length of canonical addresses created with this API. Contracts should not make any assumtions\n    /// what this value is.\n    canonical_length: usize,\n    poseidon: Poseidon,\n}\n\nimpl Default for MockApi {\n    fn default() -> Self {\n}\n}\n\nimpl Api for MockApi {\n    fn addr_validate(&self, input: &str) -> StdResult<Addr> {\n}\n\n    fn addr_canonicalize(&self, input: &str) -> StdResult<CanonicalAddr> {\n}\n\n    fn addr_humanize(&self, canonical: &CanonicalAddr) -> StdResult<Addr> {\n}\n\n    fn secp256k1_verify(\n        &self,\n        message_hash: &[u8],\n        signature: &[u8],\n        public_key: &[u8],\n    ) -> Result<bool, VerificationError> {\n}\n\n    fn poseidon_hash(&self, inputs: &[&[u8]]) -> StdResult<Vec<u8>> {\n}\n\n    fn curve_hash(&self, input: &[u8]) -> StdResult<Vec<u8>> {\n}\n\n    fn groth16_verify(\n        &self,\n        input: &[u8],\n        proof: &[u8],\n        vk: &[u8],\n    ) -> Result<bool, VerificationError> {\n}\n\n    fn secp256k1_recover_pubkey(\n        &self,\n        message_hash: &[u8],\n        signature: &[u8],\n        recovery_param: u8,\n    ) -> Result<Vec<u8>, RecoverPubkeyError> {\n}\n\n    fn ed25519_verify(\n        &self,\n        message: &[u8],\n        signature: &[u8],\n        public_key: &[u8],\n    ) -> Result<bool, VerificationError> {\n}\n\n    fn ed25519_batch_verify(\n        &self,\n        messages: &[&[u8]],\n        signatures: &[&[u8]],\n        public_keys: &[&[u8]],\n    ) -> Result<bool, VerificationError> {\n}\n\n    fn debug(&self, message: &str) {\n}\n}\n\n/// Returns a default enviroment with height, time, chain_id, and contract address\n/// You can submit as is to most contracts, or modify height/time if you want to\n/// test for expiration.\n///\n/// This is intended for use in test code only.\npub fn mock_env() -> Env {\n}\n\n/// Just set sender and funds for the message.\n/// This is intended for use in test code only.\npub fn mock_info(sender: &str, funds: &[Coin]) -> MessageInfo {\n}\n\n/// Creates an IbcChannel for testing. You set a few key parameters for handshaking,\n/// If you want to set more, use this as a default and mutate other fields\n#[cfg(feature = \"stargate\")]\npub fn mock_ibc_channel(my_channel_id: &str, order: IbcOrder, version: &str) -> IbcChannel {\n}\n\n/// Creates a IbcChannelOpenMsg::OpenInit for testing ibc_channel_open.\n#[cfg(feature = \"stargate\")]\npub fn mock_ibc_channel_open_init(\n    my_channel_id: &str,\n    order: IbcOrder,\n    version: &str,\n) -> IbcChannelOpenMsg {\n}\n\n/// Creates a IbcChannelOpenMsg::OpenTry for testing ibc_channel_open.\n#[cfg(feature = \"stargate\")]\npub fn mock_ibc_channel_open_try(\n    my_channel_id: &str,\n    order: IbcOrder,\n    version: &str,\n) -> IbcChannelOpenMsg {\n}\n\n/// Creates a IbcChannelConnectMsg::ConnectAck for testing ibc_channel_connect.\n#[cfg(feature = \"stargate\")]\npub fn mock_ibc_channel_connect_ack(\n    my_channel_id: &str,\n    order: IbcOrder,\n    version: &str,\n) -> IbcChannelConnectMsg {\n}\n\n/// Creates a IbcChannelConnectMsg::ConnectConfirm for testing ibc_channel_connect.\n#[cfg(feature = \"stargate\")]\npub fn mock_ibc_channel_connect_confirm(\n    my_channel_id: &str,\n    order: IbcOrder,\n    version: &str,\n) -> IbcChannelConnectMsg {\n}\n\n/// Creates a IbcChannelCloseMsg::CloseInit for testing ibc_channel_close.\n#[cfg(feature = \"stargate\")]\npub fn mock_ibc_channel_close_init(\n    my_channel_id: &str,\n    order: IbcOrder,\n    version: &str,\n) -> IbcChannelCloseMsg {\n}\n\n/// Creates a IbcChannelCloseMsg::CloseConfirm for testing ibc_channel_close.\n#[cfg(feature = \"stargate\")]\npub fn mock_ibc_channel_close_confirm(\n    my_channel_id: &str,\n    order: IbcOrder,\n    version: &str,\n) -> IbcChannelCloseMsg {\n}\n\n/// Creates a IbcPacketReceiveMsg for testing ibc_packet_receive. You set a few key parameters that are\n/// often parsed. If you want to set more, use this as a default and mutate other fields\n#[cfg(feature = \"stargate\")]\npub fn mock_ibc_packet_recv(\n    my_channel_id: &str,\n    data: &impl Serialize,\n) -> StdResult<IbcPacketReceiveMsg> {\n}\n\n/// Creates a IbcPacket for testing ibc_packet_{ack,timeout}. You set a few key parameters that are\n/// often parsed. If you want to set more, use this as a default and mutate other fields.\n/// The difference from mock_ibc_packet_recv is if `my_channel_id` is src or dest.\n#[cfg(feature = \"stargate\")]\nfn mock_ibc_packet(my_channel_id: &str, data: &impl Serialize) -> StdResult<IbcPacket> {\n}\n\n/// Creates a IbcPacketAckMsg for testing ibc_packet_ack. You set a few key parameters that are\n/// often parsed. If you want to set more, use this as a default and mutate other fields.\n/// The difference from mock_ibc_packet_recv is if `my_channel_id` is src or dest.\n#[cfg(feature = \"stargate\")]\npub fn mock_ibc_packet_ack(\n    my_channel_id: &str,\n    data: &impl Serialize,\n    ack: IbcAcknowledgement,\n) -> StdResult<IbcPacketAckMsg> {\n}\n\n/// Creates a IbcPacketTimeoutMsg for testing ibc_packet_timeout. You set a few key parameters that are\n/// often parsed. If you want to set more, use this as a default and mutate other fields.\n/// The difference from mock_ibc_packet_recv is if `my_channel_id` is src or dest./\n#[cfg(feature = \"stargate\")]\npub fn mock_ibc_packet_timeout(\n    my_channel_id: &str,\n    data: &impl Serialize,\n) -> StdResult<IbcPacketTimeoutMsg> {\n}\n\n/// The same type as cosmwasm-std's QuerierResult, but easier to reuse in\n/// cosmwasm-vm. It might diverge from QuerierResult at some point.\npub type MockQuerierCustomHandlerResult = SystemResult<ContractResult<Binary>>;\n\n/// MockQuerier holds an immutable table of bank balances\n/// and configurable handlers for Wasm queries and custom queries.\npub struct MockQuerier<C: DeserializeOwned = Empty> {\n    bank: BankQuerier,\n    #[cfg(feature = \"staking\")]\n    staking: StakingQuerier,\n    wasm: WasmQuerier,\n    /// A handler to handle custom queries. This is set to a dummy handler that\n    /// always errors by default. Update it via `with_custom_handler`.\n    ///\n    /// Use box to avoid the need of another generic type\n    custom_handler: Box<dyn for<'a> Fn(&'a C) -> MockQuerierCustomHandlerResult>,\n}\n\nimpl<C: DeserializeOwned> MockQuerier<C> {\n    pub fn new(balances: &[(&str, &[Coin])]) -> Self {\n}\n\n    // set a new balance for the given address and return the old balance\n    pub fn update_balance(\n        &mut self,\n        addr: impl Into<String>,\n        balance: Vec<Coin>,\n    ) -> Option<Vec<Coin>> {\n}\n\n    #[cfg(feature = \"staking\")]\n    pub fn update_staking(\n        &mut self,\n        denom: &str,\n        validators: &[crate::query::Validator],\n        delegations: &[crate::query::FullDelegation],\n    ) {\n}\n\n    pub fn update_wasm<WH: 'static>(&mut self, handler: WH)\n    where\n        WH: Fn(&WasmQuery) -> QuerierResult,\n    {\n}\n\n    pub fn with_custom_handler<CH: 'static>(mut self, handler: CH) -> Self\n    where\n        CH: Fn(&C) -> MockQuerierCustomHandlerResult,\n    {\n}\n}\n\nimpl Default for MockQuerier {\n    fn default() -> Self {\n}\n}\n\nimpl<C: CustomQuery + DeserializeOwned> Querier for MockQuerier<C> {\n    fn raw_query(&self, bin_request: &[u8]) -> QuerierResult {\n}\n}\n\nimpl<C: CustomQuery + DeserializeOwned> MockQuerier<C> {\n    pub fn handle_query(&self, request: &QueryRequest<C>) -> QuerierResult {\n}\n}\n\nstruct WasmQuerier {\n    /// A handler to handle Wasm queries. This is set to a dummy handler that\n    /// always errors by default. Update it via `with_custom_handler`.\n    ///\n    /// Use box to avoid the need of generic type.\n    handler: Box<dyn for<'a> Fn(&'a WasmQuery) -> QuerierResult>,\n}\n\nimpl WasmQuerier {\n    fn new(handler: Box<dyn for<'a> Fn(&'a WasmQuery) -> QuerierResult>) -> Self {\n}\n\n    fn update_handler<WH: 'static>(&mut self, handler: WH)\n    where\n        WH: Fn(&WasmQuery) -> QuerierResult,\n    {\n}\n\n    fn query(&self, request: &WasmQuery) -> QuerierResult {\n}\n}\n\nimpl Default for WasmQuerier {\n    fn default() -> Self {\n}\n}\n\n#[derive(Clone, Default)]\npub struct BankQuerier {\n    #[allow(dead_code)]\n    /// HashMap<denom, amount>\n    supplies: HashMap<String, Uint128>,\n    /// HashMap<address, coins>\n    balances: HashMap<String, Vec<Coin>>,\n}\n\nimpl BankQuerier {\n    pub fn new(balances: &[(&str, &[Coin])]) -> Self {\n}\n\n    pub fn update_balance(\n        &mut self,\n        addr: impl Into<String>,\n        balance: Vec<Coin>,\n    ) -> Option<Vec<Coin>> {\n}\n\n    fn calculate_supplies(balances: &HashMap<String, Vec<Coin>>) -> HashMap<String, Uint128> {\n}\n\n    pub fn query(&self, request: &BankQuery) -> QuerierResult {\n}\n}\n\n#[cfg(feature = \"staking\")]\n#[derive(Clone, Default)]\npub struct StakingQuerier {\n    denom: String,\n    validators: Vec<Validator>,\n    delegations: Vec<FullDelegation>,\n}\n\n#[cfg(feature = \"staking\")]\nimpl StakingQuerier {\n    pub fn new(denom: &str, validators: &[Validator], delegations: &[FullDelegation]) -> Self {\n}\n\n    pub fn query(&self, request: &StakingQuery) -> QuerierResult {\n}\n}\n\n/// Performs a perfect shuffle (in shuffle)\n///\n/// https://en.wikipedia.org/wiki/Riffle_shuffle_permutation#Perfect_shuffles\n/// https://en.wikipedia.org/wiki/In_shuffle\n///\n/// The number of shuffles required to restore the original order are listed in\n/// https://oeis.org/A002326, e.g.:\n///\n/// ```ignore\n/// 2: 2\n/// 4: 4\n/// 6: 3\n/// 8: 6\n/// 10: 10\n/// 12: 12\n/// 14: 4\n/// 16: 8\n/// 18: 18\n/// 20: 6\n/// 22: 11\n/// 24: 20\n/// 26: 18\n/// 28: 28\n/// 30: 5\n/// 32: 10\n/// 34: 12\n/// 36: 36\n/// 38: 12\n/// 40: 20\n/// 42: 14\n/// 44: 12\n/// 46: 23\n/// 48: 21\n/// 50: 8\n/// 52: 52\n/// 54: 20\n/// 56: 18\n/// 58: 58\n/// 60: 60\n/// 62: 6\n/// 64: 12\n/// 66: 66\n/// 68: 22\n/// 70: 35\n/// 72: 9\n/// 74: 20\n/// ```\npub fn riffle_shuffle<T: Clone>(input: &[T]) -> Vec<T> {\n}\n\npub fn digit_sum(input: &[u8]) -> usize {\n}\n\n/// Only for test code. This bypasses assertions in new, allowing us to create _*\n/// Attributes to simulate responses from the blockchain\npub fn mock_wasmd_attr(key: impl Into<String>, value: impl Into<String>) -> Attribute {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\n\npub use assertions::assert_approx_eq_impl;\n\n#[cfg(feature = \"staking\")]\npub use mock::StakingQuerier;\npub use mock::{\n    digit_sum, mock_dependencies, mock_dependencies_with_balance, mock_dependencies_with_balances,\n    mock_env, mock_info, mock_wasmd_attr, riffle_shuffle, BankQuerier, MockApi, MockQuerier,\n    MockQuerierCustomHandlerResult, MockStorage, MOCK_CONTRACT_ADDR,\n};\n#[cfg(feature = \"stargate\")]\npub use mock::{\n    mock_ibc_channel, mock_ibc_channel_close_confirm, mock_ibc_channel_close_init,\n    mock_ibc_channel_connect_ack, mock_ibc_channel_connect_confirm, mock_ibc_channel_open_init,\n    mock_ibc_channel_open_try, mock_ibc_packet_ack, mock_ibc_packet_recv, mock_ibc_packet_timeout,\n};\n}\n\n// Re-exports\n\npub use cosmwasm_derive::entry_point;\n"],[8,"//! The crypto crate is intended to be used in internal crates / utils.\n//! Please don't use any of these types directly, as\n//! they might change frequently, or be removed in the future.\n//! This crate does not adhere to semantic versioning.\n#![cfg_attr(feature = \"backtraces\", feature(backtrace))]\n\nmod ed25519 {\nuse ed25519_zebra::{batch, Signature, VerificationKey};\nuse rand_core::OsRng;\n\nuse crate::errors::{CryptoError, CryptoResult};\n\n/// Length of a serialized public key\npub const EDDSA_PUBKEY_LEN: usize = 32;\n\n/// EdDSA ed25519 implementation.\n///\n/// This function verifies messages against a signature, with the public key of the signer,\n/// using the ed25519 elliptic curve digital signature parametrization / algorithm.\n///\n/// The maximum currently supported message length is 4096 bytes.\n/// The signature and public key are in [Tendermint](https://docs.tendermint.com/v0.32/spec/blockchain/encoding.html#public-key-cryptography)\n/// format:\n/// - signature: raw ED25519 signature (64 bytes).\n/// - public key: raw ED25519 public key (32 bytes).\npub fn ed25519_verify(message: &[u8], signature: &[u8], public_key: &[u8]) -> CryptoResult<bool> {\n}\n\n/// Performs batch Ed25519 signature verification.\n///\n/// Batch verification asks whether all signatures in some set are valid, rather than asking whether\n/// each of them is valid. This allows sharing computations among all signature verifications,\n/// performing less work overall, at the cost of higher latency (the entire batch must complete),\n/// complexity of caller code (which must assemble a batch of signatures across work-items),\n/// and loss of the ability to easily pinpoint failing signatures.\n///\n/// This batch verification implementation is adaptive, in the sense that it detects multiple\n/// signatures created with the same verification key, and automatically coalesces terms\n/// in the final verification equation.\n///\n/// In the limiting case where all signatures in the batch are made with the same verification key,\n/// coalesced batch verification runs twice as fast as ordinary batch verification.\n///\n/// Three Variants are suppported in the input for convenience:\n///  - Equal number of messages, signatures, and public keys: Standard, generic functionality.\n///  - One message, and an equal number of signatures and public keys: Multiple digital signature\n/// (multisig) verification of a single message.\n///  - One public key, and an equal number of messages and signatures: Verification of multiple\n/// messages, all signed with the same private key.\n///\n/// Any other variants of input vectors result in an error.\n///\n/// Notes:\n///  - The \"one-message, with zero signatures and zero public keys\" case, is considered the empty\n/// case.\n///  - The \"one-public key, with zero messages and zero signatures\" case, is considered the empty\n/// case.\n///  - The empty case (no messages, no signatures and no public keys) returns true.\npub fn ed25519_batch_verify(\n    messages: &[&[u8]],\n    signatures: &[&[u8]],\n    public_keys: &[&[u8]],\n) -> CryptoResult<bool> {\n}\n\n/// Error raised when signature is not 64 bytes long\nstruct InvalidEd25519SignatureFormat;\n\nimpl From<InvalidEd25519SignatureFormat> for CryptoError {\n    fn from(_original: InvalidEd25519SignatureFormat) -> Self {\n}\n}\n\nfn read_signature(data: &[u8]) -> Result<[u8; 64], InvalidEd25519SignatureFormat> {\n}\n\n/// Error raised when pubkey is not 32 bytes long\nstruct InvalidEd25519PubkeyFormat;\n\nimpl From<InvalidEd25519PubkeyFormat> for CryptoError {\n    fn from(_original: InvalidEd25519PubkeyFormat) -> Self {\n}\n}\n\nfn read_pubkey(data: &[u8]) -> Result<[u8; 32], InvalidEd25519PubkeyFormat> {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod errors {\n#[cfg(feature = \"backtraces\")]\nuse std::backtrace::Backtrace;\nuse std::fmt::Debug;\nuse thiserror::Error;\n\npub type CryptoResult<T> = core::result::Result<T, CryptoError>;\n\n#[derive(Error, Debug)]\npub enum CryptoError {\n    #[error(\"Batch verify error: {msg}\")]\n    BatchErr {\n        msg: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Crypto error: {msg}\")]\n    GenericErr {\n        msg: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Invalid hash format\")]\n    InvalidHashFormat {\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Invalid public key format\")]\n    InvalidPubkeyFormat {\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Invalid signature format\")]\n    InvalidSignatureFormat {\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n    #[error(\"Invalid recovery parameter. Supported values: 0 and 1.\")]\n    InvalidRecoveryParam {\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n}\n\nimpl CryptoError {\n    pub fn batch_err(msg: impl Into<String>) -> Self {\n}\n\n    pub fn generic_err(msg: impl Into<String>) -> Self {\n}\n\n    pub fn invalid_hash_format() -> Self {\n}\n\n    pub fn invalid_pubkey_format() -> Self {\n}\n\n    pub fn invalid_signature_format() -> Self {\n}\n\n    pub fn invalid_recovery_param() -> Self {\n}\n\n    /// Numeric error code that can easily be passed over the\n    /// contract VM boundary.\n    pub fn code(&self) -> u32 {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod identity_digest {\n//! Dummy 256-bits Digest impl.\n//! This digest stores/accepts a value of the proper length.\n//! To be used for / with already hashed values, just to comply with the Digest contract.\n//!\n//! Adapted from `sha2` [sha256.rs](https://github.com/RustCrypto/hashes/blob/master/sha2/src/sha256.rs)\nuse digest::consts::U32;\nuse digest::generic_array::GenericArray;\nuse digest::{FixedOutput, HashMarker, Output, OutputSizeUser, Reset, Update};\n\n/// The 256-bits identity container\n#[derive(Clone, Default)]\npub struct Identity256 {\n    array: GenericArray<u8, U32>,\n}\n\nimpl Update for Identity256 {\n    fn update(&mut self, hash: &[u8]) {\n}\n}\n\nimpl OutputSizeUser for Identity256 {\n    type OutputSize = U32;\n}\n\nimpl FixedOutput for Identity256 {\n    fn finalize_into(self, out: &mut Output<Self>) {\n}\n}\n\nimpl HashMarker for Identity256 {}\n\nimpl Reset for Identity256 {\n    fn reset(&mut self) {\n}\n}\n}\nmod secp256k1 {\nuse digest::{Digest, Update}; // trait\nuse k256::{\n    ecdsa::recoverable,\n    ecdsa::signature::{DigestVerifier, Signature as _}, // traits\n    ecdsa::{Signature, VerifyingKey},                   // type aliases\n    elliptic_curve::sec1::ToEncodedPoint,\n};\n\nuse crate::errors::{CryptoError, CryptoResult};\nuse crate::identity_digest::Identity256;\n\n/// Max length of a message hash for secp256k1 verification in bytes.\n/// This is typically a 32 byte output of e.g. SHA-256 or Keccak256. In theory shorter values\n/// are possible but currently not supported by the implementation. Let us know when you need them.\npub const MESSAGE_HASH_MAX_LEN: usize = 32;\n\n/// ECDSA (secp256k1) parameters\n/// Length of a serialized signature\npub const ECDSA_SIGNATURE_LEN: usize = 64;\n\n/// Length of a serialized compressed public key\nconst ECDSA_COMPRESSED_PUBKEY_LEN: usize = 33;\n/// Length of a serialized uncompressed public key\nconst ECDSA_UNCOMPRESSED_PUBKEY_LEN: usize = 65;\n/// Max length of a serialized public key\npub const ECDSA_PUBKEY_MAX_LEN: usize = ECDSA_UNCOMPRESSED_PUBKEY_LEN;\n\n/// ECDSA secp256k1 implementation.\n///\n/// This function verifies message hashes (typically, hashed unsing SHA-256) against a signature,\n/// with the public key of the signer, using the secp256k1 elliptic curve digital signature\n/// parametrization / algorithm.\n///\n/// The signature and public key are in \"Cosmos\" format:\n/// - signature:  Serialized \"compact\" signature (64 bytes).\n/// - public key: [Serialized according to SEC 2](https://www.oreilly.com/library/view/programming-bitcoin/9781492031482/ch04.html)\n/// (33 or 65 bytes).\npub fn secp256k1_verify(\n    message_hash: &[u8],\n    signature: &[u8],\n    public_key: &[u8],\n) -> CryptoResult<bool> {\n}\n\n/// Recovers a public key from a message hash and a signature.\n///\n/// This is required when working with Ethereum where public keys\n/// are not stored on chain directly.\n///\n/// `recovery_param` must be 0 or 1. The values 2 and 3 are unsupported by this implementation,\n/// which is the same restriction as Ethereum has (https://github.com/ethereum/go-ethereum/blob/v1.9.25/internal/ethapi/api.go#L466-L469).\n/// All other values are invalid.\n///\n/// Returns the recovered pubkey in compressed form, which can be used\n/// in secp256k1_verify directly.\npub fn secp256k1_recover_pubkey(\n    message_hash: &[u8],\n    signature: &[u8],\n    recovery_param: u8,\n) -> Result<Vec<u8>, CryptoError> {\n}\n\n/// Error raised when hash is not 32 bytes long\nstruct InvalidSecp256k1HashFormat;\n\nimpl From<InvalidSecp256k1HashFormat> for CryptoError {\n    fn from(_original: InvalidSecp256k1HashFormat) -> Self {\n}\n}\n\nfn read_hash(data: &[u8]) -> Result<[u8; 32], InvalidSecp256k1HashFormat> {\n}\n\n/// Error raised when signature is not 64 bytes long (32 bytes r, 32 bytes s)\nstruct InvalidSecp256k1SignatureFormat;\n\nimpl From<InvalidSecp256k1SignatureFormat> for CryptoError {\n    fn from(_original: InvalidSecp256k1SignatureFormat) -> Self {\n}\n}\n\nfn read_signature(data: &[u8]) -> Result<[u8; 64], InvalidSecp256k1SignatureFormat> {\n}\n\n/// Error raised when public key is not in one of the two supported formats:\n/// 1. Uncompressed: 65 bytes starting with 0x04\n/// 2. Compressed: 33 bytes starting with 0x02 or 0x03\nstruct InvalidSecp256k1PubkeyFormat;\n\nimpl From<InvalidSecp256k1PubkeyFormat> for CryptoError {\n    fn from(_original: InvalidSecp256k1PubkeyFormat) -> Self {\n}\n}\n\nfn check_pubkey(data: &[u8]) -> Result<(), InvalidSecp256k1PubkeyFormat> {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod zk {\nmod errors {\n#[cfg(feature = \"backtraces\")]\nuse std::backtrace::Backtrace;\nuse std::fmt::Debug;\nuse thiserror::Error;\n\npub type ZKResult<T> = core::result::Result<T, ZKError>;\n\n#[derive(Error, Debug)]\npub enum ZKError {\n    #[error(\"ZK verification error\")]\n    VerifierError {\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n\n    #[error(\"Invalid hash input\")]\n    InvalidHashInput {},\n\n    #[error(\"ZK error: {msg}\")]\n    GenericErr {\n        msg: String,\n        #[cfg(feature = \"backtraces\")]\n        backtrace: Backtrace,\n    },\n}\n\nimpl ZKError {\n    pub fn generic_err(msg: impl Into<String>) -> Self {\n}\n\n    /// Numeric error code that can easily be passed over the\n    /// contract VM boundary.\n    pub fn code(&self) -> u32 {\n}\n}\n}\n\n#[allow(clippy::all)]\nmod poseidon {\nuse ark_bn254::Fr as Bn254Fr;\nuse ark_ff::{BigInteger, PrimeField};\nuse ark_std::vec::Vec;\nuse arkworks_native_gadgets::poseidon::{FieldHasher, Poseidon as ArkworksPoseidon};\nuse arkworks_native_gadgets::to_field_elements;\nuse arkworks_setups::common::setup_params;\nuse arkworks_setups::Curve;\n\nuse crate::ZKError;\n\npub type PoseidonHasher = ArkworksPoseidon<Bn254Fr>;\n\n#[derive(Debug, Clone)]\npub struct Poseidon {\n    poseidon_width_3_bytes: PoseidonHasher,\n    poseidon_width_4_bytes: PoseidonHasher,\n    poseidon_width_5_bytes: PoseidonHasher,\n}\n\nimpl Poseidon {\n    pub fn new() -> Self {\n}\n\n    pub fn hash(&self, inputs: &[&[u8]]) -> Result<Vec<u8>, ZKError> {\n}\n}\n\nimpl Default for Poseidon {\n    fn default() -> Self {\n}\n}\n\n#[test]\nfn test_hash() {\n}\n}\n\n#[allow(clippy::all)]\nmod verifier {\nuse super::{ZKError, ZKResult};\n\npub const GROTH16_VERIFIER_KEY_LEN: usize = 360;\npub const GROTH16_PROOF_LEN: usize = 128;\n\nuse ark_bn254::Bn254;\n#[allow(clippy::all)]\nuse ark_crypto_primitives::{Error, SNARK};\nuse ark_ec::PairingEngine;\nuse ark_groth16::{Groth16, Proof, VerifyingKey};\nuse ark_serialize::CanonicalDeserialize;\nuse ark_std::marker::PhantomData;\nuse arkworks_native_gadgets::to_field_elements;\n\npub struct ArkworksVerifierGroth16<E: PairingEngine>(PhantomData<E>);\n\nimpl<E: PairingEngine> ArkworksVerifierGroth16<E> {\n    pub fn verify(\n        public_inp_bytes: &[u8],\n        proof_bytes: &[u8],\n        vk_bytes: &[u8],\n    ) -> Result<bool, Error> {\n}\n}\n\npub type ArkworksVerifierBn254 = ArkworksVerifierGroth16<Bn254>;\n\npub fn groth16_verify(\n    public_inp_bytes: &[u8],\n    proof_bytes: &[u8],\n    vk_bytes: &[u8],\n) -> ZKResult<bool> {\n}\n}\n\n#[allow(clippy::all)]\nmod keccak {\nuse ark_bn254::Fr as Bn254Fr;\nuse ark_ff::{BigInteger, PrimeField};\nuse ark_std::vec::Vec;\nuse arkworks_setups::common::keccak_256;\n\npub fn curve_hash(input: &[u8]) -> Vec<u8> {\n}\n}\n\npub use errors::{ZKError, ZKResult};\npub use keccak::curve_hash;\npub use poseidon::Poseidon;\npub use verifier::{\n    groth16_verify, ArkworksVerifierBn254, GROTH16_PROOF_LEN, GROTH16_VERIFIER_KEY_LEN,\n};\n}\n\n#[doc(hidden)]\npub use crate::ed25519::EDDSA_PUBKEY_LEN;\n#[doc(hidden)]\npub use crate::ed25519::{ed25519_batch_verify, ed25519_verify};\n#[doc(hidden)]\npub use crate::errors::{CryptoError, CryptoResult};\n#[doc(hidden)]\npub use crate::secp256k1::{secp256k1_recover_pubkey, secp256k1_verify};\n#[doc(hidden)]\npub use crate::secp256k1::{ECDSA_PUBKEY_MAX_LEN, ECDSA_SIGNATURE_LEN, MESSAGE_HASH_MAX_LEN};\n#[doc(hidden)]\npub use crate::zk::*;\n"],[9,"mod bucket {\nuse serde::{de::DeserializeOwned, ser::Serialize};\nuse std::marker::PhantomData;\n\nuse cosmwasm_std::{to_vec, StdError, StdResult, Storage};\n#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::{Order, Record};\n\nuse crate::length_prefixed::{to_length_prefixed, to_length_prefixed_nested};\n#[cfg(feature = \"iterator\")]\nuse crate::namespace_helpers::range_with_prefix;\nuse crate::namespace_helpers::{get_with_prefix, remove_with_prefix, set_with_prefix};\n#[cfg(feature = \"iterator\")]\nuse crate::type_helpers::deserialize_kv;\nuse crate::type_helpers::{may_deserialize, must_deserialize};\n\n/// An alias of Bucket::new for less verbose usage\npub fn bucket<'a, T>(storage: &'a mut dyn Storage, namespace: &[u8]) -> Bucket<'a, T>\nwhere\n    T: Serialize + DeserializeOwned,\n{\n}\n\n/// An alias of ReadonlyBucket::new for less verbose usage\npub fn bucket_read<'a, T>(storage: &'a dyn Storage, namespace: &[u8]) -> ReadonlyBucket<'a, T>\nwhere\n    T: Serialize + DeserializeOwned,\n{\n}\n\npub struct Bucket<'a, T>\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    storage: &'a mut dyn Storage,\n    prefix: Vec<u8>,\n    // see https://doc.rust-lang.org/std/marker/struct.PhantomData.html#unused-type-parameters for why this is needed\n    data: PhantomData<T>,\n}\n\nimpl<'a, T> Bucket<'a, T>\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    pub fn new(storage: &'a mut dyn Storage, namespace: &[u8]) -> Self {\n}\n\n    pub fn multilevel(storage: &'a mut dyn Storage, namespaces: &[&[u8]]) -> Self {\n}\n\n    /// save will serialize the model and store, returns an error on serialization issues\n    pub fn save(&mut self, key: &[u8], data: &T) -> StdResult<()> {\n}\n\n    pub fn remove(&mut self, key: &[u8]) {\n}\n\n    /// load will return an error if no data is set at the given key, or on parse error\n    pub fn load(&self, key: &[u8]) -> StdResult<T> {\n}\n\n    /// may_load will parse the data stored at the key if present, returns Ok(None) if no data there.\n    /// returns an error on issues parsing\n    pub fn may_load(&self, key: &[u8]) -> StdResult<Option<T>> {\n}\n\n    #[cfg(feature = \"iterator\")]\n    pub fn range<'b>(\n        &'b self,\n        start: Option<&[u8]>,\n        end: Option<&[u8]>,\n        order: Order,\n    ) -> Box<dyn Iterator<Item = StdResult<Record<T>>> + 'b> {\n}\n\n    /// Loads the data, perform the specified action, and store the result\n    /// in the database. This is shorthand for some common sequences, which may be useful.\n    ///\n    /// If the data exists, `action(Some(value))` is called. Otherwise `action(None)` is called.\n    pub fn update<A, E>(&mut self, key: &[u8], action: A) -> Result<T, E>\n    where\n        A: FnOnce(Option<T>) -> Result<T, E>,\n        E: From<StdError>,\n    {\n}\n}\n\npub struct ReadonlyBucket<'a, T>\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    storage: &'a dyn Storage,\n    prefix: Vec<u8>,\n    // see https://doc.rust-lang.org/std/marker/struct.PhantomData.html#unused-type-parameters for why this is needed\n    data: PhantomData<T>,\n}\n\nimpl<'a, T> ReadonlyBucket<'a, T>\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    pub fn new(storage: &'a dyn Storage, namespace: &[u8]) -> Self {\n}\n\n    pub fn multilevel(storage: &'a dyn Storage, namespaces: &[&[u8]]) -> Self {\n}\n\n    /// load will return an error if no data is set at the given key, or on parse error\n    pub fn load(&self, key: &[u8]) -> StdResult<T> {\n}\n\n    /// may_load will parse the data stored at the key if present, returns Ok(None) if no data there.\n    /// returns an error on issues parsing\n    pub fn may_load(&self, key: &[u8]) -> StdResult<Option<T>> {\n}\n\n    #[cfg(feature = \"iterator\")]\n    pub fn range<'b>(\n        &'b self,\n        start: Option<&[u8]>,\n        end: Option<&[u8]>,\n        order: Order,\n    ) -> Box<dyn Iterator<Item = StdResult<Record<T>>> + 'b> {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod length_prefixed {\n//! This module is an implemention of a namespacing scheme described\n//! in https://github.com/webmaster128/key-namespacing#length-prefixed-keys\n//!\n//! Everything in this file is only responsible for building such keys\n//! and is in no way specific to any kind of storage.\n\n/// Calculates the raw key prefix for a given namespace as documented\n/// in https://github.com/webmaster128/key-namespacing#length-prefixed-keys\npub fn to_length_prefixed(namespace: &[u8]) -> Vec<u8> {\n}\n\n/// Calculates the raw key prefix for a given nested namespace\n/// as documented in https://github.com/webmaster128/key-namespacing#nesting\npub fn to_length_prefixed_nested(namespaces: &[&[u8]]) -> Vec<u8> {\n}\n\n/// Encodes the length of a given namespace as a 2 byte big endian encoded integer\nfn encode_length(namespace: &[u8]) -> [u8; 2] {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod namespace_helpers {\nuse cosmwasm_std::Storage;\n#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::{Order, Record};\n\npub(crate) fn get_with_prefix(\n    storage: &dyn Storage,\n    namespace: &[u8],\n    key: &[u8],\n) -> Option<Vec<u8>> {\n}\n\npub(crate) fn set_with_prefix(\n    storage: &mut dyn Storage,\n    namespace: &[u8],\n    key: &[u8],\n    value: &[u8],\n) {\n}\n\npub(crate) fn remove_with_prefix(storage: &mut dyn Storage, namespace: &[u8], key: &[u8]) {\n}\n\n#[inline]\nfn concat(namespace: &[u8], key: &[u8]) -> Vec<u8> {\n}\n\n#[cfg(feature = \"iterator\")]\npub(crate) fn range_with_prefix<'a>(\n    storage: &'a dyn Storage,\n    namespace: &[u8],\n    start: Option<&[u8]>,\n    end: Option<&[u8]>,\n    order: Order,\n) -> Box<dyn Iterator<Item = Record> + 'a> {\n}\n\n#[cfg(feature = \"iterator\")]\n#[inline]\nfn trim(namespace: &[u8], key: &[u8]) -> Vec<u8> {\n}\n\n/// Returns a new vec of same length and last byte incremented by one\n/// If last bytes are 255, we handle overflow up the chain.\n/// If all bytes are 255, this returns wrong data - but that is never possible as a namespace\n#[cfg(feature = \"iterator\")]\nfn namespace_upper_bound(input: &[u8]) -> Vec<u8> {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod prefixed_storage {\nuse cosmwasm_std::Storage;\n#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::{Order, Record};\n\nuse crate::length_prefixed::{to_length_prefixed, to_length_prefixed_nested};\n#[cfg(feature = \"iterator\")]\nuse crate::namespace_helpers::range_with_prefix;\nuse crate::namespace_helpers::{get_with_prefix, remove_with_prefix, set_with_prefix};\n\n/// An alias of PrefixedStorage::new for less verbose usage\npub fn prefixed<'a>(storage: &'a mut dyn Storage, namespace: &[u8]) -> PrefixedStorage<'a> {\n}\n\n/// An alias of ReadonlyPrefixedStorage::new for less verbose usage\npub fn prefixed_read<'a>(\n    storage: &'a dyn Storage,\n    namespace: &[u8],\n) -> ReadonlyPrefixedStorage<'a> {\n}\n\npub struct PrefixedStorage<'a> {\n    storage: &'a mut dyn Storage,\n    prefix: Vec<u8>,\n}\n\nimpl<'a> PrefixedStorage<'a> {\n    pub fn new(storage: &'a mut dyn Storage, namespace: &[u8]) -> Self {\n}\n\n    // Nested namespaces as documented in\n    // https://github.com/webmaster128/key-namespacing#nesting\n    pub fn multilevel(storage: &'a mut dyn Storage, namespaces: &[&[u8]]) -> Self {\n}\n}\n\nimpl<'a> Storage for PrefixedStorage<'a> {\n    fn get(&self, key: &[u8]) -> Option<Vec<u8>> {\n}\n\n    fn set(&mut self, key: &[u8], value: &[u8]) {\n}\n\n    fn remove(&mut self, key: &[u8]) {\n}\n\n    #[cfg(feature = \"iterator\")]\n    /// range allows iteration over a set of keys, either forwards or backwards\n    /// uses standard rust range notation, and eg db.range(b\"foo\"..b\"bar\") also works reverse\n    fn range<'b>(\n        &'b self,\n        start: Option<&[u8]>,\n        end: Option<&[u8]>,\n        order: Order,\n    ) -> Box<dyn Iterator<Item = Record> + 'b> {\n}\n}\n\npub struct ReadonlyPrefixedStorage<'a> {\n    storage: &'a dyn Storage,\n    prefix: Vec<u8>,\n}\n\nimpl<'a> ReadonlyPrefixedStorage<'a> {\n    pub fn new(storage: &'a dyn Storage, namespace: &[u8]) -> Self {\n}\n\n    // Nested namespaces as documented in\n    // https://github.com/webmaster128/key-namespacing#nesting\n    pub fn multilevel(storage: &'a dyn Storage, namespaces: &[&[u8]]) -> Self {\n}\n}\n\nimpl<'a> Storage for ReadonlyPrefixedStorage<'a> {\n    fn get(&self, key: &[u8]) -> Option<Vec<u8>> {\n}\n\n    fn set(&mut self, _key: &[u8], _value: &[u8]) {\n}\n\n    fn remove(&mut self, _key: &[u8]) {\n}\n\n    #[cfg(feature = \"iterator\")]\n    /// range allows iteration over a set of keys, either forwards or backwards\n    fn range<'b>(\n        &'b self,\n        start: Option<&[u8]>,\n        end: Option<&[u8]>,\n        order: Order,\n    ) -> Box<dyn Iterator<Item = Record> + 'b> {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod sequence {\nuse cosmwasm_std::{StdResult, Storage};\n\nuse crate::Singleton;\n\n/// Sequence creates a custom Singleton to hold an empty sequence\npub fn sequence<'a>(storage: &'a mut dyn Storage, key: &[u8]) -> Singleton<'a, u64> {\n}\n\n/// currval returns the last value returned by nextval. If the sequence has never been used,\n/// then it will return 0.\npub fn currval(seq: &Singleton<u64>) -> StdResult<u64> {\n}\n\n/// nextval increments the counter by 1 and returns the new value.\n/// On the first time it is called (no sequence info in db) it will return 1.\npub fn nextval(seq: &mut Singleton<u64>) -> StdResult<u64> {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod singleton {\nuse serde::{de::DeserializeOwned, ser::Serialize};\nuse std::marker::PhantomData;\n\nuse cosmwasm_std::{to_vec, StdError, StdResult, Storage};\n\nuse crate::length_prefixed::to_length_prefixed;\nuse crate::type_helpers::{may_deserialize, must_deserialize};\n\n/// An alias of Singleton::new for less verbose usage\npub fn singleton<'a, T>(storage: &'a mut dyn Storage, key: &[u8]) -> Singleton<'a, T>\nwhere\n    T: Serialize + DeserializeOwned,\n{\n}\n\n/// An alias of ReadonlySingleton::new for less verbose usage\npub fn singleton_read<'a, T>(storage: &'a dyn Storage, key: &[u8]) -> ReadonlySingleton<'a, T>\nwhere\n    T: Serialize + DeserializeOwned,\n{\n}\n\n/// Singleton effectively combines PrefixedStorage with TypedStorage to\n/// work on a single storage key. It performs the to_length_prefixed transformation\n/// on the given name to ensure no collisions, and then provides the standard\n/// TypedStorage accessors, without requiring a key (which is defined in the constructor)\npub struct Singleton<'a, T>\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    storage: &'a mut dyn Storage,\n    key: Vec<u8>,\n    // see https://doc.rust-lang.org/std/marker/struct.PhantomData.html#unused-type-parameters for why this is needed\n    data: PhantomData<T>,\n}\n\nimpl<'a, T> Singleton<'a, T>\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    pub fn new(storage: &'a mut dyn Storage, key: &[u8]) -> Self {\n}\n\n    /// save will serialize the model and store, returns an error on serialization issues\n    pub fn save(&mut self, data: &T) -> StdResult<()> {\n}\n\n    pub fn remove(&mut self) {\n}\n\n    /// load will return an error if no data is set at the given key, or on parse error\n    pub fn load(&self) -> StdResult<T> {\n}\n\n    /// may_load will parse the data stored at the key if present, returns Ok(None) if no data there.\n    /// returns an error on issues parsing\n    pub fn may_load(&self) -> StdResult<Option<T>> {\n}\n\n    /// update will load the data, perform the specified action, and store the result\n    /// in the database. This is shorthand for some common sequences, which may be useful\n    ///\n    /// This is the least stable of the APIs, and definitely needs some usage\n    pub fn update<A, E>(&mut self, action: A) -> Result<T, E>\n    where\n        A: FnOnce(T) -> Result<T, E>,\n        E: From<StdError>,\n    {\n}\n}\n\n/// ReadonlySingleton only requires a Storage and exposes only the\n/// methods of Singleton that don't modify state.\npub struct ReadonlySingleton<'a, T>\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    storage: &'a dyn Storage,\n    key: Vec<u8>,\n    // see https://doc.rust-lang.org/std/marker/struct.PhantomData.html#unused-type-parameters for why this is needed\n    data: PhantomData<T>,\n}\n\nimpl<'a, T> ReadonlySingleton<'a, T>\nwhere\n    T: Serialize + DeserializeOwned,\n{\n    pub fn new(storage: &'a dyn Storage, key: &[u8]) -> Self {\n}\n\n    /// load will return an error if no data is set at the given key, or on parse error\n    pub fn load(&self) -> StdResult<T> {\n}\n\n    /// may_load will parse the data stored at the key if present, returns Ok(None) if no data there.\n    /// returns an error on issues parsing\n    pub fn may_load(&self) -> StdResult<Option<T>> {\n}\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\nmod type_helpers {\nuse serde::de::DeserializeOwned;\nuse std::any::type_name;\n\n#[cfg(feature = \"iterator\")]\nuse cosmwasm_std::Record;\nuse cosmwasm_std::{from_slice, StdError, StdResult};\n\n/// may_deserialize parses json bytes from storage (Option), returning Ok(None) if no data present\n///\n/// value is an odd type, but this is meant to be easy to use with output from storage.get (Option<Vec<u8>>)\n/// and value.map(|s| s.as_slice()) seems trickier than &value\npub(crate) fn may_deserialize<T: DeserializeOwned>(\n    value: &Option<Vec<u8>>,\n) -> StdResult<Option<T>> {\n}\n\n/// must_deserialize parses json bytes from storage (Option), returning NotFound error if no data present\npub(crate) fn must_deserialize<T: DeserializeOwned>(value: &Option<Vec<u8>>) -> StdResult<T> {\n}\n\n#[cfg(feature = \"iterator\")]\npub(crate) fn deserialize_kv<T: DeserializeOwned>(kv: Record<Vec<u8>>) -> StdResult<Record<T>> {\n}\n\n#[cfg(test)]\nmod tests {\n}\n}\n\npub use bucket::{bucket, bucket_read, Bucket, ReadonlyBucket};\npub use length_prefixed::{to_length_prefixed, to_length_prefixed_nested};\npub use prefixed_storage::{prefixed, prefixed_read, PrefixedStorage, ReadonlyPrefixedStorage};\npub use sequence::{currval, nextval, sequence};\npub use singleton::{singleton, singleton_read, ReadonlySingleton, Singleton};\n"]]}}